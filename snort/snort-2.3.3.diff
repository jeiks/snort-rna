diff -Naur snort-2.3.3/src/define_values.c snort-2.3.3.new/src/define_values.c
--- snort-2.3.3/src/define_values.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/define_values.c	2008-02-18 01:18:39.000000000 -0300
@@ -0,0 +1,839 @@
+#include "define_values.h"
+#include "snort.h"
+
+/*****************************************************************************
+  void freeUnits(pUnit_val Units)
+  ----------------------------------------------------------------------------
+	releases memory of the Unit-array
+	-> Units : Arrray which contains all Units of the network.
+             The last unit must be empty (all entries 0 or NULL)
+*****************************************************************************/
+void freeUnits(pUnit_val Units_val)
+{
+	pUnit_val unit = Units_val;
+
+	while(unit->number) {																	 /* e.g. non-empty unit */
+		if (unit->members) killList(unit->members);			 /* make sure, that there is */
+		if (unit->sources) killList(unit->sources);			 /* memory to release        */
+		if (unit->weights) free(unit->weights);
+		if (unit->name) free(unit->name);
+		if (unit->dest) free(unit->dest);
+		
+		if(unit->FeatureWidth) {
+			int i;
+			for(i = 0; i < unit->FeatureWidth; i++) {
+				if(unit->TDNNsources[i]) free(unit->TDNNsources[i]);
+				if(unit->TDNNweights[i]) free(unit->TDNNweights[i]);
+			}
+			if(unit->TDNNsources) free(unit->TDNNsources);
+			if(unit->TDNNweights) free(unit->TDNNweights);
+		}
+		unit++;
+	}
+
+	free(Units_val);
+}
+
+
+/*****************************************************************************
+  void freeLayers(pLayer Layers)
+  ----------------------------------------------------------------------------
+	releases memory of the Layer-array
+	-> Units : Arrray which contains all Layer of the network.
+             The last Layer must be empty (all entries 0 or NULL)
+*****************************************************************************/
+void freeLayers(pLayer Layers)
+{
+	pLayer layer = Layers;
+
+	while(layer->members) {														 /* e.g. non-empty layer */
+		if (layer->members) free(layer->members);				 /* make sure, that there is */
+		if (layer->sources) free(layer->sources);				 /* memory to release        */
+		if (layer->name) free(layer->name);
+		if (layer->readCounter) free(layer->readCounter);
+		if (layer->writeCounter) free(layer->writeCounter);
+
+		layer++;
+	}
+
+	free(Layers);
+}
+
+/*****************************************************************************
+  int checkLearnFunc(void)
+  ----------------------------------------------------------------------------
+  checks, if the Learning Function is supported by the snns2c
+  <- Error Code : OK / NOT_SUPPORTED
+  *****************************************************************************/
+int checkLearnFunc(void)
+{
+  static char *NotSupportedLearnFuncs[] = {
+    "ART1", "ART2", "ARTMAP", "BackPercolation", "Hebbian", "RM_delta",
+    "RCC", "Kohonen", NULL
+  };
+
+  char *LearnFunc = krui_getLearnFunc();     /* learning function of the network */
+  char **string   = NotSupportedLearnFuncs;  /* current function name to test */
+
+  while(*string) {
+    if (!strcmp(*string, LearnFunc)) {	     /* e.g. the same function-name */
+      return(NOT_SUPPORTED);
+    }
+    string++;
+  }
+  
+  return(OK);
+}
+
+/******************************************************************************
+  void checkErr(int errCode)
+  -----------------------------------------------------------------------------
+  writes an error message if needed and also stops program if errCode
+  stands for a fatal error
+  -> errCode : code of the actual status
+  ******************************************************************************/
+void checkErr(int errCode)
+{
+  switch(errCode) 
+      {
+      case OK          : ;
+	break;
+      case ERR         : printf("unspecified Error\n");
+	break;
+      case CANT_ADD    :
+      case MEM_ERR     : printf("not enough memory\n");
+	break;
+      case CANT_LOAD   : printf("can't load file\n");
+	break;
+      case WRONG_PARAM : printf("wrong parameters\n");
+	break;
+      case CANT_OPEN   : printf("can't open file\n");
+	break;
+      case NO_CPN      : printf("net is not a CounterPropagation network\n");
+	break;
+      case NO_TDNN     : printf("net is not a Time Delay Neural Network\n");
+	break;
+      case ILLEGAL_CYCLES : printf("net contains illegal cycles\n");
+	break;
+      case WRONG_ACT_FUNC : ;
+	break;
+      case NOT_SUPPORTED  : printf("not supported network type\n");
+	break;
+      default             : printf("unknown error code : %d\n", errCode);
+      }
+}
+
+/*****************************************************************************
+  bool is_BPTT_net(void)
+  ----------------------------------------------------------------------------
+  checks, if the current Net is a BPTT, BBPTT or QPTT Network by testing
+  the learning functions.
+  <- (func) : TRUE  Net is a kind of BPTT Network
+  FALSE otherwise
+  *****************************************************************************/
+bool is_BPTT_net(void)
+{
+  return (   (0 == strcmp("BPTT", krui_getLearnFunc() ))
+	  || (0 == strcmp("BBPTT", krui_getLearnFunc() ))
+	  || (0 == strcmp("QPTT", krui_getLearnFunc() )) );
+}
+
+/*****************************************************************************
+  int checkActFunc(char *actName)
+  ----------------------------------------------------------------------------
+  checks, if an activation Function with the name actName is present
+  -> actName : Name of the activation function
+  <- (func)  : number in the function table or -1 if not present
+*****************************************************************************/
+int checkActFunc(char *actName)
+{
+  int i=0;
+  
+  while (**(ACT_FUNC_NAMES + i) ) {
+    if (!strcmp(ACT_FUNC_NAMES[i], actName) ) return (i);
+    i++;
+  }
+  fprintf(stderr, "Can't find the function <%s>\n", actName);
+  return(-1);
+}
+
+/******************************************************************************
+  int matchLayer(pLayer layer, pUnit_val unit)
+  -----------------------------------------------------------------------------
+  checks if the unit could be in the same layer as the other units wich
+  are in the layer yet
+  -> layer : pointer to the (existing) layer
+  unit  : pointer to the unit wich is to be prooved
+  <- (func) TRUE the unit matches with the other units
+  FALSE otherwise
+  ******************************************************************************/ 
+int matchLayer(pLayer layer, pUnit_val unit)
+{
+  static int is_BPTT = 0, first_time = 1;
+
+  /* a special flag is set to avoid unneeded function calls */
+  if (first_time) {
+    is_BPTT = is_BPTT_net();
+    first_time = 0;
+  }
+
+  /* input neurons are all treated the same way */
+  if ( (unit->type == INPUT) && (layer->type == INPUT) ) return (TRUE);
+
+  /* unit should match the attributes of the Layer */
+  if (unit->type != layer->type) return(FALSE);
+  if (unit->ActFunc != layer->ActFunc) return(FALSE);
+
+  /* BPTT-nets have no topological order */
+  if (is_BPTT) return (TRUE);
+
+  /* unit must not be a member of the source units */ 
+  if (isMember(layer->sources, unit->number) ) return (FALSE);
+
+  /* Neue Version von Matthias Oderdorfer */
+  return ( CompareSources(unit->sources, layer->sources) );
+ 
+  /* alte Version */
+  /* a member of the layer must not be a source element of the unit */
+  /* return( !haveIntersection(unit->sources, layer->members) ); */
+}
+
+/*****************************************************************************
+  int initLayer(pLayer layer, pUnit_val unit)
+  ----------------------------------------------------------------------------
+  initialize the given layer e.g :
+  - initializes the two lists members and sources
+  - insert the type and the Number of the activation-function of the
+  given Unit in the predefined places.
+  - inserts the sources of the given Unit into the list sources
+  
+  -> layer : pointer to the new Layer
+  unit  : pointer to the first (e.g.prototype-) unit
+  <- (func) : Status (Errorcodes)
+  *****************************************************************************/
+int initLayer(pLayer layer, pUnit_val unit)
+{
+  layer->members = newList();		   /* a list for member unit */
+  if (!layer->members) return(MEM_ERR);
+
+  layer->sources = newList();		   /* a list for all predecessor */
+  if (!layer->sources) return(MEM_ERR);	   /* units of all members       */
+  
+  addList(layer->members, unit->number);   /* prototype unit is the first member */
+  if (copyList(layer->sources, unit->sources) ) return(MEM_ERR);
+
+  layer->ActFunc = unit->ActFunc;
+  layer->type    = unit->type;
+
+  unit->layer = layer;
+
+  return(OK);
+}
+
+
+/******************************************************************************
+  int searchLayer(pUnit_val unit, pLayer globalLayers)
+  -----------------------------------------------------------------------------
+  searches a Layer with matches the unit (or an empty Layer) and inserts the
+  unit in the layer.
+  -> unit         : actual unit wich searches a friendly layer
+  globalLayers : array of all Layers
+  <- (func) MEM_ERR : not enough Memory
+  OK      : no problems
+  ******************************************************************************/
+int searchLayer(pUnit_val unit, pLayer globalLayers)
+{
+  pLayer layer;
+
+  layer = globalLayers;
+  while(TRUE) {
+    if (layer->members == NULL) {	   /* empty layer found */
+      return(initLayer(layer, unit));	   /* give possible Errors to caller */
+    }
+    else if (matchLayer(layer, unit) ) {   /* matching layer found */
+      if (addList(layer->members, unit->number)) {
+	return(MEM_ERR);
+      }
+      unit->layer = layer; 
+      return(mergeList(layer->sources, unit->sources)); /* returns Status */
+    }
+    layer++;
+  }
+}
+
+
+/******************************************************************************
+  int divideNet(pUnit_val globalUnits, pLayer globalLayers, int *TDNN_prot)
+  -----------------------------------------------------------------------------
+  parts a net into groups and prepares the Net for sorting the
+  layers.
+  
+  -> globalUnits  : all the Units are going to be written in this array
+  globalLayers : all the different Layers will be written in this array
+  <- globalUnits  : (the values in the array)
+  globalLayers : (the values in the array)
+  TDNN_prot    : The numbers of the prototype units of each unit
+  <- (func) MEM_ERR : not enough Memory
+  OK      : no problems
+  ******************************************************************************/
+int divideNet(pUnit_val globalUnits, pLayer globalLayers, int *TDNN_prot)
+{
+  int       unitNo, sourceNo;		   /* number of the unit and source unit */
+  pUnit_val     unit;       		   /* unit and prototype unit */
+  FlintType dummy, weight;		   /* link weights */
+  int       error;			   /* error code    */
+  char      *string;			   /* free variable */
+  int       pos;			   /* free variable */
+
+  /* --------------------------------------------
+   * loading all Units and group them into Layers 
+   */
+  unitNo = krui_getFirstUnit(); 
+  unit   = globalUnits;
+  
+  while (unitNo) {
+    unit->members = newList();
+    if (!unit->members) return (MEM_ERR);
+    
+    unit->number  = unitNo;
+    addList(unit->members, unitNo);	/* the Prototype is also part of the member list */
+
+    /* copy the entries from SNNS to the own format */
+    unit->act     = krui_getUnitActivation(unitNo);
+    unit->type    = krui_getUnitTType(unitNo);
+    unit->Bias    = krui_getUnitBias(unitNo);
+
+    /* units always have a name (at least its old number) */
+    string = krui_getUnitName(unitNo);
+    if (NULL == string) {
+      unit->name = malloc(12 * sizeof(char));
+      if(! unit->name) {
+	return (MEM_ERR);
+      }
+      sprintf(unit->name, "Old: %d", unit->number);
+    }
+    else {
+      unit->name = malloc(MAX(1,strlen(string)+1));
+      if(! unit->name) {
+	return (MEM_ERR);
+      }
+      strcpy(unit->name, string);
+    }
+
+    unit->ActFunc = checkActFunc(krui_getUnitActFuncName(unitNo) );
+    if (unit->ActFunc < 0) return(WRONG_ACT_FUNC);
+
+    /* insert all Source units in the list */
+    unit->sources = newList();
+    if (!unit->sources) return (MEM_ERR);
+    sourceNo = krui_getFirstPredUnit(&dummy);
+    while (sourceNo) {
+      /* only special-hidden-neurons may have links to itself */
+      if ( (unit->type != SPECIAL_H) && !is_BPTT_net() ) {
+        if (unit->number == sourceNo) return(ILLEGAL_CYCLES);
+      }
+      if(addList(unit->sources, sourceNo)) return (MEM_ERR);
+      sourceNo = krui_getNextPredUnit(&dummy);
+    }
+    /* now the weights can be written in the right order */
+    /* One more Element is allocated, because the array might have size 0 */ 
+    unit->weights = (float *)malloc(NoOf(unit->sources) * sizeof(float) + sizeof(float));
+    if (!unit->weights) return(MEM_ERR);
+    sourceNo = krui_getFirstPredUnit(&weight);
+    while (sourceNo) {
+      pos = searchList(unit->sources, sourceNo);
+      unit->weights[pos] = weight;
+      sourceNo = krui_getNextPredUnit(&weight);
+    }
+#ifdef DEBUG
+    printUnit(unit);
+#endif
+    error = searchLayer(unit, globalLayers);
+		if (error) return(error);
+
+    unit++;
+    unitNo = krui_getNextUnit();
+  }
+
+  return(OK);
+}
+
+#ifdef DEBUG
+/*function for DEBUG*/
+void printLayer(pLayer layer)
+{
+  int i;
+  printf("\nLayer %d", layer->number);
+  printf("\nmembers: ");
+  for (i = 0; i < NoOf(layer->members); i++) {
+    printf("%d ", element(layer->members, i) );
+  }
+  printf("\nsources: ");
+  for (i = 0; i < NoOf(layer->sources); i++) {
+    printf("%d ", element(layer->sources, i) );
+  }
+  printf("\n");
+}
+#endif
+
+/****************************************************************************
+  char checkOrder(pLayer globalLayers, int x, int y)
+  ---------------------------------------------------------------------------
+  checks the order between layer x and layer y
+  
+  SIDE-EFFECT : the entry SuccDelay is set up, if one layer follows
+  immediatly another. (needed by TDNN-networks)
+  
+  -> globalLayers : all layers of the net
+  x, y         : numbers of layer x and y
+  <- (func)    -1       : layer x before layer y
+  0       : indifferent
+  1       : layer x after layer y
+  ILLEGAL_CYCLES : error occured (no order given)
+  ****************************************************************************/
+signed char checkOrder(pLayer globalLayers, int x, int y)
+{
+  /* preference of the unit type : low value means early update */
+  static char pref[12] = {0, 0, 2, 0, 1, 3, 3, 3, 3, 3, 3, 3};
+
+  signed char order = 0;
+
+  if (pref[globalLayers[x].type] < pref[globalLayers[y].type]) {
+    order = (signed char)-1;	/* e.g. layer x before layer y */
+  }
+  else if (pref[globalLayers[x].type] > pref[globalLayers[y].type]) {
+    order = 1;			/* e.g. layer x after layer y */ 
+  }
+
+	/* BPTT-Networks may contain any cycles so they must not be checked */
+	if (is_BPTT_net() ) {
+		return(order);
+	}
+
+  if (haveIntersection(globalLayers[x].sources, globalLayers[y].members) ) {	        
+    globalLayers[y].SuccDelay = globalLayers[x].delay; /* Side-Effect */
+    if (order == -1) {
+      if (SPECIAL_H != globalLayers[y].type) return (ILLEGAL_CYCLES);
+    }
+    else {
+      order = 1;
+    }
+  }
+  if (haveIntersection(globalLayers[x].members, globalLayers[y].sources) ) {		
+    globalLayers[x].SuccDelay = globalLayers[y].delay; /* Side-Effect */
+    if (order == 1) {
+      if (SPECIAL_H != globalLayers[x].type) return (ILLEGAL_CYCLES);
+    }
+    else {
+      order = (signed char)-1;
+    }
+  }
+
+  return(order);
+}
+
+
+/*****************************************************************************
+  int sortNet(pLayer globalLayers, int NoOfLayers, int *order)
+  ----------------------------------------------------------------------------
+  calculates the order between the globalLayers an returns it in the array
+  order. So the first number in the array is the first Layer to be updated
+  and so on.
+  -> globalLayers : Array of all layers in the net
+  NoOfLayers   : Number of all layers in the net
+  <- order        : the order for updating the layers
+  (func)    OK : no errors occured
+  MEM_ERR : not enough memory for calculations
+  *****************************************************************************/ 
+int sortNet(pLayer globalLayers, int NoOfLayers, int *order)
+{
+  char **matrix;		/* precedence matrix        */
+  char  *mask;			/* already chosen layers    */
+  int    i, j, x, y, ord, isSource = TRUE;
+  char   precedence;
+
+  /* reserve memory for all the arrays and matrices */
+  matrix = (char **)malloc(NoOfLayers * sizeof(char *) );
+  if (!matrix) return (MEM_ERR);
+  
+  for (i = 0; i < NoOfLayers; i++) {
+    matrix[i] = (char *)calloc(NoOfLayers, sizeof(char) );
+    if (!matrix[i]) return (MEM_ERR);
+  }
+  
+  mask  = (char *)calloc(NoOfLayers, sizeof(char) );
+  if (!mask) {
+		free(matrix);
+		return (MEM_ERR);
+	}
+
+  /** build the precedence matrix of the Layer-Graph */
+  for (y = 0; y < NoOfLayers; y++) {
+    for (x = y + 1; x < NoOfLayers; x++) {
+      precedence = checkOrder(globalLayers, x, y);
+      if (precedence == ILLEGAL_CYCLES) return(ILLEGAL_CYCLES);
+
+      matrix[x][y] = precedence;
+      matrix[y][x] = -precedence;
+
+    } /* for x */
+
+  } /* for y */
+
+#ifdef DEBUG
+  printf("\nPrecedence Matrix is:\n");
+  for (y = 0; y < NoOfLayers; y++) {
+    for (x = 0; x < NoOfLayers; x++) {
+      printf("%3d ", matrix[y][x]);
+    }
+    printf("\n");
+  }
+#endif
+
+  /** put the Layers in the right order **/
+  for (ord = 0; ord < NoOfLayers; ord++) {
+
+    for (i = 0; i < NoOfLayers; i++) {
+      if (mask[i]) continue;	/* Layer already chosen */
+      
+      isSource = TRUE;
+      for (j = 0; j < NoOfLayers; j++) {
+        /* exists a layer wich must be updated before ? */
+        if (matrix[i][j] == 1) {
+          isSource = FALSE;
+          break;
+        }
+      }
+
+      if (isSource) {
+        order[ord] = i;		/* the number of the Layer becomes ord */
+        mask[i] = 1;		/* must not test this Layer again      */
+
+        for (j = 0; j < NoOfLayers; j++) {
+          matrix[j][i] = 0;	/* clear depencies for other Layers */
+        }
+
+        break;			/* find next Layer */
+      }
+
+    } /* for i */
+
+    if (!isSource) {
+      return(ILLEGAL_CYCLES);
+    }
+
+  } /* for ord */
+
+  for (i = 0; i < NoOfLayers; i++) {
+    free(matrix[i]);
+  }
+  free(matrix);
+  free(mask);
+
+#ifdef DEBUG
+  printf("\nLayers sorted in following order :\n");
+  for (i = 0; i < NoOfLayers; i++) {
+    printf(" %d", order[i]);
+  }
+  printf("\n");
+#endif
+
+  return(OK);
+}
+
+/***************************************************************************
+  int NameLayers(pLayer globalLayers, int NoOfLayers)
+  --------------------------------------------------------------------------
+  name the Layers of the Net
+  -> globalLayers : all layers of the net
+  NoOfLayers   : #layers of the net
+  <- (func) OK      : no errors
+  MEM_ERR : not enough memory
+  ***************************************************************************/
+int NameLayers(pLayer globalLayers, int NoOfLayers)
+{
+#define NAME_LENGTH 11
+
+  int  nr;
+  int  hcounter = 0, ocounter = 0, scounter =0;
+  pLayer layer = NULL;
+
+  for(nr = 0; nr < NoOfLayers; nr++) {
+    layer = (globalLayers + nr);
+    layer->name = (char *)malloc(NAME_LENGTH * sizeof(char) );
+    if (!(layer->name)) return(MEM_ERR);
+
+    switch( (globalLayers + nr)->type) {
+    case INPUT  : sprintf(layer->name, "Input"); 
+      break;
+      
+    case OUTPUT : sprintf(layer->name, "Output%d", ++ocounter);
+      break;
+      
+    case HIDDEN : sprintf(layer->name, "Hidden%d", ++hcounter); 
+      break;
+      
+    default     : sprintf(layer->name, "Special%d", ++scounter); 
+    }
+
+  }
+
+  return(OK);
+}
+
+ /*****************************************************************************
+   void writeAllWeigths(pUnit_val Units, int NoOfUnits, FILE *fOutFile)
+   ----------------------------------------------------------------------------
+   writes all Units of the Net as an array of structs to the OutputFile
+   -> pUnit_vals    : array of all units of the net
+   NoOfUnits : #units in the net
+   fOutFile  : appreciated output stream
+   Autor     : Matthias Oberdorfer
+   *****************************************************************************/
+
+void LoadAllWeights(pUnit_val Units_val, int NoOfUnits)
+ {
+   int nr, i ;
+   unsigned int pos=0;
+   for(nr = 0; nr < NoOfUnits; nr++)
+   {
+      for(i = 0; i < NoOf((Units_val + nr)->sources); i++)
+      {
+         Weights[pos] = (Units_val + nr)->weights[i];
+#ifdef DEBUG
+         printf("loading Weights[%d]=%f\n",pos,Weights[pos]);
+#endif
+         pos++;
+      }
+   }
+
+ }
+
+
+/*****************************************************************************
+  void writeUnitNew(pUnit_val unit, FILE *fOutFile)
+  ----------------------------------------------------------------------------
+  writes a Unit ( activation, bias, sources, Linkweights) as a struct to the
+  Outfile
+  -> unit   : unit wich is to be written
+  fOutFile  : appreciated output stream 
+  Autor     : Matthias Oberdorfer
+  *****************************************************************************/
+void writeUnitNew(pUnit_val unit)
+ {
+   Units[unit->number].Bias=unit->Bias;
+#ifdef DEBUG
+   printf("Units[%d].Bias=%f\n",(unit->number),Units[unit->number].Bias);
+#endif
+ }
+
+
+/*****************************************************************************
+  void LoadAllUnits(pUnit_val Units, int NoOfUnits, FILE *fOutFile)
+  ----------------------------------------------------------------------------
+  writes all Units of the Net as an array of structs to the OutputFile
+  -> pUnit_vals    : array of all units of the net
+  NoOfUnits : #units in the net
+  Autor     : Matthias Oberdorfer (changed original)
+  *****************************************************************************/
+void LoadAllUnits(pUnit_val Units_val, int NoOfUnits)
+{
+   int nr;
+   int count_links;
+
+   count_links = 0; /* no links yet */
+   for(nr = 0; nr < NoOfUnits; nr++) 
+   {
+      writeUnitNew(Units_val + nr);
+      count_links += NoOf((Units_val+nr)->sources);
+   }
+}
+
+/*****************************************************************************
+  int LoadValues(pLayer globalLayers, pUnit_val globalUnits, 
+  int NoOfLayers, int NoOfUnits,
+  int *order, char *OutFile)
+  ----------------------------------------------------------------------------
+  writes a Net wich is discribed by globalLayers and globalUnits in the File
+  named <OutFile>.
+  The order for updating the Layers is discribed in order and in the single
+  Layers there is a set of unit-numbers, wich will be updated when its the turn
+  of the layer.
+  -> globalLayers : all Layers of the Net
+  -> globalUnits  : all Units of the Net
+  -> NoOfLayers   : #Layers in the Net
+  -> NoOfUnits    : #Units in the Net
+  -> order        : in wich order the Layers have to be updated
+  <- (func) OK    : no errors occured
+  MEM_ERR   : not enough memory
+  CANT_OPEN : could not open the output-file
+******************************************************************************/
+int LoadValues(pLayer globalLayers, pUnit_val globalUnits, 
+             int NoOfLayers, int NoOfUnits,
+             int *order, char *ProcName)
+{
+  pLayer layer;
+  pUnit_val  unit;
+  int    nr, maxSource = 0, maxFeature = 0;
+  pList  OutList, FunctionList;
+  time_t timer;
+
+  /* calculate time for the date in the header of the output file */
+  time(&timer);
+ 
+  /* prepare Output Stream */
+  
+  /* maxSource is needed for writing the Unit-array */
+  for(unit = globalUnits; unit < globalUnits + NoOfUnits; unit++) {
+    maxSource  = MAX(maxSource, NoOf(unit->sources) );
+    /* Calculating the Maximum Feature-Width is harmless for non-TDNNs, dont need.. but will be left */
+    maxFeature = MAX(maxFeature, unit->FeatureWidth);
+  }
+
+  /* Net-Output may consist of several (output) Layers     */
+  /* so there must be an extra merge-list : OutList        */
+  /* FunctionList will contain a set of all used functions */
+  OutList = newList();      if (!OutList) return (MEM_ERR);
+  FunctionList = newList(); if (!FunctionList) return (MEM_ERR);
+
+  for(nr = 0; nr < NoOfLayers; nr ++) {
+    layer = globalLayers + nr;
+    if( layer->type == OUTPUT) {
+      if (mergeList(OutList, layer->members) ) return (MEM_ERR);
+    }
+    if (addList(FunctionList, layer->ActFunc) ) return(MEM_ERR);
+  }
+
+  /* find Names for the Layers */
+  if (NameLayers(globalLayers, NoOfLayers)) return(MEM_ERR);
+
+   LoadAllWeights(globalUnits, NoOfUnits);
+
+   LoadAllUnits(globalUnits, NoOfUnits);
+
+   killList(OutList);
+   killList(FunctionList);
+   return(OK);
+}
+
+/*
+main function
+*/
+int LoadNetworkValues()
+{
+   krui_err err;			     /* error code of SNNS - krui */
+   char     *netname;			     /* internal name of the SNNS-network */
+   char     *NetFileName = {pv.rna.net_filename}; /* input file */
+   pUnit_val    Units_val;      		     /* all Units and unit variable */
+   pLayer   Layers;	        	     /* all Layers and layer variable */
+   int      NoOfUnits, NoOfLayers;	     /* Number of units and layers */
+   int      *order;			     /* array with the order of the sorted layers */
+   int      nr;	        		     /* help variables */
+   int      error;			     /* error code */
+   char     *ProcName = {"Rna_alg"};	     /* function name in the output */
+   int      *TDNN_prot;                       /* Array with the numbers of the prototype units */
+   
+#ifdef DEBUG
+   printf("Importing values from %s...\n",NetFileName);
+#endif
+
+   printf("Loading Artificial Network...\n");
+
+   /* load Net */
+   err = krui_loadNet(NetFileName, &netname);
+   if (err) {
+      fprintf(stderr, "%s\n", krui_error(err) );
+      return(CANT_LOAD);
+   }
+
+   error = checkLearnFunc();
+   if (error) {
+      checkErr(error);
+      return(error);
+   }
+
+   NoOfUnits = krui_getNoOfUnits();
+
+   Units_val  =  (pUnit_val)calloc((NoOfUnits + 1), sizeof(tUnit) );  /* because of sentinels */
+   if (! Units_val) {
+            checkErr(MEM_ERR);
+            return(MEM_ERR);
+   }
+
+   Layers = (pLayer)calloc((NoOfUnits + 1), sizeof(tLayer) ); /* because of sentinels */
+   if (! Layers) {
+            free(Units_val);
+            checkErr(MEM_ERR);
+            return(MEM_ERR);
+   }
+
+   /* TDNN_prot needs one more Element, because the enumeration of the units starts with one */
+   TDNN_prot = (int *)malloc((NoOfUnits+1) * sizeof(int) );
+   if (! TDNN_prot) {
+                  free(Units_val);
+                  free(Layers);
+                  checkErr(MEM_ERR);
+                  return(MEM_ERR);
+   }
+
+   for (nr = 0; nr <= NoOfUnits; nr++) {
+      Layers[nr].number  = nr;
+   }
+
+#ifdef DEBUG
+   printf("Dividing net into Layers...\n");
+#endif
+
+   /* part Net into groups */
+   error =  divideNet(Units_val, Layers, TDNN_prot);
+   if (error) {
+            checkErr(error);
+            FREE_ALL;
+            return(error);
+   }
+   
+   /* count the Non-empty Layers */
+   for (nr = 0; Layers[nr].members != NULL; nr++);
+   NoOfLayers = nr;
+   order = (int *)malloc(NoOfLayers * sizeof(int) );
+   
+   
+   /* count the real number of units (e.g. the prototype units in TDNN) */
+   /* unused units have the number 0 the total Number can't exeed the   */
+   /* Number of Units given by the SNNS-Interface-Function              */
+   for(nr = 0; (Units_val[nr].number != 0) && (nr < NoOfUnits); nr++) {
+      Units_val[nr].index = nr;
+   }
+   NoOfUnits = nr;
+   
+#ifdef DEBUG
+   for(nr = 0; nr < NoOfLayers; printLayer(Layers + nr++) );
+#endif
+
+   /* topological sort of the layers */
+#ifdef DEBUG
+   printf("Sorting Layers...\n");
+#endif
+
+   error = sortNet(Layers, NoOfLayers, order);
+   if (error) {
+      checkErr(error);
+      FREE_ALL;
+      return(error);
+   }
+
+#ifdef DEBUG
+   printf("Loading Values...\n");
+#endif
+
+   /* Load values */
+   error = LoadValues(Layers, Units_val, NoOfLayers, NoOfUnits, order, ProcName);
+   if (error) {
+      checkErr(error);
+      FREE_ALL;
+      return(error);
+   }
+
+   FREE_ALL;
+   return(0);
+}
diff -Naur snort-2.3.3/src/define_values.h snort-2.3.3.new/src/define_values.h
--- snort-2.3.3/src/define_values.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/define_values.h	2008-02-18 00:42:40.000000000 -0300
@@ -0,0 +1,87 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <limits.h>
+#include <time.h>
+#include <memory.h>
+#include "glob_typ.h"
+#include "kr_ui.h"
+#include "rna_functions.h"
+#include "rna_templates.h"
+#include "rna_lib.h"
+
+#include "kr_typ.h"
+#include "kernel.h"
+
+#include "rna_alg.h"
+// gcc -Wall -c define_values.c -O4  -I./kernel_snns
+// gcc define_values.o rna_lib.o ./kernel_snns/libkernel.a ./kernel_snns/libfunc.a -lm -ll -Wall -o define_values
+/* Macros for calculating the minimum or maximum of two values */
+#define MAX(a, b) ( (a > b) ? (a) : (b) )
+#define MIN(a, b) ( (a < b) ? (a) : (b) )
+
+/* Macro for releasing memory of units and layers */
+#define FREE_ALL freeUnits(Units_val); freeLayers(Layers); free(TDNN_prot);
+
+/* Status (Error) Codes : OK = 0 (NO Error), ERR = 1, ...  */
+typedef enum { OK, ERR, CANT_ADD, CANT_LOAD, MEM_ERR,
+		   WRONG_PARAM, WRONG_ACT_FUNC, CANT_OPEN,
+		   ILLEGAL_CYCLES, NO_CPN, NO_TDNN, NOT_SUPPORTED} Status;
+
+/* Recordtype for Layers */
+typedef struct {
+  int   number;			/* of the Layer (not used yet) */
+  pList members;		/* Numbers of all member-units */
+  pList sources;		/* numbers of all sources of the member-units */
+  int   type;			  /* INPUT , OUTPUT ...               */
+  int   ActFunc;		/* No in the ActivationFunctionList */
+  char  *name;			/* Name of the Layer */
+  /* Special entries for TDNN */
+  int   TotalDelay;		/* Total Delay Number of the Layer */
+  int   delay;			/* Delay of the receptive Field  */
+  int   SuccDelay;		/* Delay of the following Layer */
+  char  *readCounter;		/* Name of the DelayPointer      */ 
+  char  *writeCounter;		/* Name of the WriteDelayPointer */
+} tLayer, *pLayer;
+
+/* Recordtype for Units */
+typedef struct {
+  int    number;		/* of the Unit                         */
+  pList  members;		/* Units with the same Prototype (TDNN)*/
+  pList  sources;		/* numbers of the source-Units         */
+  float  *weights;	        /* Link-Weights to the Source-Units    */
+  int    ActFunc;		/* No in the ActivationFunctionList    */
+  int    type;			/* INPUT , OUTPUT ...                  */
+  char   *name;			/* Name of the unit, given by the user */
+  float  Bias;			/* Bias of the unit                    */
+  pLayer layer;			/* Pointer to the layer wich contains the unit */
+  /* Special entries for BPTT and Elman/Jordan */
+  float  act;                   /* Initial Activation of the Unit      */
+  /* Special entries for CPN */
+  float *dest;      /* weights from Hidden to Output written in the hidden units */
+  int   NoOfDest;   /* Numbers of the weights to the Output */
+  /* Special entries for TDNN */
+  int    index;			/* Index in the global Array           */
+  int   FeatureWidth;		/* Number of Prototype Source units    */
+  int   DelayLength;		/* Delay Length of the receptive Field */
+  int   **TDNNsources;		/* special Format for TDNNs            */
+  float **TDNNweights;		/* special Format for TDNNs            */
+} tUnit, *pUnit_val;
+
+void freeUnits(pUnit_val Units_val);
+void freeLayers(pLayer Layers);
+int checkLearnFunc(void);
+void checkErr(int errCode);
+int checkActFunc(char *actName);
+int matchLayer(pLayer layer, pUnit_val unit);
+int initLayer(pLayer layer, pUnit_val unit);
+int searchLayer(pUnit_val unit, pLayer globalLayers);
+int divideNet(pUnit_val globalUnits, pLayer globalLayers, int *TDNN_prot);
+void printLayer(pLayer layer);
+int sortNet(pLayer globalLayers, int NoOfLayers, int *order);
+int NameLayers(pLayer globalLayers, int NoOfLayers);
+void LoadAllWeights(pUnit_val Units_val, int NoOfUnits);
+void writeUnitNew(pUnit_val unit);
+void LoadAllUnits(pUnit_val Units_val, int NoOfUnits);
+int LoadNetworkValues();
diff -Naur snort-2.3.3/src/detection-plugins/Makefile.in snort-2.3.3.new/src/detection-plugins/Makefile.in
--- snort-2.3.3/src/detection-plugins/Makefile.in	2005-04-23 16:47:24.000000000 -0300
+++ snort-2.3.3.new/src/detection-plugins/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,158 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/detection-plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libspd_a_AR = $(AR) $(ARFLAGS)
+libspd_a_LIBADD =
+am_libspd_a_OBJECTS = sp_dsize_check.$(OBJEXT) \
+	sp_icmp_code_check.$(OBJEXT) sp_icmp_id_check.$(OBJEXT) \
+	sp_icmp_seq_check.$(OBJEXT) sp_icmp_type_check.$(OBJEXT) \
+	sp_ip_fragbits.$(OBJEXT) sp_ip_id_check.$(OBJEXT) \
+	sp_ip_proto.$(OBJEXT) sp_ip_same_check.$(OBJEXT) \
+	sp_ip_tos_check.$(OBJEXT) sp_ipoption_check.$(OBJEXT) \
+	sp_pattern_match.$(OBJEXT) sp_react.$(OBJEXT) \
+	sp_respond.$(OBJEXT) sp_rpc_check.$(OBJEXT) \
+	sp_session.$(OBJEXT) sp_tcp_ack_check.$(OBJEXT) \
+	sp_tcp_flag_check.$(OBJEXT) sp_tcp_seq_check.$(OBJEXT) \
+	sp_tcp_win_check.$(OBJEXT) sp_ttl_check.$(OBJEXT) \
+	sp_clientserver.$(OBJEXT) sp_byte_check.$(OBJEXT) \
+	sp_byte_jump.$(OBJEXT) sp_pcre.$(OBJEXT) sp_isdataat.$(OBJEXT) \
+	sp_flowbits.$(OBJEXT) sp_asn1.$(OBJEXT)
+libspd_a_OBJECTS = $(am_libspd_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libspd_a_SOURCES)
+DIST_SOURCES = $(libspd_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libspd.a
-
 libspd_a_SOURCES = sp_dsize_check.c sp_dsize_check.h sp_icmp_code_check.c      \
 sp_icmp_code_check.h sp_icmp_id_check.c sp_icmp_id_check.h sp_icmp_seq_check.c \
 sp_icmp_seq_check.h sp_icmp_type_check.c sp_icmp_type_check.h sp_ip_fragbits.c \
@@ -99,57 +180,39 @@
 sp_byte_jump.c sp_byte_jump.h sp_pcre.c sp_pcre.h sp_isdataat.c sp_isdataat.h  \
 sp_flowbits.c sp_flowbits.h sp_asn1.c sp_asn1.h
 
-subdir = src/detection-plugins
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libspd_a_AR = $(AR) cru
-libspd_a_LIBADD =
-am_libspd_a_OBJECTS = sp_dsize_check.$(OBJEXT) \
-	sp_icmp_code_check.$(OBJEXT) sp_icmp_id_check.$(OBJEXT) \
-	sp_icmp_seq_check.$(OBJEXT) sp_icmp_type_check.$(OBJEXT) \
-	sp_ip_fragbits.$(OBJEXT) sp_ip_id_check.$(OBJEXT) \
-	sp_ip_proto.$(OBJEXT) sp_ip_same_check.$(OBJEXT) \
-	sp_ip_tos_check.$(OBJEXT) sp_ipoption_check.$(OBJEXT) \
-	sp_pattern_match.$(OBJEXT) sp_react.$(OBJEXT) \
-	sp_respond.$(OBJEXT) sp_rpc_check.$(OBJEXT) \
-	sp_session.$(OBJEXT) sp_tcp_ack_check.$(OBJEXT) \
-	sp_tcp_flag_check.$(OBJEXT) sp_tcp_seq_check.$(OBJEXT) \
-	sp_tcp_win_check.$(OBJEXT) sp_ttl_check.$(OBJEXT) \
-	sp_clientserver.$(OBJEXT) sp_byte_check.$(OBJEXT) \
-	sp_byte_jump.$(OBJEXT) sp_pcre.$(OBJEXT) sp_isdataat.$(OBJEXT) \
-	sp_flowbits.$(OBJEXT) sp_asn1.$(OBJEXT)
-libspd_a_OBJECTS = $(am_libspd_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libspd_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libspd_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/detection-plugins/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/detection-plugins/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -159,23 +222,18 @@
 	$(RANLIB) libspd.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -184,6 +242,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -195,8 +254,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -205,19 +280,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -235,9 +312,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -249,7 +324,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -257,7 +332,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -267,7 +342,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -275,6 +350,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -290,24 +367,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/generators.h snort-2.3.3.new/src/generators.h
--- snort-2.3.3/src/generators.h	2005-04-22 16:03:56.000000000 -0300
+++ snort-2.3.3.new/src/generators.h	2008-02-05 15:18:07.000000000 -0200
@@ -91,6 +91,8 @@
 #define     STREAM4_MULTIPLE_ACKED              18
 #define     STREAM4_EMERGENCY                   19
 #define     STREAM4_SUSPEND                     20
+/* Some missing here which were introduced in 2.4.0 */
+#define     STREAM4_EVASIVE_FIN                 24
 
 #define GENERATOR_SPP_ARPSPOOF      112
 #define     ARPSPOOF_UNICAST_ARP_REQUEST         1
@@ -306,6 +308,7 @@
 "(spp_stream4) TCP TOO FAST RETRANSMISSION WITH DIFFERENT DATA SIZE (possible fragroute) detection"
 #define STREAM4_EMERGENCY_STR "(spp_stream4) Shifting to Emergency Session Mode"
 #define STREAM4_SUSPEND_STR "(spp_stream4) Shifting to Suspend Mode"
+#define STREAM4_EVASIVE_FIN_STR "(spp_stream4) possible EVASIVE FIN detection"
 
 
 #define DECODE_NOT_IPV4_DGRAM_STR "(snort_decoder) WARNING: Not IPv4 datagram!"
diff -Naur snort-2.3.3/src/kernel_snns/alloca.c snort-2.3.3.new/src/kernel_snns/alloca.c
--- snort-2.3.3/src/kernel_snns/alloca.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/alloca.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,43 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/alloca.c,v $
+  SHORTNAME      : alloca.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : alloca
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 3.398
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/03/03 15:59:55 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#if ! defined(HAVE_ALLOCA) || HAVE_ALLOCA == 0
+#include <stdlib.h>
+#include <stdio.h>
+
+/* this is only a poor implementaion of alloca, which never gives
+   memory back to the system */
+
+char *alloca(size_t size)
+{
+    char *p;
+
+    p = (char *) malloc(size);
+    if (!p)
+    {
+	fprintf(stderr, "%s line %d: can't get memory for alloca\n",
+		__FILE__, __LINE__);
+	exit(1);
+    }
+    return p;
+}
+
+#endif /* ! HAVE_ALLOCA */
diff -Naur snort-2.3.3/src/kernel_snns/alloca.h snort-2.3.3.new/src/kernel_snns/alloca.h
--- snort-2.3.3/src/kernel_snns/alloca.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/alloca.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,29 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/alloca.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : alloca
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 2.3.98
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/03/03 17:54:26 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#if ! defined(HAVE_ALLOCA) || HAVE_ALLOCA == 0
+#ifndef _ALLOCA_DEFINED_
+#define _ALLOCA_DEFINED_
+
+#include <sys/types.h>
+extern char *alloca(size_t size);
+
+#endif /* _ALLOCA_DEFINED_ */
+#endif /* ! HAVE_ALLOCA */
diff -Naur snort-2.3.3/src/kernel_snns/arttr_f.c snort-2.3.3.new/src/kernel_snns/arttr_f.c
--- snort-2.3.3/src/kernel_snns/arttr_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/arttr_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,455 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/arttr_f.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel special transfer functions for ART-networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:48 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <math.h>
+#include <string.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"	    /* Kernel types and constants  */
+#include "kr_def.h"	    /* Default values	*/
+#include "kr_const.h"   /* constant values of kernel */
+#include "func_mac.h"   /* Transfer function macros  */
+#include "glob_typ.h"
+
+#include "kr_art.h"     /* global definitions especially for ART networks */
+#include "kr_art1.h"
+#include "kr_art2.h"
+#include "kr_amap.h"
+#include "krart_df.h"
+
+#include "arttr_f.ph"
+
+/*#################################################
+
+GROUP: Unit Output Functions
+
+#################################################*/
+
+
+/*######### for ART2 model ##########*/
+
+/* This is one of the possible noise function f which works
+   between q and v, and x and v units in the F1-Layer in ART2-networks.
+
+              |-
+              |  0, if 0 <= x < Theta
+       f(x) = |
+              | x, if x >= Theta
+              |-
+  It is piecewise linear (PLin)
+*/
+FlintType  OUT_ART2_Noise_PLin (register FlintType activation)
+{
+   if (activation < kra2_get_theta()) {
+      return (0.0);
+   } else {
+      return (activation);
+   } /*if*/
+} /* OUT_ART2_Noise_PLin () */
+
+
+/* This is one of the possible noise function f which works
+   between q and v, and x and v units in the F1-Layer in ART2-networks.
+
+              |-
+              |  (2*Theta*x*x) / (x*x + Theta*Theta), if 0 <= x < Theta
+       f(x) = |
+              |  x                                  , if x >= Theta
+              |-
+
+   It is continously differentiable (ContDiff)
+*/
+FlintType  OUT_ART2_Noise_ContDiff (FlintType activation)
+{
+   register FlintType theta;
+
+   theta = kra2_get_theta();
+
+   if ((0 <= activation) && (activation < theta)) {
+      return ( (2*theta*activation*activation) /
+               (activation*activation+theta*theta)
+             );
+   } else {
+      if (activation >= theta) {
+         return (activation);
+      } else {
+         return (0.0);
+      } /*if*/
+   } /*if*/
+} /* OUT_ART2_Noise_ContDiff () */
+
+
+
+
+
+/*#################################################
+
+GROUP: Unit Activation Functions
+
+#################################################*/
+
+
+/*######### for ART1 model ##########*/
+
+
+FlintType  ACT_ART1_NC  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum = 0.0;
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (((int) (sum+0.5)) >= Art1_NoOfRecUnits) {
+      return (1.0);
+   } else {
+      return (0.0);
+   } /*if*/
+} /* ACT_ART1_NC () */
+
+
+/*######### for ART2 model ##########*/
+
+
+FlintType ACT_ART2_Linear (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum = 0.0;
+
+   if (kra2_Reset()) {
+      return (unit_ptr->i_act);
+   } /*if*/
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return (sum);
+} /* ACT_ART2_Linear () */
+
+
+
+FlintType ACT_ART2_NormP  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   FlintType              NormP;
+   register FlintType     sum = 0.0;
+
+   if (kra2_Reset()) {
+      return (unit_ptr->i_act);
+   } /*if*/
+
+   NormP = kra2_L2_Norm (ART2_P_LAY);
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return ( sum / (ART2_PARAM_e + NormP) );
+} /* ACT_ART2_NormP() */
+
+
+
+FlintType ACT_ART2_NormV  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   FlintType              NormV;
+   register FlintType     sum = 0.0;
+
+   if (kra2_Reset()) {
+      return (unit_ptr->i_act);
+   } /*if*/
+
+   NormV = kra2_L2_Norm (ART2_V_LAY);
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return ( sum / (ART2_PARAM_e + NormV) );
+} /* ACT_ART2_NormV() */
+
+
+
+FlintType ACT_ART2_NormW  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   FlintType              NormW;
+   register FlintType     sum  = 0.0;
+
+   if (kra2_Reset()) {
+      return (unit_ptr->i_act);
+   } /*if*/
+
+   NormW = kra2_L2_Norm (ART2_W_LAY);
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return ( sum / (ART2_PARAM_e + NormW) );
+} /* ACT_ART2_NormW() */
+
+
+
+FlintType ACT_ART2_NormIP  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   FlintType              NormP;
+   FlintType              NormInp;
+   register FlintType     sum = 0.0;
+
+   if (kra2_Reset()) {
+      return (unit_ptr->i_act);
+   } /*if*/
+
+   NormP   = kra2_L2_Norm (ART2_P_LAY);
+   NormInp = kra2_L2_Norm (ART2_INP_LAY);
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return ( sum / (ART2_PARAM_e + kra2_get_c() * NormP + NormInp) );
+} /* ACT_ART2_NormIP() */
+
+
+
+
+FlintType ACT_ART2_Rec  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum  = 0.0;
+
+
+   /* Top Down Phase */
+   if (kra2_topdn_phase()) {
+      if (kra2_Reset()) {
+         return (-1.0);
+      } else {
+         return (unit_ptr->act);
+      } /*if*/
+   } /*if*/
+
+
+   /* Bottom Up Phase */
+   if ( ! kra2_f1_stable() ) {
+      return (-1.0);
+   } /*if*/
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return (sum);
+} /* ACT_ART2_Rec() */
+
+
+
+
+FlintType ACT_ART2_Rst  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum  = 0.0;
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (((sum >= unit_ptr->bias - 0.0001) &&
+       (kra2_Reset())) || (unit_ptr->act >= 0.9))
+   {
+      return (1.0);
+   } else {
+      return (0.0);
+   } /*if*/
+} /* ACT_ART2_Rst () */
+
+
+
+
+
+
+
+
+
+
+/*######### for ARTMAP model ##########*/
+
+
+FlintType  ACT_ARTMAP_NCa  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum = 0.0;
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (((int) (sum+0.5)) >= ArtMap_NoOfRecUnits_a) {
+      return (1.0);
+   } else {
+      return (0.0);
+   } /*if*/
+} /* ACT_ARTMAP_NCa () */
+
+
+FlintType  ACT_ARTMAP_NCb  (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType     sum = 0.0;
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (((int) (sum+0.5)) >= ArtMap_NoOfRecUnits_b) {
+      return (1.0);
+   } else {
+      return (0.0);
+   } /*if*/
+} /* ACT_ARTMAP_NCb () */
+
+
+
+/* This is an important function for ARTMAP networks
+   it calculates the net input to the drho unit (sum)
+   If sum is greater than 0 then the activation of
+   drho becomes  sum-1+epsilon where epsilon << 1
+*/
+FlintType  ACT_ARTMAP_DRho (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    sum = 0.0;
+   float                 epsilon = 0.0001;
+
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   /* sum equals     (qu - rho_a + rg + cl_b) */
+   if (sum - 2 >= 0) {
+      return (sum - 2 + epsilon);
+   } else {
+      return (0.0);
+   } /*if*/
+
+} /* ACT_ARTMAP_DRho () */
+
+
+
+
+/*#################################################
+
+GROUP: Site Functions
+
+#################################################*/
diff -Naur snort-2.3.3/src/kernel_snns/arttr_f.h snort-2.3.3.new/src/kernel_snns/arttr_f.h
--- snort-2.3.3/src/kernel_snns/arttr_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/arttr_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,43 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/arttr_f.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel special transfer functions for ART-networks 
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:45 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _ARTTR_F_DEFINED_
+#define  _ARTTR_F_DEFINED_
+
+
+extern FlintType  OUT_ART2_Noise_PLin (register FlintType activation);
+extern FlintType  OUT_ART2_Noise_ContDiff (FlintType activation);
+extern FlintType  ACT_ART1_NC  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_Linear (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_NormP  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_NormV  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_NormW  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_NormIP  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_Rec  (struct Unit *unit_ptr);
+extern FlintType ACT_ART2_Rst  (struct Unit *unit_ptr);
+extern FlintType  ACT_ARTMAP_NCa  (struct Unit *unit_ptr);
+extern FlintType  ACT_ARTMAP_NCb  (struct Unit *unit_ptr);
+extern FlintType  ACT_ARTMAP_DRho (struct Unit *unit_ptr);
+
+
+
+
+#endif 
+
+/* 43 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/arttr_f.ph snort-2.3.3.new/src/kernel_snns/arttr_f.ph
--- snort-2.3.3/src/kernel_snns/arttr_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/arttr_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,46 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/arttr_f.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel special transfer functions for ART-networks 
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:45 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _ARTTR_F_DEFINED_
+#define  _ARTTR_F_DEFINED_
+
+/* begin global definition section */
+
+FlintType  OUT_ART2_Noise_PLin (register FlintType activation);
+FlintType  OUT_ART2_Noise_ContDiff (FlintType activation);
+FlintType  ACT_ART1_NC  (struct Unit *unit_ptr);
+FlintType ACT_ART2_Linear (struct Unit *unit_ptr);
+FlintType ACT_ART2_NormP  (struct Unit *unit_ptr);
+FlintType ACT_ART2_NormV  (struct Unit *unit_ptr);
+FlintType ACT_ART2_NormW  (struct Unit *unit_ptr);
+FlintType ACT_ART2_NormIP  (struct Unit *unit_ptr);
+FlintType ACT_ART2_Rec  (struct Unit *unit_ptr);
+FlintType ACT_ART2_Rst  (struct Unit *unit_ptr);
+FlintType  ACT_ARTMAP_NCa  (struct Unit *unit_ptr);
+FlintType  ACT_ARTMAP_NCb  (struct Unit *unit_ptr);
+FlintType  ACT_ARTMAP_DRho (struct Unit *unit_ptr);
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/art_typ.h snort-2.3.3.new/src/kernel_snns/art_typ.h
--- snort-2.3.3/src/kernel_snns/art_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/art_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,50 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/art_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Global Datatypes and Constants for ART Networks
+  NOTES          : For User's Application Programs, User-Interface and Kernel
+
+  AUTHOR         : Niels Mache
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:39 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef ART_GLOBAL_TYPES
+
+#define ART_GLOBAL_TYPES
+
+
+
+/* define the possible values for the status of an ART-network
+*/
+#define ART_NO_CLASSIFICATION 0  /* The network hasn't reched a stable state
+                                    yet
+                                 */
+#define ART_CLASSIFIED        1  /* The network has found a class for the
+                                    actual input pattern
+                                 */
+#define ART_NOT_CLASSIFIABLE  2  /* The network was not able to find a
+                                    class for the actual input pattern
+                                 */
+#define ART_DONT_KNOW         3  /* The ARTMAP network does not find an
+                                    appropriate class -> all map units
+                                    are turned on.
+                                 */
+
+
+
+
+
+
+/* types */
+typedef   int                    art_cl_status;
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/art_ui.c snort-2.3.3.new/src/kernel_snns/art_ui.c
--- snort-2.3.3/src/kernel_snns/art_ui.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/art_ui.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,340 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/art_ui.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel-User-Interface for ART Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:18 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include "kr_typ.h"     /* Global Definitions for User Interface */
+#include "kr_ui.h"      /* User Interface - Function Prototypes */
+
+#include "kr_const.h"   /* Global constants for kernel */
+
+#include "glob_typ.h"   /* Global Definitions for User Interface */
+#include "kernel.h"
+
+#include "art_typ.h"    /* ART Global Definitions */
+#include "kr_art.h"     /* ART Kernel Function Prototypes */
+#include "kr_art1.h"
+#include "kr_art2.h"
+#include "kr_amap.h"
+#include "krart_df.h"   /* ART definitions and Macros */
+#include "art_ui.h"     /* ART User Interface Function Prototypes */
+
+
+
+/* funcname: artui_GetClassifiedStatus ()
+   Purpose : Returns the classification status of the actual network
+   in-Par  : none
+   out-Par : status :   Possible results are:   ART_NO_CLASSIFICATION
+                                                ART_CLASSIFIED
+                                                ART_NOT_CLASSIFIABLE
+                                                ART_DONT_KNOW
+   ret_val : krui_err:  Returns an error if no Units defined
+*/
+krui_err artui_getClassifiedStatus (art_cl_status *status)
+{
+   krui_err        ret_code           = KRERR_NO_ERROR;
+
+   *status = ART_NO_CLASSIFICATION;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   /* Check if network has been initialized or update- or learning function
+      has been applied to it. If not, we can not know, which type of ART
+      network this is, so we return, that there has been no classification.
+   */
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   switch (TopoSortID) {
+   case ART1_TOPO_TYPE:
+      if (ART1_CLASSIFIED) {
+         *status = ART_CLASSIFIED;
+      } else {
+         if (ART1_NOT_CLASSIFIABLE) {
+            *status = ART_NOT_CLASSIFIABLE;
+         } /*if*/
+      } /*if*/
+      break;
+   case ART2_TOPO_TYPE:
+      if (ART2_CLASSIFIED) {
+         *status = ART_CLASSIFIED;
+      } else {
+         if (ART2_NOT_CLASSIFIABLE) {
+           *status = ART_NOT_CLASSIFIABLE;
+         } /*if*/
+      } /*if*/
+   case ARTMAP_TOPO_TYPE:
+      if (ARTMAP_CLASSIFIED) {
+         if (kram_AllMapUnitsActive()) {
+            *status = ART_DONT_KNOW;
+         } else {
+            *status = ART_CLASSIFIED;
+         } /*if*/
+      } else {
+         if (ARTMAP_NOT_CLASSIFIABLE) {
+            *status = ART_NOT_CLASSIFIABLE;
+         } /*if*/
+      } /*if*/
+   default:
+      break;
+   } /* switch */
+
+   return (ret_code);
+} /* artui_getClassifiedStatus () */
+
+
+
+
+/* funcname: artui_getClassNo ()
+   Purpose : Returns the index of the F2-winner-unit
+   in-par  : none
+   out-par : class_no :  If unit_no is negative, then no winning unit exists.
+   ret-val : krui_err :  Returns an error if no Units defined.
+*/
+krui_err artui_getClassNo (int *class_no)
+{
+   krui_err       ret_code        = KRERR_NO_ERROR;
+
+   *class_no = -1;
+
+   if (krui_getNoOfUnits () == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   /* Check if network has been initialized or update- or learning function
+      has been applied to it. If not, we can not know, which type of ART
+      network this is, so we return, that there has been no classification.
+      If there is a adequate TopoSortID, then we get the no. of the class,
+      if there has been a classification.
+   */
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   switch (TopoSortID) {
+   case ART1_TOPO_TYPE:
+      if (ART1_CLASSIFIED) {
+         *class_no = kra1_getClassNo ();
+      } /*if*/
+      break;
+   case ART2_TOPO_TYPE:
+      if (ART2_CLASSIFIED) {
+         *class_no = kra2_getClassNo ();
+      } /*if*/
+   case ARTMAP_TOPO_TYPE:
+      if (ARTMAP_CLASSIFIED && (!kram_AllMapUnitsActive())) {
+         *class_no = kram_getClassNo ();
+      } /*if*/
+   default:
+      break;
+   } /* switch */
+
+   return (ret_code);
+} /* artui_getClassNo () */
+
+
+
+/* funcname: artui_getN ()
+   Purpose : Returns the number of F1-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : N : number of F1-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getN (int *N)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *N = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   if ((TopoSortID == ART1_TOPO_TYPE) || (TopoSortID == ART2_TOPO_TYPE)) {
+      *N = NoOfInputUnits;
+   } /*if*/
+
+   return (ret_code);
+} /* artui_getN () */
+
+
+/* funcname: artui_getM ()
+   Purpose : Returns the number of F2-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : M : number of F2-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getM (int *M)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *M = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   switch (TopoSortID) {
+   case ART1_TOPO_TYPE:
+      *M = Art1_NoOfRecUnits;
+      break;
+   case ART2_TOPO_TYPE:
+      *M = Art2_NoOfRecUnits;
+      break;
+   } /*switch*/
+
+   return (ret_code);
+} /* artui_getM () */
+
+
+
+/* funcname: artui_getNa ()
+   Purpose : Returns the number of F1a-units in an ARTMAP network
+   in-par  : none
+   out-par : Na: number of F1a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNa (int *Na)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *Na = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   if (TopoSortID == ARTMAP_TOPO_TYPE) {
+      *Na = ArtMap_NoOfInpUnits_a;
+   } /*if*/
+
+   return (ret_code);
+} /* artui_getNa () */
+
+
+
+
+/* funcname: artui_getNb ()
+   Purpose : Returns the number of F1b-units in an ARTMAP network
+   in-par  : none
+   out-par : Nb: number of F1b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNb (int *Nb)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *Nb = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   if (TopoSortID == ARTMAP_TOPO_TYPE) {
+      *Nb = ArtMap_NoOfInpUnits_b;
+   } /*if*/
+
+   return (ret_code);
+} /* artui_getNb () */
+
+
+
+
+/* funcname: artui_getMa ()
+   Purpose : Returns the number of F2a-units in an ARTMAP network
+   in-par  : none
+   out-par : Ma: number of F2a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMa (int *Ma)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *Ma = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   if (TopoSortID == ARTMAP_TOPO_TYPE) {
+      *Ma = ArtMap_NoOfRecUnits_a;
+   } /*if*/
+
+   return (ret_code);
+} /* artui_getMa () */
+
+
+
+/* funcname: artui_getMb ()
+   Purpose : Returns the number of F2b-units in an ARTMAP network
+   in-par  : none
+   out-par : Mb: number of F2b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMb (int *Mb)
+{
+   krui_err         ret_code = KRERR_NO_ERROR;
+
+   *Mb = -1;
+
+   if (krui_getNoOfUnits() == 0) {
+      ret_code = KRERR_NO_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (NetModified) {
+      return (ret_code);
+   } /*if*/
+
+   if (TopoSortID == ARTMAP_TOPO_TYPE) {
+      *Mb = ArtMap_NoOfRecUnits_b;
+   } /*if*/
+
+   return (ret_code);
+} /* artui_getMb () */
diff -Naur snort-2.3.3/src/kernel_snns/art_ui.h snort-2.3.3.new/src/kernel_snns/art_ui.h
--- snort-2.3.3/src/kernel_snns/art_ui.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/art_ui.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,135 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/art_ui.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel User Interface Function Prototypes for ART networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann 
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:42 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _ART_UI_DEFINED_
+#define  _ART_UI_DEFINED_
+
+
+/* funcname: artui_getClassifiedStatus ()
+   Purpose : Returns the classification status of the actual network
+   in-Par  : none
+   out-Par : status :   Possible results are:   ART_NO_CLASSIFICATION
+                                                ART_CLASSIFIED
+                                                ART_NOT_CLASSIFIABLE
+                                                ART_DONT_KNOW
+   ret_val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getClassifiedStatus (
+                                    art_cl_status *status
+                                   );
+
+
+
+/* funcname: artui_getClassNo ()
+   Purpose : Returns the index of the F2-winner-unit
+   in-par  : none
+   out-par : class_no:  If class_no is negative, then no winning unit exists.
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getClassNo (
+                           int *class_no
+                          );
+
+
+
+/* funcname: artui_getN ()
+   Purpose : Returns the number of F1-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : N : number of F1-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getN (
+                     int *N
+                    );
+
+
+
+
+/* funcname: artui_getM ()
+   Purpose : Returns the number of F2-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : M : number of F2-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getM (
+                     int *M
+                    );
+
+
+
+
+/* funcname: artui_getNa ()
+   Purpose : Returns the number of F1a-units in an ARTMAP network
+   in-par  : none
+   out-par : Na: number of F1a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNa (
+                     int *Na
+                    );
+
+
+
+
+/* funcname: artui_getNb ()
+   Purpose : Returns the number of F1b-units in an ARTMAP network
+   in-par  : none
+   out-par : Nb: number of F1b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNb (
+                     int *Nb
+                    );
+
+
+
+
+/* funcname: artui_getMa ()
+   Purpose : Returns the number of F2a-units in an ARTMAP network
+   in-par  : none
+   out-par : Ma: number of F2a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMa (
+                     int *Ma
+                    );
+
+
+
+
+/* funcname: artui_getMb ()
+   Purpose : Returns the number of F2b-units in an ARTMAP network
+   in-par  : none
+   out-par : Mb: number of F2b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMb (
+                     int *Mb
+                    );
+
+
+
+
+#endif 
+
+
+
+
+
+/* 135 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/art_ui.ph snort-2.3.3.new/src/kernel_snns/art_ui.ph
--- snort-2.3.3/src/kernel_snns/art_ui.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/art_ui.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,138 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/art_ui.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel User Interface Function Prototypes for ART networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann 
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:43 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _ART_UI_DEFINED_
+#define  _ART_UI_DEFINED_
+
+/* begin global definition section */
+
+/* funcname: artui_getClassifiedStatus ()
+   Purpose : Returns the classification status of the actual network
+   in-Par  : none
+   out-Par : status :   Possible results are:   ART_NO_CLASSIFICATION
+                                                ART_CLASSIFIED
+                                                ART_NOT_CLASSIFIABLE
+                                                ART_DONT_KNOW
+   ret_val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getClassifiedStatus (
+                                    art_cl_status *status
+                                   );
+
+
+
+/* funcname: artui_getClassNo ()
+   Purpose : Returns the index of the F2-winner-unit
+   in-par  : none
+   out-par : class_no:  If class_no is negative, then no winning unit exists.
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getClassNo (
+                           int *class_no
+                          );
+
+
+
+/* funcname: artui_getN ()
+   Purpose : Returns the number of F1-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : N : number of F1-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getN (
+                     int *N
+                    );
+
+
+
+
+/* funcname: artui_getM ()
+   Purpose : Returns the number of F2-units in an ART1 or ART2 network
+   in-par  : none
+   out-par : M : number of F2-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getM (
+                     int *M
+                    );
+
+
+
+
+/* funcname: artui_getNa ()
+   Purpose : Returns the number of F1a-units in an ARTMAP network
+   in-par  : none
+   out-par : Na: number of F1a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNa (
+                     int *Na
+                    );
+
+
+
+
+/* funcname: artui_getNb ()
+   Purpose : Returns the number of F1b-units in an ARTMAP network
+   in-par  : none
+   out-par : Nb: number of F1b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getNb (
+                     int *Nb
+                    );
+
+
+
+
+/* funcname: artui_getMa ()
+   Purpose : Returns the number of F2a-units in an ARTMAP network
+   in-par  : none
+   out-par : Ma: number of F2a-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMa (
+                     int *Ma
+                    );
+
+
+
+
+/* funcname: artui_getMb ()
+   Purpose : Returns the number of F2b-units in an ARTMAP network
+   in-par  : none
+   out-par : Mb: number of F2b-Units (-1 is returned if not topologically sorted)
+   ret-val : krui_err:  Returns an error if no Units defined.
+*/
+krui_err artui_getMb (
+                     int *Mb
+                    );
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/calc_err.c snort-2.3.3.new/src/kernel_snns/calc_err.c
--- snort-2.3.3/src/kernel_snns/calc_err.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/calc_err.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,108 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/calc_err.c,v $
+  SHORTNAME      : calc_err
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Tool: Calculates the error of a table-lookup function
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 06.12.91
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:21 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <math.h>
+
+
+#define MINUS_INFINITE_BORDER  -100.0
+#define PLUS_INFINITE_BORDER	100.0
+#define CALC_STEPS 200000
+
+
+
+/* ***************************************************************** */
+
+/*  Sigmoid Function
+*/
+double	f( x )
+double	x;
+{
+  return( 1.0 / (1.0 + exp( -x )));
+}
+
+/*  Sigmoid Function
+    using table lookup and linear approximation method
+*/
+double	 LogisticTbl( x )
+double	x;
+{
+#include "sigmoid.tbl"
+
+  register int	index;
+
+
+  index = (int) (x * SCALE_FACTOR) + INDEX_OFFSET;
+
+  if (index < 0)
+    {  /*  x is less then MIN_APPROX_X:
+	   approx. func value to MINUS_INFINITE_FUNC_VALUE  */
+    if (index <= MIN_INDEX)
+      { /*  printf( "x below -infinite : %g\n", x );  */
+	return( MINUS_INFINITE_FUNC_VALUE );
+      }
+    /*	printf( "x below MIN_APPROX_X : %g\n", x );  */
+    return( m[0] * x + b[0] );
+    }
+
+  if (index > NO_OF_APPROX)
+    {  /*  x is greater then MAX_APPROX_X:
+	   approx. func value to PLUS_INFINITE_FUNC_VALUE  */
+    if (index >= MAX_INDEX)
+      { /*  printf( "x above +infinite : %g\n", x );  */
+	return( PLUS_INFINITE_FUNC_VALUE );
+      }
+    /*	printf( "x above MAX_APPROX_X : %g\n", x );  */
+    return( m[ NO_OF_APPROX ] * x + b[ NO_OF_APPROX ] );
+    }
+
+  return( m[ index ] * x + b[ index ] );
+}
+
+
+/* ***************************************************************** */
+
+
+
+
+int  main()
+{
+  double  x, step, y1, y2, devit;
+  int	  i, nl_cycle;
+
+
+  devit = 0.0;
+  step = (PLUS_INFINITE_BORDER - MINUS_INFINITE_BORDER) / (double) CALC_STEPS;
+
+  x = MINUS_INFINITE_BORDER;
+  y1 = fabs( f(x) - LogisticTbl( x ) );
+  x += step;
+
+  for (i = 0; i < CALC_STEPS - 1; i++)
+    {
+    y2 = fabs( f(x) - LogisticTbl( x ) );
+    devit += 0.5 * (y1 + y2) * step;
+    y1 = y2;
+    x += step;
+    }
+
+  fprintf( stdout, "Error in [%+g,%+g]: %.10g\n",
+	   MINUS_INFINITE_BORDER, PLUS_INFINITE_BORDER, devit );
+}
diff -Naur snort-2.3.3/src/kernel_snns/cc_display.c snort-2.3.3.new/src/kernel_snns/cc_display.c
--- snort-2.3.3/src/kernel_snns/cc_display.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_display.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,322 @@
+/****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_display.c,v $
+  SHORTNAME      : cc_display.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Display Functions of Cascade-Correlation
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl /  Juergen Gatter
+  DATE           : 26.11.95
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Christian Wehrfritz
+  RCS VERSION    : $Revision: 1.10 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:49 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"	
+#include "kr_const.h"	 
+#include "kr_def.h"	 
+#include "kr_mac.h"
+#include "kernel.h"
+#include "kr_ui.h"
+#include "kr_newpattern.h"
+#include "cc_mac.h"
+#include "cc_type.h"
+#include "cc_glob.h"
+
+#include "cc_display.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_calculateNetParameters
+
+  PURPOSE  : Calculates the position of the current input, hidden and output
+             layer.
+  NOTES    :
+
+  UPDATE   : 13.11.95 <changed by Juergen Gatter>
+******************************************************************************/
+
+krui_err cc_calculateNetParameters()
+{         
+ struct Unit *unitPtr;
+ int x,y;
+ int xPosOfLastInsertedHiddenUnit,yPosOfLastInsertedHiddenUnit;
+
+ int inputXMin=MAX_POS, inputXMax=0,
+     hiddenXMin=MAX_POS,hiddenXMax=0,
+     outputXMin=MAX_POS,outputXMax=0;
+ int inputYMin=MAX_POS,inputYMax=0,
+     hiddenYMin=MAX_POS,hiddenYMax=0,
+     outputYMin=MAX_POS,outputYMax=0;
+ int xInputOffset=0,xHiddenOffset=0,xOutputOffset=0;
+ int yInputOffset=0,yHiddenOffset=0,yOutputOffset=0;
+
+ NoOfInputUnits  = 0;
+ NoOfHiddenUnits = 0;
+ NoOfOutputUnits = 0;
+
+ FOR_ALL_UNITS(unitPtr){  /* calculate the dimensions of the actual net */
+   x = GET_UNIT_XPOS(unitPtr);
+   y = GET_UNIT_YPOS(unitPtr);
+
+   if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+     NoOfInputUnits++;
+     inputYMax = MAX(y,inputYMax); inputYMin = MIN(y,inputYMin);
+     inputXMax = MAX(x,inputXMax); inputXMin = MIN(x,inputXMin);
+   }
+   else if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+     NoOfHiddenUnits++;
+     hiddenYMax = MAX(y,hiddenYMax); hiddenYMin = MIN(y,hiddenYMin);
+     hiddenXMax = MAX(x,hiddenXMax); hiddenXMin = MIN(x,hiddenXMin);
+   }
+   else if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+     NoOfOutputUnits++;
+     outputYMax = MAX(y,outputYMax); outputYMin = MIN(y,outputYMin);
+     outputXMax = MAX(x,outputXMax); outputXMin = MIN(x,outputXMin);
+   }
+ }
+
+ if(NoOfHiddenUnits==0){ /* init Positions for empty network */
+   hiddenXMax = hiddenXMin = X_MIN_POS + (inputXMax-inputXMin) + 3;
+   hiddenYMax = hiddenYMin = Y_MIN_POS;
+ }
+
+ xPosOfLastInsertedHiddenUnit =
+       X_MIN_POS + (inputXMax - inputXMin) + (hiddenXMax - hiddenXMin) + 3;
+
+ yPosOfLastInsertedHiddenUnit = Y_MIN_POS-1;
+
+ cc_outputXMax =
+       X_MIN_POS + (inputXMax-inputXMin) + (hiddenXMax-hiddenXMin) + 
+                   (outputXMax-outputXMin) + 6;
+
+ xInputOffset = X_MIN_POS - inputXMin;
+ yInputOffset = Y_MIN_POS - inputYMin;
+ xHiddenOffset = X_MIN_POS + (inputXMax-inputXMin) - hiddenXMin + 3;
+ yHiddenOffset = Y_MIN_POS - hiddenYMin;
+ xOutputOffset = X_MIN_POS + (inputXMax-inputXMin) + (hiddenXMax-hiddenXMin) - outputXMin + 4;
+ yOutputOffset = Y_MIN_POS - outputYMin;   
+
+ cc_lastFirstOutputRow=MAX_POS;
+
+ FOR_ALL_UNITS(unitPtr){
+   if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr) ) {
+     SET_UNIT_XPOS(unitPtr,GET_UNIT_XPOS(unitPtr)+xInputOffset);
+     SET_UNIT_YPOS(unitPtr,GET_UNIT_YPOS(unitPtr)+yInputOffset);
+   }
+   if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+     SET_UNIT_XPOS(unitPtr,GET_UNIT_XPOS(unitPtr)+xHiddenOffset);
+     SET_UNIT_YPOS(unitPtr,GET_UNIT_YPOS(unitPtr)+yHiddenOffset);
+   }
+   if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr) ) {
+     SET_UNIT_XPOS(unitPtr,GET_UNIT_XPOS(unitPtr)+xOutputOffset);
+     SET_UNIT_YPOS(unitPtr,GET_UNIT_YPOS(unitPtr)+yOutputOffset);
+     if(cc_lastFirstOutputRow > GET_UNIT_XPOS(unitPtr))
+        cc_lastFirstOutputRow =  GET_UNIT_XPOS(unitPtr);
+
+   }
+ }
+
+ if(NoOfHiddenUnits!=0) {
+   FOR_ALL_UNITS(unitPtr){
+     if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+       x = GET_UNIT_XPOS(unitPtr);
+       y = GET_UNIT_YPOS(unitPtr);
+       if(x == xPosOfLastInsertedHiddenUnit){
+         if(y >= yPosOfLastInsertedHiddenUnit){
+           yPosOfLastInsertedHiddenUnit = y;
+         }
+       }
+     }
+   }
+ }
+
+ FOR_ALL_UNITS(unitPtr){
+   if(IS_INPUT_UNIT(unitPtr))
+     CC_SET_LAYER_NO(unitPtr,0);
+   if(IS_OUTPUT_UNIT(unitPtr))
+     CC_SET_LAYER_NO(unitPtr,NoOfLayers+2);
+ }
+
+ cc_outputXMax=/* *outXMax; */ X_MIN_POS+4;
+
+ /* cc_display_mode = Y_MAX_MODE1;
+ cc_LayerDistance = 2;
+ */
+ cc_hiddenXminPos = hiddenXMin;
+
+ return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_setSpecialUnits
+
+  PURPOSE  : Positions the SpecialUnits
+  NOTES    :
+
+  UPDATE   : 25.11.95 <Juergen Gatter>
+******************************************************************************/
+
+
+void cc_setSpecialUnits(int X_Max)
+{
+  int Multiplikator,cnt;
+  struct Unit* UnitPtr;
+
+  if((cc_MaxSpecialUnitNo==0)||(NetLearnAlgorithm==TACOMA)) return;
+  Multiplikator = MAX(1,(X_Max-X_MIN_POS)/cc_MaxSpecialUnitNo);
+
+  FOR_ALL_SPECIAL_UNITS(UnitPtr,cnt){
+     SET_UNIT_XPOS(UnitPtr,X_MIN_POS+Multiplikator*cnt);
+     SET_UNIT_YPOS(UnitPtr,Y_MIN_POS-2);
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : cc_setHiddenUnit
+
+  PURPOSE  : Positions the hidden layer.
+  NOTES    : originally, only the new hidden unit was placed.
+             But with the modifications, it's easier to re-place
+             all hidden/output-units new.
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+krui_err cc_setHiddenUnit(struct Unit *NotUsedUnitPtr, int LayerOfNewUnit)
+
+{
+
+  struct Unit* UnitPtr;
+  int i,LayerNo;
+  int* UnitCount;
+  int diff;
+
+  CALLOC_ERRORCHECK(UnitCount,NoOfLayers+2,int);
+
+  UnitCount[0]=0;
+  for(i=1;i<=NoOfLayers;i++){
+      ListOfLayers[i].xPosFirstRow = FIRST_ROW_NEXT_LAYER(i-1);
+      UnitCount[i]=0;
+  }
+
+  diff = FIRST_ROW_NEXT_LAYER(NoOfLayers)-cc_lastFirstOutputRow;
+
+  cc_outputXMax = cc_lastFirstOutputRow = FIRST_ROW_NEXT_LAYER(NoOfLayers);
+ 
+  if ((LayerOfNewUnit==0)||((ListOfLayers[LayerOfNewUnit].NoOfUnitsInLayer % cc_display_mode)==1))
+  {               
+    cc_redisplay();                       /* look, if we must change the mode */
+    cc_setSpecialUnits(cc_outputXMax+2);  /* re-place special units */ 
+  }
+
+  FOR_ALL_UNITS(UnitPtr){
+      if((IS_HIDDEN_UNIT(UnitPtr))||
+	 ((NetLearnAlgorithm==TACOMA)&&(IS_SPECIAL_UNIT(UnitPtr)))) {
+	  LayerNo=CC_LAYER_NO(UnitPtr);
+	  SET_UNIT_XPOS(UnitPtr,ListOfLayers[LayerNo].xPosFirstRow +
+			UnitCount[LayerNo] / cc_display_mode);
+	  SET_UNIT_YPOS(UnitPtr,Y_MIN_POS+UnitCount[LayerNo] % cc_display_mode);
+	  UnitCount[LayerNo]++;
+      }else if(IS_OUTPUT_UNIT(UnitPtr)){
+/*	  SET_UNIT_XPOS(UnitPtr,FIRST_ROW_NEXT_LAYER(NoOfLayers));*/
+	  SET_UNIT_XPOS(UnitPtr,GET_UNIT_XPOS(UnitPtr)+diff);
+      }
+  }
+  FREE_IF_USED(UnitCount); 
+  return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_updatePosOfSpecialUnits
+
+  PURPOSE  : Updates the position of the special units.
+  NOTES    :
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+void cc_updatePosOfSpecialUnits(void)
+{
+ int x,outputXMax=0;
+ struct Unit *unitPtr;
+ 
+ if(cc_cascade) {
+   FOR_ALL_UNITS(unitPtr) {
+     if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+       x = GET_UNIT_XPOS(unitPtr);
+       if((x >= outputXMax) || (outputXMax==0)){
+         outputXMax = x;
+       }
+     }
+   }
+   cc_setSpecialUnits(outputXMax+2);
+   cc_cascade = 0;
+   cc_redisplay();
+ }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : void cc_redisplay
+
+  PURPOSE  : changes, iff necessary, the display-mode.
+  NOTES    :
+
+  UPDATE   : 20.11.95 <Juergen Gatter>
+******************************************************************************/
+
+void cc_redisplay(void)
+{
+  int MaxUnitsInLayer = 0;
+  int i;
+
+  for(i=1;i<=NoOfLayers;i++){
+      ListOfLayers[i].xPosFirstRow = FIRST_ROW_NEXT_LAYER(i-1);
+  }                 /* eval the pos of the outputlayer */
+
+  if (FIRST_ROW_NEXT_LAYER(NoOfLayers) < X_MAX_DISPLAYABLE) return; 
+  /* ah, we must change something */
+
+  for(i=0;i<=NoOfLayers;i++)
+     MaxUnitsInLayer = MAX(ListOfLayers[i].NoOfUnitsInLayer,MaxUnitsInLayer);
+  
+  if (MaxUnitsInLayer <= cc_display_mode){
+           /* then a change of cc_display_mode wouldn't help */
+     cc_LayerDistance = MAX(1,cc_LayerDistance-1);
+     if (cc_LayerDistance==1)
+        cc_display_mode = Y_MAX_MODE5;
+  }        /* if LayerDistance==1 there could be arbritrary large Layers. */
+  else{    /* I change the display mode */
+     switch(cc_display_mode){
+        case(Y_MAX_MODE1) : cc_display_mode = Y_MAX_MODE2; break;
+        case(Y_MAX_MODE2) : cc_display_mode = Y_MAX_MODE3; break;
+        case(Y_MAX_MODE3) : cc_display_mode = Y_MAX_MODE4; break;
+        case(Y_MAX_MODE4) : cc_display_mode = Y_MAX_MODE5; break;
+        case(Y_MAX_MODE5) : return;
+     } 
+  }
+  
+ if(cc_display_mode != Y_MAX_MODE5) cc_redisplay();
+  return;
+}
+
diff -Naur snort-2.3.3/src/kernel_snns/cc_display.h snort-2.3.3.new/src/kernel_snns/cc_display.h
--- snort-2.3.3/src/kernel_snns/cc_display.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_display.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,37 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_display.h,v $
+  SHORTNAME      : cc_display.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Display Functions of Cascade-Correlation
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl /  Juergen Gatter
+  DATE           : 26.11.95
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Christian Wehrfritz
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:48 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_DISPLAY_DEFINED_
+#define  _CC_DISPLAY_DEFINED_
+
+/* begin global definition section */
+extern krui_err cc_calculateNetParameters(void);
+extern void cc_setSpecialUnits(int X_Max);
+extern krui_err cc_setHiddenUnit(struct Unit *UnitPtr,int LayerOfNewUnit);
+extern void cc_updatePosOfSpecialUnits(void);
+extern void cc_redisplay(void);
+
+extern int cc_hiddenXminPos;
+
+/* end   global definition section */
+
+/* begin privat definition section */
+/* end privat definition section */
+
+#endif /* _CC_DISPLAY_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_display.ph snort-2.3.3.new/src/kernel_snns/cc_display.ph
--- snort-2.3.3/src/kernel_snns/cc_display.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_display.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,42 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_display.ph,v $
+  SHORTNAME      : cc_display.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl, Christian Wehrfritz (PCC)
+  DATE           : 5.2.1993
+
+  CHANGED BY     : Michael Schmalzl
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:50 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_DISPLAY_DEFINED_
+#define  _CC_DISPLAY_DEFINED_
+
+/* begin global definition section */
+krui_err cc_calculateNetParameters(void);
+void cc_setSpecialUnits(int X_Max);
+krui_err cc_setHiddenUnit(struct Unit *UnitPtr,int LayerOfNewUnit);
+void cc_updatePosOfSpecialUnits(void);
+void cc_redisplay(void);
+
+int cc_hiddenXminPos;
+
+/* end   global definition section */
+
+/* begin privat definition section */
+int cc_display_mode=Y_MAX_MODE1;
+int cc_LayerDistance=DEFAULT_DISTANCE_BETWEEN_LAYERS;
+int cc_lastFirstOutputRow;
+
+
+/* end privat definition section */
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/cc_glob.c snort-2.3.3.new/src/kernel_snns/cc_glob.c
--- snort-2.3.3/src/kernel_snns/cc_glob.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_glob.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,990 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_glob.c,v $
+  SHORTNAME      : cc_glob
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Common functions for all CC algorithms 
+  NOTES          : This file was put together from the earlier files cc_rcc 
+                   and cc_rcc_topo
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 5.2.93
+
+  CHANGED BY     : Guenter Mamier
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:51 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+
+#include "kr_typ.h"	
+#include "kr_const.h"	 
+#include "kr_def.h"	 
+#include "random.h"
+#include "kr_mac.h"
+#include "kernel.h"
+#include "kr_ui.h"
+#include "kr_newpattern.h"
+#include "cc_mac.h"	
+#include "cc_type.h"
+#include "cc_modify.h"
+#include "cc_display.h"
+
+#include "cc_glob.ph"   
+
+
+/*****************************************************************************
+  FUNCTION : cc_printHeadline
+  PURPOSE  : prints Headline iff cc_printOnOff is ON
+  NOTES    :
+
+  UPDATE   : 30.3.96 <Juergen Gatter>
+******************************************************************************/
+void cc_printHeadline(char* s,int Length)
+{
+    int LengthText,Length1,Length2;
+    int i;
+
+    LengthText=strlen(s)+2;
+    if ((LengthText>Length)||(!cc_printOnOff))
+	return;
+    Length2 = ((Length-LengthText) / 2);
+    Length1 = Length-Length2-LengthText;
+    printf("\n");
+    for (i=0;i<Length1;i++)
+	printf("-");
+    printf(" %s ",s);
+    for (i=0;i<Length2;i++)
+	printf("-");
+    printf("\n\n");
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_getErr
+  PURPOSE  : get sum of squared errors (sse) = (o_actual - y_desired)^2
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+float cc_getErr (int StartPattern, int EndPattern)
+{
+    int p=0, sub, start, end, n,  pat, dummy;
+    float sse=0, devit,error;
+    register Patterns out_pat;
+    register struct Unit *OutputUnitPtr;
+    int Correct;
+    int WhichWin,CorrWin;
+    float MaxAct;
+
+    KernelErrorCode = kr_initSubPatternOrder(StartPattern,EndPattern);
+    ERROR_CHECK;
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK;
+    SumSqError = 0.0;
+
+    for(p=start; p<=end;p++){
+	Correct=TRUE;
+	MaxAct=0.0;
+	cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	PROPAGATE_THROUGH_OUTPUT_LAYER(OutputUnitPtr,dummy,p);
+
+	out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+
+	FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,dummy){
+	    if (*out_pat > 0.5) CorrWin = dummy;
+	    devit =  OutputUnitPtr->Out.output - *(out_pat++);
+	    if  (OutputUnitPtr->Out.output > MaxAct)
+	    {
+		MaxAct=OutputUnitPtr->Out.output;
+		WhichWin=dummy;
+	    }
+	    if (abs(devit) > 0.2) Correct=FALSE;
+	    sse += devit*devit;
+	    error = devit * 
+		((*OutputUnitPtr->act_deriv_func)(OutputUnitPtr) + cc_fse);
+	    SumSqError += error*error;
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return sse;
+}
+
+/*****************************************************************************
+  FUNCTION : cc_LayerCorrectnessTest
+
+  PURPOSE  : Tests if the layer data is valid
+
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+void cc_LayerCorrectnessTest(float* ParameterInArray,
+			     int StartPattern, int EndPattern)
+{
+    int LayerDataCorrect=TRUE;
+    struct Unit *UnitPtr,*UnitPtr2;
+    struct Link *LinkPtr;
+
+    FOR_ALL_UNITS(UnitPtr){
+	if ((CC_LAYER_NO(UnitPtr)==0)&&(IS_OUTPUT_UNIT(UnitPtr)))
+	    LayerDataCorrect=FALSE;
+    }
+
+    if (!LayerDataCorrect) {
+	cc_calculateNetParameters();
+	FOR_ALL_UNITS(UnitPtr){
+	    CC_SET_LAYER_NO(UnitPtr,0);
+	} 
+
+	NoOfLayers=0;
+	/*cc_lastFirstOutputRow=100000;*/
+
+	FOR_ALL_UNITS(UnitPtr){
+	    FOR_ALL_LINKS(UnitPtr,LinkPtr){
+		UnitPtr2=LinkPtr->to;
+		if ((CC_LAYER_NO(UnitPtr2)+1) > CC_LAYER_NO(UnitPtr))
+		    CC_SET_LAYER_NO(UnitPtr,CC_LAYER_NO(UnitPtr2)+1);
+	    }
+	    if(CC_LAYER_NO(UnitPtr)>NoOfLayers)
+                NoOfLayers=CC_LAYER_NO(UnitPtr);
+	    /*if ((IS_OUTPUT_UNIT(unitPtr))&&
+	      (GET_UNIT_XPOS(unitPtr) < cc_lastFirstOutputRow))
+	      cc_lastFirstOutputRow =  GET_UNIT_XPOS(unitPtr);*/
+	} /* This algorithm works correct, iff u2 is in a layer greater than u1
+	     --> NO(U2) > NO(U1) (except output units)*/
+ 
+    }
+ 
+    if (NoOfHiddenUnits<=0) {
+	NoOfLayers=0;
+	LastInsertedHiddenUnit=0;
+    }
+
+    SumSqError=0.0;  /* Recalc SumSqEror later */
+}
+
+/*****************************************************************************
+  FUNCTION : cc_freeStorage
+
+  PURPOSE  : Frees all the storage allocated by CC.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err cc_freeStorage(int StartPattern,int EndPattern, int flag)
+{
+    struct Unit *unitPtr;
+    struct Link *linkPtr;
+    int start, end, n;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK;
+
+    cc_storageFree = 1;
+
+    if(flag==1){
+	(void) cc_deleteAllSpecialAndAllHiddenUnits();
+	cc_end = 0;
+	FOR_ALL_UNITS(unitPtr){
+	    if(UNIT_IN_USE(unitPtr) && IS_OUTPUT_UNIT(unitPtr)){
+		unitPtr->value_a =  unitPtr->value_b = unitPtr->value_c = 0;
+		FOR_ALL_LINKS(unitPtr,linkPtr){
+		    linkPtr->value_a =  linkPtr->value_b = linkPtr->value_c = 0;
+		}
+	    }
+	}
+	return(KRERR_NO_ERROR);
+    }else{
+	FREE_2DIMENSIONAL_ARRAY_WITH_PRINT(OutputUnitError,n,p);
+	FREE_2DIMENSIONAL_ARRAY(CorBetweenSpecialActAndOutError,
+				cc_MaxSpecialUnitNo,s);
+	FREE_2DIMENSIONAL_ARRAY(SpecialUnitAct,n,p);
+	FREE_2DIMENSIONAL_ARRAY(ActOfUnit,n,p);
+	FREE_IF_USED(MeanOutputUnitError);
+	FREE_IF_USED(SpecialUnitSumAct);
+
+	cc_actualNetSaved=FALSE;
+
+	cc_deallocateMemory(); /* deallocate Memory needed by modifications */
+
+	return(KRERR_NO_ERROR);
+    }
+
+}
+
+/*****************************************************************************
+  FUNCTION : cc_allocateStorage
+
+  PURPOSE  : Allocates all the storage needed by CC
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+krui_err cc_allocateStorage(int StartPattern, int  EndPattern, 
+			    int NoOfSpecialUnits)
+{
+    int p;
+    int start, end, n;
+
+    OldNoOfSpecialUnitStorage = NoOfSpecialUnits;
+    cc_storageFree = 0;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK;
+
+    CALLOC_ERRORCHECK(MeanOutputUnitError,NoOfOutputUnits,float);
+    CALLOC_ERRORCHECK(SpecialUnitSumAct,NoOfSpecialUnits,float);
+    CALLOC_2DIMENSIONAL_ARRAY(OutputUnitError,n,NoOfOutputUnits,float,p);
+    CALLOC_2DIMENSIONAL_ARRAY(SpecialUnitAct,n,cc_MaxSpecialUnitNo,float,p);
+    CALLOC_2DIMENSIONAL_ARRAY(CorBetweenSpecialActAndOutError,NoOfSpecialUnits,
+			      NoOfOutputUnits,float,p);
+    if(cc_fastmode){
+	CALLOC_2DIMENSIONAL_ARRAY(ActOfUnit,n,
+				  (NoOfInputUnits+NoOfHiddenUnits+NO_OF_GROUPS),
+				  float,p);
+	/* no of groups is set to a value bigger than 1, iff CCS-modification
+	   is set */
+    }
+
+    return(cc_allocateMemoryForModifications());
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_deleteAllSpecialAndAllHiddenUnits
+
+  PURPOSE  : Deletes all special units and all hidden units.
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+krui_err cc_deleteAllSpecialAndAllHiddenUnits(void)
+{
+    struct Unit *UnitPtr;
+
+    if(NoOfUnits != 0) {
+	FOR_ALL_UNITS(UnitPtr){
+	    if((IS_HIDDEN_UNIT(UnitPtr) || IS_SPECIAL_UNIT(UnitPtr)) && 
+	       UNIT_IN_USE(UnitPtr)) {
+		KernelErrorCode = kr_removeUnit(UnitPtr); 
+		ERROR_CHECK;
+	    }
+	}
+	kr_forceUnitGC();
+	NoOfHiddenUnits = 0;
+	NetModified = 1;
+    }
+    return(KRERR_NO_ERROR);
+} 
+
+ 
+
+/*****************************************************************************
+  FUNCTION : cc_initActivationArrays
+
+  PURPOSE  : 
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+void cc_initActivationArrays(void)
+{
+    int s,o;
+    struct Unit *outputUnitPtr,*specialUnitPtr;
+
+    FOR_ALL_SPECIAL_UNITS(specialUnitPtr,s) {
+	SpecialUnitSumAct[s] = 0.0;
+    }
+
+    FOR_ALL_SPECIAL_UNITS(specialUnitPtr,s) {
+	FOR_ALL_OUTPUT_UNITS(outputUnitPtr,o) {
+	    CorBetweenSpecialActAndOutError[s][o] = 0.0;
+	}
+    } 
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_generateRandomNo
+
+  PURPOSE  : Generates a random number in the interval [-maxValue,+maxValue]
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+FlintType cc_generateRandomNo(float maxValue)
+{
+    return (FlintType)(drand48()*2.0*maxValue-maxValue);  
+}
+
+
+  
+/*****************************************************************************
+  FUNCTION : cc_initOutputUnits
+
+  PURPOSE  : Initializes the links of the output units.
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+void cc_initOutputUnits(void)
+{
+    struct Unit *outputUnitPtr;
+    struct Link *linkPtr;
+    int o;
+
+    FOR_ALL_OUTPUT_UNITS(outputUnitPtr,o){
+	outputUnitPtr->value_a = 
+	    outputUnitPtr->value_b = outputUnitPtr->value_c = 0;
+	FOR_ALL_LINKS(outputUnitPtr,linkPtr){
+	    linkPtr->value_a =  linkPtr->value_b = linkPtr->value_c = 0;
+	}
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_getPatternParameter
+
+  PURPOSE  : Get the Pattern-Parameters needed
+  NOTES    :
+
+  UPDATE   : 30.11.95 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_getPatternParameter(int StartPattern,int EndPattern,
+				int* start, int* end,int* n)
+{
+    KernelErrorCode = kr_initSubPatternOrder(StartPattern,EndPattern);
+    ERROR_CHECK;
+    *start = kr_AbsPosOfFirstSubPat(StartPattern);
+    *end   = kr_AbsPosOfFirstSubPat(EndPattern);
+    *end  += kr_NoOfSubPatPairs(EndPattern) - 1;
+    *n = *end - *start + 1;
+    return (KernelErrorCode);
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_getActivationsForActualPattern
+
+  PURPOSE  : Gets or calculates the activations for the input and
+             hidden units.
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+void cc_getActivationsForActualPattern(int SubPatternNo,int First,int* pat,
+                                       int* sub)
+{
+    struct Unit   *UnitPtr;
+    Patterns  in_pat;
+    int dummy,relPatternNo;
+    int Index1,Index2;
+
+    relPatternNo=SubPatternNo-First;
+
+    kr_getSubPatternByNo(pat,sub,SubPatternNo);
+    in_pat = kr_getSubPatData(*pat,*sub,INPUT,NULL);
+    if((cc_fastmode)&&(cc_actualNetSaved)){
+	FOR_ALL_INPUT_UNITS(UnitPtr,Index1){
+	    UnitPtr->Out.output = ActOfUnit[relPatternNo][Index1];
+	}
+     	FOR_ALL_HIDDEN_UNITS(UnitPtr,Index2){
+	    UnitPtr->Out.output = UnitPtr->act = 
+		ActOfUnit[relPatternNo][Index1+Index2];
+	}
+    }else{
+	PROPAGATE_THROUGH_INPUT_LAYER(UnitPtr,dummy,in_pat);
+	PROPAGATE_THROUGH_HIDDEN_LAYER(UnitPtr,dummy,SubPatternNo);
+	if(cc_fastmode){  /* then save activations */
+	    FOR_ALL_INPUT_UNITS(UnitPtr,Index1){
+		ActOfUnit[relPatternNo][Index1] = UnitPtr->Out.output;
+	    }
+	    FOR_ALL_HIDDEN_UNITS(UnitPtr,Index2){
+		ActOfUnit[relPatternNo][Index1+Index2] = UnitPtr->Out.output;
+	    }
+	}
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_setPointers
+
+  PURPOSE  : Calculates the beginning of the input, hidden, output and special
+             units in the topo_ptr_array. 
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+krui_err cc_setPointers(void)
+{
+    FirstInputUnitPtr   = (struct Unit **)(&topo_ptr_array[1]);
+    if(*(FirstInputUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    FirstHiddenUnitPtr  = FirstInputUnitPtr  + NoOfInputUnits  + 1;
+    if(*(FirstHiddenUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    FirstOutputUnitPtr  = FirstHiddenUnitPtr + NoOfHiddenUnits + 1;
+    if(*(FirstOutputUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    FirstSpecialUnitPtr = FirstOutputUnitPtr + NoOfOutputUnits + 1;    
+    if(*(FirstSpecialUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_initSpecialUnitLinks
+
+  PURPOSE  : Sets all the links of the special units to zero.
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+krui_err cc_initSpecialUnitLinks(void)
+{
+    int s;
+    struct Unit *SpecialUnitPtr;
+    struct Link *LinkPtr;
+
+    FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+	SpecialUnitPtr->bias = 0.0;
+	BIAS_CURRENT_SLOPE(SpecialUnitPtr) = 0.0; 
+	BIAS_PREVIOUS_SLOPE(SpecialUnitPtr) = 0.0; 
+	BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr) = 0.0;
+	FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+	    LinkPtr->weight = cc_generateRandomNo(CC_MAX_VALUE);
+	    LN_CURRENT_SLOPE(LinkPtr) = 0.0;
+	    LN_PREVIOUS_SLOPE(LinkPtr) = 0.0;
+	    LN_LAST_WEIGHT_CHANGE(LinkPtr) = 0.0;
+	}
+    }
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_deleteAllSpecialUnits
+
+  PURPOSE  : Deletes all special units.
+  NOTES    :
+
+  UPDATE   : 19.01.96
+******************************************************************************/
+krui_err cc_deleteAllSpecialUnits(void)
+{
+    struct Unit *UnitPtr;
+
+    if(NoOfUnits != 0) {
+	FOR_ALL_UNITS(UnitPtr){
+	    if(IS_SPECIAL_UNIT(UnitPtr) && UNIT_IN_USE(UnitPtr)){
+		KernelErrorCode = kr_removeUnit(UnitPtr); 
+		ERROR_CHECK;
+	    }
+	}
+	kr_forceUnitGC();
+	NetModified = 1;
+    }
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : QuickPropOfflinePart
+
+  PURPOSE  : Update the weights ( or bias ) in QuickProp-Style
+  NOTES    :
+
+  UPDATE   : extracted 19.1.96 Juergen Gatter
+******************************************************************************/
+float QuickPropOfflinePart(float oldValue, float* previousSlope,
+			   float* currentSlope, float* LastChange,
+			   float epsilon, float mu, float decay)
+{
+    float current,change;
+
+    current = *currentSlope + decay * oldValue;
+    if(*previousSlope == 0.0){
+	change = -epsilon*current;
+    }else{
+	if(current*(SGN(*previousSlope)) >= (mu/(mu+1))*fabs(*previousSlope)){
+	    change = mu * (*LastChange);
+	}else{
+	    change = *LastChange * current / (*previousSlope-current);
+	}
+	if (SGN(*previousSlope)==SGN(current)){
+	    change -= epsilon * current;
+	}
+    }
+    *previousSlope =  current;
+    *currentSlope  =  0.0;
+    return (*LastChange = change);
+}
+
+
+/*****************************************************************************
+  FUNCTION : RPropOfflinePart
+
+  PURPOSE  : Update the weights ( or bias ) in QuickProp-Style
+  NOTES    : 
+
+  UPDATE   : extracted 19.1.96 Juergen Gatter
+******************************************************************************/
+float RPropOfflinePart(float oldValue,float* previousSlope, float* currentSlope,
+		       float* LastChange, float epsilonMinus, 
+		       float epsilonPlus,float dummy)
+{
+    float change,lastChange;
+
+    change = 0;
+    lastChange = (*LastChange == 0.0) ? 1.0 : *LastChange;
+    if (*currentSlope != 0.0){ 
+	if (*previousSlope == 0.0){
+	    change = fabs(lastChange) * SIGN(*currentSlope);
+	}else if (*previousSlope > 0.0){
+	    change = 
+		((*currentSlope>0.0)? epsilonPlus : -epsilonMinus) * lastChange;
+	}else{
+	    change = 
+		((*currentSlope<0.0)? epsilonPlus : -epsilonMinus) * lastChange;
+	}
+	if (fabs(change) < 0.00001) change = 0.00001 * SIGN(change);
+	if (fabs(change) > 10.0   ) change = 10.0    * SIGN(change);
+    }
+    *previousSlope = *currentSlope;
+    *currentSlope  =  0.0;
+    *LastChange = change;
+    return (-change);
+}
+
+/*****************************************************************************
+  FUNCTION : BackPropOfflinePart
+
+  PURPOSE  : Update the weights ( or bias ) in BackProp
+  NOTES    : This one is used by rcc.
+
+  UPDATE   : extracted 19.1.96 Juergen Gatter
+******************************************************************************/
+float BackPropOfflinePart(float oldValue, float* previousSlope,
+			  float* currentSlope, float* LastChange,
+			  float eta, float mu, float dummy)
+{
+    float change;
+
+    *LastChange = change = -(*currentSlope * eta + *LastChange * mu);
+
+    *previousSlope = *currentSlope;
+    *currentSlope = 0.0;
+    return(change);
+
+}
+          
+/*****************************************************************************
+  FUNCTION : OnlineBackPropPropOfflinePart
+
+  PURPOSE  : Update the weights ( or bias ) in BackProp (online)
+  NOTES    : 
+
+  UPDATE   : extracted 19.1.96 Juergen Gatter
+******************************************************************************/
+float OnlineBackPropOfflinePart(float oldValue, float* previousSlope,
+				float* currentSlope, float* LastChange,
+				float eta, float mu, float dummy)
+{  
+    return(0.0);
+}
+          
+
+
+/*****************************************************************************
+  FUNCTION : cc_setCycletestFlag(struct Unit* UnitPtr)
+
+  PURPOSE  : Sets CycletestFlag to 1
+  NOTES    :
+
+  UPDATE   : 22.11.95 (Juergen Gatter)
+******************************************************************************/
+void cc_setCycletestFlag(struct Unit* UnitPtr)
+{
+  if (UnitPtr->lln >= 0)
+     UnitPtr->lln = (-1)-UnitPtr->lln;
+}
+
+/*****************************************************************************
+  FUNCTION : cc_testCycletestFlag(struct Unit* UnitPtr)
+
+  PURPOSE  : test whether CycletestFlag is 1
+  NOTES    :
+
+  UPDATE   : 22.11.95 (Juergen Gatter)
+******************************************************************************/
+static bool cc_testCycletestFlag(struct Unit* UnitPtr)
+{
+  return (UnitPtr->lln >= 0);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_clearAllCycletestFlags(void)
+
+  PURPOSE  : resets the CycletestFlag to 0.
+  NOTES    : 
+
+  UPDATE   : 22.11.95 (Juergen Gatter)
+******************************************************************************/
+static void cc_clearAllCycletestFlags(void)
+{
+  struct Unit* UnitPtr;
+
+  FOR_ALL_UNITS(UnitPtr) {
+    if (UnitPtr->lln < 0)
+       UnitPtr->lln = (-1) - UnitPtr->lln;
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_clearFlags
+
+  PURPOSE  : Clears all CC flags.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void cc_clearFlags(void)
+{
+    struct Unit *unitPtr;
+
+    cc_clearAllCycletestFlags();
+
+    FOR_ALL_UNITS(unitPtr){
+	if(UNIT_IN_USE(unitPtr)){
+	    unitPtr->flags &= ~UFLAG_REFRESH;
+	    LINKS_LEAVING(unitPtr) = 0;
+	    LINKS_ARRIVEING(unitPtr) = 0;
+	    INPUT_LINKS(unitPtr) = 0;
+	}
+    }
+} 
+
+
+/*****************************************************************************
+  FUNCTION : DepthFirst4
+
+  PURPOSE  : Depth search routine for topological sorting.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void  DepthFirst4(struct Unit *unit_ptr, int depth )
+{
+
+    struct Site   *site_ptr;
+    struct Link   *link_ptr;
+
+    if (unit_ptr->flags & UFLAG_REFRESH){
+	/*  the 'touch' flag is set: don't continue search  */
+	topo_msg.src_error_unit = unit_ptr - unit_array; /* store unit number */
+
+	if IS_OUTPUT_UNIT( unit_ptr ){
+	    /*  this output unit has a output connection to another unit  */
+	    if (topo_msg.error_code == KRERR_NO_ERROR)
+		topo_msg.error_code = KRERR_O_UNITS_CONNECT;
+	}else if (cc_testCycletestFlag(unit_ptr)){
+	    /*  logical layer no. isn't set => Cycle found  */
+	    topo_msg.no_of_cycles++;
+	    if (topo_msg.error_code == KRERR_NO_ERROR)
+		topo_msg.error_code = KRERR_CYCLES;
+	}
+
+	return;
+    }else
+	/*  set the 'touch' flag  */
+	unit_ptr->flags |= UFLAG_REFRESH;
+
+    switch (unit_ptr->flags & UFLAG_INPUT_PAT){
+    
+    case  UFLAG_DLINKS:   /*  unit has direct links  */
+	FOR_ALL_LINKS(unit_ptr,link_ptr){
+	    DepthFirst4( link_ptr->to, depth + 1 );  /*  increase depth  */
+	    if(IS_INPUT_UNIT(link_ptr->to)){
+		INPUT_LINKS(unit_ptr)++;
+	    }
+	    if((IS_HIDDEN_UNIT(link_ptr->to)) && (IS_HIDDEN_UNIT(unit_ptr))){
+		LINKS_LEAVING(link_ptr->to)++;
+		LINKS_ARRIVEING(unit_ptr)++;
+	    }
+	}
+	break;
+    case  UFLAG_SITES:  /*  unit has sites  */
+	FOR_ALL_SITES_AND_LINKS(unit_ptr,site_ptr, link_ptr) {
+	    DepthFirst4( link_ptr->to, depth + 1 );  /*  increase depth  */
+	    if(IS_INPUT_UNIT(link_ptr->to)){
+		INPUT_LINKS(unit_ptr)++;
+	    }
+	    if((IS_HIDDEN_UNIT(link_ptr->to)) && (IS_HIDDEN_UNIT(unit_ptr))){
+		LINKS_LEAVING(link_ptr->to)++;
+		LINKS_ARRIVEING(unit_ptr)++;
+	    }
+	}
+	break;
+    }
+
+    /*  remember the depth (for cycle detection and statistics)  */
+    cc_setCycletestFlag(unit_ptr);
+
+    /*  store only hidden units  */
+    if IS_HIDDEN_UNIT( unit_ptr )
+	*global_topo_ptr++ = unit_ptr;  /*  store sorted unit pointer  */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : DepthFirst5
+
+  PURPOSE  : Depth search routine for topological sorting.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void  DepthFirst5(struct Unit *unit_ptr, int depth )
+{
+    struct Site   *site_ptr;
+    struct Link   *link_ptr;
+
+    if (unit_ptr->flags & UFLAG_REFRESH){
+	/* the 'touch' flag is set: don't continue search  */
+	topo_msg.src_error_unit = unit_ptr - unit_array; /* store unit number */
+
+	if IS_OUTPUT_UNIT( unit_ptr ){
+	    /*  this output unit has a output connection to another unit  */
+	    if (topo_msg.error_code == KRERR_NO_ERROR)
+		topo_msg.error_code = KRERR_O_UNITS_CONNECT;
+	}else if (cc_testCycletestFlag(unit_ptr)){
+	    /*  logical layer no. isn't set => Cycle found  */
+	    topo_msg.no_of_cycles++;
+	    if (topo_msg.error_code == KRERR_NO_ERROR)
+		topo_msg.error_code = KRERR_CYCLES;
+	}
+
+	return;
+    }else
+	/*  set the 'touch' flag  */
+	unit_ptr->flags |= UFLAG_REFRESH;
+
+    switch (unit_ptr->flags & UFLAG_INPUT_PAT){
+    
+    case  UFLAG_DLINKS:   /*  unit has direct links  */
+	FOR_ALL_LINKS(unit_ptr,link_ptr) {
+	    if((IS_HIDDEN_UNIT(unit_ptr)) && (link_ptr->to == unit_ptr)) {
+		/* RCC code deleted */
+	    }else{ 
+		DepthFirst5( link_ptr->to, depth + 1 );  /*  increase depth  */
+		if(IS_INPUT_UNIT(link_ptr->to)){
+		    INPUT_LINKS(unit_ptr)++;
+		}
+		if((IS_HIDDEN_UNIT(link_ptr->to))&&(IS_HIDDEN_UNIT(unit_ptr))){
+		    LINKS_LEAVING(link_ptr->to)++;
+		    LINKS_ARRIVEING(unit_ptr)++;
+		}
+	    }
+	}
+	break;
+    case  UFLAG_SITES:  /*  unit has sites  */
+	FOR_ALL_SITES_AND_LINKS(unit_ptr,site_ptr, link_ptr) {
+	    if((IS_HIDDEN_UNIT(unit_ptr)) && (link_ptr->to == unit_ptr)) {
+		/* RCC code deleted */
+	    }else{ 
+		DepthFirst5( link_ptr->to, depth + 1 );  /*  increase depth  */
+		if(IS_INPUT_UNIT(link_ptr->to)){
+		    INPUT_LINKS(unit_ptr)++;
+		}
+		if((IS_HIDDEN_UNIT(link_ptr->to))&&(IS_HIDDEN_UNIT(unit_ptr))){
+		    LINKS_LEAVING(link_ptr->to)++;
+		    LINKS_ARRIVEING(unit_ptr)++;
+		}
+	    }
+	}
+	break;
+    }
+
+    cc_setCycletestFlag(unit_ptr);
+
+    /*  store only hidden units  */
+    if IS_HIDDEN_UNIT( unit_ptr )
+	 *global_topo_ptr++ = unit_ptr;  /*  store sorted unit pointer  */
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_topoSort
+
+  PURPOSE  : Calls the Main routine for topological sorting for CC
+             and clears all cycletestFlags.
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err cc_topoSort(int topoSortID)
+{
+    int Error;
+
+    Error = cc_topoSortMain(topoSortID);
+    cc_clearAllCycletestFlags();
+    return (Error);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_topoSortMain
+
+  PURPOSE  : Main routine for topological sorting for CC.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err cc_topoSortMain(int topoSortId)
+{
+    register struct Unit   *unit_ptr;
+    int   io_units,h,counter=0;
+  
+    KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+    if(topoSortId == TOPOLOGICAL_CC) {
+	cc_clearFlags();    /*  reset units 'touch' flags  */
+    }
+
+    global_topo_ptr = topo_ptr_array;  /*  initialize global pointer */
+
+    /*  limit left side of the topological array with NULL pointer  */
+    *global_topo_ptr++ = NULL;
+
+    /*  put all input units in the topologic array  */
+    io_units = 0;
+    FOR_ALL_UNITS( unit_ptr ) 
+	if (IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr )){
+	    if UNIT_HAS_INPUTS( unit_ptr ){
+		/*  this input unit has a connection to another unit  */
+		topo_msg.dest_error_unit = unit_ptr - unit_array;  
+		
+		KernelErrorCode = KRERR_I_UNITS_CONNECT;  
+		return( KernelErrorCode );
+	    }
+
+	    io_units++;       /*  there is a input unit  */
+	    *global_topo_ptr++ = unit_ptr;  /*  save input unit  */
+	}
+  
+    if ((NoOfInputUnits = io_units) == 0){
+	/*  no input units */
+	KernelErrorCode = KRERR_NO_INPUT_UNITS;
+	return( KernelErrorCode );
+    }
+
+    /*  limit input units in the topological array with NULL pointer  */
+    *global_topo_ptr++ = NULL;
+
+    /*  begin depth search at the first output unit  */
+    io_units = 0;
+    FOR_ALL_UNITS( unit_ptr )
+	if (IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr )){
+	    io_units++;       /*  there is a output unit  */
+	    if(topoSortId == TOPOLOGICAL_CC){
+		DepthFirst4( unit_ptr, 1 );
+	    }
+	    else { /* topoSortId == TOPOLOGICAL_BCC */ 
+		DepthFirst4(unit_ptr,1);
+	    }      
+	    if (topo_msg.error_code != KRERR_NO_ERROR){
+		/*  stop if an error occured  */
+		KernelErrorCode = topo_msg.error_code;
+		return( KernelErrorCode );
+	    }
+	}
+
+
+    if ((NoOfOutputUnits = io_units) == 0){
+	/*  no output units */
+	KernelErrorCode = KRERR_NO_OUTPUT_UNITS;
+	return( KernelErrorCode );
+    }
+
+    /*  limit hidden units in the topological array with NULL pointer  */
+    *global_topo_ptr++ = NULL;
+
+    /*  put all output units in the topological array  */
+    FOR_ALL_UNITS( unit_ptr ) 
+	if (IS_OUTPUT_UNIT(unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+	    *global_topo_ptr++ = unit_ptr;  /*  save output unit  */
+
+    /*  limit right side of the topologic array with NULL pointer  */
+    *global_topo_ptr++ = NULL;
+  
+    FOR_ALL_UNITS( unit_ptr ) {
+	if (IS_SPECIAL_UNIT(unit_ptr) && UNIT_IN_USE( unit_ptr )) {
+	    *global_topo_ptr++ = unit_ptr;  /*  save output unit  */
+	    unit_ptr->flags |= UFLAG_REFRESH;
+	}
+    }
+    /*  limit right side of the topologic array with NULL pointer  */
+    *global_topo_ptr++ = NULL;
+
+    /*  calc. no. of sorted units  */
+    no_of_topo_units = (global_topo_ptr - topo_ptr_array) - 5;
+
+    /*  search for dead units i.e. units without inputs  */
+    FOR_ALL_UNITS( unit_ptr )
+	if (!(unit_ptr->flags & UFLAG_REFRESH) && UNIT_IN_USE( unit_ptr )){
+	    topo_msg.no_of_dead_units++;
+	    if (topo_msg.src_error_unit == 0)
+		topo_msg.src_error_unit = unit_ptr - unit_array;  
+	}
+
+    if (topo_msg.no_of_dead_units != 0)
+	/* KernelErrorCode = KRERR_DEAD_UNITS;
+	 * allowed for compression */
+	if(KernelErrorCode == KRERR_NO_ERROR){
+	    FirstHiddenUnitPtr = (struct Unit **)(&topo_ptr_array[1]) + 
+		                 NoOfInputUnits + 1;
+	    FOR_ALL_HIDDEN_UNITS(unit_ptr,h){
+		switch(topoSortId){
+		case TOPOLOGICAL_CC : 
+		    break;
+		case TOPOLOGICAL_BCC : 
+		    if((LINKS_LEAVING(unit_ptr)+LINKS_ARRIVEING(unit_ptr)+1) !=
+		       NoOfHiddenUnits) {
+			KernelErrorCode = KRERR_CC_ERROR6;
+			return(KernelErrorCode);
+		    }
+		    if(LINKS_ARRIVEING(unit_ptr) != counter++) {
+			KernelErrorCode = KRERR_CC_ERROR6;
+			return(KernelErrorCode);
+		    }
+		    if(counter == NoOfHiddenUnits) {
+			counter = 0;
+		    }
+		    break;
+		}  
+	    }
+	}
+    return( KernelErrorCode );
+}
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/cc_glob.h snort-2.3.3.new/src/kernel_snns/cc_glob.h
--- snort-2.3.3/src/kernel_snns/cc_glob.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_glob.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,131 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_glob.h,v $
+  SHORTNAME      : cc_glob.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : This file was put together from the earlier files cc_rcc 
+                   and cc_rcc_topo
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 5.2.92
+
+  CHANGED BY     : Michael Schmalzl
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:52 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_GLOB_DEFINED_
+#define  _CC_GLOB_DEFINED_
+
+/* begin global definition section */
+extern void      cc_printHeadline(char* s,int Length);
+extern float     cc_getErr (int StartPattern, int EndPattern);
+extern void      cc_LayerCorrectnessTest(float* ParameterInArray, 
+					 int StartPattern,
+					 int EndPattern);
+extern krui_err  cc_freeStorage(int StartPattern, int EndPattern, int flag);
+extern krui_err  cc_deleteAllSpecialAndAllHiddenUnits(void);
+extern krui_err  cc_allocateStorage(int StartPattern, int EndPattern, 
+				    int NoOfSpecialUnits);
+extern void      cc_initActivationArrays(void);
+extern FlintType cc_generateRandomNo(float maxValue);
+extern void      cc_getActivationsForActualPattern(int SubPatterNo,int First,
+					      int* pat,int* sub);
+extern void      cc_initOutputUnits(void);
+extern krui_err  cc_getPatternParameter(int StartPattern, int Endpattern,
+					int* start, int* end, int* n);
+extern void      cc_initInputUnitsWithPattern(int PatternNo);
+extern krui_err  cc_setPointers(void);
+extern krui_err  cc_initSpecialUnitLinks(void);
+extern krui_err  cc_deleteAllSpecialUnits(void); 
+
+extern krui_err  cc_topoSort(int topoSortId);
+extern void      cc_setCycletestFlag(struct Unit* UnitPtr);
+
+extern struct CC_DATA cc_data; 
+extern char *cc_onOffArray[];  
+extern char *cc_actFuncArray[]; 
+extern char *cc_actFuncArray2[]; 
+extern char *cc_learningFuncArray[];
+extern char *cc_ModificationArray[];
+extern char *cc_pruningFuncArray[];
+extern int cc_end;
+extern int cc_storageFree;
+extern int cc_allButtonIsPressed;
+extern int cc_cascadeFlag;
+/* pcc */
+extern int LastInsertedHiddenUnit;
+extern int cc_backfittingOnOff;
+extern int cc_MaxSpecialUnitNo;
+extern int cc_modification;
+extern struct Unit  **FirstInputUnitPtr,**FirstHiddenUnitPtr,
+                    **FirstOutputUnitPtr,**FirstSpecialUnitPtr,
+                    *bestSpecialUnitPtr;
+
+extern float **OutputUnitError;
+extern float **SpecialUnitAct;
+extern float **CorBetweenSpecialActAndOutError;
+extern float *MeanOutputUnitError;
+extern float *SpecialUnitSumAct;
+
+extern float SumSqError;
+extern int cc_printOnOff;
+extern int *reset;
+extern int cc_cascade;
+extern int FirstUnitOnLastLayer;
+
+extern float cc_Parameter[5];
+extern int NoOfLayers;         /* Number of hidden layers */
+extern struct CC_LAYER* ListOfLayers;  /* holds data for each layer */
+extern int SizeOfLayerlist;   
+extern float** ActOfUnit;
+extern float cc_fse;
+extern int cc_learningFunction;
+
+
+/* now the variables needed by display */
+
+extern int cc_display_mode;
+extern int cc_LayerDistance;
+extern int cc_outputXMax;
+
+extern int cc_fastmode;
+extern int cc_actualNetSaved;
+
+extern krui_err (*cc_propagateSpecialUnitsBackward)
+                             (int start,int end,int n,int counter,
+                              float param1,float param2,float param3);
+extern float (*cc_propagateOutputUnitsBackward)
+                             (int PatternNo, int sub_pat_no,
+                              float param1,float param2,float param3);
+extern float (*cc_SpecialUnitUpdate)( float oldValue, float* previousSlope,
+				      float* currentSlope, float* LastChange,
+				      float param1,float param2,float param3);
+extern float (*cc_OutputUnitUpdate)(float oldValue, float* previousSlope,
+				    float* currentSlope, float* LastChange,
+				    float param1,float param2,float param3);
+extern float QuickPropOfflinePart(float oldValue, float* previousSlope, 
+				  float* currentSlope, float* LastChange,
+				  float epsilon,float mu,float decay);
+extern float BackPropOfflinePart(float oldValue, float* previousSlope,
+				 float* currentSlope,float* LastChange,
+				 float dummy1,float dummy2,float dummy3);
+extern float OfflineBackPropOfflinePart(float oldValue, float* previousSlope,
+					float* currentSlope,float* LastChange,
+					float eta,float mu,float dummy);
+extern float RPropOfflinePart(float oldValue, float* previousSlope,
+			      float* currentSlope, float* LastChange,
+			      float epsilonMinus,float epsilonPlus,float dummy);
+extern float OnlineBackPropOfflinePart(float oldValue, float* previousSlope,
+				       float* currentSlope, float* LastChange,
+				       float eta,float mu,float dummy);
+
+extern int NetLearnAlgorithm;
+
+/* end global definition section */
+
+#endif /* _CC_GLOB_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_glob.ph snort-2.3.3.new/src/kernel_snns/cc_glob.ph
--- snort-2.3.3/src/kernel_snns/cc_glob.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_glob.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,188 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_glob.ph,v $
+  SHORTNAME      : cc_glob.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : This file was put together from the earlier files cc_rcc 
+                   and cc_rcc_topo
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 5.2.92
+
+  CHANGED BY     : Guenter Mamier
+  RCS VERSION    : $Revision: 2.5 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:53 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_GLOB_DEFINED_
+#define  _CC_GLOB_DEFINED_
+
+/* begin global definition section */
+void      cc_printHeadline(char* s,int Length);
+float     cc_getErr (int StartPattern, int EndPattern);
+void      cc_LayerCorrectnessTest(float* ParameterInArray,
+				  int StartPattern, int EndPattern);
+krui_err  cc_freeStorage(int StartPattern, int EndPattern, int flag);
+krui_err  cc_deleteAllSpecialAndAllHiddenUnits(void);
+krui_err  cc_allocateStorage(int StartPattern, int EndPattern, 
+			     int NoOfSpecialUnits);
+FlintType cc_generateRandomNo(float maxValue);
+void      cc_initActivationArrays(void);
+void      cc_getActivationsForActualPattern(int SubPatterNo,int First,int* pat,
+					    int* sub);
+void      cc_initOutputUnits(void);
+krui_err  cc_getPatternParameter(int StartPattern, int Endpattern,
+				 int* start, int* end,int* n);
+void      cc_initInputUnitsWithPattern(int PatternNo);
+krui_err  cc_setPointers(void);
+krui_err  cc_initSpecialUnitLinks(void);
+krui_err  cc_deleteAllSpecialUnits(void);   
+
+krui_err  cc_topoSort(int topoSortId);
+void      cc_setCycletestFlag(struct Unit* UnitPtr);
+
+float QuickPropOfflinePart(float oldValue, float* previousSlope,
+			   float* currentSlope,float* LastChange,
+			   float epsilon, float mu, float decay);
+float BackPropOfflinePart(float oldValue, float* previousSlope,
+			  float* currentSlope, float* LastChange,
+			  float dummy1, float dummy2, float dummy3);
+float OfflineBackPropOfflinePart(float oldValue, float* previousSlope,
+				 float* currentSlope, float* LastChange,
+				 float epsilon, float mu, float dummy);
+float RPropOfflinePart(float oldValue, float* previousSlope, 
+		       float* currentSlope, float* LastChange,
+		       float epsilonMinus, float epsilonPlus, float dummy);
+float OnlineBackPropOfflinePart(float oldValue, float* previousSlope,
+				float* currentSlope, float* LastChange,
+				float eta, float mu, float dummy);
+
+struct CC_DATA  cc_data ={
+  { MAX_PIXEL_ERROR,
+    LEARNING_FUNC, MODIFICATION,
+    ON_OFF, 0, 0, 150, SBC,
+    { 0.0, 0.0, 0.0, 0.0, 0.0 },
+    OFF},
+  { MIN_COVARIANCE_CHANGE, 
+    SPECIAL_PATIENCE,
+    MAX_NO_OF_COVARIANCE_UPDATE_CYCLES,
+    MAX_SPECIAL_UNIT_NO, 
+    SPECIAL_FUNC_TYPE },
+  { MIN_ERROR_CHANGE,
+    OUT_PATIENCE,
+    MAX_NO_OF_ERROR_UPDATE_CYCLES}
+};
+
+char *cc_actFuncArray[]     ={"Act_Logistic","Act_LogSym","Act_TanH",
+                              "Act_CC_Thresh","Act_Sinus","Act_Exponential",
+			      "Act_Random"};
+char *cc_actFuncArray2[]     ={"Logistic"," LogSym ",
+			      "  TanH  ","dummy"," Sinus  ",
+			      "  Gauss "," Random "};
+char *cc_learningFuncArray[]={" Batch-BP  "," Backprop  ",
+			      " Quickprop ","   Rprop   "};
+char *cc_ModificationArray[]={"   none ","   SDCC ","   LFCC ","   RLCC ",
+			      "   ECC  ","   GCC  ","  Static"};
+char *cc_pruningFuncArray[] ={" SBC "," AIC ","CMSEP"};
+
+int cc_end                = 0;
+int cc_storageFree        = 1;
+int cc_allButtonIsPressed = 1;
+
+
+struct Unit  **FirstInputUnitPtr,**FirstHiddenUnitPtr,
+             **FirstOutputUnitPtr,**FirstSpecialUnitPtr,
+              *bestSpecialUnitPtr;
+
+float **OutputUnitError=NULL;
+float **SpecialUnitAct=NULL;
+float **CorBetweenSpecialActAndOutError=NULL;
+float *MeanOutputUnitError=NULL;
+float *SpecialUnitSumAct=NULL;
+int   LastInsertedHiddenUnit;
+
+float SumSqError;
+
+int cc_printOnOff;
+int cc_backfittingOnOff;
+int cc_MaxSpecialUnitNo;
+int cc_modification = -1;
+int cc_fastmode;
+float cc_Parameter[5];
+
+
+int *reset=0;
+int cc_cascade=0;
+int NoOfLayers = 0;             /* number hidden layers */
+Layer_Type* ListOfLayers=NULL;  /* data of layers */
+int SizeOfLayerlist;  
+
+
+int cc_outputXMax;
+
+int     cc_actualNetSaved = FALSE;
+float** ActOfUnit = NULL;
+int     NetLearnAlgorithm = NO_INC_ALGORITHM;
+
+float cc_fse = 0.1;
+int cc_learningFunction;
+
+int prot_fd = -1;
+FILE* prot_stream;
+char DumpText[1024];
+bool cc_NetErgProtocolled;
+int CountSpecTrains,CountOutTrains,CountLinks;
+
+void Prot();
+void prot(char* s);
+void Prot_Parameters(float* Params,int NetIsCC);
+int filedesc = -1;
+
+/* the following functions are dummy declarations without implemented body!!
+   They are realized by directing their pointers to other functions */
+krui_err (*cc_propagateSpecialUnitsBackward)(int start, int end, int n,
+					     int counter, float param1,
+					     float param2, float param3);
+float (*cc_propagateOutputUnitsBackward)(int PatternNo, int sub_pat_no,
+					 float param1, float param2,
+					 float param3);
+float (*cc_SpecialUnitUpdate)(float oldValue, float* previousSlope,
+			      float* currentSlope, float* LastChange,
+			      float param1, float param2, float param3);
+float (*cc_OutputUnitUpdate)(float oldValue, float* previousSlope,
+			     float* currentSlope, float* LastChange,
+			     float param1, float param2, float param3);
+
+/* end global definition section */
+
+
+
+/* begin privat definition section */
+
+static int OldNoOfSpecialUnitStorage = 0;
+
+#define LINKS_LEAVING(unitPtr)   unitPtr->value_a
+#define LINKS_ARRIVEING(unitPtr) unitPtr->value_b
+#define INPUT_LINKS(unitPtr)     unitPtr->value_c
+
+static void  cc_clearFlags(void);
+static void  DepthFirst4(struct Unit *unitPtr, int depth);
+static void  DepthFirst5(struct Unit *unitPtr, int depth);
+krui_err     cc_topoSortMain(int topoSortID);
+
+static TopoPtrArray	global_topo_ptr;
+
+/* end  privat definition section */
+
+#endif /* _CC_GLOB_DEFINED_ */
+
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/cc_learn.c snort-2.3.3.new/src/kernel_snns/cc_learn.c
--- snort-2.3.3/src/kernel_snns/cc_learn.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_learn.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1052 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_learn.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Functions of CC
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl, modified by Christian Wehrfritz (PCC)
+  DATE           : 5.2.93
+
+  CHANGED BY     : Michael Schmalzl, Juergen Gatter
+  RCS VERSION    : $Revision: 2.18 $
+  LAST CHANGE    : $Date: 1998/04/20 11:54:44 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "random.h"
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+#include "kernel.h"      /*  kernel function prototypes  */
+#include "kr_mac.h"      /*  Kernel Macros   */
+
+
+#include "kr_ui.h"
+#include "cc_type.h"
+#include "cc_mac.h"
+#include "cc_learn.ph"
+#include "cc_glob.h"
+#include "kr_newpattern.h"
+#include "cc_modify.h"
+#include "cc_prune.h"
+#include "cc_display.h"
+#include "tacoma_learn.h"
+
+/*****************************************************************************
+  FUNCTION : cc_initVariables
+
+  PURPOSE  : read some Parameters and global dates.
+
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_initVariables(float* ParameterInArray,
+			  int StartPattern,int EndPattern)
+{
+    int i;
+
+    cc_LayerCorrectnessTest(ParameterInArray,StartPattern,EndPattern);
+
+    srand48((long)time(NULL)); 
+ 
+
+    /* now read the parameters from the window to global variables */
+
+    cc_printOnOff = (int)ParameterInArray[8]; 
+    cc_backfittingOnOff = (int)ParameterInArray[18];
+    cc_MaxSpecialUnitNo = (int)ParameterInArray[12];
+    cc_modification = (int)ParameterInArray[21];
+    for (i=0;i<5;i++){
+	cc_Parameter[i]=ParameterInArray[22+i];
+    } 
+    cc_fastmode=(int)ParameterInArray[27];
+    cc_fse=((LEARNING_FUNCTION==BACKPROP)? PARAM3 : 0.1);
+
+    KernelErrorCode=cc_InitModificationVariables();
+    ERROR_CHECK;
+    KernelErrorCode=cc_TestWhetherParametersAreValid();
+    ERROR_CHECK;
+    cc_end=FALSE;
+    cc_cascade=1; 
+
+    KernelErrorCode = cc_GetTrainFunctions(LEARNING_FUNCTION);
+    ERROR_CHECK;
+
+    if (NoOfHiddenUnits==0)
+	KernelErrorCode = cc_calculateNetParameters();
+    ERROR_CHECK;
+    KernelErrorCode = cc_generateLayerList();
+    ERROR_CHECK;
+    if(strcmp(krui_getUpdateFunc(),"CC_Order")){
+	return(KRERR_CC_ERROR10);
+    }
+
+    if(strcmp(krui_getInitialisationFunc(),"CC_Weights")){
+	return(KRERR_CC_ERROR11);
+    }
+
+    return KRERR_NO_ERROR;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_calculateCorrelation
+
+  PURPOSE  : Calculates the correlation of the pool of candidate units and 
+             returns the high score.
+  NOTES    :
+
+  UPDATE   : 30.3.96 <Juergen Gatter>
+******************************************************************************/
+float cc_calculateCorrelation(int StartPattern, int EndPattern, int counter)
+{
+
+    int s,o,n;
+    double highScore, unchangedhighScore, scoreBuffer;
+    float bestSpecialUnitScore = -0.1 ,
+	bestSpecialUnitUnchangedScore=0.0;
+    struct Unit *SpecialUnitPtr = NULL,*OutputUnitPtr;
+    int start, end;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK;
+
+    if(cc_printOnOff)  printf("Cycle %d ",counter);
+
+    FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+	unchangedhighScore = 0.0;
+	FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o) {
+	    scoreBuffer = (CorBetweenSpecialActAndOutError[s][o] - 
+			   (MeanOutputUnitError[o] * SpecialUnitSumAct[s] )) / 
+		          SumSqError;
+	    unchangedhighScore += fabs(scoreBuffer);
+	    SIGN_OF_THE_CORRELATION[s][o] = SIGN(scoreBuffer);
+	}
+    
+	highScore = cc_modifyHighScore(SpecialUnitPtr,s,unchangedhighScore);
+
+	cc_actualizeGroupHighscores(highScore,s,SpecialUnitPtr);
+
+	if(highScore> bestSpecialUnitScore){
+	    bestSpecialUnitScore = highScore;
+	    bestSpecialUnitUnchangedScore = unchangedhighScore;
+	    bestSpecialUnitPtr = SpecialUnitPtr;
+	}
+	if(cc_printOnOff)  printf("S[%d]: %.4f ",s,unchangedhighScore);
+    }
+    if(cc_printOnOff) {
+	printf("Best : %d:%.4f \n",GET_UNIT_NO(bestSpecialUnitPtr),
+	       bestSpecialUnitScore);
+    } 
+    return(bestSpecialUnitUnchangedScore);
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_GetTrainFunctions
+
+  PURPOSE  : Assigns the trainings functions.
+
+  NOTES    :
+
+  UPDATE   : 10.10.95 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_GetTrainFunctions(int learnFunc)
+{
+    cc_learningFunction = learnFunc;
+    cc_propagateOutputUnitsBackward  = cc_propagateOutput;
+    cc_propagateSpecialUnitsBackward = cc_propagateSpecial;
+    switch(learnFunc) { 
+    case BACKPROP: 
+	cc_SpecialUnitUpdate = 
+	    cc_OutputUnitUpdate = BackPropOfflinePart;
+	break; 
+    case BACKPROP_ONLINE:
+	cc_SpecialUnitUpdate =
+	    cc_OutputUnitUpdate = OnlineBackPropOfflinePart;
+	cc_propagateOutputUnitsBackward  = cc_propagateOutputOnlineCase;
+	cc_propagateSpecialUnitsBackward = cc_propagateSpecialOnlineCase;
+	break;            
+    case QUICKPROP: 
+	cc_SpecialUnitUpdate = 
+	    cc_OutputUnitUpdate = QuickPropOfflinePart;
+
+	break; 
+    case RPROP: 
+	cc_SpecialUnitUpdate = 
+	    cc_OutputUnitUpdate = RPropOfflinePart;
+
+	break;
+    default: CC_ERROR(KRERR_CC_ERROR3);
+    }
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_trainSpecialUnits
+
+  PURPOSE  : Trains the special units.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void cc_trainSpecialUnits(int maxNoOfCovarianceUpdateCycles, 
+			    float minCovarianceChange,
+                            int specialPatience,int StartPattern, 
+			    int EndPattern,float param1, float param2,
+                            float param3,int MaxSpecialUnitNo)
+{
+    struct Unit* UnitPtr;
+    struct Link* LinkPtr;
+    int s;
+    int counter,start,end,n;
+    float oldHighScore=0.0,newHighScore;
+    float Error;
+
+    cc_printHeadline("Training of the candidates",LENGTH_HEADLINE);
+    cc_calculateOutputUnitError(StartPattern,EndPattern);
+    if (SumSqError==0.0){
+	Error = cc_getErr(StartPattern,EndPattern); /* calc SumSqError */
+	if (SumSqError==0.0)
+	    return;
+    }
+    for (counter=0;counter<maxNoOfCovarianceUpdateCycles;counter++){
+	cc_calculateSpecialUnitActivation(StartPattern,EndPattern);
+        newHighScore = cc_calculateCorrelation(StartPattern,EndPattern,counter);
+        KernelErrorCode = cc_getPatternParameter(StartPattern, EndPattern,
+						 &start, &end, &n);
+        ERROR_CHECK_WRC;
+	(*cc_propagateSpecialUnitsBackward)(start, end, n, counter,
+					    param1, param2, param3);
+        ERROR_CHECK_WRC;
+
+        FOR_ALL_SPECIAL_UNITS(UnitPtr,s){
+	    UnitPtr->bias += 
+		(*cc_SpecialUnitUpdate)(UnitPtr->bias,
+					&BIAS_PREVIOUS_SLOPE(UnitPtr),
+					&BIAS_CURRENT_SLOPE(UnitPtr),
+					&BIAS_LAST_WEIGHT_CHANGE(UnitPtr),
+					param1,param2,param3);
+	    FOR_ALL_LINKS(UnitPtr,LinkPtr){
+		LinkPtr->weight +=
+		    (*cc_SpecialUnitUpdate)(LinkPtr->weight,
+					    &LN_PREVIOUS_SLOPE(LinkPtr),
+					    &LN_CURRENT_SLOPE(LinkPtr),
+					    &LN_LAST_WEIGHT_CHANGE(LinkPtr),
+					    param1, param2, param3);
+	    }
+	}
+
+	cc_initActivationArrays(); 
+
+        if ((counter % specialPatience)==0){
+	    if(fabs(newHighScore-oldHighScore) < 
+	       minCovarianceChange*oldHighScore)
+		return;
+	    else
+		oldHighScore = newHighScore;
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_trainOutputUnits
+
+  PURPOSE  : Trains the output units.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void cc_trainOutputUnits(int maxNoOfErrorUpdateCycles, int backfittPatience,
+			    float minErrorChange,
+                            int outPatience,int StartPattern,int EndPattern, 
+			    float param1, float param2, float param3, 
+			    float **ParameterOutArray,int *NoOfOutParams)
+{
+
+    int p,pat,sub,counter=0;
+    float oldNetError=FLOAT_MAX;
+    int start,end,n;
+    struct Unit* UnitPtr;
+    struct Link* LinkPtr;
+    int s,dummy;
+    static float OutParameter[1];
+
+    cc_printHeadline("Training of the output units",LENGTH_HEADLINE);
+    *NoOfOutParams = 1;
+    *ParameterOutArray = OutParameter;
+    cc_initOutputUnits();
+    cc_actualNetSaved=FALSE;
+
+   /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(StartPattern,EndPattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+        return;
+
+    for (counter=0;counter< maxNoOfErrorUpdateCycles;counter++){
+        cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+	for(p=start; p<=end;p++){
+           cc_getActivationsForActualPattern(p,start,&pat,&sub);
+           PROPAGATE_THROUGH_OUTPUT_LAYER(UnitPtr,dummy,p);
+	   (*cc_propagateOutputUnitsBackward)(pat,sub,param1,param2,param3);
+	}
+        cc_actualNetSaved=TRUE;
+        FOR_ALL_OUTPUT_UNITS(UnitPtr,s){
+           UnitPtr->bias += 
+               (*cc_OutputUnitUpdate)(UnitPtr->bias,
+				      &BIAS_PREVIOUS_SLOPE(UnitPtr),
+				      &BIAS_CURRENT_SLOPE(UnitPtr),
+				      &BIAS_LAST_WEIGHT_CHANGE(UnitPtr),
+				      param1,param2,param3);
+           FOR_ALL_LINKS(UnitPtr,LinkPtr){
+               LinkPtr->weight +=
+                  (*cc_OutputUnitUpdate)(LinkPtr->weight,
+					 &LN_PREVIOUS_SLOPE(LinkPtr),
+					 &LN_CURRENT_SLOPE(LinkPtr),
+					 &LN_LAST_WEIGHT_CHANGE(LinkPtr),
+					 param1,param2,param3);
+           }
+	}
+         NET_ERROR(OutParameter)=cc_getErr(StartPattern,EndPattern);
+
+	 /* otherways, it's not the actual error */
+	 if(cc_printOnOff) printf("Epoch: %d NetError: %f \n",counter+1, 
+				  NET_ERROR(OutParameter));
+	 if ((counter % outPatience)==0){
+	    if(fabs(NET_ERROR(OutParameter)-oldNetError) < 
+	       minErrorChange * oldNetError)
+		return;
+	    else
+		oldNetError=NET_ERROR(OutParameter);
+	 }
+    }
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_calculateOutputUnitError
+
+  PURPOSE  : Calculates the error of all output units and stores the result
+             in the array OutputUnitError
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void cc_calculateOutputUnitError(int StartPattern,int EndPattern)
+{
+
+    register struct Unit *UnitPtr;
+    register Patterns  out_pat;
+    register TopoPtrArray     topo_ptr;
+    register int o,p;
+    int start, end,pat,sub,n;
+  
+    FOR_ALL_OUTPUT_UNITS(UnitPtr,o) 
+       OUTPUT_UNIT_SUM_ERROR[o] = 0.0;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK_WRC;
+
+    for(p=start; p<=end;p++){
+	topo_ptr = topo_ptr_array;
+        cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+        ERROR_CHECK_WRC;
+        FOR_ALL_OUTPUT_UNITS(UnitPtr,o) {
+            CALCULATE_ACTIVATION_AND_OUTPUT(UnitPtr,
+					    (*UnitPtr->act_func)(UnitPtr),p);
+            OUTPUT_UNIT_SUM_ERROR[o] += 
+		(OutputUnitError[p][o] =  
+		      (UnitPtr->Out.output-(*out_pat++))*
+		      ((*UnitPtr->act_deriv_func)(UnitPtr)+cc_fse)); 
+        }
+    }
+
+    FOR_ALL_OUTPUT_UNITS(UnitPtr,o)
+       MeanOutputUnitError[o] = (OUTPUT_UNIT_SUM_ERROR[o] / n);
+
+    cc_actualNetSaved=TRUE;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION :  cc_calculateSpecialUnitActivation
+
+  PURPOSE  :  Calculates the covariance  between the output units and the 
+              special units and stores the result the array 
+	      CorBetweenSpecialActAndOutError.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void cc_calculateSpecialUnitActivation(int StartPattern, int EndPattern)
+{ 
+
+    register struct Unit  *specialUnitPtr,*outputUnitPtr;
+    register int o,s,p;
+    int pat,sub;
+    int start,end,n;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);  
+    ERROR_CHECK_WRC;
+
+    for(p=start; p<=end;p++){
+        cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	FOR_ALL_SPECIAL_UNITS(specialUnitPtr,s) {
+            CALCULATE_ACTIVATION_AND_OUTPUT(specialUnitPtr,
+				(*specialUnitPtr->act_func) (specialUnitPtr),p);
+	    SpecialUnitSumAct[s] += 
+		SpecialUnitAct[p][s] = specialUnitPtr->Out.output;
+            FOR_ALL_OUTPUT_UNITS(outputUnitPtr,o) {
+	        CorBetweenSpecialActAndOutError[s][o] += 
+		    SpecialUnitAct[p][s] * OutputUnitError[p][o];
+	    }
+	}
+    } 
+    cc_actualNetSaved=TRUE;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_propagateOutput
+
+  PURPOSE  : Propagates a pattern backward through the net.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+float cc_propagateOutput(int PatternNo, int sub_pat_no, float param1, 
+			 float param2, float param3)
+{
+
+    struct Link   *LinkPtr;
+    struct Site   *site_ptr;
+    struct Unit   *OutputUnitPtr;
+    Patterns      out_pat;
+    float         error,devit;
+    int           dummy;
+
+    out_pat = kr_getSubPatData(PatternNo,sub_pat_no,OUTPUT,NULL);
+    ERROR_CHECK;
+
+    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,dummy){
+	devit =  OutputUnitPtr->Out.output - *(out_pat++);
+	error = devit * 
+	    ((*OutputUnitPtr->act_deriv_func)(OutputUnitPtr) + cc_fse);
+        BIAS_CURRENT_SLOPE(OutputUnitPtr) += error;
+
+      	if (UNIT_HAS_DIRECT_INPUTS(OutputUnitPtr)) {  
+	    FOR_ALL_LINKS(OutputUnitPtr,LinkPtr) {
+		LN_CURRENT_SLOPE(LinkPtr) +=  error * LinkPtr->to->Out.output;
+	    }
+	}else{
+	    FOR_ALL_SITES_AND_LINKS(OutputUnitPtr,site_ptr,LinkPtr) {
+		LN_CURRENT_SLOPE(LinkPtr) +=  error * LinkPtr->to->Out.output;
+	    }
+	}
+    }
+    return(0); /* not used anymore, since result isn't valid when used */ 
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_propagateOutputOnlineCase
+
+  PURPOSE  : Propagates a pattern backward through the net.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+float cc_propagateOutputOnlineCase(int PatternNo, int sub_pat_no,
+				   float eta,float mu,float dummy1)
+{
+
+    struct Link   *LinkPtr;
+    struct Site   *site_ptr;
+    struct Unit   *OutputUnitPtr;
+    Patterns      out_pat;
+    float         error,sum_error,devit;
+    int           dummy;
+    float         lastChange;
+
+    sum_error = 0.0; 
+    out_pat = kr_getSubPatData(PatternNo,sub_pat_no,OUTPUT,NULL);
+    ERROR_CHECK;
+    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,dummy){
+	devit =  OutputUnitPtr->Out.output - *(out_pat++);
+
+	sum_error += devit * devit;
+	error = devit * 
+	        ((*OutputUnitPtr->act_deriv_func)(OutputUnitPtr) + dummy1);
+        lastChange = BIAS_LAST_WEIGHT_CHANGE(OutputUnitPtr);
+  	OutputUnitPtr->bias -= 
+	    ((BIAS_LAST_WEIGHT_CHANGE(OutputUnitPtr) = 
+	      error * eta  + lastChange * mu));
+
+	if (UNIT_HAS_DIRECT_INPUTS(OutputUnitPtr)) { 
+	    FOR_ALL_LINKS(OutputUnitPtr,LinkPtr) {
+                lastChange =  LN_LAST_WEIGHT_CHANGE(LinkPtr);
+		LinkPtr->weight -= 
+		    ((LN_LAST_WEIGHT_CHANGE(LinkPtr) = 
+		      error*LinkPtr->to->Out.output*eta+lastChange*mu));
+	    }
+	}else{
+	    FOR_ALL_SITES_AND_LINKS(OutputUnitPtr,site_ptr,LinkPtr) {
+                lastChange =  LN_LAST_WEIGHT_CHANGE(LinkPtr);
+		LinkPtr->weight -= 
+		    ((LN_LAST_WEIGHT_CHANGE(LinkPtr) = 
+		      error*LinkPtr->to->Out.output*eta+lastChange*mu));
+	    }
+	}
+    }
+    return(sum_error); 
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_propagateSpecial
+
+  PURPOSE  : Propagation in Case of Special Units, no BackProp
+  NOTES    :
+
+  UPDATE   : 30.3.96 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_propagateSpecial(int start,int end,int n,int counter,
+			     float param1, float param2,float param3)
+{
+
+    float change=0.0,actPrime;
+    int s,o,p,pat,sub;
+    struct Unit *SpecialUnitPtr,*OutputUnitPtr;
+    struct Link *LinkPtr;
+
+    for(p=start; p<=end;p++){
+        cc_getActivationsForActualPattern(p,start,&pat,&sub);
+
+	FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+	    change = 0.0;
+	    SpecialUnitPtr->act = SpecialUnitAct[p][s];
+	    actPrime = (*SpecialUnitPtr->act_deriv_func)(SpecialUnitPtr);
+	    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o) 
+		if(UNITS_IN_SAME_GROUP(s,o)){
+		    change -= SIGN_OF_THE_CORRELATION[s][o] *
+			(OutputUnitError[p][o]-MeanOutputUnitError[o]);
+		}  
+            change *= actPrime/SumSqError;
+            BIAS_CURRENT_SLOPE(SpecialUnitPtr) += change;
+
+	    FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr)
+		LN_CURRENT_SLOPE(LinkPtr) += change * LinkPtr->to->Out.output;
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_propagateSpecialOnlineCase
+
+  PURPOSE  : Propagation in Case of Special Units for BackProp
+  NOTES    :
+
+  UPDATE   : 30.3.96 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_propagateSpecialOnlineCase(int start,int end,int n,int counter,
+				       float eta, float mu, float dummy)
+{
+
+    float change=0.0,actPrime;
+    int s,o,p,pat,sub;
+    struct Unit *SpecialUnitPtr,*OutputUnitPtr;
+    struct Link *LinkPtr;
+    float lastChange;
+
+    for(p=start; p<=end;p++){
+        cc_getActivationsForActualPattern(p,start,&pat,&sub);
+
+	FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+	    change = 0.0;
+	    SpecialUnitPtr->act = SpecialUnitAct[p][s];
+	    actPrime = (*SpecialUnitPtr->act_deriv_func)(SpecialUnitPtr);
+	    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o) 
+               if(UNITS_IN_SAME_GROUP(s,o)){
+		change += SIGN_OF_THE_CORRELATION[s][o] *
+		   (OutputUnitError[p][o]-MeanOutputUnitError[o]);
+	       }  
+            change *= actPrime/SumSqError;
+            lastChange = BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr);
+	    SpecialUnitPtr->bias += 
+		(BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr) = 
+		 (change * eta + lastChange * mu));     
+	    FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+		lastChange = LN_LAST_WEIGHT_CHANGE(LinkPtr);
+		LinkPtr->weight += 
+		    (LN_LAST_WEIGHT_CHANGE(LinkPtr) = 
+		     change*LinkPtr->to->Out.output*eta+lastChange*mu);
+	    }
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return(KRERR_NO_ERROR);
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_CC
+
+  PURPOSE  : The main routine of CC
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err LEARN_CC(int StartPattern, int EndPattern, 
+		  float *ParameterInArray, int NoOfInParams, 
+		  float **ParameterOutArray, int *NoOfOutParams)
+{
+
+  NetLearnAlgorithm = CC;
+
+  return(LEARN_CasCor(StartPattern,EndPattern,ParameterInArray,NoOfInParams,
+		      ParameterOutArray,NoOfOutParams));
+}
+
+
+ 
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_CasCor
+
+  PURPOSE  : The main learn routine of CC
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err LEARN_CasCor(int StartPattern, int EndPattern,
+		      float *ParameterInArray, int NoOfInParams,
+		      float **ParameterOutArray, int *NoOfOutParams)
+    
+{
+
+    static int   GroupNo;
+    static float LeTe;
+    int TempErrorCode; /* Used by the macro ERROR_CHECK_WITH_MEM_DEALLOC */
+ 
+    if(cc_allButtonIsPressed == 1) { 
+	KernelErrorCode = cc_initVariables(ParameterInArray, StartPattern,
+					   EndPattern);
+	ERROR_CHECK;
+    }
+
+    if(cc_end){
+	cc_deleteAllSpecialUnits();
+	return(cc_freeStorage(StartPattern,EndPattern,0));
+    }
+
+    cc_allocateStorage(StartPattern,EndPattern,MAX_SPECIAL_UNIT_NUMBER);
+    ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+ 
+    /* it's easier to delete and reconstruct the Units, than to change them */
+    KernelErrorCode = cc_deleteAllSpecialUnits();
+    ERROR_CHECK_WITH_MEMORY_DEALLOCATION; 
+  
+    KernelErrorCode = cc_generateSpecialUnits(SPECIAL_FUNCTION_TYPE);
+    ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+
+    KernelErrorCode = cc_initSpecialUnitLinks();
+    ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+  
+    if(cc_storageFree){   CC_ERROR(KRERR_CC_ERROR2);    }
+
+    /* If this is the first run, train the output connections */
+    if (NoOfHiddenUnits<1) {
+	if((OUT_PATIEN != 0) && (MAX_NO_ERROR_UPDATE_CYCLES != 0)) {
+	    cc_trainOutputUnits(MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE, 
+				MINIMAL_ERROR_CHANGE, OUT_PATIEN,
+				StartPattern, EndPattern, PARAM1, PARAM2,
+				PARAM3, ParameterOutArray, NoOfOutParams);
+	}
+    }
+
+    /* compute the selection criterion before the new hidden is installed */
+    if (CC_PRUNE_ONOFF) {
+	LeTe=cc_getPruningError(PRUNE_FUNC,StartPattern,EndPattern,1);
+    }
+
+    /* train the candidates */
+    if(cc_test(StartPattern,EndPattern,MAX_PIXEL_ERR) ==  CONTINUE_LEARNING) {
+	if((SPEC_PATIENCE != 0) && (MAX_NO_OF_COVAR_UPDATE_CYCLES != 0)) {
+	    cc_trainSpecialUnits(MAX_NO_OF_COVAR_UPDATE_CYCLES,
+				 MIN_COVAR_CHANGE,SPEC_PATIENCE,
+				 StartPattern,EndPattern,
+				 PARAM4,PARAM5,PARAM6,MAX_SPECIAL_UNIT_NUMBER);
+	}
+    }else {			/* STOP_LEARNING  */
+	cc_end = TRUE;
+	return(cc_freeStorage(StartPattern,EndPattern,0));
+    }
+
+    cc_actualNetSaved=FALSE;
+
+    /* install new hidden unit(s) */
+    for (GroupNo=0;GroupNo<cc_calculateNoOfNewUnits();GroupNo++){
+	if((SPEC_PATIENCE != 0) && (MAX_NO_OF_COVAR_UPDATE_CYCLES != 0)) {
+	    KernelErrorCode = cc_generateHiddenUnit(GroupNo);
+	    ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+	}
+    }
+  
+    /* retrain the output connections */
+    if((OUT_PATIEN != 0) && (MAX_NO_ERROR_UPDATE_CYCLES != 0)) {
+	cc_trainOutputUnits(MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE,
+			    MINIMAL_ERROR_CHANGE, OUT_PATIEN, StartPattern,
+			    EndPattern, PARAM1, PARAM2, PARAM3,
+			    ParameterOutArray,NoOfOutParams); 
+    }
+
+
+    /* prune the new hidden unit and retrain the output connections again */
+    if (CC_PRUNE_ONOFF) {
+	cc_pruneNet(StartPattern, EndPattern, PRUNE_FUNC);
+	if((OUT_PATIEN != 0) && (MAX_NO_ERROR_UPDATE_CYCLES != 0)) {
+	    cc_trainOutputUnits(MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE,
+				MINIMAL_ERROR_CHANGE,
+				OUT_PATIEN,StartPattern,EndPattern,PARAM1,
+				PARAM2,PARAM3,ParameterOutArray,NoOfOutParams); 
+	}
+	if (cc_getPruningError(PRUNE_FUNC,StartPattern,EndPattern,2)>LeTe) {
+	    cc_remove_Unit(); 
+	}       
+    }
+    cc_deleteAllSpecialUnits();
+    cc_allButtonIsPressed = 0;
+    return(cc_freeStorage(StartPattern,EndPattern,0));
+}
+
+
+/*****************************************************************************
+  FUNCTION : void cc_generateLayerList
+
+  PURPOSE  : generates list with data of the layers
+  NOTES    :
+
+  UPDATE   : 20.11.95 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_generateLayerList(void)
+{
+
+    int i;
+    struct Unit* UnitPtr;
+
+    FREE_IF_USED(ListOfLayers);  /* we allocate a new list */
+    CALLOC_ERRORCHECK(ListOfLayers,MINIMAL_LAYERLIST_SIZE+NoOfLayers,
+		      Layer_Type);
+    ListOfLayers[0].NoOfUnitsInLayer = NoOfInputUnits;
+    ListOfLayers[0].xPosFirstRow = cc_hiddenXminPos;
+
+    SizeOfLayerlist = MINIMAL_LAYERLIST_SIZE+NoOfLayers;
+
+    for (i=1;i<SizeOfLayerlist;i++){
+	ListOfLayers[i].xPosFirstRow = MAX_POS;
+	ListOfLayers[i].NoOfUnitsInLayer = 0;
+    }
+    /* calculating data for the layers */
+    FOR_ALL_UNITS(UnitPtr){
+	if (IS_HIDDEN_UNIT(UnitPtr)){
+	    if(CC_LAYER_NO(UnitPtr) >=SizeOfLayerlist)
+		printf("\n\n\nInternal error with layers\n\n\n");
+	    else{
+		ListOfLayers[CC_LAYER_NO(UnitPtr)].NoOfUnitsInLayer++;
+		ListOfLayers[CC_LAYER_NO(UnitPtr)].xPosFirstRow =
+		    MIN(ListOfLayers[CC_LAYER_NO(UnitPtr)].xPosFirstRow,
+			GET_UNIT_XPOS(UnitPtr));
+	    }
+	}
+    } 
+    return(KRERR_NO_ERROR);
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : void cc_actualizeLayerList
+
+  PURPOSE  : changes the Size of the LayerList, iff needed.
+  NOTES    : the List have to be generated with cc_generateLayerList.
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+krui_err cc_actualizeLayerlist(struct Unit* UnitPtr, int LayerNo)
+{
+
+    int i;
+    struct CC_LAYER* Newlist;
+
+    if (LayerNo > NoOfLayers){
+	NoOfLayers++;
+	if (NoOfLayers >= SizeOfLayerlist-1){ /* then double size */
+
+	    CALLOC_ERRORCHECK(Newlist,SizeOfLayerlist * 2,struct CC_LAYER);
+
+	    for(i=0;i<SizeOfLayerlist;i++)
+		Newlist[i]=ListOfLayers[i]; 
+
+	    for(i=SizeOfLayerlist;i<2*SizeOfLayerlist;i++)
+		Newlist[i].NoOfUnitsInLayer=0;
+
+	    SizeOfLayerlist *= 2;
+	    free(ListOfLayers);
+	    ListOfLayers=Newlist;    
+	}
+	ListOfLayers[NoOfLayers].NoOfUnitsInLayer=1;
+	ListOfLayers[NoOfLayers].xPosFirstRow=
+	    FIRST_ROW_NEXT_LAYER(NoOfLayers-1);
+    }else     
+	ListOfLayers[LayerNo].NoOfUnitsInLayer++;
+
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_err cc_generateHiddenUnit
+
+  PURPOSE  : Generates a new hidden unit 
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err cc_generateHiddenUnit(int GroupNo)
+{
+
+    int LayerOfNewUnit;
+ 
+    int CurrentUnit,dummy,NewHiddenUnit;
+    struct Unit *HiddenUnitPtr,*OutputUnitPtr;
+
+    bestSpecialUnitPtr=cc_getModifiedBestSpecialUnitPtr(GroupNo);
+
+    LayerOfNewUnit = CC_LAYER_NO(bestSpecialUnitPtr);
+    KernelErrorCode=cc_actualizeLayerlist(bestSpecialUnitPtr,LayerOfNewUnit);
+    ERROR_CHECK;
+    LastInsertedHiddenUnit=
+        CurrentUnit = 
+	    KernelErrorCode = 
+	        kr_copyUnit(ONLY_INPUTS,GET_UNIT_NO(bestSpecialUnitPtr));
+    if(KernelErrorCode < 0)  return(KernelErrorCode); 
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    KernelErrorCode = kr_unitSetTType(CurrentUnit,HIDDEN); 
+    ERROR_CHECK;
+
+    HiddenUnitPtr = kr_getUnitPtr(CurrentUnit); 
+    ERROR_CHECK;
+
+    CC_SET_LAYER_NO(HiddenUnitPtr,LayerOfNewUnit);
+
+    KernelErrorCode = cc_setHiddenUnit(HiddenUnitPtr,LayerOfNewUnit);
+    ERROR_CHECK;
+
+    KernelErrorCode = krui_setCurrentUnit(CurrentUnit); 
+    ERROR_CHECK;
+
+    NewHiddenUnit = CurrentUnit;
+
+    /* generate links between output unit and new hidden unit */
+    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,dummy){
+	CurrentUnit = GET_UNIT_NO(OutputUnitPtr);
+	KernelErrorCode = krui_setCurrentUnit(CurrentUnit); 
+	ERROR_CHECK;
+
+	KernelErrorCode = krui_createLink(NewHiddenUnit,0.0);
+	ERROR_CHECK; 
+    }       /* and change its Layer if necessary */
+    KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+    ERROR_CHECK;    
+
+    KernelErrorCode = cc_setPointers();
+    ERROR_CHECK;
+
+    NetModified = FALSE;
+
+    return(KRERR_NO_ERROR);
+    
+}
+
+ 
+
+/*****************************************************************************
+  FUNCTION : cc_test
+
+  PURPOSE  : Tests whether to continue learning or not.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+int cc_test(int StartPattern, int EndPattern, float maxPixelError)
+{
+    int p,sub,pat,o;
+    int start, end,n,dummy;
+    Patterns out_pat;
+    struct Unit *unitPtr;
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(StartPattern,EndPattern);
+    ERROR_CHECK;
+
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+
+    for(p=start; p<=end;p++){
+     	cc_getActivationsForActualPattern(p,start,&pat,&sub);
+
+	PROPAGATE_THROUGH_OUTPUT_LAYER(unitPtr,dummy,p);
+
+	out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+
+	FOR_ALL_OUTPUT_UNITS(unitPtr,o){
+	    if((fabs(*(out_pat++) - unitPtr->Out.output))>maxPixelError){
+		return(CONTINUE_LEARNING);
+	    } 
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return(STOP_LEARNING);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_generateSpecialUnits   
+
+  PURPOSE  : Generates the special units
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err cc_generateSpecialUnits(int type)
+{
+
+    int i,selector,calcLayerNo;
+    struct Unit *UnitPtr;
+    struct Unit *SpecUnitPtr;
+    int CurrentUnit;
+
+    cc_MakeMiscCalculationsForModifications();
+
+    for(i=0;i<cc_MaxSpecialUnitNo;i++) {
+        selector = ((type==RANDOM) ?  i % (NO_OF_ACT_FUNCS - 1) : type);
+
+	KernelErrorCode = 
+	    kr_unitSetTType(CurrentUnit=kr_makeDefaultUnit(),SPECIAL); 
+	ERROR_CHECK;
+	KernelErrorCode = krui_setUnitActFunc(CurrentUnit,
+					      cc_actFuncArray[selector]);
+	ERROR_CHECK;  
+
+	SpecUnitPtr = kr_getUnitPtr(CurrentUnit); 
+	ERROR_CHECK;
+  
+	KernelErrorCode = krui_setCurrentUnit(CurrentUnit); 
+	ERROR_CHECK;
+
+        KernelErrorCode = cc_calculateConnections(i);
+        ERROR_CHECK;
+
+        calcLayerNo=0;
+	FOR_ALL_UNITS(UnitPtr){
+	    if((IS_INPUT_UNIT(UnitPtr) ||  IS_HIDDEN_UNIT(UnitPtr)) && 
+	       cc_UnitsHaveToBeConnected(i,UnitPtr) &&
+	       UNIT_IN_USE(UnitPtr)) {
+		if (CC_LAYER_NO(UnitPtr) > calcLayerNo) 
+		    calcLayerNo = CC_LAYER_NO(UnitPtr);
+		KernelErrorCode = 
+		    krui_createLink(GET_UNIT_NO(UnitPtr),
+				    cc_generateRandomNo(CC_MAX_VALUE)); 
+		ERROR_CHECK;
+	    }
+	}
+        CC_SET_LAYER_NO(SpecUnitPtr,calcLayerNo+1);
+    }
+
+   
+    KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+    ERROR_CHECK;    
+
+    KernelErrorCode = cc_setPointers();
+    ERROR_CHECK;
+
+    cc_setSpecialUnits(cc_outputXMax+2);
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : TEST_CasCor
+
+  PURPOSE  : main routine for the test of Cascade Correlation nets
+  RETURNS  : kernel error code
+  NOTES    : Output Parameters:  1 : error of the network (sum of all cycles)
+
+
+  UPDATE   : 17.01.96 <Juergen Gatter>
+******************************************************************************/
+krui_err TEST_CasCor(int start_pattern, int end_pattern,
+		     float *parameterInArray, int NoOfInParams,
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    int          saved_cc_fastmode;
+    static float OutParameter[1];
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NoOfInParams < 1) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+
+    saved_cc_fastmode = cc_fastmode; 
+    cc_fastmode = FALSE;       
+    NET_ERROR(OutParameter) = cc_getErr(start_pattern, end_pattern);
+  
+    cc_fastmode = saved_cc_fastmode;
+    cc_actualNetSaved = FALSE;
+    return (KernelErrorCode);
+}
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/cc_learn.h snort-2.3.3.new/src/kernel_snns/cc_learn.h
--- snort-2.3.3/src/kernel_snns/cc_learn.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_learn.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,39 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_learn.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 5.2.92
+
+  CHANGED BY     : Michael Schmalzl
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:57 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_LEARN_DEFINED_
+#define  _CC_LEARN_DEFINED_
+
+/* begin global definition section */
+extern krui_err LEARN_CC(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+extern krui_err LEARN_CasCor(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+extern krui_err TEST_CasCor(int start_pattern, int end_pattern,
+			float *parameterInArray, int NoOfInParams,
+			float **parameterOutArray, int *NoOfOutParams);
+
+/* end   global definition section */
+
+/* begin privat definition section */
+/* end privat definition section */
+
+#endif /* _CC_LEARN_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_learn.ph snort-2.3.3.new/src/kernel_snns/cc_learn.ph
--- snort-2.3.3/src/kernel_snns/cc_learn.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_learn.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,75 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_learn.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl, Christian Wehrfritz (PCC)
+  DATE           : 5.2.1993
+
+  CHANGED BY     : Michael Schmalzl
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:58 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_LEARN_DEFINED_
+#define  _CC_LEARN_DEFINED_
+
+/* begin global definition section */
+extern krui_err LEARN_CC(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+extern krui_err LEARN_CasCor(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+/* end   global definition section */
+
+/* begin privat definition section */
+float cc_calculateCorrelation(int StartPattern,int EndPattern,int counter);
+ krui_err cc_GetTrainFunctions(int learnFunc);
+
+ void cc_calculateSpecialUnitActivation(int startPattern,int endPattern);
+ krui_err cc_generateSpecialUnits(int type);
+ int  cc_test(int StartPattern,int EndPattern,float maxPixelError); 
+
+ void  cc_calculateOutputUnitError(int StartPattern,int EndPattern);
+ void  cc_trainSpecialUnits(int maxNoOfCovarianceUpdateCycles, 
+			    float minCovarianceChange,
+                            int specialPatience,int StartPattern, 
+			    int EndPattern,
+                            float param1, float param2, float param3, 
+			    int MaxSpecialUnitNo);
+void  cc_trainOutputUnits(int maxNoOfErrorUpdateCycles,int backfittPatience,
+			     float minErrorChange, 
+                             int outPatience, int StartPattern,int EndPattern,
+                             float param1, float param2,float param3,
+                             float **ParameterOutArray,int *NoOfOutParams);
+
+krui_err cc_propagateSpecial(int start,int end,int n,
+					 int counter,float param1, float param2, 
+                                          float param3);
+ float cc_propagateOutput(int PatternNo, int sub_pat_no,float param1,float param2,float param3);
+krui_err cc_propagateSpecialOnlineCase(int start,int end,int n,
+					 int counter,float param1, float param2, 
+                                          float param3);
+ float cc_propagateOutputOnlineCase(int PatternNo, int sub_pat_no,float param1,float param2,float param3);
+
+ krui_err cc_generateHiddenUnit(int GroupNo);
+
+ krui_err cc_initVariables(float* ParameterInArray,
+                                int StartPattern,int EndPattern);
+ krui_err cc_generateLayerList(void);
+
+ krui_err cc_actualizeLayerlist(struct Unit* UnitPtr,int LayerNo);
+
+
+
+/* end privat definition section */
+
+
+#endif /* _CC_LEARN_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_mac.h snort-2.3.3.new/src/kernel_snns/cc_mac.h
--- snort-2.3.3/src/kernel_snns/cc_mac.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_mac.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,461 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_mac.h,v $
+  SHORTNAME      : mac.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : macros for cascade correlation and TACOMA
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 24.2.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/02/25 15:25:59 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _CC_MAC_DEFINED_
+#define _CC_MAC_DEFINED_
+
+/* constants for all algorithms */
+
+#define NO_INC_ALGORITHM 0
+#define CC 1
+#define TACOMA 3
+
+#define OFF 0
+#define ON  1
+
+
+#define FIELD_EMPTY -1
+
+#define NO_OF_ACT_FUNCS 7
+
+#define ASYM_SIGMOID 0
+#define SYM_SIGMOID  1
+#define TANH         2
+#define THRESHOLD    3
+#define SINUS        4
+#define EXPONENTIAL  5
+#define RANDOM       6  /* RANDOM has to be last Act_function !!! */
+
+#define SIN_FAKTOR   0.1    
+#define THRESHOLD_DERIV 1   /* not used anymore */
+
+#define BACKPROP         0
+#define BACKPROP_ONLINE  1
+#define QUICKPROP        2
+#define RPROP            3
+
+#define SBC          0
+#define AIC          1
+#define CMSEP        2
+
+#define CC_NO_MOD    0
+#define CC_SDCC      1
+#define CC_LFCC      2
+#define CC_RLCC      3
+#define CC_ECC       4
+#define CC_GCC       5
+#define CC_STAT      6
+
+#define CONTINUE_LEARNING 1
+#define STOP_LEARNING 0
+
+#define CC_MAX_VALUE  0.1 
+#define FLOAT_MAX 1E+37
+
+
+
+     /* these are the standard parameter settings */
+
+/* output parameter definitions */
+#define  OUT_PATIENCE                  50 
+#define  MAX_NO_OF_ERROR_UPDATE_CYCLES 200
+#define  MIN_ERROR_CHANGE              0.01
+
+/* special parameter definitions */
+#define  SPECIAL_PATIENCE                   25 
+#define  MAX_NO_OF_COVARIANCE_UPDATE_CYCLES 200
+#define  MIN_COVARIANCE_CHANGE              0.04
+#define  MAX_SPECIAL_UNIT_NO                8
+#define  SPECIAL_FUNC_TYPE                  SYM_SIGMOID
+
+/* global parameter definitions */
+#define  MAX_PIXEL_ERROR 0.2
+#define  LEARNING_FUNC   QUICKPROP
+#define  MODIFICATION    CC_NO_MOD
+#define  ON_OFF   OFF
+#define  CACHING_ONOFF ON
+
+
+/* Constants for the  display-functions */
+
+#define X_MIN_POS 2
+#define Y_MIN_POS 3
+#define MAX_POS   1000000
+#define MIN_HIDDEN_LAYER_HEIGHT 5
+
+#define Y_MAX_MODE1                      5
+#define Y_MAX_MODE2                      8
+#define Y_MAX_MODE3                     12
+#define Y_MAX_MODE4                     20
+#define Y_MAX_MODE5                     MAX_POS
+#define X_MAX_DISPLAYABLE               30
+#define DEFAULT_DISTANCE_BETWEEN_LAYERS  2
+#define DISTANCE_TO_INOUT_LAYERS         3
+
+/* Output-constants */    
+
+#define LENGTH_HEADLINE                 80
+
+
+
+/* Size of one block of the layerlist */
+
+#define MINIMAL_LAYERLIST_SIZE 100
+
+/* where the slopes are stored */
+
+#define LN_CURRENT_SLOPE(LinkPtr)       LinkPtr->value_a
+#define LN_PREVIOUS_SLOPE(LinkPtr)      LinkPtr->value_b
+#define LN_LAST_WEIGHT_CHANGE(LinkPtr)  LinkPtr->value_c
+
+#define BIAS_CURRENT_SLOPE(UnitPtr)      UnitPtr->value_a
+#define BIAS_PREVIOUS_SLOPE(UnitPtr)     UnitPtr->value_b
+#define BIAS_LAST_WEIGHT_CHANGE(UnitPtr) UnitPtr->value_c
+
+
+/* Macros for all learn algorithms */
+
+#define  NET_ERROR( param )      param[ 0 ]  /*    returns the net error   */
+
+#define GET_UNIT_NO(UnitPtr) \
+   ((int) ((UnitPtr) - unit_array))  
+
+#define GET_UNIT_XPOS(UnitPtr) \
+   (*UnitPtr).unit_pos.x
+
+#define GET_UNIT_YPOS(UnitPtr) \
+   (*UnitPtr).unit_pos.y
+
+#define SET_UNIT_XPOS(UnitPtr,XPos) \
+   (*UnitPtr).unit_pos.x = XPos 
+
+#define SET_UNIT_YPOS(UnitPtr,YPos) \
+   (*UnitPtr).unit_pos.y = YPos
+
+/* error-macros */
+
+#define ERROR_CHECK \
+   if(KernelErrorCode!=KRERR_NO_ERROR) { \
+     return(KernelErrorCode); \
+   }  
+
+#define ERROR_CHECK_WITH_MEMORY_DEALLOCATION \
+   if((TempErrorCode=KernelErrorCode)!=KRERR_NO_ERROR) { \
+     cc_freeStorage(StartPattern,EndPattern,0); \
+     return(TempErrorCode); \
+   } 
+
+#define TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION \
+   if((TempErrorCode=KernelErrorCode)!=KRERR_NO_ERROR) { \
+     tac_freeStorage(StartPattern,EndPattern); \
+     return(TempErrorCode); \
+   } 
+
+#define UPS_ERROR_CHECK_WITH_MEMORY_DEALLOCATION \
+   if((TempErrorCode=KernelErrorCode)!=KRERR_NO_ERROR) { \
+     ups_freeStorage(StartPattern,EndPattern); \
+     return(TempErrorCode); \
+   } 
+
+#define ERROR_CHECK_WRC \
+   if(KernelErrorCode!=KRERR_NO_ERROR) { \
+     return; \
+   } 
+
+#define CC_ERROR(ErrorCode) \
+   return(ErrorCode)
+ 
+/* memory allocation macros */
+
+#define FREE_IF_USED(i) \
+   if((i) != NULL){free(i); i=NULL; }
+
+#define FREE_2DIMENSIONAL_ARRAY(Anker,NoOfRows,i) \
+   if (Anker!=NULL){ \
+      FREE_IF_USED(Anker[0]); \
+      FREE_IF_USED(Anker); \
+      Anker = NULL; \
+   }
+
+#define FREE_2DIMENSIONAL_ARRAY_WITH_PRINT(Anker,NoOfRows,i) \
+   if (Anker!=NULL){ \
+     FREE_IF_USED(Anker[0]);  \
+      Anker = NULL; \
+   }
+
+#define FREE_2ND_ARRAY(Anker,NoOfRows,UnderType,i) \
+   if (Anker!=NULL){ \
+      FREE_IF_USED(Anker[0].UnderType); \
+   }
+
+#define CALLOC_ERRORCHECK(Anker,Anzahl,Datentyp) \
+ if( (Anker = (Datentyp *) calloc(Anzahl,sizeof(Datentyp))) == NULL){ \
+      CC_ERROR(KernelErrorCode=KRERR_CC_ERROR3); \
+ }
+
+#define CALLOC_2DIMENSIONAL_ARRAY(Anker,NoOfRows,NoOfCols,DatenTyp,i) \
+  { \
+     CALLOC_ERRORCHECK(Anker,NoOfRows,DatenTyp*); \
+     CALLOC_ERRORCHECK(Anker[0],(NoOfRows)*(NoOfCols),DatenTyp); \
+     for(i=1;i<NoOfRows;i++) \
+     { \
+        Anker[i]=Anker[i-1]+NoOfCols; \
+     } \
+  } \
+
+#define CALLOC_2ND_ARRAY(Anker,NoOfRows,UnderType,NoOfCols,DataType,i) \
+  { \
+     CALLOC_ERRORCHECK(Anker[0].UnderType,(NoOfRows)*(NoOfCols),DataType); \
+     for(i=1;i<(NoOfRows);i++) \
+     { \
+        Anker[i].UnderType=Anker[i-1].UnderType+(NoOfCols); \
+     } \
+  }
+  
+
+
+/* propagation macros */
+
+#define CALCULATE_ACTIVATION_AND_OUTPUT(UnitPtr,value,p) \
+ { \
+    UnitPtr->Out.output = ((UnitPtr->out_func == OUT_IDENTITY) ? \
+                          (UnitPtr->act = value) : \
+                          (*UnitPtr->out_func) (UnitPtr->act = value)); \
+ }
+
+#define CALCULATE_INPUTUNIT_ACTIVATION_AND_OUTPUT(UnitPtr,value) \
+    UnitPtr->Out.output = ((UnitPtr->out_func == OUT_IDENTITY) ? \
+                          (UnitPtr->act = value) : \
+                          (*UnitPtr->out_func) (UnitPtr->act = value)); \
+
+#define PROPAGATE_THROUGH_INPUT_LAYER(inputUnitPtr,dummy,pattern) \
+    FOR_ALL_INPUT_UNITS(inputUnitPtr,dummy){ \
+        CALCULATE_INPUTUNIT_ACTIVATION_AND_OUTPUT(inputUnitPtr,*pattern++); \
+    }
+
+#define PROPAGATE_THROUGH_HIDDEN_LAYER(hiddenUnitPtr,dummy,pattern) \
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,dummy) { \
+        CALCULATE_ACTIVATION_AND_OUTPUT(hiddenUnitPtr, \
+                  (*hiddenUnitPtr->act_func)(hiddenUnitPtr),pattern); \
+    }
+
+#define PROPAGATE_THROUGH_OUTPUT_LAYER(outputUnitPtr,dummy,pattern) \
+    FOR_ALL_OUTPUT_UNITS(outputUnitPtr,dummy) { \
+        CALCULATE_ACTIVATION_AND_OUTPUT(outputUnitPtr, \
+                  (*outputUnitPtr->act_func)(outputUnitPtr),pattern); \
+    }
+#define PROPAGATE_THROUGH_SPECIAL_LAYER(specialUnitPtr,dummy,pattern) \
+	FOR_ALL_SPECIAL_UNITS(specialUnitPtr,dummy) { \
+            CALCULATE_ACTIVATION_AND_OUTPUT(specialUnitPtr, \
+                      (*specialUnitPtr->act_func) (specialUnitPtr),pattern); \
+    }
+
+/* modification macros */
+
+#define UNITS_IN_SAME_GROUP(spec,outpt) \
+    ((cc_modification!=CC_GCC)|| \
+    ((spec%CCS_NO_OF_GROUPS)==ccs_GroupList[outpt]))
+
+#define NO_OF_GROUPS ((cc_modification!=CC_GCC) ? 1 : CCS_NO_OF_GROUPS)
+
+
+/* misc macros */
+
+#define IF_PTR_IS_NOT_NULL(ptr) if(ptr!=NULL)
+
+#define FOR_ALL_INPUT_UNITS(UnitPtr,i) \
+   for(UnitPtr= *FirstInputUnitPtr,i=0;UnitPtr!=NULL;UnitPtr=FirstInputUnitPtr[++i])
+
+#define FOR_ALL_HIDDEN_UNITS(UnitPtr,h) \
+   for(UnitPtr= *FirstHiddenUnitPtr,h=0;UnitPtr!=NULL;UnitPtr=FirstHiddenUnitPtr[++h])
+
+#define FOR_ALL_OUTPUT_UNITS(UnitPtr,o) \
+   for(UnitPtr= *FirstOutputUnitPtr,o=0;UnitPtr!=NULL;UnitPtr=FirstOutputUnitPtr[++o])
+
+#define FOR_ALL_SPECIAL_UNITS(UnitPtr,s) \
+   for(UnitPtr= *FirstSpecialUnitPtr,s=0;UnitPtr!=NULL;UnitPtr=FirstSpecialUnitPtr[++s])
+          
+#define FOR_ALL_PATTERNS(StartPattern,EndPattern,p) \
+   for(p=StartPattern;p<=EndPattern;p++)
+
+#define SIGN(n) (((n) > 0) ? (1) : (-1))
+
+#define GET_RECURRENT_LINK(unit_ptr,link_ptr) \
+   (link_ptr) = (struct Link *) (unit_ptr)->sites 
+
+#define FOR_ALL_NOT_RECURRENT_LINKS( unit_ptr, link_ptr ) \
+for ((link_ptr) = ((struct Link *) (unit_ptr)->sites)->next; (link_ptr) != NULL; \
+     (link_ptr) = (link_ptr)->next)
+
+#define MAX(a,b) (((a)>(b))?(a):(b))
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+#define NO_OF_NET_UNITS \
+   (NoOfInputUnits+NoOfOutputUnits+NoOfHiddenUnits)
+
+#define NO_OF_INOUT_UNITS \
+   (NoOfInputUnits+NoOfOutputUnits)
+
+#define REL_HIDDEN_NO(a) \
+   ((a)-NoOfInputUnits-NoOfOutputUnits)
+
+
+#define DISTANCE_BETWEEN_LAYERS(a) \
+   (((a)==0)||((a)==NoOfLayers)) ? DISTANCE_TO_INOUT_LAYERS : cc_LayerDistance
+
+
+#define CC_LAYER_NO(Ptr) ((Ptr->lln >= 0) ? Ptr->lln : ((-1) - Ptr->lln))
+
+#define CC_SET_LAYER_NO(Ptr,LayerNo) \
+   if (Ptr->lln >= 0) \
+      Ptr->lln = LayerNo; \
+   else \
+      Ptr->lln = (-1) - LayerNo;
+
+#define FIRST_ROW_NEXT_LAYER(i) \
+   ((i>0) ? \
+   (ListOfLayers[i].xPosFirstRow + \
+   (((ListOfLayers[i].NoOfUnitsInLayer)-1) / cc_display_mode) + \
+   (DISTANCE_BETWEEN_LAYERS(i))) : \
+   ListOfLayers[i].xPosFirstRow)
+
+#define PRINTF  if (cc_printOnOff) printf 
+
+#define SIGN_OF_THE_CORRELATION CorBetweenSpecialActAndOutError
+
+#define OUTPUT_UNIT_SUM_ERROR   MeanOutputUnitError
+/* Aus Performance-Gruenden wird Variable 2-mal benutzt. 
+*/
+/* */
+
+/* Parameters for Cascade-Correlation */
+
+
+#define PARAM1                          ParameterInArray[0]
+#define PARAM2                          ParameterInArray[1]
+#define PARAM3                          ParameterInArray[2]
+#define PARAM4                          ParameterInArray[3]
+#define PARAM5                          ParameterInArray[4]
+#define PARAM6                          0.0001
+#define MAX_PIXEL_ERR                   ParameterInArray[6]
+#define LEARNING_FUNCTION               (int)ParameterInArray[7]
+#define CC_PRINT_ONOFF                  (int)ParameterInArray[8]
+#define MIN_COVAR_CHANGE                ParameterInArray[9]
+#define SPEC_PATIENCE                   ParameterInArray[10]
+#define MAX_NO_OF_COVAR_UPDATE_CYCLES   ParameterInArray[11] 
+#define MAX_SPECIAL_UNIT_NUMBER         ParameterInArray[12] 
+#define SPECIAL_FUNCTION_TYPE           (int)ParameterInArray[13] 
+#define MINIMAL_ERROR_CHANGE            ParameterInArray[14]
+#define OUT_PATIEN                      ParameterInArray[15] 
+#define MAX_NO_ERROR_UPDATE_CYCLES      ParameterInArray[16]
+#define CC_PRUNE_ONOFF                  (int)ParameterInArray[17]
+#define CC_BACKFITTING_ONOFF            (int)ParameterInArray[18]
+#define BACKFITT_PATIENCE               ParameterInArray[19]
+#define PRUNE_FUNC                      (int)ParameterInArray[20]
+#define MODIFICATION_NO                 (int)ParameterInArray[21]
+#define CC_PARAMETER1                   ParameterInArray[22]
+#define CC_PARAMETER2                   ParameterInArray[23]
+#define CC_PARAMETER3                   ParameterInArray[24]
+#define CC_PARAMETER4                   ParameterInArray[25]
+#define CC_PARAMETER5                   ParameterInArray[26]
+#define CC_FASTMODE                     ParameterInArray[27]
+
+/* Parameters for the modifications of CC */
+
+
+#define CCM_HEIGHT                      cc_Parameter[0]
+#define CCM_DIFF_HEIGHT                 cc_Parameter[1]
+#define CCM_DAEMPFUNG                   cc_Parameter[2]
+
+#define CCR_NO_OF_LINKS                 (int)cc_Parameter[0]
+
+#define CCC_M                           cc_Parameter[0]
+
+#define CCO_FAKTOR                      cc_Parameter[0]
+
+#define CCS_NO_OF_GROUPS                (int)cc_Parameter[0]
+
+#define CCB_LAMBDA                      cc_Parameter[0]
+
+#define SGN(x) (((x)==0.0)?0.0:(((x)<0.0)?-1.0:1.0))
+
+
+/* And now .... the TACOMA macros... */
+
+
+#define TAC_ALPHA(d,max) (0.1 * ((max-d)/(max)))
+
+
+#define TAC_KOHONEN  ((int)cc_Parameter[0])
+   /* how much runs to determine the best special units ? */
+#define TAC_XI_RI_ETA  (cc_Parameter[1])
+     /* step-width learning of xi and ri */
+#define TAC_THRESHOLD cc_Parameter[2]
+   /* All special units with g over this threshold were built in */
+#define TAC_LAMBDA    cc_Parameter[3]
+   /* A connection ist built in, iff the correlation is better than lambda */
+#define TAC_BETA      cc_Parameter[4]
+   /* To determine the initial radius of a link.*/
+#define TAC_ETA       0.7
+
+
+#define TAC_XIRI_ONLINE TRUE
+
+
+#define TAC_EXP(x) \
+	( (x>88.72) ? MAXFLOAT : ((x<-88.0) ? 0.0 : exp(x)) )
+
+#define XI_OF_LINK(LinkPtr) \
+	(LinkPtr->value_b)
+
+#define RI_OF_LINK(LinkPtr) \
+	(LinkPtr->value_a)
+ 
+/* if you change  XI_OF_LINK and/or RI_OF_LINK, then take a look at the loading
+   routines at krio_readConnectionDefs (kr_io.c) */
+
+
+#define SUMMED_DISTANCES Ri
+
+#define TAC_MAX_VALUE 1.0
+
+/* Macros for Upstart */
+
+
+#define UPS_MAX_VALUE 1.0
+
+#define UPS_BEST_WEIGHT(LinkPtr) LinkPtr->value_c
+
+#define UPS_MODIFIKATION_ON  (cc_Parameter[0] > 0.0)
+
+#define UPS_ETA (cc_Parameter[1])
+
+#define UPS_NEW_MODE (cc_Parameter[1]>0.0)
+
+#define UPS_TEST (cc_Parameter[2]>0.0)
+
+#define UPS_NOT_CALCULATED 0
+
+#define UPS_GREAT_VALUE 10000
+
+#define UPS_DAUGHTER_LINK(LinkPtr) LinkPtr->value_a
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/cc_modify.c snort-2.3.3.new/src/kernel_snns/cc_modify.c
--- snort-2.3.3/src/kernel_snns/cc_modify.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_modify.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,409 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_modify.c,v $
+  SHORTNAME      : cc_modify.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Functions of CC for the Modifications
+  NOTES          :
+                   For more information about the implemented modifications see:
+                   
+                   J. Gatter:
+                   "Lernverfahren neuronaler Netze mit automatischer
+                    Bestimmung der Netzwerktopologie"
+                   Diplomarbeit Nr. 1337, university of Stuttgart
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 30.11.95
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.11 $
+  LAST CHANGE    : $Date: 1998/04/20 11:54:45 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>  
+#include <memory.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "random.h"
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+#include "kernel.h"      /*  kernel function prototypes  */
+#include "kr_mac.h"      /*  Kernel Macros   */
+
+
+#include "kr_ui.h"
+#include "cc_type.h"
+#include "cc_mac.h"
+#include "kr_newpattern.h"
+#include "cc_modify.ph"
+#include "cc_glob.h"
+
+/*****************************************************************************
+  FUNCTION : cc_InitModificationVariables
+
+  PURPOSE  : Initialise the Variables needed by the modification-routines.
+
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+krui_err  cc_InitModificationVariables(void)
+{
+  if ((NoOfLayers==0)||(cc_modification!=CC_STAT))
+    ccm_CurrentLayerHeight=ccm_MissingUnitsInLayer=0;
+  return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_TestWhetherParametersAreValid
+
+  PURPOSE  : tests correctness of the additional parameters.
+
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+
+krui_err cc_TestWhetherParametersAreValid(void)
+{
+  switch(cc_modification){
+      case(CC_GCC) :
+           if (CCS_NO_OF_GROUPS <=0){
+          	 printf("0 groups isn't valid. Changed to 1 group.\n");
+              cc_Parameter[0]=1.0;
+           }
+           if (CCS_NO_OF_GROUPS > NoOfOutputUnits){
+              printf("I'm not able to make more groups than OutputUnits.\n");
+              printf("Changed to %d groups.\n",NoOfOutputUnits);
+              cc_Parameter[0]= (float)NoOfOutputUnits;
+           }
+           if (CCS_NO_OF_GROUPS > cc_MaxSpecialUnitNo){
+              printf("I'm not able to make more groups than candidates.\n");
+              printf("Changed to %d groups.\n",cc_MaxSpecialUnitNo);
+              cc_Parameter[0]= (float)cc_MaxSpecialUnitNo;
+           }
+         break;
+      case(CC_SDCC) :
+           if (CCB_LAMBDA < 0.0) return (KRERR_CC_INVALID_ADD_PARAMETERS);
+         break;
+      case(CC_LFCC) :
+           if (CCR_NO_OF_LINKS < 1) return (KRERR_CC_INVALID_ADD_PARAMETERS);
+         break;
+      case(CC_RLCC):
+           if (CCO_FAKTOR <= 0.0) return (KRERR_CC_INVALID_ADD_PARAMETERS);
+         break;
+      case(CC_ECC):
+           if (CCC_M <= 0.0) return (KRERR_CC_INVALID_ADD_PARAMETERS);
+         break;
+      case(CC_STAT) :
+         break;       /* everything's possible, since 0 or negative LayerHeights
+                         are automatic converted to 1 */
+   }
+   return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_allocateMemoryForModifications
+
+  PURPOSE  : allocates the needed memory
+
+  NOTES    : dealloc by cc_deallocateMemory 
+             
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+krui_err cc_allocateMemoryForModifications (void)
+{
+    switch(cc_modification){
+      case(CC_LFCC) :        
+        CALLOC_ERRORCHECK(ccr_ListOfChosenUnits,CCR_NO_OF_LINKS,int);
+	break;
+      case(CC_GCC) :
+        CALLOC_ERRORCHECK(ccs_GroupList,NoOfOutputUnits,int);
+        CALLOC_ERRORCHECK(ccs_GroupData,CCS_NO_OF_GROUPS,struct CC_GROUP);
+	break;
+      default:
+	break;
+    }
+    return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_deallocateMemory
+
+  PURPOSE  : deallocates used memory.
+
+  NOTES    : macro tests if pointer isn't used. Then it have to be NULL.
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+void cc_deallocateMemory(void)
+{
+  FREE_IF_USED(ccs_GroupList);
+  FREE_IF_USED(ccs_GroupData);
+  FREE_IF_USED(ccr_ListOfChosenUnits);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_modifyHighScore
+
+  PURPOSE  : changes the HighScore according the the actual modification.
+
+  NOTES    : 
+             
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+double cc_modifyHighScore(struct Unit* SpecialUnitPtr, int s, double old)
+{   
+   switch(cc_modification){
+      case(CC_SDCC) : 
+         return  ((s >= (cc_MaxSpecialUnitNo/2)) ? CCB_LAMBDA*old : old);
+      case(CC_RLCC) :
+         return (pow(CCO_FAKTOR,NoOfLayers-CC_LAYER_NO(SpecialUnitPtr))*old);
+      default :
+         return (old);
+   }
+ }
+
+/*****************************************************************************
+  FUNCTION : cc_actualizeGroupHighscores
+
+  PURPOSE  : changes the HighScores if more then one candidate should be 
+             built in.
+
+  NOTES    : 
+             
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+void cc_actualizeGroupHighscores(double Score,int s,struct Unit* UnitPtr)
+{
+   if(cc_modification==CC_GCC){
+      if(Score > ccs_GroupData[s % CCS_NO_OF_GROUPS].Score)
+         ccs_GroupData[s % CCS_NO_OF_GROUPS].Score = Score;
+         ccs_GroupData[s % CCS_NO_OF_GROUPS].BestUnitPtr = UnitPtr;
+   }
+}
+
+/*****************************************************************************
+  FUNCTION : cc_calculateNoOfNewUnits
+
+  PURPOSE  : How many new Units will we have in one cycle ?
+             
+
+  NOTES    : 
+             
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+int cc_calculateNoOfNewUnits(void)
+{
+  switch(cc_modification){
+     case (CC_GCC) : return (CCS_NO_OF_GROUPS);
+     default              : return 1;
+   }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : cc_getModifiedBestSpecialUnitPtr()
+
+  PURPOSE  : change the bestSpecialUnitPtr if needed.
+             
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+ struct Unit*  cc_getModifiedBestSpecialUnitPtr(int GroupNo)
+{
+  switch(cc_modification){
+     case(CC_GCC) :
+         return(ccs_GroupData[GroupNo].BestUnitPtr);
+     default : 
+         return(bestSpecialUnitPtr);
+   }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_UnitsHaveToBeConnected
+
+  PURPOSE  : Test whether the Units have to be connected, according
+             the the actual modification.
+  NOTES    : SpecialUnitNo is in [0..cc_MaxSpecialUnitNo-1]. UnitNo
+             is the number of the other unit.
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+bool cc_UnitsHaveToBeConnected(int SpecialUnitNo,struct Unit *UnitPtr)
+{
+  int UnitNo,relUnitNo;
+  int i;
+
+  UnitNo=GET_UNIT_NO(UnitPtr);
+
+  relUnitNo=((IS_HIDDEN_UNIT(UnitPtr)) ? REL_HIDDEN_NO(UnitNo) : UnitNo);
+
+  switch (cc_modification){  /* no break required */
+    case(CC_SDCC)      : return((IS_INPUT_UNIT(UnitPtr))||
+                           (SpecialUnitNo >= cc_MaxSpecialUnitNo/2)||
+                           (CC_LAYER_NO(UnitPtr)<NoOfLayers));
+    case(CC_ECC) :
+                       return ((IS_INPUT_UNIT(UnitPtr)) ||
+                           ((float)relUnitNo/(float)(1+NoOfHiddenUnits)) <= CCC_M);
+    case(CC_STAT) :
+                       return ((IS_INPUT_UNIT(UnitPtr)) ||
+                           (relUnitNo <= NoOfHiddenUnits + 1 -
+                           (ccm_CurrentLayerHeight-ccm_MissingUnitsInLayer)));
+    case(CC_LFCC) :
+                       for(i=0;i<CCR_NO_OF_LINKS;i++){
+                           if (UnitNo==ccr_ListOfChosenUnits[i]){
+                                 return (TRUE);
+                           }
+                       }
+                       return (FALSE); /* Nicht in Liste vorhanden */        
+    case(CC_RLCC)      :
+                       return(CC_LAYER_NO(UnitPtr) < cco_ActualLayer);
+    default          : return (TRUE);  /* no modification */
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : cc_calculateConnections
+
+  PURPOSE  : calculates the connections, if necessary
+  NOTES    : 
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+krui_err cc_calculateConnections(int SpecUnitNo)
+{
+  struct Unit * UnitPtr;
+  int *ListOfAllUnits;
+  int  cnt=0,i,j,Choose; 
+  int FoundUnits=0;
+ 
+  switch(cc_modification){
+     case (CC_LFCC) :
+        CALLOC_ERRORCHECK(ListOfAllUnits,NoOfInputUnits+NoOfHiddenUnits,int);
+        FOR_ALL_UNITS(UnitPtr){
+           if (IS_INPUT_UNIT(UnitPtr)||
+              IS_HIDDEN_UNIT(UnitPtr)){
+                ListOfAllUnits[FoundUnits++] = GET_UNIT_NO(UnitPtr);
+           }     /* Copz numbers of every unit to LOAL */
+        }
+
+        if (FoundUnits<=CCR_NO_OF_LINKS){
+           for(i=0;i<FoundUnits;i++){
+              ccr_ListOfChosenUnits[i]=ListOfAllUnits[i];
+           }     /* get input from all units */
+        }
+        else{
+           for(i=0;i<CCR_NO_OF_LINKS;i++){
+              Choose = (int)(drand48()*(float)(FoundUnits-i));    
+                /* choose one of the remaining units */
+              for (j=0,cnt=0;
+                  ((cnt<Choose)||(ListOfAllUnits[j] == FIELD_EMPTY));
+                   j++){
+                 if (ListOfAllUnits[j] != FIELD_EMPTY) cnt++;
+		 /* Count `til choosen number. There have to be 
+                    CCR_NO_OF_LINKS entries remaining.*/
+      	      }
+              ccr_ListOfChosenUnits[i] = ListOfAllUnits[j];
+              ListOfAllUnits[j] = FIELD_EMPTY;
+              UnitPtr=kr_getUnitPtr(ccr_ListOfChosenUnits[i]);
+                /* get Unit number and free place. */
+           }
+        }  
+        free(ListOfAllUnits);
+        return(KRERR_NO_ERROR);
+     case(CC_RLCC) :
+        if (cc_MaxSpecialUnitNo==1)
+           cco_ActualLayer = NoOfLayers+1;
+        else
+          cco_ActualLayer = 1+(int)((SpecUnitNo*(NoOfLayers+0.9999)) / (cc_MaxSpecialUnitNo-1));
+        return(KRERR_NO_ERROR);
+     default : return(KRERR_NO_ERROR);
+   }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_MakeMiscCalculationsForModifications
+
+  PURPOSE  : <CCM>    calculate Height of layer iff necessary.
+             <CCS>    generates the list of the output-Units of a group.
+  NOTES    : 
+
+  UPDATE   : 17.11.95 <Juergen Gatter>
+******************************************************************************/
+
+void cc_MakeMiscCalculationsForModifications(void)
+{
+   float fTemp;
+   int   Height,i,j,k,chose;
+
+   switch(cc_modification){
+      case(CC_STAT) :
+         if (ccm_MissingUnitsInLayer == 0){
+            if(NoOfLayers==0){
+               fTemp = CCM_HEIGHT;
+               Height= (int)fTemp;
+	    }else{
+               fTemp=
+                  exp((-NoOfLayers*CCM_DAEMPFUNG))*CCM_HEIGHT;
+                         /* calculate funtion */
+               Height = (int)(fTemp+
+                     (drand48()*2.0*CCM_DIFF_HEIGHT-CCM_DIFF_HEIGHT));
+                         /* add or substract radom didderence */
+            }     
+            PRINTF("HeightOfLayer %d set to %d.\n",NoOfLayers,((Height>0) ? Height : 1));
+        
+            ccm_CurrentLayerHeight = ccm_MissingUnitsInLayer = ((Height>0) ? Height : 1);
+                        /* Height is correct, if it's bigger than 0 */
+	 }
+         ccm_MissingUnitsInLayer--;
+         return;
+      case(CC_GCC):
+         for(i=0;i<NoOfOutputUnits;i++)
+            ccs_GroupList[i] = FIELD_EMPTY;  /* all places are free */
+         for(i=0;i<CCS_NO_OF_GROUPS;i++){
+            chose=(int)(drand48()*(NoOfOutputUnits-i));                             
+            /* I want the OutputUnit No chose, which is left, in my group */
+            for(j=0;(k<chose)||(ccs_GroupList[j]!=FIELD_EMPTY);j++){
+            /* Count from the start, and take the chosen Unit which is left.
+               j can't get greater or equal NoOfOutputUnits, because there
+               must be (NoOfOutputUnits-i) empty places in ccs_groupList. */
+                if (ccs_GroupList[j] == FIELD_EMPTY) k++;
+            }
+            ccs_GroupList[j] = i; /* it gets the no of the group. */
+	 }
+         /* Now it's guaranteed that it's exactly one output-unit in
+            every group. The rest of the Output-Units will distributed
+            on the groups. */
+         for (j=0;j<NoOfOutputUnits;j++){
+            if (ccs_GroupList[j] == FIELD_EMPTY)
+                ccs_GroupList[j] = (int)(drand48()*CCS_NO_OF_GROUPS);
+	 }
+         return;
+      default :  
+         return;
+   }
+}
diff -Naur snort-2.3.3/src/kernel_snns/cc_modify.h snort-2.3.3.new/src/kernel_snns/cc_modify.h
--- snort-2.3.3/src/kernel_snns/cc_modify.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_modify.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,78 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_modify.h,v $
+  SHORTNAME      : cc_modify.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : 
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.4 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_MODIFY_DEFINED_
+#define  _CC_MODIFY_DEFINED_
+
+/* begin global definition section */
+
+extern krui_err  cc_InitModificationVariables(void);
+   /* inits some global Varibales. */
+
+extern krui_err cc_TestWhetherParametersAreValid(void);
+   /* is the Parameter-Input in the Windows valid ? */
+
+extern krui_err cc_allocateMemoryForModifications(void);
+   /* allocates Memory needed by some of the Modifications    */
+   /* i.E. ccr_ListOfChosenUnits, ccs_GroupList,ccs_GroupData */
+
+extern void cc_deallocateMemory(void);
+   /* deallocates the above allocated Memory                              */
+   /* gets and returns ErrorCode                                          */  
+   /* Routine is called by the Makro ERROR_CHECK_WITH_MEMORY_DEALLOCATION */
+
+extern double cc_modifyHighScore(struct Unit* SpecialUnitPtr, int s, double old);
+   /* modifies the HighScore according the actual Modification       */
+   /* s is the No (0..Max) of the Special Unit, old is the unchanged */
+   /* HighScore. The calling routine uses the changed HighScore to   */
+   /* determine the best Special Unit.                               */
+
+extern void cc_actualizeGroupHighscores(double Score,int s,struct Unit* UnitPtr);
+   /* if more then one group is used, this routine actualises the  */
+   /* according datas. Parameters see above.                       */
+
+extern int cc_calculateNoOfNewUnits(void);
+   /* How much Units do we have to install ? */
+
+extern struct Unit*  cc_getModifiedBestSpecialUnitPtr(int GroupNo);
+   /* get the best SpecialUnit according to the actual GroupNo */
+
+extern bool cc_UnitsHaveToBeConnected(int SpecialUnitNo,struct Unit *UnitPtr);
+   /* should the be a connection between the two units ?  */
+
+extern krui_err cc_calculateConnections(int SpecUnitNo);
+   /* calculate a connection table, if this must be done before */
+   /* all units where checked.                                  */
+
+extern void cc_MakeMiscCalculationsForModifications(void);
+   /* make some misc calculations for the Modifications.    */
+   /* Actually : CCM --> Calculate Layer Height.            */
+   /*            CCS --> Calculate Correlation Output Units */
+   /*                    and Groups.                        */
+extern int* ccs_GroupList;
+   /* dynamic Array [0..NoOfOutputUnits]. the Group in which */
+   /* the specified Output-Unit is.                          */
+
+
+/* end   global definition section */
+
+/* begin privat definition section */
+/* end privat definition section */
+
+#endif /* _CC_MODIFY_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_modify.ph snort-2.3.3.new/src/kernel_snns/cc_modify.ph
--- snort-2.3.3/src/kernel_snns/cc_modify.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_modify.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,94 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_modify.ph,v $
+  SHORTNAME      : cc_modify.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : 
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.4 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_MODIFY_DEFINED_
+#define  _CC_MODIFY_DEFINED_
+
+/* begin global definition section */
+
+krui_err  cc_InitModificationVariables(void);
+   /* inits some global Varibales. */
+
+krui_err cc_TestWhetherParametersAreValid(void);
+   /* is the Parameter-Input in the Windows valid ? */
+
+krui_err cc_allocateMemoryForModifications(void);
+   /* allocates Memory needed by some of the Modifications    */
+   /* i.E. ccr_ListOfChosenUnits, ccs_GroupList,ccs_GroupData */
+
+void cc_deallocateMemory(void);
+   /* deallocates the above allocated Memory                              */
+
+double cc_modifyHighScore(struct Unit* SpecialUnitPtr, int s, double old);
+   /* modifies the HighScore according the actual Modification       */
+   /* s is the No (0..Max) of the Special Unit, old is the unchanged */
+   /* HighScore. The calling routine uses the changed HighScore to   */
+   /* determine the best Special Unit.                               */
+
+void cc_actualizeGroupHighscores(double Score,int s,struct Unit* UnitPtr);
+   /* if more then one group is used, this routine actualises the  */
+   /* according datas. Parameters see above.                       */
+
+int cc_calculateNoOfNewUnits(void);
+   /* How much Units do we have to install ? */
+
+struct Unit*  cc_getModifiedBestSpecialUnitPtr(int GroupNo);
+   /* get the best SpecialUnit according to the actual GroupNo */
+
+bool cc_UnitsHaveToBeConnected(int SpecialUnitNo,struct Unit *UnitPtr);
+   /* should the be a connection between the two units ?  */
+
+krui_err cc_calculateConnections(int SpecUnitNo);
+   /* calculate a connection table, if this must be done before */
+   /* all units where checked.                                  */
+
+void cc_MakeMiscCalculationsForModifications(void);
+   /* make some misc calculations for the Modifications.    */
+   /* Actually : CCM --> Calculate Layer Height.            */
+   /*            CCS --> Calculate Correlation Output Units */
+   /*                    and Groups.                        */
+int* ccs_GroupList=NULL;
+   /* dynamic Array [0..NoOfOutputUnits]. the Group in which */
+   /* the specified Output-Unit is.                          */
+
+/* end   global definition section */
+
+/* begin privat definition section */
+
+int ccm_CurrentLayerHeight=0;
+   /* Height of the actual Layer in ccm */
+
+int ccm_MissingUnitsInLayer=0;
+   /* How much Units do we need 'til the layer is full ? */
+
+int cco_ActualLayer;
+   /* the layer of the actual Special Unit in cco */
+
+struct CC_GROUP* ccs_GroupData=NULL;
+   /* dynamic Array [0..NoOfGroups]. Def CC_GROUP --> cc_type.h   */
+   /* the Actual best Unit and the correlated Score of the Group. */
+
+int *ccr_ListOfChosenUnits=NULL;
+   /* dynamic Array [0..CCR_NO_OF_LINKS].                      */
+   /* Used by ccr. CCR_NO_OF_LINKS should be a small constant  */
+   /* entered in the WindowParameters (for example 2,4 or 8).  */      
+
+/* end privat definition section */
+
+#endif /* _CC_MODIFY_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_prune.c snort-2.3.3.new/src/kernel_snns/cc_prune.c
--- snort-2.3.3/src/kernel_snns/cc_prune.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_prune.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,245 @@
+/*****************************************************************************
+  FILE           :  $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_prune.c,v $
+  SHORTNAME      : cc_prune.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Routines of Pruned Cascade Correlation, 
+  NOTES          : 
+
+  AUTHOR         : Christian Wehrfritz
+  DATE           : 
+
+  CHANGED BY     : Juergen Gatter
+# IDENTIFICATION : $State: Exp $ $Locker:  $
+# RCS VERSION    : $Revision: 1.8 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "random.h"
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+#include "kernel.h"      /*  kernel function prototypes  */
+#include "kr_mac.h"      /*  Kernel Macros   */
+
+
+#include "kr_ui.h"
+#include "cc_type.h"
+#include "cc_mac.h"
+#include "cc_glob.h"
+#include "kr_newpattern.h"
+#include "cc_prune.ph"
+
+/*****************************************************************************
+  FUNCTION : float cc_calculatePruneError(int p,int n,float sse)
+
+  PURPOSE  : return the pruning-errror related value
+
+  UPDATE   : 17.11.95 <Juergen Gatter>
+******************************************************************************/
+
+float cc_calculatePruneError(int prune_func,int p,int n,float sse)
+{
+    switch (prune_func){
+      case SBC:
+	return n * log(sse/n) + p*log(n);
+      case AIC:
+	return n* log(sse/n) + p*2;
+      case CMSEP:
+	return sse/(n-2*p);
+      default:
+	return 0.0;
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : float cc_getPruningError(int StartPattern,int EndPattern,bool before)
+
+  PURPOSE  : return the pruning-errror related value
+  NOTES    : mode==0 no printing, mode==1 before installing, mode==2 after.
+
+  UPDATE   : 17.11.95 <Juergen Gatter>
+******************************************************************************/
+
+float cc_getPruningError(int pruneFunc,int StartPattern,int EndPattern,int mode)
+{
+  int p,n;
+  float sse,GeTe;
+
+  p=krui_countLinks();
+  sse = cc_getErr (StartPattern, EndPattern);
+  n=kr_np_pattern( PATTERN_GET_NUMBER, 0, 0 );
+  GeTe = cc_calculatePruneError(pruneFunc,p,n,sse);
+
+  if (mode>0){
+    if (mode==1){
+       printf("Selection criterion is %s\n", cc_pruningFuncArray[pruneFunc]);
+    } 
+    printf("%s %s inserting unit (p=%i): %f\n",
+          cc_pruningFuncArray[pruneFunc],(mode==1)?"before":"after",
+          p,GeTe);
+  }
+  return (GeTe);
+}
+
+/*****************************************************************************
+  FUNCTION : cc_pruneNet
+
+  PURPOSE  : remove nonessential links
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void cc_pruneNet (int StartPattern, int EndPattern, int pruneFunc)
+{
+  struct Unit *unit_ptr, *outputUnit_ptr;
+  struct Link *link_ptr;
+  int n,o, source=0, target=0,p;
+  float tmp, sse, sbc=50000, sbc_ifKilled;
+    
+  /* compute no of params (p), sample size (n), error (sse) and 
+   * the selection criterion 
+   */
+  p=krui_countLinks();
+  sse = cc_getErr (StartPattern, EndPattern);
+  n=kr_np_pattern( PATTERN_GET_NUMBER, 0, 0 );
+
+  sbc=cc_getPruningError(pruneFunc,StartPattern,EndPattern,0);
+
+  unit_ptr=kr_getUnitPtr(LastInsertedHiddenUnit);
+
+  /* before attempting to remove weights, decrement p */
+  p--;
+
+  /* check for useless connections to output units */
+  FOR_ALL_OUTPUT_UNITS(outputUnit_ptr, o) {
+    FOR_ALL_LINKS(outputUnit_ptr,link_ptr) {
+      if (link_ptr->to == unit_ptr) {
+	tmp = link_ptr->weight;
+	link_ptr->weight = 0.0;
+	sse = cc_getErr (StartPattern, EndPattern);
+	link_ptr->weight = tmp;
+        sbc_ifKilled=cc_calculatePruneError(pruneFunc,p,n,sse);
+
+	printf("selection criterion if link %i-->%i gets killed: %f\n",
+	       GET_UNIT_NO(link_ptr->to),GET_UNIT_NO(outputUnit_ptr),
+	       sbc_ifKilled);
+	if (sbc_ifKilled<sbc) {
+	  sbc=sbc_ifKilled;
+	  target= GET_UNIT_NO(outputUnit_ptr);
+	  source= GET_UNIT_NO(link_ptr->to);
+	}
+      }
+    }
+  }
+  /* check for useless connections to input/hidden units */
+  FOR_ALL_LINKS (unit_ptr,link_ptr) {
+    tmp = link_ptr->weight;
+    link_ptr->weight = 0.0;
+    sse = cc_getErr (StartPattern, EndPattern);
+    link_ptr->weight = tmp;
+
+    sbc_ifKilled=cc_calculatePruneError(pruneFunc,p,n,sse);
+
+    printf("selection criterion if link %i-->%i gets killed: %f\n",
+	   GET_UNIT_NO(link_ptr->to),GET_UNIT_NO(unit_ptr),
+	   sbc_ifKilled);
+    if (sbc_ifKilled<sbc) {
+      sbc=sbc_ifKilled;
+      target= GET_UNIT_NO(unit_ptr);
+      source= GET_UNIT_NO(link_ptr->to);
+    }
+  }
+  if (source) {
+    /* remove this links, which is least important; then try again */
+    cc_killLink (source, target);
+    ERROR_CHECK_WRC;
+    cc_pruneNet(StartPattern, EndPattern, pruneFunc);
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_removeUnit
+
+  PURPOSE  : Should remove Unit, does nothing. 
+
+  NOTES    : Parameteruebergabe richten, falls Routine aktiviert wird.
+
+  UPDATE   : 24.11.95 <ausgelagert by Juergen Gatter>
+******************************************************************************/
+
+void cc_remove_Unit(void)
+{
+
+
+      /* remove unit, train output connections and 
+       * return with error to stop learning-process 
+       */
+      /*
+	krui_deleteUnit(LastInsertedHiddenUnit);
+	KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+	ERROR_CHECK;
+	cc_xPS_trainNet(MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE, 
+	MINIMAL_ERROR_CHANGE,
+	OUT_PATIEN,StartPattern,EndPattern,PARAM1,
+	PARAM2,PARAM3,ParameterOutArray,NoOfOutParams); 
+	*/
+      printf("\nNOTE: selection criterion is increasing, the net is becoming too big!\n=====================================================================\n\n");
+}
+
+
+/*****************************************************************************
+  FUNCTION : cc_killLink
+
+  PURPOSE  : delete the link between source and target 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void cc_killLink (int source, int target)
+{
+  struct Unit *unit_ptr;
+
+  /* set pointers and... */
+  KernelErrorCode = kr_setCurrUnit(target);
+  ERROR_CHECK_WRC;
+  krui_isConnected(source);
+  ERROR_CHECK_WRC;
+
+  /* ...kill that beast */
+  KernelErrorCode=krui_deleteLink();
+  if(KernelErrorCode!=KRERR_NO_ERROR) { 
+    printf("\nLink not deleted%i",KernelErrorCode); 
+  } else {
+    printf("link %i ----> %i killed\n",source,target);
+  }
+  KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+  if(KernelErrorCode==KRERR_DEAD_UNITS) { 
+    printf("\nlast link removed, killing Unit !"); 
+    unit_ptr=kr_getUnitPtr(topo_msg.src_error_unit); 
+    KernelErrorCode = kr_removeUnit(unit_ptr);
+    if(KernelErrorCode!=KRERR_NO_ERROR) { 
+      printf("\nSNNS-kernel panic:%i cannot remove unit! aborting",
+	     KernelErrorCode);
+      fflush(stdout);
+      exit (0);
+    }
+    KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+  }  
+}
+
diff -Naur snort-2.3.3/src/kernel_snns/cc_prune.h snort-2.3.3.new/src/kernel_snns/cc_prune.h
--- snort-2.3.3/src/kernel_snns/cc_prune.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_prune.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,31 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_prune.h,v $
+  SHORTNAME      : cc_prune.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : 
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_PRUNE_DEFINED_
+#define  _CC_PRUNE_DEFINED_
+/* begin global definition section */
+float cc_getPruningError
+      (int pruneFunc,int StartPattern,int EndPattern,int mode);
+
+void cc_pruneNet (int StartPattern, int EndPattern, int pruneFunc);
+
+void cc_remove_Unit(void);
+/* end   global definition section */
+
+#endif /* _CC_PRUNE_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_prune.ph snort-2.3.3.new/src/kernel_snns/cc_prune.ph
--- snort-2.3.3/src/kernel_snns/cc_prune.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_prune.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,39 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_prune.ph,v $
+  SHORTNAME      : cc_prune.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : 
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _CC_PRUNE_DEFINED_
+#define  _CC_PRUNE_DEFINED_
+/* begin global definition section */
+float cc_getPruningError
+      (int pruneFunc,int StartPattern,int EndPattern,int mode);
+
+void cc_pruneNet (int StartPattern, int EndPattern, int pruneFunc);
+
+void cc_remove_Unit(void);
+
+/* end   global definition section */
+
+/* begin privat definition section */
+float cc_calculatePruneError(int prune_func,int p,int n,float sse);
+
+void cc_killLink (int source, int target);
+
+/* end privat definition section */
+
+#endif /* _CC_PRUNE_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/cc_type.h snort-2.3.3.new/src/kernel_snns/cc_type.h
--- snort-2.3.3/src/kernel_snns/cc_type.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/cc_type.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,87 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/cc_type.h,v $
+  SHORTNAME      : type.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : type definitions for cascade correlation
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl
+  DATE           : 24.2.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:05 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _CC_TYPE_DEFINED_
+#define _CC_TYPE_DEFINED_
+
+typedef struct CC_DATA {
+  struct {
+    float pixelError;
+    int learningFunc;
+    int modification;
+    int onOff;
+    int pruneOnOff;
+    int backfittOnOff;
+    int backfittPatience;
+    int pruneFunc;
+    float addParameters[5]; 
+    int fastmode;
+  } GLOBAL;
+  struct {
+    double covarianceChange;
+    int    candidatePatience;
+    int    maxNoOfUpdateCycles;
+    int    maxNoOfCandUnits;
+    int    actFunc;
+  } CAND;
+  struct {
+    double errorChange;
+    int    outputPatience;
+    int    maxNoOfUpdateCycles;
+  } OUT;
+} CASCADE_TYPE;
+
+typedef struct CC_LAYER {
+  int xPosFirstRow;
+  int NoOfUnitsInLayer;
+} Layer_Type;
+
+typedef struct CC_GROUP {
+  struct Unit* BestUnitPtr;
+  int Score;
+} CC_Group_Type;
+
+typedef struct TAC_LINK_ERROR {
+  float LnCurrentSlope;
+  float LnPreviousSlope;
+  float LnLastWeightChange;
+} TAC_LINK_ERROR_TYPE;
+
+typedef struct TAC_SPECIAL_UNIT {
+  int   NoOfUnitsInRegion;
+  float SummedErrorInRegion;
+  float ErrorCorrelation;
+  float Window;
+  float* Xi;
+  float* Ri;
+  TAC_LINK_ERROR_TYPE* LinkError;
+} TAC_SPECIAL_UNIT_TYPE;
+
+
+typedef struct TAC_PRIME{
+  float xi_CurrentSlope;
+  float ri_CurrentSlope;
+  float xi_PreviousSlope;
+  float ri_PreviousSlope;
+  float xi_LastChange;
+  float ri_LastChange;
+} TAC_PRIME_TYPE;
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/config.h snort-2.3.3.new/src/kernel_snns/config.h
--- snort-2.3.3/src/kernel_snns/config.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/config.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,107 @@
+/* config.h.  Generated automatically by configure.  */
+/* configuration/config.hin.  Generated automatically from configure.in by autoheader.  */
+
+/* Define if using alloca.c.  */
+/* #undef C_ALLOCA */
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define if you have alloca, as a function or macro.  */
+#define HAVE_ALLOCA 1
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+#define HAVE_ALLOCA_H 1
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+/* #undef size_t */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown
+ */
+/* #undef STACK_DIRECTION */
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS 1
+
+/* Define if you have xgrabsc installed */
+/* #undef HAVE_XGRABSC */
+
+/* Define if you have the getcwd function.  */
+#define HAVE_GETCWD 1
+
+/* Define if you have the lrand48 function.  */
+#define HAVE_LRAND48 1
+
+/* Define if you have the strdup function.  */
+#define HAVE_STRDUP 1
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/file.h> header file.  */
+#define HAVE_SYS_FILE_H 1
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/time.h> header file.  */
+#define HAVE_SYS_TIME_H 1
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the <values.h> header file.  */
+#define HAVE_VALUES_H 1
+
+/* AIX requires this to be the first thing in the file.  */
+/* don't change the indentation !!!! */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# if HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca (int size);
+#   endif
+#  endif
+# endif
+#endif
+
+#include "alloca.h"
+#include "getcwd.h"
+#include "strdup.h"
+#include "lrand48.h"
diff -Naur snort-2.3.3/src/kernel_snns/dlvq_learn.c snort-2.3.3.new/src/kernel_snns/dlvq_learn.c
--- snort-2.3.3/src/kernel_snns/dlvq_learn.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/dlvq_learn.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1111 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/dlvq_learn.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Functions of DLVQ
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl 
+  DATE           : 5.2.93
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:54 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+#include "kernel.h"      /*  kernel function prototypes  */
+#include "kr_ui.h"
+#include "kr_mac.h"      /*  Kernel Macros   */
+
+#include "kr_ui.h"
+#include "cc_mac.h"
+#include "kr_newpattern.h"
+#include "cc_glob.h"
+#include "dlvq_type.h"
+#include "dlvq_learn.ph"
+
+
+/*****************************************************************************
+  FUNCTION : sortHiddenUnitsByClasses
+
+  PURPOSE  : Sorts the hidden units by its class.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void sortHiddenUnitsByClasses(int left, int right)
+{
+    int i,last;
+    struct Unit *temp;
+ 
+    if(left >= right ){
+	return;
+    }
+    temp = FirstHiddenUnitPtr[left]; 
+    FirstHiddenUnitPtr[left] = FirstHiddenUnitPtr[(left+right)/2]; 
+    FirstHiddenUnitPtr[(left+right)/2] = temp;  
+    last = left; 
+    for(i=left+1;i<=right;i++){
+	if(FirstHiddenUnitPtr[i]->bias < FirstHiddenUnitPtr[left]->bias) {
+	    temp = FirstHiddenUnitPtr[++last]; 
+	    FirstHiddenUnitPtr[last]=FirstHiddenUnitPtr[i]; 
+	    FirstHiddenUnitPtr[i]=temp;
+	}
+    }
+    temp = FirstHiddenUnitPtr[left]; 
+    FirstHiddenUnitPtr[left]=FirstHiddenUnitPtr[last]; 
+    FirstHiddenUnitPtr[last] = temp;
+    sortHiddenUnitsByClasses(left,last);
+    sortHiddenUnitsByClasses(last+1,right);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : getNoOfClasses
+
+  PURPOSE  : Looks how many different classes exist and checks whether the 
+             no. of the first class is zero.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err getNoOfClasses(int startPattern, int endPattern)
+{
+    int p,patternClass=0,maxPatternClass=0,minPatternClass=0;
+    int *tmpArray,counter,class;
+    int start, end;
+    int pat, sub_pat;
+    Patterns out_pat;
+
+    KernelErrorCode = kr_initSubPatternOrder(startPattern, endPattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return KernelErrorCode;
+    start = kr_AbsPosOfFirstSubPat(startPattern);
+    end   = kr_AbsPosOfFirstSubPat(endPattern);
+    end  += kr_NoOfSubPatPairs(endPattern) - 1;
+    for(p=start; p<=end;p++){
+
+	kr_getSubPatternByNo(&pat, &sub_pat, p);
+	out_pat = kr_getSubPatData(pat, sub_pat, OUTPUT, NULL);
+
+	patternClass = *out_pat;
+	if(patternClass < minPatternClass){
+	    minPatternClass = patternClass;
+	} 
+	if(patternClass > maxPatternClass){
+	    maxPatternClass = patternClass;
+	} 
+    }
+
+    if(minPatternClass != 0){
+	return(DLVQ_ERROR2); /* There exists a class smaller than 0 */
+    } 
+
+    counter = 0;
+    p = start;
+    tmpArray =  (int *)calloc(maxPatternClass+1,sizeof(int));
+
+    while((counter != (maxPatternClass+1)) && (p <= end)){
+	kr_getSubPatternByNo(&pat, &sub_pat, p++);
+	out_pat = kr_getSubPatData(pat, sub_pat, OUTPUT, NULL);
+	class = *out_pat;
+	if(tmpArray[class] == 0){
+	    counter++;
+	    tmpArray[class] = 1;
+	}
+    }
+    free(tmpArray);
+    
+    if(counter != (maxPatternClass+1)){
+	return(DLVQ_ERROR1); /*  There are empty classes */
+    }
+    noOfClasses = maxPatternClass+1;
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : allocMixupArray
+
+  PURPOSE  : Allocate the storage of the "mixupArray".
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void allocMixupArray(void)
+{
+    int i,j;
+
+    /* free storage */
+    for(i=0;i<oldNoOfClasses;i++) {
+	for(j=0;j<oldNoOfClasses;j++) {
+	    free(mixupArray[i][j].link);
+	}
+    }
+
+    for(i=0;i<oldNoOfClasses;i++) {
+	free(mixupArray[i]);
+    }
+ 
+    if(mixupArray != NULL) {
+	free(mixupArray);
+	mixupArray = NULL;
+    }
+ 
+    /* alloc storage */
+    mixupArray = (struct MIX_UP **)calloc(noOfClasses,sizeof(struct MIX_UP *));
+
+    for(i=0;i<noOfClasses;i++) {
+	mixupArray[i] = 
+	    (struct MIX_UP *)calloc(noOfClasses,sizeof(struct MIX_UP));   
+    }
+
+    for(i=0;i<noOfClasses;i++) {
+	for(j=0;j<noOfClasses;j++) {
+	    mixupArray[i][j].link = 
+  	        (double *)calloc(NoOfInputUnits,sizeof(double));
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : allocLastInsertedUnitArray
+
+  PURPOSE  : Allocate the storage of the array "lastInsertedUnitArray".
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void allocLastInsertedUnitArray(void)
+{
+
+    /* free storage */
+    if(lastInsertedUnitArray != NULL){
+	free(lastInsertedUnitArray);
+	lastInsertedUnitArray = NULL;
+    }
+
+    /* alloc storage */
+    lastInsertedUnitArray = (int *)calloc(noOfClasses,sizeof(int));
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : allocInitialUnitArray
+
+  PURPOSE  : Allocate the storage of the array "initialUnitArray"
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void allocInitialUnitArray(void)
+{
+    int i;
+
+    /* free storage */
+    for(i=0;i<oldNoOfClasses;i++) {
+	free(initialUnitArray[i].link);
+    }
+
+    if(initialUnitArray != NULL) {
+	free(initialUnitArray);
+	initialUnitArray = NULL;
+    }
+ 
+    /* alloc storage */
+    initialUnitArray = 
+	(struct MIX_UP *)calloc(noOfClasses,sizeof(struct MIX_UP));
+
+    for(i=0;i<noOfClasses;i++) {
+	initialUnitArray[i].link = 
+	    (double *)calloc(NoOfInputUnits,sizeof(double));
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : normPatterns
+
+  PURPOSE  : Norm all patterns.
+  NOTES    : This function is of no permanent effect since the manipulation 
+  of  the input pattern takes place on a copy of the original data.
+  Patterns must be normalized before use of DLVQ !!!!!
+  Therefore the body of the function is commented out. The original code is 
+  left in place to demonstrate the necessary operation. (M. Vogt)
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void normPatterns(int startPattern, int endPattern)
+{
+
+/* see NOTES of funtion header */
+
+/*
+    double sum,sqrtSum;
+    Patterns in_pat,in_patStorage;
+    int p,i;
+    int start, end;
+    int pat, sub;
+    int count;
+
+    KernelErrorCode = kr_initSubPatternOrder(startPattern,endPattern);
+    start = kr_AbsPosOfFirstSubPat(startPattern);
+    end   = kr_AbsPosOfFirstSubPat(endPattern);
+    end  += kr_NoOfSubPatPairs(endPattern) - 1;
+    for(p=start; p<=end;p++){
+
+	kr_getSubPatternByNo(&pat,&sub,p);
+	in_pat = kr_getSubPatData(pat,sub,INPUT,&count);
+	sum = 0.0;  
+	in_patStorage = in_pat;  
+
+	for(i=0;i<count;i++){   
+	    sum += (*in_pat) * (*in_pat);
+	    in_pat++;
+	}
+	sqrtSum = sqrt(sum);
+	in_pat = in_patStorage;
+
+	for(i=0;i<count;i++){   
+	    *in_pat = *in_pat / sqrtSum;
+	    in_pat++;
+	}
+    }
+*/
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : normReferenceVec
+
+  PURPOSE  :
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void normReferenceVec(struct Unit *hiddenUnitPtr)
+{
+    double sum,sqrtSum;
+    struct Link *linkPtr;
+
+    sum = 0.0;
+    FOR_ALL_LINKS(hiddenUnitPtr,linkPtr) {
+	sum += linkPtr->weight * linkPtr->weight;
+    }
+
+    sqrtSum = sqrt(sum);
+
+    FOR_ALL_LINKS(hiddenUnitPtr,linkPtr){
+	if(sqrtSum > 0)
+	    linkPtr->weight = linkPtr->weight / sqrtSum;
+	else
+	    /* Special case */
+	    linkPtr->weight = 0.0;
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : moveVec
+
+  PURPOSE  : Train the vectors.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void moveVec(struct Unit *correctReferenceVec, float learnParam1,
+                    struct Unit *wrongReferenceVec,   float learnParam2)
+{
+    struct Link *linkPtr;
+
+    FOR_ALL_LINKS(correctReferenceVec,linkPtr){
+	linkPtr->weight += learnParam1 * (linkPtr->to->act - linkPtr->weight);
+    }
+    normReferenceVec(correctReferenceVec);
+
+    FOR_ALL_LINKS(wrongReferenceVec,linkPtr){
+	linkPtr->weight -= learnParam2 * (linkPtr->to->act - linkPtr->weight);
+    }
+    normReferenceVec(wrongReferenceVec);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : 
+
+  PURPOSE  :
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void writeVectorToMixupArray(int correctClass, int wrongClass, 
+				    int patternNo, int sub_pat_no)
+{
+    Patterns in_pat;
+    double *link=NULL;
+    int i,count;
+ 
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(patternNo,sub_pat_no,INPUT,&count);
+    link = mixupArray[correctClass][wrongClass].link; 
+
+    for(i=0;i<count;i++){
+	link[i] = (double)in_pat[i];
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : initInitialUnitArray
+
+  PURPOSE  : Init the array "initialUnitArray".
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void initInitialUnitArray(int startPattern, int endPattern)
+{
+    int p,i,j;
+    Patterns in_pat;
+    Patterns out_pat;
+    int start, end;
+    int pat, sub;
+    int count;
+
+    KernelErrorCode = kr_initSubPatternOrder(startPattern,endPattern);
+    start = kr_AbsPosOfFirstSubPat(startPattern);
+    end   = kr_AbsPosOfFirstSubPat(endPattern);
+    end  += kr_NoOfSubPatPairs(endPattern) - 1;
+    for(p=start; p<=end;p++){
+	kr_getSubPatternByNo(&pat,&sub,p);
+	in_pat = kr_getSubPatData(pat,sub,INPUT,&count);
+	out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+	for(i=0;i<count;i++){
+	    (initialUnitArray[(int) *out_pat].link)[i] = *in_pat++;
+	    initialUnitArray[(int) *out_pat].counter++;
+	}
+    }
+    for(i=0;i<noOfClasses;i++){
+	for(j=0;j<count;j++){
+	    (initialUnitArray[i].link)[j] /= initialUnitArray[i].counter;
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : initFirstUnit
+
+  PURPOSE  : Init the links of a class unit. Remember: At the beginning of
+             the learning there exist no hidden units. The first step of 
+             the algorithm inserts for every class a hidden unit. This
+             functions inits the links of this first units. The array
+             "initialUnitArray" contains for every class the average
+             activation over all patterns.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void initFirstUnit(struct Unit *hiddenUnitPtr, int class)
+{
+    int i;
+    struct Link *linkPtr;
+    struct Unit *inputUnitPtr;
+
+    i = 0;
+    FOR_ALL_UNITS(inputUnitPtr){
+	if(IS_INPUT_UNIT(inputUnitPtr) && UNIT_IN_USE(inputUnitPtr)){
+	    inputUnitPtr->act = (initialUnitArray[class].link)[i++];
+	}
+    }
+
+    hiddenUnitPtr->bias = class;
+    FOR_ALL_LINKS(hiddenUnitPtr,linkPtr) {
+	linkPtr->weight = linkPtr->to->act;
+    }
+    normReferenceVec(hiddenUnitPtr);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : deleteAllLinksOfTheOutputUnit
+
+  PURPOSE  : 
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static krui_err deleteAllLinksOfTheOutputUnit(void)
+{
+    KernelErrorCode = krui_setCurrentUnit(GET_UNIT_NO(*FirstOutputUnitPtr));
+    ERROR_CHECK;
+
+    krui_deleteAllInputLinks();
+    krui_deleteAllOutputLinks();
+
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : calculateUnitXYPos
+
+  PURPOSE  : Calculates the position of the current input, hidden and output
+             layer.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void calculateUnitXYPos(void)
+{
+    int xPos,yPos,maxXPos=0,maxYPos,minXPos=0,minYPos=0,i,
+        xOffset,yOffset,bias,h;
+    struct Unit *inputUnitPtr=NULL,*hiddenUnitPtr;
+
+    inputUnitPtr = *FirstInputUnitPtr;
+    maxXPos = minXPos = GET_UNIT_XPOS(inputUnitPtr);
+    maxYPos = minYPos = GET_UNIT_YPOS(inputUnitPtr); 
+
+    /* find maxXPos ... of the input layer */
+    FOR_ALL_INPUT_UNITS(inputUnitPtr,i) {
+	xPos = GET_UNIT_XPOS(inputUnitPtr);
+	yPos = GET_UNIT_YPOS(inputUnitPtr);
+	if(xPos > maxXPos) {
+	    maxXPos = xPos;
+	}
+	if(xPos < minXPos){
+	    minXPos = xPos;
+	}
+	if(yPos > maxYPos) {
+	    maxYPos = yPos;
+	}
+	if(yPos < minYPos){
+	    minYPos = yPos;
+	}
+    }
+
+    xOffset = minXPos - 2;
+    yOffset = minYPos - 2;
+
+    FOR_ALL_INPUT_UNITS(inputUnitPtr,i){
+	SET_UNIT_XPOS(inputUnitPtr,GET_UNIT_XPOS(inputUnitPtr) - xOffset);
+	SET_UNIT_YPOS(inputUnitPtr,GET_UNIT_YPOS(inputUnitPtr) - yOffset);
+    }
+
+    bias = (*FirstHiddenUnitPtr)->bias; 
+    xPos = (maxXPos - xOffset + 3);
+    yPos = 1;
+ 
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,h){
+	if(bias == hiddenUnitPtr->bias){
+	    yPos++;
+	}else{
+	    xPos++;
+	    bias = hiddenUnitPtr->bias;
+	    yPos = 2;
+	}
+	SET_UNIT_XPOS(hiddenUnitPtr,xPos);
+	SET_UNIT_YPOS(hiddenUnitPtr,yPos);
+    }   
+
+    SET_UNIT_XPOS(*FirstOutputUnitPtr,xPos+3);
+    SET_UNIT_YPOS(*FirstOutputUnitPtr,2);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : insertNewUnits
+
+  PURPOSE  : Inserts new hidden units to the net. The weights of the links
+             are stored in the "mixupArray". 
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static krui_err insertNewUnits(void)
+{
+    int i,j,k,maxCount,maxJ=0,newUnit;
+    double sum,sqrtSum,weight;
+    struct Unit *newUnitPtr,*inputUnitPtr;
+    struct Link *linkPtr;
+
+    for(i=0;i<noOfClasses;i++) {
+	maxCount = 0;
+	for(j=0;j<noOfClasses;j++){
+	    if(mixupArray[i][j].counter > maxCount) {
+		maxCount = mixupArray[i][j].counter;
+		maxJ = j;
+	    }     
+	}
+	if(maxCount != 0){
+
+	    /* Generate new unit */
+	    newUnit = 
+		KernelErrorCode = 
+		    krui_copyUnit(lastInsertedUnitArray[i],INPUTS_AND_OUTPUTS);
+	    if(KernelErrorCode < 0){
+		ERROR_CHECK;
+	    }
+	    KernelErrorCode = KRERR_NO_ERROR; 
+	    newUnitPtr = kr_getUnitPtr(lastInsertedUnitArray[i] = newUnit);
+	    newUnitPtr->unit_pos.y += 1;     
+   
+	    /*init new unit */
+	    sum = 0.0;
+	    k = 0;
+	    FOR_ALL_UNITS(inputUnitPtr){
+		if(IS_INPUT_UNIT(inputUnitPtr) && UNIT_IN_USE(inputUnitPtr)) {
+		    weight = 
+			inputUnitPtr->act = 
+			    ((mixupArray[i][maxJ].link)[k++] /
+			     mixupArray[i][maxJ].counter);     
+		    sum += weight * weight;
+		}
+	    }
+	    sqrtSum = sqrt(sum);
+
+	    FOR_ALL_LINKS(newUnitPtr,linkPtr) {
+		linkPtr->weight = linkPtr->to->act / sqrtSum;
+	    }
+	}
+    }
+
+    initMixupArray();
+ 
+    return(KRERR_NO_ERROR);
+} 
+
+
+
+/*****************************************************************************
+  FUNCTION : initMixupArray
+
+  PURPOSE  : Init the array "mixupArray".
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void initMixupArray(void)
+{
+    int i,j,sizeOfInputVector;
+    
+    sizeOfInputVector = sizeof(double) * NoOfInputUnits;
+
+    for(i=0;i<noOfClasses;i++) {
+	for(j=0;j<noOfClasses;j++){
+	    if(mixupArray[i][j].counter != 0){
+		(void)memset(mixupArray[i][j].link,0,sizeOfInputVector);
+		mixupArray[i][j].counter = 0;
+	    }
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION :  printMixupArray
+
+  PURPOSE  :
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void printMixupArray(int cycle)
+{
+    int i,j;
+
+    printf("Cycle %d \n",cycle+1);
+    printf("Total number of incorrectly classified items: %d \n",
+	   wrongClassCounter);
+    printf("Array of classified items:\n\n");
+
+    for(i=0;i<noOfClasses;i++) {
+	for(j=0;j<noOfClasses;j++){
+	    printf("%d ",mixupArray[i][j].counter);
+	}
+	printf("\n");
+    }
+    printf("\n\n");
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : dlvq_trainNet
+
+  PURPOSE  :
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void dlvq_trainNet(int noOfTrainingCycles, int startPattern,
+			  int endPattern, float learnParam1, float learnParam2)
+{
+    struct Unit *correctMaxActivatedUnitPtr=NULL,
+    *wrongMaxActivatedUnitPtr=NULL,
+    *inputUnitPtr,
+    *hiddenUnitPtr;
+    double correctMaxAct,wrongMaxAct,act;
+    Patterns in_pat;
+    Patterns out_pat;
+    int i,h,p,j,noOfTrainingCyclesMinus1=noOfTrainingCycles-1;
+    struct Link *linkPtr;
+    int start, end;
+    int pat, sub;
+ 
+    for(j=0;j<noOfTrainingCycles;j++){
+
+	KernelErrorCode = kr_initSubPatternOrder(startPattern,endPattern);
+	start = kr_AbsPosOfFirstSubPat(startPattern);
+	end   = kr_AbsPosOfFirstSubPat(endPattern);
+	end  += kr_NoOfSubPatPairs(endPattern) - 1;
+	for(p=start; p<=end;p++){
+
+	    kr_getSubPatternByNo(&pat,&sub,p);
+	    in_pat = kr_getSubPatData(pat,sub,INPUT,NULL);
+	    out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+
+	    FOR_ALL_INPUT_UNITS(inputUnitPtr,i){
+		inputUnitPtr->Out.output = inputUnitPtr->act = *in_pat++;
+	    }
+  
+	    correctMaxAct = -1e9;
+	    wrongMaxAct   = -1e9;
+	    correctMaxActivatedUnitPtr = NULL;
+	    wrongMaxActivatedUnitPtr = NULL;
+	    
+	    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,h) {
+		act = 0.0;
+		FOR_ALL_LINKS(hiddenUnitPtr,linkPtr) {
+		    act += linkPtr->weight * linkPtr->to->act;
+		}
+		hiddenUnitPtr->act = act;
+
+		if((((int)hiddenUnitPtr->bias) == ((int) *out_pat)) && 
+		   (act >= correctMaxAct)){
+		    correctMaxAct = act;
+		    correctMaxActivatedUnitPtr = hiddenUnitPtr;
+		}
+		else if((((int)hiddenUnitPtr->bias)!=((int) *out_pat)) && 
+			(act >= wrongMaxAct)){
+		    wrongMaxAct = act;
+		    wrongMaxActivatedUnitPtr = hiddenUnitPtr;
+		}
+	    }
+	    if(correctMaxAct <= wrongMaxAct){
+		wrongClassCounter++;
+		mixupArray[(int) *out_pat]
+		          [(int)wrongMaxActivatedUnitPtr->bias].counter++;
+		if(j == noOfTrainingCyclesMinus1){
+		    writeVectorToMixupArray(
+				       (int)correctMaxActivatedUnitPtr->bias,
+				       (int)wrongMaxActivatedUnitPtr->bias,
+				       pat,sub);
+		}else{ 
+		    moveVec(correctMaxActivatedUnitPtr,learnParam1,
+			    wrongMaxActivatedUnitPtr,learnParam2);
+		}
+	    }
+	} /* end: noOfTrainingCycles */
+	printMixupArray(j);  
+
+	if(wrongClassCounter == 0){
+	    continueLearning = 0;
+	    return;
+	}
+
+	if(j!=noOfTrainingCyclesMinus1){ 
+	    initMixupArray();  
+	    wrongClassCounter = 0;   
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : initLastInsertedUnitArray
+
+  PURPOSE  : Init the array lastInsertedUnitArray. This array contains the
+             position of the last inserted unit. There is an entry for
+             every class.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void initLastInsertedUnitArray(void)
+{
+    int h,bias;
+    struct Unit *hiddenUnitPtr=NULL,*lastUnitPtr=NULL;
+
+    bias = (*FirstHiddenUnitPtr)->bias;
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,h){
+	if(((int)(hiddenUnitPtr->bias)) == ((int)bias)) {
+	    lastUnitPtr = hiddenUnitPtr;
+	}else{
+	    lastInsertedUnitArray[(int)lastUnitPtr->bias] =
+		GET_UNIT_NO(lastUnitPtr);
+	    bias = hiddenUnitPtr->bias;
+	    lastUnitPtr = hiddenUnitPtr;
+	}
+    }
+    lastInsertedUnitArray[(int)lastUnitPtr->bias]=GET_UNIT_NO(lastUnitPtr);
+
+}  
+
+
+
+/*****************************************************************************
+  FUNCTION : dlvq_setPointers
+
+  PURPOSE  : Calculates the beginning of the input, hidden, output
+             units in the topo_ptr_array.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err dlvq_setPointers(void)
+{
+    FirstInputUnitPtr   = (struct Unit **)(&topo_ptr_array[1]);
+    if(*(FirstInputUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    FirstHiddenUnitPtr  = FirstInputUnitPtr  + NoOfInputUnits  + 1;
+    if(*(FirstHiddenUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    FirstOutputUnitPtr  = FirstHiddenUnitPtr + NoOfHiddenUnits + 1;
+    if(*(FirstOutputUnitPtr-1)!=NULL) CC_ERROR(KRERR_CC_ERROR1);
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : generateMissingClassHiddenUnits
+
+  PURPOSE  : If all hidden units of a class are removed, this functions 
+             generates a new first hidden unit. 
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void generateMissingClassHiddenUnits(int *generatedNewUnit)
+{
+    struct Unit *hiddenUnitPtr;
+    int i,h;
+
+    *generatedNewUnit = 0;
+
+    for(i=0;i<noOfClasses;i++){
+	lastInsertedUnitArray[i] = 0;
+    }
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,h){
+	lastInsertedUnitArray[(int)hiddenUnitPtr->bias] = 1;
+    }
+    for(i=0;i<noOfClasses;i++){
+	if(lastInsertedUnitArray[i] == 0) {
+	    (void)insertFirstUnit(&hiddenUnitPtr);
+	    initFirstUnit(hiddenUnitPtr,i);
+	    *generatedNewUnit = 1;
+	}else{
+	    lastInsertedUnitArray[i] = 0;
+	} 
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : insertFirstUnit
+
+  PURPOSE  : Inserts the first hidden units to the net. For every class one
+             unit.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static krui_err insertFirstUnit(struct Unit **hiddenUnitPtr)
+{
+    int hiddenUnit=0;
+    struct Unit *inputUnitPtr;
+
+    hiddenUnit = KernelErrorCode = krui_createDefaultUnit(); 
+    if(KernelErrorCode < 0) {
+	ERROR_CHECK;
+    }
+
+    KernelErrorCode = krui_setUnitTType(hiddenUnit,HIDDEN);  
+    ERROR_CHECK;
+
+    KernelErrorCode = krui_setUnitActFunc(hiddenUnit,"Act_Identity");
+    ERROR_CHECK;
+
+    *hiddenUnitPtr = kr_getUnitPtr(hiddenUnit);
+    KernelErrorCode = krui_setCurrentUnit(hiddenUnit);
+    ERROR_CHECK;
+
+    /* generate links between hidden unit and input units */
+    FOR_ALL_UNITS(inputUnitPtr) {
+	if(IS_INPUT_UNIT(inputUnitPtr) && UNIT_IN_USE(inputUnitPtr)){
+	    KernelErrorCode = krui_createLink(GET_UNIT_NO(inputUnitPtr),0.0);
+	    ERROR_CHECK;
+	}
+    }
+
+    /* generate a link between the output unit and the hidden unit */
+    KernelErrorCode = krui_setCurrentUnit(GET_UNIT_NO(*FirstOutputUnitPtr));
+    ERROR_CHECK;
+    KernelErrorCode = krui_createLink(hiddenUnit,1.0); 
+    ERROR_CHECK;
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : allocArrays
+
+  PURPOSE  :
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void allocArrays(void)
+{
+    allocMixupArray();
+    allocLastInsertedUnitArray();
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : generateTmpTopoPtrArray
+
+  PURPOSE  : Generates a topo_ptr_array for local use.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void generateTmpTopoPtrArray(void)
+{
+    struct Unit *unitPtr;
+    TopoPtrArray tmp_array;
+
+    if(topo_ptr_array != NULL) {
+	free(topo_ptr_array);
+    }
+
+    tmp_array = 
+	topo_ptr_array = 
+	    (struct Unit **)calloc(NoOfInputUnits+5,sizeof(struct Unit *));
+
+    *tmp_array = NULL;
+    tmp_array++;
+    FOR_ALL_UNITS(unitPtr){
+	if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+	    *tmp_array = unitPtr;
+	    tmp_array++;
+	}
+    }
+    *tmp_array = NULL;
+    tmp_array++;
+    *tmp_array = NULL;
+    tmp_array++;
+    FOR_ALL_UNITS(unitPtr){
+	if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)){
+	    *tmp_array = unitPtr;
+	    tmp_array++;
+	}
+    }
+    *tmp_array = NULL;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : freeTmpTopoPtrArray
+
+  PURPOSE  : Frees the storage of the temporary "topo_ptr_array".
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+static void freeTmpTopoPtrArray(void)
+{
+    free(topo_ptr_array);
+    topo_ptr_array = NULL;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_DLVQ
+
+  PURPOSE  : The main learn routine of DLVQ
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err LEARN_DLVQ(int startPattern, int endPattern, float *ParameterInArray,
+		    int NoOfInParams, float **ParameterOutArray, 
+		    int *NoOfOutParams)
+{
+    static int cycleCounter=0,noOfTrainingCycles=0;
+    struct Unit  *unitPtr,*hiddenUnitPtr;
+    int i,d1,d2,d3,noOfLinks,generatedNewUnit;
+    static float learnParam1=0.03,learnParam2=0.03;
+    static float OutParameter[1];
+
+    *NoOfOutParams = 1;
+    *ParameterOutArray = OutParameter;
+
+    if(cc_allButtonIsPressed) {
+	continueLearning = 1;
+	cycleCounter = 0;
+	wrongClassCounter = 0;
+	NoOfInputUnits = NoOfHiddenUnits = NoOfOutputUnits = 0;
+	FOR_ALL_UNITS(unitPtr) {
+	    if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfInputUnits++;
+	    }
+	    if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfHiddenUnits++;
+	    }
+	    if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfOutputUnits++;
+	    }
+	}
+	if(NoOfOutputUnits != 1){
+	    return(DLVQ_ERROR3); /* Wrong no. of output units */
+	}
+
+	learnParam1 = ParameterInArray[0];
+	learnParam2 = ParameterInArray[1];
+	noOfTrainingCycles = (int)ParameterInArray[2];
+	dlvq_numberOfLearnCycles = (int)ParameterInArray[3];
+    }
+  
+
+    if(newPatternsLoaded){
+	newPatternsLoaded = 0;
+	KernelErrorCode = getNoOfClasses(startPattern,endPattern);
+	ERROR_CHECK;
+	normPatterns(startPattern,endPattern);
+	allocInitialUnitArray();
+	initInitialUnitArray(startPattern,endPattern);
+    }
+
+    if(cc_allButtonIsPressed && (NoOfHiddenUnits == 0)){ /* First time */
+	allocArrays();
+	generateTmpTopoPtrArray();
+	KernelErrorCode = dlvq_setPointers();
+	ERROR_CHECK;
+	KernelErrorCode = deleteAllLinksOfTheOutputUnit();
+	ERROR_CHECK;
+	for(i=0;i<noOfClasses;i++) {
+	    KernelErrorCode = insertFirstUnit(&hiddenUnitPtr);
+	    ERROR_CHECK;
+	    initFirstUnit(hiddenUnitPtr,i);
+	}
+	freeTmpTopoPtrArray();
+	KernelErrorCode = kr_topoSort(TOPOLOGICAL_FF);
+	ERROR_CHECK;     
+	KernelErrorCode = dlvq_setPointers();
+	ERROR_CHECK; 
+
+	sortHiddenUnitsByClasses(0,noOfClasses-1);
+	calculateUnitXYPos();    
+	initLastInsertedUnitArray();
+
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }else if(cc_allButtonIsPressed && (NoOfHiddenUnits != 0)) { 
+
+	/* Continue learning */
+	if(NetModified || LearnFuncHasChanged){
+	    allocArrays();
+	    KernelErrorCode = kr_topoSort(TOPOLOGICAL_FF);
+	    ERROR_CHECK;    
+	    KernelErrorCode = dlvq_setPointers();
+	    ERROR_CHECK; 
+	    krui_getNetInfo(&d1,&noOfLinks,&d2,&d3);
+	    if(noOfLinks != NoOfInputUnits*NoOfHiddenUnits + NoOfHiddenUnits){
+		return(DLVQ_ERROR4); /* the network has a wrong topology */
+	    }
+
+	    generateMissingClassHiddenUnits(&generatedNewUnit);
+	    if(generatedNewUnit) {
+		KernelErrorCode = kr_topoSort(TOPOLOGICAL_FF);
+		ERROR_CHECK;
+		KernelErrorCode = dlvq_setPointers();
+		ERROR_CHECK; 
+	    }
+	    NetModified = FALSE;
+	    LearnFuncHasChanged = FALSE;
+	}
+      
+	/* even if the net is not modified you have to do the following
+	   steps for security. 
+	   */  
+	sortHiddenUnitsByClasses(0,NoOfHiddenUnits-1);
+	calculateUnitXYPos();         
+	initLastInsertedUnitArray();
+    }  
+
+    if(cc_allButtonIsPressed){
+	oldNoOfClasses = noOfClasses;
+	cc_allButtonIsPressed = 0;
+    }
+
+    if(continueLearning){
+	initMixupArray();
+	dlvq_trainNet(noOfTrainingCycles,startPattern,endPattern,
+		      learnParam1,learnParam2);
+	NET_ERROR(OutParameter) = wrongClassCounter;
+	if((cycleCounter<(dlvq_numberOfLearnCycles-1)) &&
+	   (wrongClassCounter != 0)){ 
+	    /*do not insert new hidden units by the last path through the net*/
+	    wrongClassCounter = 0;
+	    cycleCounter++; 
+	    KernelErrorCode = insertNewUnits();
+	    ERROR_CHECK;
+	    KernelErrorCode = kr_topoSort(TOPOLOGICAL_FF);
+	    ERROR_CHECK;
+	    KernelErrorCode = dlvq_setPointers();
+	    ERROR_CHECK; 
+	}
+    } 
+    return(KRERR_NO_ERROR);
+}
+
+
diff -Naur snort-2.3.3/src/kernel_snns/dlvq_learn.h snort-2.3.3.new/src/kernel_snns/dlvq_learn.h
--- snort-2.3.3/src/kernel_snns/dlvq_learn.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/dlvq_learn.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,38 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/dlvq_learn.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl 
+  DATE           : 5.2.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:07 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+/* begin global definition section */
+
+extern krui_err getNoOfClasses(int startPattern, int endPattern);
+extern krui_err LEARN_DLVQ(int startPattern, int endPattern, float *ParameterInArray,
+                   int NoOfInParams, float **ParameterOutArray, int *NoOfOutParams);
+extern void normPatterns(int startPattern, int endPattern);
+extern void allocInitialUnitArray(void);
+extern void initInitialUnitArray(int startPattern, int endPattern);
+extern void allocArrays(void);
+extern krui_err dlvq_setPointers(void);
+extern void generateMissingClassHiddenUnits(int *generatedNewUnit);
+
+extern int newPatternsLoaded;
+extern int dlvq_numberOfLearnCycles;
+/* end global definition section */
+
+/* begin privat definition section */
+/* end privat definition section */
diff -Naur snort-2.3.3/src/kernel_snns/dlvq_learn.ph snort-2.3.3.new/src/kernel_snns/dlvq_learn.ph
--- snort-2.3.3/src/kernel_snns/dlvq_learn.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/dlvq_learn.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,91 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/dlvq_learn.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl 
+  DATE           : 5.2.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:08 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+/* begin global definition section */
+
+krui_err getNoOfClasses(int startPattern, int endPattern);
+
+krui_err LEARN_DLVQ(int startPattern, int endPattern, float *ParameterInArray,
+		    int NoOfInParams, float **ParameterOutArray, 
+		    int *NoOfOutParams);
+
+void normPatterns(int startPattern, int endPattern);
+
+void allocInitialUnitArray(void);
+
+void initInitialUnitArray(int startPattern, int endPattern);
+
+void allocArrays(void);
+
+krui_err dlvq_setPointers(void);
+
+void generateMissingClassHiddenUnits(int *generatedNewUnit);
+
+int newPatternsLoaded = 0;
+int dlvq_numberOfLearnCycles=0;
+
+/* end global definition section */
+
+/* begin privat definition section */
+
+static struct MIX_UP  **mixupArray;
+static struct MIX_UP  *initialUnitArray;
+static int *lastInsertedUnitArray;
+
+static int noOfClasses=0;
+static int oldNoOfClasses=0;
+static int wrongClassCounter=0;
+static int continueLearning=0;
+
+static void printMixupArray(int cycle);
+
+static void allocMixupArray(void);
+
+static void allocLastInsertedUnitArray(void);
+
+static void normReferenceVec(struct Unit *hiddenUnitPtr);
+
+static void moveVec(struct Unit *correctReferenceVec, float learnParam1,
+                     struct Unit *wrongReferenceVec,  float learnParam2);
+
+static void writeVectorToMixupArray(int correctClass, int wrongClass, 
+				    int patternNo, int sub_pat_no);
+
+static void initFirstUnit(struct Unit *hiddenUnitPtr, int class);
+
+static krui_err insertFirstUnit(struct Unit **hiddenUnitPtr);
+
+static krui_err insertNewUnits(void);
+
+static void initMixupArray(void);
+
+static void dlvq_trainNet(int noOfTrainingCycles, int startPattern, 
+			  int endPattern, float learnParam1, 
+			  float learnParam2);
+
+static void generateTmpTopoPtrArray(void);
+
+static void calculateUnitXYPos(void);
+
+static void initLastInsertedUnitArray(void);
+
+static void sortHiddenUnitsByClasses(int left, int right);
+
+/* begin privat definition section */
diff -Naur snort-2.3.3/src/kernel_snns/dlvq_type.h snort-2.3.3.new/src/kernel_snns/dlvq_type.h
--- snort-2.3.3/src/kernel_snns/dlvq_type.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/dlvq_type.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,27 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/dlvq_type.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Michael Schmalzl 
+  DATE           : 5.2.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:09 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+typedef struct MIX_UP {
+           int counter;
+           double *link;
+   } MIX_UP_TYPE;
+
+typedef int UNIT_NO;
+
diff -Naur snort-2.3.3/src/kernel_snns/enzo_mem_typ.h snort-2.3.3.new/src/kernel_snns/enzo_mem_typ.h
--- snort-2.3.3/src/kernel_snns/enzo_mem_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/enzo_mem_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,112 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/enzo_mem_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : declaration of all Enzo related variables
+  NOTES          :
+ 
+  AUTHOR         : Thomas Ragg
+  DATE           : 12.11.95
+ 
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:10 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _ENZO_MEM_TYP_H
+#define _ENZO_MEM_TYP_H
+
+typedef struct
+{
+    /* ---------------------------------------------------------------------- */
+    /*                                                                        */
+    /*   These are all the variables you need to describe the internal        */
+    /*   state of an SNNS-net in memory.                                      */
+    /*                                                                        */
+    /*   Note that this is HIGHLY dependend on the version of SNNS!           */
+    /*   Manipulate the net only via the krui-functions!                      */
+    /*   Do NOT use this structure for anything but                           */
+    /*   krm_get_net() and krm_put_net() ...                                  */
+    /*                                                                        */
+    /* ---------------------------------------------------------------------- */
+    
+    int       NoOfLinks;
+    int       NoOfAllocLinks;
+    LinkArray link_array;
+    LinkArray link_block_list;
+    LinkArray free_link_ptr;
+    
+    int       NoOfSites;
+    int       NoOfNetSites;
+    int       NoOfAllocSites;
+    SiteArray site_array;
+    SiteArray site_block_list;
+    SiteArray free_site_ptr;
+
+    int       NoOfAllocUnits;
+    int       FreeUnitIndex;
+    int       NoOfUnits;
+    int       NoOfInputUnits;
+    int       NoOfOutputUnits;
+    int       NoOfHiddenUnits;
+    int       MaxUnitNo;
+    int       MinUnitNo;
+    UnitArray unit_array;
+
+    TopoPtrArray topo_ptr_array;
+    
+    int         NoOfNTableEntries;
+    int         NoOfAllocNTableEntries;
+    NTableArray NTable_array;
+    NTableArray NTable_block_list;
+    NTableArray free_NTable_entry;
+    NTableArray curr_NTable_entry;
+    NTableArray curr_NTable_block;
+    
+    int         NoOfSTableEntries;
+    int         NoOfAllocSTableEntries;
+    STableArray STable_array;
+    STableArray STable_block_list;
+    STableArray free_STable_entry;
+    STableArray curr_STable_entry;
+    STableArray curr_STable_block;
+    
+    
+    struct FtypeUnitStruct  *Ftype_list_root;
+    struct FtypeUnitStruct  *curr_Ftype_entry;
+    int                      NoOfFTableEntries;
+
+    char update_func[FUNCTION_NAME_MAX_LEN],
+         learn_func [FUNCTION_NAME_MAX_LEN],
+         init_func  [FUNCTION_NAME_MAX_LEN];
+    
+    FlintType u_act, u_bias;
+    int u_ttflags, u_subnet_no, u_layer_no;
+    char u_act_func[FUNCTION_NAME_MAX_LEN],
+         u_out_func[FUNCTION_NAME_MAX_LEN];
+
+    bool NetModified, NetInitialize, LearnFuncHasChanged;
+    struct Unit *unitPtr;
+    struct Site *sitePtr, *prevSitePtr;
+    struct Link *linkPtr, *prevLinkPtr;
+    int unitNo;
+    int specialNetworkType;
+
+    int TopoSortID;
+    int no_of_topo_units;
+    /* global_topo_ptr seems to be unproblematic; its only used inside
+       the topol. sorting functions */
+    
+} memNet;
+
+
+typedef struct
+{
+    int      number;
+} memPat;
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/ext_typ.h snort-2.3.3.new/src/kernel_snns/ext_typ.h
--- snort-2.3.3/src/kernel_snns/ext_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/ext_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,162 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/ext_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS MasPar Kernel: Datatypes and Constants for Internal Usage
+  NOTES          :
+
+  AUTHOR         : Niels Mache 
+  DATE           : 01.01.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:11 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef  KR_EXTERNAL_TYPES
+#define  KR_EXTERNAL_TYPES
+
+
+typedef  void	(* FunctionPtr) (void *,...);
+typedef  krui_err  (* NetFunctionPtr) (void *,...);
+
+
+struct  UnitValues  {
+  unsigned short  selector;
+  int  lun, lln;
+  FlintType  out, act, i_act, bias;
+};
+
+struct UnitDescriptor  {
+  int  srcUnitLLN,
+       destUnitLLN,
+       srcUnitLUN,
+       destUnitLUN;
+};
+
+
+struct NetFuncParameters  {
+  int  start_pattern_no,
+       end_pattern_no,
+       cycles,
+       
+       no_of_input_parameters,
+       no_of_output_parameters;
+
+  float  input_parameters[NO_OF_LEARN_PARAMS],
+         output_parameters[NO_OF_LEARN_PARAMS];
+
+  FunctionPtr  function;              /*  pointer to the function  */
+};
+
+
+
+
+
+/*#################################################
+
+GROUP: Type Definition of Function Table
+
+#################################################*/
+
+/*  Function table structure
+*/
+struct  FuncTable  {
+  char    *func_name;                 /*  name of the function  */
+  unsigned short  func_type,          /*  type of the function  */
+           no_of_input_parameters,    /*  no. of input parameters used by this function  */
+                                      /*  (only for Update, Init and Learning functions)  */
+           no_of_output_parameters;   /*  no. of ouput parameters returned by this function  */
+                                      /*  (only for Update and Learning functions)  */
+  FunctionPtr  function;              /*  pointer to the function  */
+#ifdef PARAGON_KERNEL
+  bool     parallelized;	      /*  learning function parallelized for */ 
+				      /*  the Intel Paragon service process  */
+#endif
+};
+
+
+
+#define  FUNCTION_NAME_MAX_LEN   100
+
+struct FuncInfoDescriptor  {
+  int      number;
+  char     func_name[FUNCTION_NAME_MAX_LEN];   /*  name of the function  */
+  unsigned short    
+           func_type,                 /*  type of the function  */
+           no_of_input_parameters,    /*  no. of input parameters used by this function  */
+                                      /*  (only for Update, Init and Learning functions)  */
+           no_of_output_parameters;   /*  no. of ouput parameters returned by this function  */
+                                      /*  (only for Update and Learning functions)  */
+  FunctionPtr  function;              /*  pointer to the function  */
+#ifdef PARAGON_KERNEL
+  bool     parallelized;              /*  learning function parallelized for */
+				      /*  the Intel Paragon  */
+#endif
+};
+
+
+/*#################################################
+
+GROUP: Feedforward network descriptor
+
+#################################################*/
+
+#ifdef MASPAR_KERNEL
+
+/* max. number of layers of a feedforward network in superscalar kernel mode  */
+#define  FF_MAX_LAYERS  8
+
+struct  FFnetDescriptor  {
+  int  no_of_layers;   /*  no. of layers of the network */
+  int  no_of_weights;	/*  no. of weights in network  */
+
+  struct
+    {  /*  describes the layers of the network
+           (layers[i] describes the units in layer i, layer 0 is the input layer)  */
+    int  no_of_units;          /*  no. of units in this layer  */
+
+    struct
+      {  /*  inputs[k] describes the input connections of the units in
+             the layer i to units in layer k  */
+      int  no_of_inputs;         /*  stores the total no. of connections
+                                     from units in layer k with units in layer i.
+                                 */
+      FlintType  *weight_array;  /*  pointer to the weight array containing the
+                                     connection weights of connections from
+                                     layer i to layer k.
+                                 */
+
+      /*  if the network has partial connected units:  */
+      /*  first input connection of unit i to unit <first_connection>
+          in layer k
+      */
+      /*  gap count of the input connections of units in layer i with
+          units in layer k
+      */
+    }  inputs[FF_MAX_LAYERS - 1];
+
+  }  layers[FF_MAX_LAYERS];
+};
+
+
+struct  MasParInfo  {
+  int  no_of_PEs,
+       memory_perPE,
+       no_of_network_copies,
+       no_of_used_PEs;
+
+  float  efficiency;
+};
+
+#endif
+
+#endif
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/func_mac.h snort-2.3.3.new/src/kernel_snns/func_mac.h
--- snort-2.3.3/src/kernel_snns/func_mac.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/func_mac.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,91 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/func_mac.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Macros for transfer functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 21.06.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:12 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef KR_FUNC_MACROS
+#define KR_FUNC_MACROS
+
+#define  UNIT_PTR   struct Unit *
+#define  SITE_PTR   struct Site *
+
+#define  ACT_FUNC_DEFS      register struct Link  *__link_ptr; \
+                            register struct Site  *__site_ptr;
+
+#define  SITE_FUNC_DEFS     register struct Link  *__link_ptr;
+
+
+/*#################################################
+
+GROUP: Link Macros
+
+#################################################*/
+
+#define  GET_FIRST_UNIT_LINK( u_ptr )   (__link_ptr = ( (u_ptr)->flags & UFLAG_DLINKS) ? \
+                                         ( (struct Link *) (u_ptr)->sites) : (NULL) )
+
+#define  GET_FIRST_SITE_LINK( s_ptr )   (__link_ptr = (s_ptr)->links)
+
+#define  GET_NEXT_LINK      (__link_ptr = __link_ptr->next)
+
+#define  GET_WEIGHTED_OUTPUT    ( (__link_ptr->weight) * (__link_ptr->to->Out.output) )
+
+#define  GET_OUTPUT         (__link_ptr->to->Out.output)
+
+#define  GET_WEIGHT         (__link_ptr->weight)
+
+#define  GET_TACOMA_RADIUS  (__link_ptr->value_a)
+
+#define  GET_TACOMA_COORD   (__link_ptr->value_b)
+
+#define  LINK_FROM_INPUT_UNIT (IS_INPUT_UNIT(__link_ptr->to))
+
+/* calculate each component of the euclidic distance */ 
+#define  GET_EUCLID_COMP    ( ((__link_ptr->weight) - (__link_ptr->to->Out.output))*((__link_ptr->weight) - (__link_ptr->to->Out.output)) )
+
+
+/*#################################################
+
+GROUP: Site Macros
+
+#################################################*/
+
+#define  GET_FIRST_SITE( u_ptr )    (__site_ptr = ( (u_ptr)->flags & UFLAG_SITES) ? \
+                                     ( (u_ptr)->sites ) : (NULL) )
+
+#define  GET_NEXT_SITE      (__site_ptr = __site_ptr->next)
+
+#define  GET_SITE_NAME      (__site_ptr->site_table->Entry.site_name->Entry.symbol)
+
+#define  GET_SITE_VALUE     ( (*__site_ptr->site_table->site_func) (__site_ptr) )
+
+/*  Future Application (in SNNS-Kernel V1.4 the sites don't have weights).
+*/
+#define  GET_SITE_WEIGHT    ((FlintType) 1)
+
+
+/*#################################################
+
+GROUP: Unit Macros
+
+#################################################*/
+
+#define  GET_UNIT_BIAS( u_ptr )  ((u_ptr)->bias)
+#define  GET_UNIT_ACT( u_ptr )   ((u_ptr)->act)
+
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/func_tbl.c snort-2.3.3.new/src/kernel_snns/func_tbl.c
--- snort-2.3.3/src/kernel_snns/func_tbl.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/func_tbl.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,413 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/func_tbl.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Function table
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 25.06.90
+
+  CHANGED BY     : Sven Doering, Michael Vogt, Ralf Huebner, Thomas Gern
+  RCS VERSION    : $Revision: 2.51 $
+  LAST CHANGE    : $Date: 1998/09/03 09:52:20 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+
+#include "kr_typ.h"	    /*	Kernel Types and Constants  */
+#include "kr_const.h"       /*  Constant Declarators for SNNS-Kernel  */
+#include "learn_f.h"
+#include "init_f.h"
+#include "trans_f.h"
+#include "remap_f.h"
+#include "update_f.h"
+#include "arttr_f.h"
+#include "tbl_func.h"
+#include "kr_td.h"
+#include "cc_learn.h"
+#include "tacoma_learn.h"
+#include "cc_type.h"
+#include "dlvq_learn.h"
+#include "prun_f.h"
+#include "stochastic_learn_f.h" 
+#include "scaled_conj_grad.h"
+
+#include "func_tbl.ph"
+
+/*  The function table contains 5 entries:
+     - the XGUI-Identifier of this function (a pointer to a string constant),
+       note that the identifier have to match [A-Za-z]^[|, ]* (i.e. the first
+       character of the symbol must be a letter and all other characters must
+       not match [|, ])
+
+     - an integer constant that determine the class of the function.
+       8 different classes are possible:
+       OUT_FUNC, ACT_FUNC, ACT_DERIV_FUNC, SITE_FUNC, UPDATE_FUNC, LEARN_FUNC,
+       INIT_FUNC, PRUNING_FUNC and TEST_FUNC
+
+     - the number of input parameters for this function (only needed for Update,
+       Init, Learning and Test functions)
+
+     - the number of output parameters returned by this function (only needed
+       for Update, Learning and Test functions)
+
+     - a pointer to the (user defined) function.
+*/
+
+/*  *********************************************************************  */
+
+/*  Here is the function table
+*/
+struct FuncTable  kernel_func_table[]	=
+  {
+
+/*  Output functions  */
+/*  In 'kr_const.h' is defined that the NULL-pointer presents the
+    identity function. So the "Out_Identity" function is represented
+    by the NULL-pointer instead of the function pointer.
+*/
+/*  This is the DEFAULT FUNCTION  */
+{"Out_Identity",     OUT_FUNC | DEFAULT_FUNC, 0, 0, (FunctionPtr) OUT_IDENTITY},
+
+{"Out_Threshold05",  OUT_FUNC, 0, 0, (FunctionPtr) OUT_Threshold05},
+{"Out_Clip_01",      OUT_FUNC, 0, 0, (FunctionPtr) OUT_Clip_01},
+{"Out_Clip_11",      OUT_FUNC, 0, 0, (FunctionPtr) OUT_Clip_11},
+{"Out_ART2_Noise_PLin", OUT_FUNC, 0, 0, (FunctionPtr) OUT_ART2_Noise_PLin},
+{"Out_ART2_Noise_ContDiff", OUT_FUNC, 0, 0, (FunctionPtr) OUT_ART2_Noise_ContDiff},
+
+/*  Activation functions  */
+/*  This is the DEFAULT FUNCTION  */
+{"Act_Logistic",     ACT_FUNC | DEFAULT_FUNC, 0, 0, (FunctionPtr) ACT_Logistic},
+{"Act_Elliott",      ACT_FUNC, 0, 0, (FunctionPtr) ACT_Elliott},
+{"Act_BSB",          ACT_FUNC, 0, 0, (FunctionPtr) ACT_BSBFunction},
+{"Act_TanH",         ACT_FUNC, 0, 0, (FunctionPtr) ACT_TanHFunction},
+{"Act_TanH_Xdiv2",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_TanHFunction_Xdiv2},
+{"Act_Perceptron",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_Perceptron},
+{"Act_Signum",       ACT_FUNC, 0, 0, (FunctionPtr) ACT_Signum},
+{"Act_Signum0",      ACT_FUNC, 0, 0, (FunctionPtr) ACT_Signum0},
+{"Act_Softmax",     ACT_FUNC ,0, 0, (FunctionPtr) ACT_Softmax},
+{"Act_StepFunc",     ACT_FUNC, 0, 0, (FunctionPtr) ACT_StepFunction},
+{"Act_HystStep",     ACT_FUNC, 0, 0, (FunctionPtr) ACT_HystStepFunction},
+{"Act_BAM",          ACT_FUNC, 0, 0, (FunctionPtr) ACT_BAMFunction},
+{"Logistic_notInhibit" , ACT_FUNC, 0, 0, (FunctionPtr) ACT_LogisticI},
+{"Act_MinOutPlusWeight", ACT_FUNC, 0, 0, (FunctionPtr) ACT_MinOutPlusWeight},
+{"Act_Identity",     ACT_FUNC, 0, 0, (FunctionPtr) ACT_Linear},
+{"Act_IdentityPlusBias", ACT_FUNC, 0, 0, (FunctionPtr) ACT_Linear_bias},
+{"Act_LogisticTbl",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_LogisticTbl},
+{"Act_RBF_Gaussian", ACT_FUNC, 0, 0, (FunctionPtr) ACT_RBF_Gaussian},
+{"Act_RBF_MultiQuadratic", ACT_FUNC, 0, 0, (FunctionPtr) ACT_RBF_Multiquadratic},
+{"Act_RBF_ThinPlateSpline", ACT_FUNC, 0, 0, (FunctionPtr) ACT_RBF_Thinplatespline},
+{"Act_less_than_0",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_less_than_0},
+{"Act_at_most_0",    ACT_FUNC, 0, 0, (FunctionPtr) ACT_at_most_0},
+{"Act_at_least_2",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_at_least_2},
+{"Act_at_least_1",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_at_least_1},
+{"Act_exactly_1",    ACT_FUNC, 0, 0, (FunctionPtr) ACT_exactly_1},
+{"Act_Product",      ACT_FUNC, 0, 0, (FunctionPtr) ACT_Product},
+
+{"Act_ART1_NC",      ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART1_NC},
+{"Act_ART2_Identity",ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_Linear},
+{"Act_ART2_NormP",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_NormP},
+{"Act_ART2_NormV",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_NormV},
+{"Act_ART2_NormW",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_NormW},
+{"Act_ART2_NormIP",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_NormIP},
+{"Act_ART2_Rec",     ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_Rec},
+{"Act_ART2_Rst",     ACT_FUNC, 0, 0, (FunctionPtr) ACT_ART2_Rst},
+{"Act_ARTMAP_NCa",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_ARTMAP_NCa},
+{"Act_ARTMAP_NCb",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_ARTMAP_NCb},
+{"Act_ARTMAP_DRho",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_ARTMAP_DRho},
+{"Act_LogSym",       ACT_FUNC, 0, 0, (FunctionPtr) ACT_LogisticSym},
+{"Act_CC_Thresh",    ACT_FUNC, 0, 0, (FunctionPtr) ACT_CC_Threshold},
+{"Act_Sinus",        ACT_FUNC, 0, 0, (FunctionPtr) ACT_SIN},
+{"Act_Exponential",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_EXPONENT},
+{"Act_TD_Logistic",  ACT_FUNC, 0, 0, (FunctionPtr) ACT_TD_Logistic},
+{"Act_TD_Elliott",   ACT_FUNC, 0, 0, (FunctionPtr) ACT_TD_Elliott},
+{"Act_Euclid",       ACT_FUNC, 0, 0, (FunctionPtr) ACT_Euclid},
+{"Act_Component",    ACT_FUNC, 0, 0, (FunctionPtr) ACT_Component},
+{"Act_RM",	     ACT_FUNC, 0, 0, (FunctionPtr) ACT_RM}, 
+{"Act_TACOMA",       ACT_FUNC, 0, 0, (FunctionPtr) ACT_TACOMA},
+
+
+/*  Derivation functions of the activation functions
+    NOTE: The derivative function of the activation function MUST have
+	  the same name as the belonging activation function.
+*/
+{"Act_Logistic",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Logistic},
+{"Act_Elliott",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Elliott},
+{"Act_BSB",          ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_BSBFunction},
+{"Act_TanH",         ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_TanHFunction},
+{"Act_TanH_Xdiv2",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_TanHFunction_Xdiv2},
+{"Act_Perceptron",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Signum",       ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Signum0",      ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Softmax",     ACT_DERIV_FUNC ,0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_StepFunc",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_HystStep",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_BAM",          ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Logistic_notInhibit",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_MinOutPlusWeight", ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Identity",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Identity},
+{"Act_IdentityPlusBias", ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Identity},
+{"Act_LogisticTbl",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Logistic},
+{"Act_RBF_Gaussian", ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_RBF_Gaussian},
+{"Act_RBF_MultiQuadratic", ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_RBF_Multiquadratic},
+{"Act_RBF_ThinPlateSpline", ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_RBF_Thinplatespline},
+{"Act_less_than_0",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_at_most_0",    ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_at_least_1",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_at_least_2",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_exactly_1",    ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Product",      ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART1_NC",      ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_Identity",ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_NormP",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_NormV",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_NormW",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_NormIP",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_Rec",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ART2_Rst",     ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ARTMAP_NCa",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ARTMAP_NCb",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_ARTMAP_DRho",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_LogSym",       ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_LogisticSym},
+{"Act_CC_Thresh",    ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_CC_Threshold},
+{"Act_Sinus",        ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_SIN},
+{"Act_Exponential",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_EXPONENT},
+{"Act_TD_Logistic",  ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_TD_Logistic},
+{"Act_TD_Elliott",   ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_TD_Elliott},
+{"Act_Euclid",       ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_Component",    ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy},
+{"Act_RM",           ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_Dummy}, 
+{"Act_TACOMA",       ACT_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_DERIV_TACOMA},
+
+/*  Second derivation functions of the activation functions
+    NOTE: The second derivative function of the activation function
+    MUST have the same name as the belonging activation function.
+*/
+{"Act_Logistic",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Logistic},
+{"Act_Elliott",             ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Elliott},
+{"Act_BSB",                 ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_BSBFunction},
+{"Act_TanH",                ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_TanHFunction},
+{"Act_TanHPlusBias",        ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_TanHFunction},
+{"Act_TanH_Xdiv2",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_TanHFunction_Xdiv2},
+{"Act_Perceptron",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Signum",              ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Signum0",             ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Softmax",             ACT_2_DERIV_FUNC ,0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_StepFunc",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_HystStep",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_BAM",                 ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Logistic_notInhibit",     ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_MinOutPlusWeight",    ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Identity",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Identity},
+{"Act_IdentityPlusBias",    ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Identity},
+{"Act_LogisticTbl",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Logistic},
+{"Act_RBF_Gaussian",        ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_RBF_MultiQuadratic",  ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_RBF_ThinPlateSpline", ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_less_than_0",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_at_most_0",           ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_at_least_1",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_at_least_2",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_exactly_1",           ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Product",             ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART1_NC",             ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_Identity",       ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_NormP",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_NormV",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_NormW",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_NormIP",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_Rec",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ART2_Rst",            ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ARTMAP_NCa",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ARTMAP_NCb",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_ARTMAP_DRho",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_LogSym",              ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_TanHFunction},
+{"Act_TD_Logistic",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_TD_Elliott",          ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Euclid",              ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Component",           ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_RM",                  ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy}, 
+{"Act_TACOMA",              ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_CC_Thresh",           ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Sinus",               ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+{"Act_Exponential",         ACT_2_DERIV_FUNC, 0, 0, (FunctionPtr) ACT_2_DERIV_Dummy},
+
+
+/*  Site functions  */
+{"Site_WeightedSum", SITE_FUNC | DEFAULT_FUNC, 0, 0, (FunctionPtr) SITE_WeightedSum},
+{"Site_Pi",          SITE_FUNC, 0, 0, (FunctionPtr) SITE_ProductA},
+{"Site_Produkt",     SITE_FUNC, 0, 0, (FunctionPtr) SITE_Product},
+{"Site_Max",         SITE_FUNC, 0, 0, (FunctionPtr) SITE_Max},
+{"Site_Min",         SITE_FUNC, 0, 0, (FunctionPtr) SITE_Min},
+{"Site_at_least_2",  SITE_FUNC, 0, 0, (FunctionPtr) SITE_at_least_2},
+{"Site_at_least_1",  SITE_FUNC, 0, 0, (FunctionPtr) SITE_at_least_1},
+{"Site_at_most_0",   SITE_FUNC, 0, 0, (FunctionPtr) SITE_at_most_0},
+{"Site_Reciprocal",  SITE_FUNC, 0, 0, (FunctionPtr) SITE_Reciprocal_WeightedSum},
+
+/*  Update functions  */
+/*  This is the DEFAULT FUNCTION  */
+{"Topological_Order", UPDATE_FUNC | DEFAULT_FUNC, 0, 0, (FunctionPtr) UPDATE_topologicalPropagate},
+{"ART1_Stable",       UPDATE_FUNC, 1, 0, (FunctionPtr) UPDATE_ART1_Propagate},
+{"ART1_Synchronous",  UPDATE_FUNC, 1, 0, (FunctionPtr) UPDATE_ART1_syncPropagate},
+{"ART2_Stable",       UPDATE_FUNC, 5, 0, (FunctionPtr) UPDATE_ART2_Propagate},
+{"ART2_Synchronous",  UPDATE_FUNC, 5, 0, (FunctionPtr) UPDATE_ART2_syncPropagate},
+{"ARTMAP_Stable",     UPDATE_FUNC, 3, 0, (FunctionPtr) UPDATE_ARTMAP_Propagate},
+{"ARTMAP_Synchronous",UPDATE_FUNC, 3, 0, (FunctionPtr) UPDATE_ARTMAP_syncPropagate},
+{"Auto_Synchronous",    UPDATE_FUNC, 1, 0, (FunctionPtr) UPDATE_RM_Propagate},
+{"BAM_Order",         UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_BAM},
+{"BPTT_Order",        UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_BPTT},
+{"CC_Order",          UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_CC_Propagate},
+{"CounterPropagation",UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_CPNPropagate},
+{"Dynamic_LVQ",       UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_DLVQ_Propagate},
+{"Hopfield_Fixed_Act",  UPDATE_FUNC, 1, 0, (FunctionPtr) UPDATE_FixAct_Hop},
+{"Hopfield_Synchronous",UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_syncPropagateHop},
+{"JE_Order"  ,        UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_JE_Propagate},
+{"JE_Special",        UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_JE_Special},
+{"Kohonen_Order",     UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_KohonenPropagate},
+{"Random_Order",      UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_randomOrderPropagate},
+{"Random_Permutation",UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_randomPermutPropagate},
+{"Serial_Order",      UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_serialPropagate},
+{"Synchonous_Order",  UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_syncPropagate},
+{"TimeDelay_Order",   UPDATE_FUNC, 0, 0, (FunctionPtr) UPDATE_TimeDelayPropagate},
+{"ENZO_prop",         UPDATE_FUNC, 1, 0, (FunctionPtr) ENZO_propagate},
+
+/*  Leaning Functions  */
+/*  This is the DEFAULT FUNCTION  */
+{"Std_Backpropagation", LEARN_FUNC | DEFAULT_FUNC | FF_LEARN_FUNC, 2, 1, (FunctionPtr) LEARN_backprop},
+
+{"ART1",                LEARN_FUNC, 1, 0, (FunctionPtr) LEARN_ART1},
+{"ART2",                LEARN_FUNC, 5, 0, (FunctionPtr) LEARN_ART2},
+{"ARTMAP",              LEARN_FUNC, 3, 0, (FunctionPtr) LEARN_ARTMAP},
+{"BackPercolation",     LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_perc},
+{"BackpropBatch",       LEARN_FUNC | FF_LEARN_FUNC, 2, 1, (FunctionPtr) LEARN_backpropBatch},
+{"BackpropChunk",       LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_backpropChunk},
+{"BackpropClassJogChunk", LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_backpropClassJogChunk},
+{"BackpropJogChunk",    LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_backpropJogChunk},
+{"BackpropMomentum",    LEARN_FUNC | FF_LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_backpropMomentum},
+{"BackpropWeightDecay", LEARN_FUNC | FF_LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_backpropWeightDecay},
+{"BPTT",                LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_BPTT},
+{"BBPTT",               LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_BBPTT},
+{"CC",                  LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_CC},
+{"Counterpropagation",  LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_CPN},
+{"Dynamic_LVQ",         LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_DLVQ}, /* No Of params must be 5 !!! Otherwise batchman will not work for this function */
+{"Hebbian",             LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_HEBB},
+{"JE_BP",               LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_JE_Backprop},
+{"JE_BP_Momentum",      LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_JE_BackpropMomentum},
+{"JE_Quickprop",        LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_JE_Quickprop},
+{"JE_Rprop",            LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_JE_Rprop},
+{"Kohonen",             LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_kohonen},
+{"Monte-Carlo",         LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_MonteCarlo},
+{"PruningFeedForward",  LEARN_FUNC, 5, 1, (FunctionPtr) NULL},
+{"QPTT",                LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_QPTT},
+{"Quickprop",           LEARN_FUNC | FF_LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_quickprop},
+{"RadialBasisLearning", LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_RBF},
+{"RBF-DDA",             LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_RBF_DDA},
+{"RM_delta",            LEARN_FUNC, 2, 1, (FunctionPtr) LEARN_RM_delta},
+{"Rprop",               LEARN_FUNC | FF_LEARN_FUNC, 3, 1, (FunctionPtr) LEARN_rprop},
+{"RpropMAP",            LEARN_FUNC | FF_LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_RpropMAP},
+{"SCG",                 LEARN_FUNC | FF_LEARN_FUNC, 4, 2, (FunctionPtr) LEARN_SCG},
+{"Sim_Ann_SS", LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_SimulatedAnnealingSS},
+{"Sim_Ann_WTA", LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_SimulatedAnnealingWTA},
+{"Sim_Ann_WWTA", LEARN_FUNC, 4, 1, (FunctionPtr) LEARN_SimulatedAnnealingWWTA},
+{"TACOMA",              LEARN_FUNC, 5, 1, (FunctionPtr) LEARN_Tacoma},
+{"TimeDelayBackprop",   LEARN_FUNC, 2, 1, (FunctionPtr) LEARN_TDbackprop},
+
+/*  Testing Functions  */
+/*  This is the DEFAULT FUNCTION  */
+{"Std_Backpropagation", TEST_FUNC | DEFAULT_FUNC, 2, 1, (FunctionPtr) TEST_backprop},
+/* {"ART1",                TEST_FUNC, 1, 0, (FunctionPtr) TEST_ART1}, */
+ {"BackpropBatch",       TEST_FUNC, 2, 1, (FunctionPtr) TEST_backprop},
+/* {"ART2",                TEST_FUNC, 5, 0, (FunctionPtr) TEST_ART2}, */
+{"BackpropChunk",       TEST_FUNC, 2, 1, (FunctionPtr) TEST_backprop},
+{"BackpropClassJogChunk",TEST_FUNC, 2, 1, (FunctionPtr) TEST_backprop},
+{"BackpropMomentum",    TEST_FUNC, 4, 1, (FunctionPtr) TEST_backpropMomentum},
+/* {"ARTMAP",              TEST_FUNC, 3, 0, (FunctionPtr) TEST_ARTMAP}, */
+{"BackpropWeightDecay", TEST_FUNC, 4, 1, (FunctionPtr) TEST_backpropMomentum},
+/* {"BackPercolation",     TEST_FUNC, 3, 1, (FunctionPtr) TEST_perc}, 
+{"PruningFeedForward",  TEST_FUNC, 5, 1, (FunctionPtr) NULL},
+{"Hebbian",             TEST_FUNC, 3, 1, (FunctionPtr) TEST_HEBB}, */
+{"TimeDelayBackprop",   TEST_FUNC, 2, 1, (FunctionPtr) TEST_TDbackprop},
+/* {"RM_delta",            TEST_FUNC, 2, 1, (FunctionPtr) TEST_RM_delta},*/
+{"Quickprop",           TEST_FUNC, 4, 1, (FunctionPtr) TEST_backpropMomentum},
+/* {"Counterpropagation",  TEST_FUNC, 3, 1, (FunctionPtr) TEST_CPN},*/
+{"Rprop",               TEST_FUNC, 3, 1, (FunctionPtr) TEST_rprop},
+{"RpropMAP",          TEST_FUNC, 5, 1, (FunctionPtr) TEST_MAP},
+/* {"RadialBasislearning", TEST_FUNC, 4, 1, (FunctionPtr) TEST_RBF},
+{"Dynamic_LVQ",         TEST_FUNC, 5, 1, (FunctionPtr) TEST_DLVQ},*/
+{"BPTT",                TEST_FUNC, 3, 1, (FunctionPtr) TEST_BPTT},
+{"CC",                  TEST_FUNC, 5, 1, (FunctionPtr) TEST_CasCor},
+{"TACOMA",              TEST_FUNC, 5, 1, (FunctionPtr) TEST_CasCor},
+{"BBPTT",               TEST_FUNC, 3, 1, (FunctionPtr) TEST_BPTT},
+{"QPTT",                TEST_FUNC, 4, 1, (FunctionPtr) TEST_BPTT},
+/*{"Kohonen",             TEST_FUNC, 5, 1, (FunctionPtr) TEST_kohonen},*/
+{"JE_BP",               TEST_FUNC, 3, 1, (FunctionPtr) TEST_JE_Backprop},
+{"JE_BP_Momentum",      TEST_FUNC, 5, 1, (FunctionPtr) TEST_JE_BackpropMomentum},
+{"JE_Quickprop",        TEST_FUNC, 5, 1, (FunctionPtr) TEST_JE_BackpropMomentum},
+{"JE_Rprop",            TEST_FUNC, 4, 1, (FunctionPtr) TEST_JE_Rprop}, 
+{"Monte-Carlo",         TEST_FUNC, 4, 1, (FunctionPtr) TEST_MonteCarlo}, 
+{"SCG",                 TEST_FUNC, 4, 1, (FunctionPtr) TEST_SCG},
+{"Sim_Ann_SS", TEST_FUNC, 4, 1, (FunctionPtr) TEST_SimulatedAnnealingSS},
+{"Sim_Ann_WTA", TEST_FUNC, 4, 1, (FunctionPtr) TEST_SimulatedAnnealingWTA},
+{"Sim_Ann_WWTA", TEST_FUNC, 4, 1, (FunctionPtr) TEST_SimulatedAnnealingWWTA},
+
+/*  Initialisation Functions  */
+/*  This is the DEFAULT FUNCTION  */
+{"Randomize_Weights",   INIT_FUNC | DEFAULT_FUNC, 2, 0, (FunctionPtr) INIT_randomizeWeights},
+
+{"ART1_Weights",        INIT_FUNC, 2, 0, (FunctionPtr) INIT_Weights_ART1},
+{"ART2_Weights",        INIT_FUNC, 2, 0, (FunctionPtr) INIT_Weights_ART2},
+{"ARTMAP_Weights",      INIT_FUNC, 4, 0, (FunctionPtr) INIT_Weights_ARTMAP},
+{"CC_Weights",          INIT_FUNC, 2, 0, (FunctionPtr) INIT_CC_Weights},
+{"ClippHebb",           INIT_FUNC, 2, 0, (FunctionPtr) INIT_ClippHebb},
+{"CPN_Weights_v3.2",    INIT_FUNC, 2, 0, (FunctionPtr) INIT_Weights_CPNv32},
+{"CPN_Weights_v3.3",    INIT_FUNC, 2, 0, (FunctionPtr) INIT_Weights_CPNv33},
+{"CPN_Rand_Pat",        INIT_FUNC, 0, 0, (FunctionPtr) INIT_Weights_CPN_Rand_Pat},
+{"DLVQ_Weights",        INIT_FUNC, 2, 0, (FunctionPtr) INIT_CC_Weights},
+{"Hebb",                INIT_FUNC, 2, 0, (FunctionPtr) INIT_Hebb}, 
+{"Hebb_Fixed_Act",      INIT_FUNC, 2, 0, (FunctionPtr) INIT_HOP_FixAct},
+{"JE_Weights",          INIT_FUNC, 5, 0, (FunctionPtr) INIT_JE_Weights},
+{"Kohonen_Rand_Pat",    INIT_FUNC, 0, 0, (FunctionPtr) INIT_SOM_Rand_Pat},
+{"Kohonen_Weights_v3.2",INIT_FUNC, 2, 0, (FunctionPtr) INIT_SOM_Weights_v32},
+{"Kohonen_Const",       INIT_FUNC, 2, 0, (FunctionPtr) INIT_SOM_Weights_const},
+{"PseudoInv",           INIT_FUNC, 0, 0, (FunctionPtr) INIT_PseudoInv},
+{"Random_Weights_Perc", INIT_FUNC, 2, 0, (FunctionPtr) INIT_randomizeWeights_perc},
+{"RBF_Weights",         INIT_FUNC, 5, 0, (FunctionPtr) INIT_RBF_Weights},
+{"RBF_Weights_Kohonen", INIT_FUNC, 3, 0, (FunctionPtr) INIT_RBF_Weights_kohonen},
+{"RBF_Weights_Redo",    INIT_FUNC, 3, 0, (FunctionPtr) INIT_RBF_Weights_redo},
+{"RM_Random_Weights",   INIT_FUNC, 2, 0, (FunctionPtr) INIT_RM_randomizeWeights},
+{"ENZO_noinit",         INIT_FUNC,  0, 0, (FunctionPtr) ENZO_noinit},
+
+/* Pruning Functions */
+/*  This is the DEFAULT FUNCTION  */
+{"MagPruning", PRUNING_FUNC | DEFAULT_FUNC, 1, 1, (FunctionPtr) PRUNE_Mag},
+
+{"OptimalBrainDamage", PRUNING_FUNC, 1, 1, (FunctionPtr) PRUNE_OBD},
+{"OptimalBrainSurgeon", PRUNING_FUNC, 1, 1, (FunctionPtr) PRUNE_OBS},
+{"Skeletonization", PRUNING_FUNC, 1, 1, (FunctionPtr) PRUNE_Skeletonization},
+{"Noncontributing_Units", PRUNING_FUNC, 1, 1, (FunctionPtr) PRUNE_Noncontributing},
+
+/* Remap Functions */
+/*  This is the DEFAULT FUNCTION  */
+{"None", REMAP_FUNC | DEFAULT_FUNC, 0, 0, (FunctionPtr) REMAP_none},
+{"Binary", REMAP_FUNC, 0, 0, (FunctionPtr) REMAP_binary},
+{"Inverse", REMAP_FUNC, 0, 0, (FunctionPtr) REMAP_invers},
+{"Clip", REMAP_FUNC, 2, 0, (FunctionPtr) REMAP_clip},
+{"LinearScale", REMAP_FUNC, 2, 0, (FunctionPtr) REMAP_linearscale},
+{"Norm", REMAP_FUNC, 0, 0, (FunctionPtr) REMAP_norm},
+{"Threshold", REMAP_FUNC, 4, 0, (FunctionPtr) REMAP_threshold}
+  };
+
+
+/*  Define the function table size
+*/
+const int  NoOfKernelFuncs = (sizeof (kernel_func_table) / sizeof (struct FuncTable));
+/*  **********************************************************************  */
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/func_tbl.h snort-2.3.3.new/src/kernel_snns/func_tbl.h
--- snort-2.3.3/src/kernel_snns/func_tbl.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/func_tbl.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,25 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/func_tbl.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Function table
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 02.02.93
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:14 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _FUNC_TBL_DEFINED_
+#define  _FUNC_TBL_DEFINED_
+
+extern struct FuncTable  kernel_func_table[];
+extern const int  NoOfKernelFuncs;
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/func_tbl.ph snort-2.3.3.new/src/kernel_snns/func_tbl.ph
--- snort-2.3.3/src/kernel_snns/func_tbl.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/func_tbl.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,35 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/func_tbl.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Function table
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 02.02.93
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:15 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _FUNC_TBL_DEFINED_
+#define  _FUNC_TBL_DEFINED_
+
+/* begin global definition section */
+
+/* struct FuncTable  kernel_func_table[]; */
+
+const int  NoOfKernelFuncs;
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/getcwd.c snort-2.3.3.new/src/kernel_snns/getcwd.c
--- snort-2.3.3/src/kernel_snns/getcwd.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/getcwd.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,44 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/getcwd.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : getcwd
+  NOTES          : 
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 2.3.98
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/03/03 15:59:56 $
+
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#if ! defined(HAVE_GETCWD) || HAVE_GETCWD == 0
+#include <stdlib.h>
+
+/* unfortunately there is no easy way to locate the current directory
+   if getcwd is not present. Even getwd will not work since getcwd
+   seems to be more standardized than getwd. So we better set the
+   current pathname to "" instead of trying tricks like 'pwd' */
+
+#define _DEFAULT_CWD_NAME ""
+
+char *getcwd(char *buf, size_t size)
+{
+    if (buf == NULL)
+	buf = malloc(size);
+
+    if (buf != NULL)
+	strncpy(buf, _DEFAULT_CWD_NAME, size);
+
+    return buf;
+}
+
+#undef _DEFAULT_CWD_NAME
+
+#endif /* ! HAVE_GETCWD */
diff -Naur snort-2.3.3/src/kernel_snns/getcwd.h snort-2.3.3.new/src/kernel_snns/getcwd.h
--- snort-2.3.3/src/kernel_snns/getcwd.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/getcwd.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,28 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/getcwd.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : getcwd
+  NOTES          : 
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 2.3.98
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/03/03 17:54:27 $
+
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#if ! defined(HAVE_GETCWD) || HAVE_GETCWD == 0
+#ifndef _GETCWD_DEFINED_
+#define _GETCWD_DEFINED_
+
+#include <sys/types.h>
+extern char *getcwd(char *buf, size_t size);
+
+#endif /* _GETCWD_DEFINED_ */
+#endif /* ! HAVE_GETCWD */
diff -Naur snort-2.3.3/src/kernel_snns/glob_typ.h snort-2.3.3.new/src/kernel_snns/glob_typ.h
--- snort-2.3.3/src/kernel_snns/glob_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/glob_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,494 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/glob_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel: Global Datatypes and Constants
+  NOTES          : For User's Application Programs, User-Interface and Kernel
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 14.02.90 
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Sven Doering, Christine Bagdi
+  RCS VERSION    : $Revision: 2.31 $
+  LAST CHANGE    : $Date: 1998/04/20 11:54:49 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef KR_GLOBAL_TYPES
+#define KR_GLOBAL_TYPES
+
+#include <stdio.h>
+
+#ifdef ultrix
+   /* DEC's pseudo ansi C-compiler doesn't understand const  */
+#  define const
+#endif
+
+
+#ifndef __BORLANDC__
+
+
+
+/*  define MASPAR_KERNEL to build the parallel MasPar Kernel
+*/
+/*
+#define MASPAR_KERNEL
+*/
+
+#endif
+
+#ifdef MASPAR_KERNEL
+
+/*  define MASPAR_KERNEL_EMULATION to build a (sequentiel) kernel that simulates
+    the MasPar interface
+*/
+/*
+#define  MASPAR_KERNEL_EMULATION
+*/
+
+/*
+#define  KERNEL_VERBOSE
+*/
+
+#endif
+
+
+/* ******************************************   */
+
+#ifndef TRUE
+#define     TRUE    1
+#endif
+#ifndef FALSE
+#define     FALSE   0
+#endif
+
+/*#################################################
+
+GROUP: Public Constants
+
+#################################################*/
+
+/*  Kernel user interface error codes
+*/
+#define  KRERR_NO_ERROR         0
+#define  KRERR_INSUFFICIENT_MEM -1
+#define  KRERR_UNIT_NO          -2
+#define  KRERR_OUTFUNC          -3
+#define  KRERR_ACTFUNC          -4
+#define  KRERR_SITEFUNC         -5
+#define  KRERR_CREATE_SITE      -6
+#define  KRERR_ALREADY_CONNECTED  -7
+#define  KRERR_CRITICAL_MALLOC  -8
+#define  KRERR_FTYPE_NAME       -9
+#define  KRERR_FTYPE_ENTRY      -10
+#define  KRERR_COPYMODE         -11
+#define  KRERR_NO_SITES         -12
+#define  KRERR_FROZEN           -13
+#define  KRERR_REDEF_SITE_NAME  -14
+#define  KRERR_UNDEF_SITE_NAME  -15
+#define  KRERR_NOT_3D           -16
+#define  KRERR_DUPLICATED_SITE  -17
+#define  KRERR_INUSE_SITE       -18
+#define  KRERR_FTYPE_SITE       -19
+#define  KRERR_FTYPE_SYMBOL     -20
+#define  KRERR_IO               -21
+#define  KRERR_SAVE_LINE_LEN    -22
+#define  KRERR_FEW_LAYERS       -23
+#define  KRERR_NO_UNITS         -24
+#define  KRERR_EOF              -25
+#define  KRERR_LINE_LENGTH      -26
+#define  KRERR_FILE_FORMAT      -27
+#define  KRERR_FILE_OPEN        -28
+#define  KRERR_FILE_SYNTAX      -29
+#define  KRERR_MALLOC1          -30
+#define  KRERR_TTYPE            -31
+#define  KRERR_SYMBOL           -32
+#define  KRERR_NO_SUCH_SITE     -33
+#define  KRERR_NO_HIDDEN_UNITS  -34
+#define  KRERR_CYCLES           -35
+#define  KRERR_DEAD_UNITS       -36
+#define  KRERR_INPUT_PATTERNS   -37
+#define  KRERR_OUTPUT_PATTERNS  -38
+#define  KRERR_CHANGED_I_UNITS  -39
+#define  KRERR_CHANGED_O_UNITS  -40
+#define  KRERR_NO_INPUT_UNITS   -41
+#define  KRERR_NO_OUTPUT_UNITS  -42
+#define  KRERR_NO_PATTERNS      -43
+#define  KRERR_INCORE_PATTERNS  -44
+#define  KRERR_PATTERN_NO       -45
+#define  KRERR_LEARNING_FUNC    -46
+#define  KRERR_PARAMETERS       -47
+#define  KRERR_UPDATE_FUNC      -48
+#define  KRERR_INIT_FUNC        -49
+#define  KRERR_DERIV_FUNC       -50
+#define  KRERR_I_UNITS_CONNECT	-51
+#define  KRERR_O_UNITS_CONNECT	-52
+#define  KRERR_TOPOMODE 	-53
+#define  KRERR_LEARNING_SITES   -54
+#define  KRERR_SITES_NO_SUPPORT -55
+#define  KRERR_NO_MASPAR_KERNEL -56
+#define  KRERR_NOT_NEIGHBOUR_LAYER -57
+#define  KRERR_MUCH_LAYERS      -58
+#define  KRERR_NOT_FULLY_CONNECTED -59
+#define  KRERR_MODE_FF1_INVALID_OP -60
+#define  KRERR_NET_TRANSFORM    -61
+#define  KRERR_NO_CURRENT_LINK	-62
+#define  KRERR_NO_CURRENT_UNIT	-63
+#define  KRERR_UNIT_NO_INPUTS	-64
+#define  KRERR_TOPO_DEFINITION	-65
+#define  KRERR_BAD_CONNECTION   -66
+#define  KRERR_MASPAR_NO_RESPOND -67
+#define  KRERR_NOT_IMPEMENTED_YET -68
+#define  KRERR_NOT_PARALLEL_MODE  -69
+#define  KRERR_MASPAR_OUT_OF_PE_MEM -70
+#define  KRERR_MASPAR_COMMUNICATE -71
+#define  KRERR_MASPAR_OUT_OF_PE   -72
+#define  KRERR_MISSING_DEFAULT_FUNC  -73
+#define  KRERR_MASPAR_MULTI_OUT_FUNC -74
+#define  KRERR_MASPAR_MULTI_ACT_FUNC -75
+#define  KRERR_NET_DEPTH        -76
+#define  KRERR_NO_OF_UNITS_IN_LAYER         -77
+#define  KRERR_UNIT_MISSING                 -78
+#define  KRERR_UNDETERMINED_UNIT            -79
+#define  KRERR_ACT_FUNC                     -80
+#define  KRERR_OUT_FUNC                     -81
+#define  KRERR_SITE_FUNC                    -82
+#define  KRERR_UNEXPECTED_SITES             -83
+#define  KRERR_UNEXPECTED_DIRECT_INPUTS     -84
+#define  KRERR_SITE_MISSING                 -85
+#define  KRERR_UNEXPECTED_LINK              -86
+#define  KRERR_LINK_MISSING                 -87
+#define  KRERR_LINK_TO_WRONG_SITE           -88
+#define  KRERR_TOPOLOGY                     -89
+#define  KRERR_PARAM_BETA                   -90
+#define  KRERR_CC_ERROR1                    -91
+#define  KRERR_CC_ERROR2                    -92
+#define  KRERR_CC_ERROR3                    -93
+#define  KRERR_CC_ERROR4                    -94
+#define  KRERR_CC_ERROR5                    -95
+#define  KRERR_CC_ERROR6                    -96
+#define  KRERR_CC_ERROR7                    -97
+#define  KRERR_CC_ERROR8                    -98
+#define  KRERR_CC_ERROR9                    -99
+#define  KRERR_CC_ERROR10                  -100
+#define  KRERR_CC_ERROR11                  -101
+#define  DLVQ_ERROR1                       -102
+#define  DLVQ_ERROR2                       -103
+#define  DLVQ_ERROR3                       -104
+#define  DLVQ_ERROR4                       -105
+#define  DLVQ_ERROR5                       -106
+#define  KRERR_NP_NO_MORE_ENTRIES          -107
+#define  KRERR_NP_NO_SUCH_PATTERN_SET      -108
+#define  KRERR_NP_NO_CURRENT_PATTERN       -109
+#define  KRERR_NP_DIMENSION                -110
+#define  KRERR_NP_NO_SUCH_PATTERN          -111
+#define  KRERR_NP_NO_CURRENT_PATTERN_SET   -112
+#define  KRERR_NP_DOES_NOT_FIT             -113
+#define  KRERR_NP_NO_TRAIN_SCHEME          -114
+#define  KRERR_NP_NO_OUTPUT_PATTERN        -115
+#define  KRERR_NP_INCOMPATIBLE_NEW         -116
+#define  KRERR_IP_ISNOTINITED              -117
+#define  KRERR_IP_ISINITED                 -118
+#define  KRERR_IP_SENDMSGFAILED            -119
+#define  KRERR_IP_MSGSYNTAX                -120
+#define  KRERR_IP_UNKNOWENCMD              -121
+#define  KRERR_IP_LESSPAT                  -122
+#define  KRERR_IP_WEIGHTUPDATE             -123
+#define  KRERR_IP_LEARNFNOTPAR             -124
+/* codes 125 to 129 belonged to delted rpc sources */
+#define  KRERR_NP_WORKAROUND               -130
+#define  DDA_PARAM_ONE                     -131
+#define  DDA_PARAM_TWO                     -132
+#define  DDA_PARAM_THREE                   -133
+#define  DDA_DESIRED_CLASS                 -134
+#define  DDA_CONN_POINTER                  -135
+#define  DDA_SHORTCUTS                     -136
+#define  DDA_INPUT_ACT_FUNC                -137
+#define  DDA_HIDDEN_ACT_FUNC               -138
+#define  DDA_OUTPUT_ACT_FUNC               -139
+#define  KRERR_CC_INVALID_ADD_PARAMETERS   -140
+#define  KRERR_UPS_ACT_NOT_THRESHOLD       -141
+#define  KRERR_UPS_LEARN_NOT_BACKPROP      -142
+#define  KRERR_SINGLE_CLASS                -143
+#define  KRERR_REMAP_FUNC                  -144
+#define  KRERR_NO_CLASSES                  -145
+#define  KRERR_ILL_CLASS_DISTRIB           -146
+#define  KRERR_CANT_NORM                   -147
+
+/*  Function types
+*/
+#define  OUT_FUNC        1
+#define  ACT_FUNC        2
+#define  SITE_FUNC       3
+#define  LEARN_FUNC      4
+#define  UPDATE_FUNC     5
+#define  INIT_FUNC       6
+#define  ACT_DERIV_FUNC  7
+#define  JOG_WEIGHT_FUNC 8
+#define  ACT_2_DERIV_FUNC 9
+#define  PRUNING_FUNC    10
+#define  TEST_FUNC       11  
+#define  REMAP_FUNC       12  
+
+#define  FUNC_TYPE_MASK  0x00ff
+#define  DEFAULT_FUNC    0x0100
+#define  BENCH_FUNC      0x0200
+#define  FF_LEARN_FUNC   0x0400          /* used by pruning algorithms */
+
+
+
+/*   entry types for name table
+*/
+#define  UNUSED_SYM         0
+#define  UNIT_SYM           1
+#define  SITE_SYM           2
+#define  FTYPE_UNIT_SYM     3
+
+/* constants for the network-analyzer tool
+*/
+
+#define MAX_ARRAY_SIZE 5000
+#define NA_ERROR_LIN      1
+#define NA_ERROR_SQR      2
+#define NA_ERROR_SU       3
+
+/*  Copy Modes
+*/
+#define  INPUTS_AND_OUTPUTS     1
+#define  ONLY_INPUTS            2
+#define  ONLY_OUTPUTS           3
+#define  ONLY_UNIT              4
+
+
+/*  Topological Unit Types
+*/
+#define  UNKNOWN    0
+#define  INPUT      1
+#define  OUTPUT     2
+#define  HIDDEN     3
+#define  DUAL       4
+#define  SPECIAL    5
+#define  SPECIAL_I  6
+#define  SPECIAL_O  7
+#define  SPECIAL_H  8
+#define  SPECIAL_D     9
+#define  SPECIAL_X    10 /* Only used for toggle special flag */
+#define  N_SPECIAL_X  11 /* Only used for toggle special flag */
+
+/*  Unit Input Types
+*/
+#define  NO_INPUTS      0
+#define  SITES          1
+#define  DIRECT_LINKS   2
+
+/*  Pattern update modes
+*/
+#define  OUTPUT_NOTHING  1
+#define  OUTPUT_ACT      2
+#define  OUTPUT_OUT      3
+
+/*  Maximum number of pattern sets
+*/
+#define  NO_OF_PAT_SETS 5
+
+/*  Maximum Dimensions of Pattern
+*/
+#define MAX_NO_OF_VAR_I_DIM     2  /* maximum number of variable input       */
+				   /* dimensions                             */
+#define MAX_NO_OF_VAR_O_DIM     2  /* maximum number of variable             */
+				   /* output dimensions                      */
+#define MAX_NO_OF_VAR_DIM       2  /* maximum of MAX_NO_OF_VAR_I_DIM         */
+				   /* MAX_NO_OF_VAR_O_DIM                    */
+
+/*  Maximum no. of learning parameters for learning functions
+*/
+#define     NO_OF_LEARN_PARAMS	28
+
+/*  Maximum no. of results from the learning functions
+*/
+#define     NO_OF_RESULTS	10
+
+/*  Maximum no. of stored error from the learning functions
+*/
+#define     NO_OF_STORED_ERRORS	50
+
+/*  Maximum no. of init parameters for initialization functions
+*/
+#define     NO_OF_INIT_PARAMS   10
+
+/*  Maximum no. of update parameters for update functions
+*/
+#define     NO_OF_UPDATE_PARAMS   10
+
+/*  Maximum no. of parameters for pattern remap functions
+*/
+#define     NO_OF_REMAP_PARAMS   5
+
+
+
+
+/*  Translation Table op's
+*/
+#define     OP_TRANSTABLE_GET           1
+#define     OP_TRANSTABLE_SET           2
+#define     OP_TRANSTABLE_CLEAR         3
+
+
+
+/*#################################################
+
+GROUP: Global Var's
+
+#################################################*/
+
+/*  Kernel Interface Error Code
+*/
+#ifndef SNNS_KERNEL
+extern int  KernelErrorCode;
+#endif
+
+/*#################################################
+
+GROUP: Global Datatypes
+
+#################################################*/
+
+typedef int     bool;
+typedef float   FlintType;
+typedef int     krui_err;
+
+
+typedef struct
+{
+    double parameter[NO_OF_LEARN_PARAMS]; 
+    /*  UI_NO_OF_CASCADE_PARAMS is declared in ui.h the learn parameter     */ 
+    int noOfParameters;                      /* number of learn parameters  */
+    char **parameterDescription;             /* not supported yet           */
+    double result[NO_OF_RESULTS];            /* the result of training      */
+    int noOfResults;                         /* number of results           */
+    int firstPattern;                        /* the first pattern to train  */
+    int lastPattern;                         /* the last pattern to train   */
+    int noOfEpochs;                          /* number of epochs to learn   */
+    double learnErrors[NO_OF_STORED_ERRORS]; /* stores the Error            */
+    int atEpoch[NO_OF_STORED_ERRORS];        /* the epoch for the error     */
+    int noOfErrors;                          /* the number of stored errrors*/
+    float netError;                          /* the last net error          */
+    int   lastEpoch;                         /* the last epoch learned      */
+    bool interrupted;                        /* marks if all epochs learned */
+} NetLearnParameters;
+
+typedef struct 
+{
+    int number_of_pattern;     /* the number of pattern (pairs) in           */
+                               /* this set                                   */
+    int virtual_no_of_pattern; /* the number of pattern (pairs) if           */
+                               /* class_distrib_active == TRUE               */
+    bool output_present;       /* TRUE if output pattern present             */
+    bool fixed_fixsizes;       /* the fixsizes of all pattern are equal      */
+    int in_fixsize;            /* if fixed_fixsizes TRUE, fixsize of         */
+                               /* the input pattern, else -1                 */
+    int out_fixsize;           /* if fixed_fixsizes TRUE, fixsize of         */
+                               /* the output pattern, else -1                */
+    int in_number_of_dims;     /* number of variable input dimensions        */
+    int out_number_of_dims;    /* number of variable output dimensions       */
+    int in_max_dim_sizes[MAX_NO_OF_VAR_I_DIM];  /* maximum values of         */
+                                                /* the input dimension       */
+    int out_max_dim_sizes[MAX_NO_OF_VAR_O_DIM]; /* maximum values of the     */
+                                                /* output dimension          */
+    int in_min_dim_sizes[MAX_NO_OF_VAR_I_DIM];  /* minimum values of the     */
+                                                /* input dimensions          */
+    int out_min_dim_sizes[MAX_NO_OF_VAR_O_DIM]; /* minimum values of the     */
+                                                /* output dimensions         */
+
+    int classes;               /* number of pattern classes if > 0           */
+    char **class_names;        /* array of <classes> class names, ordered    */
+    bool class_distrib_active; /* class amount redistribution is active      */
+    int *class_redistribution; /* amounts for redistrib. <classes> entries   */
+    
+    char *remap_function;      /* name of remap function or NULL             */
+    float remap_params[NO_OF_REMAP_PARAMS];     /* remap function parameters */
+    int no_of_remap_params;    /* number of remap function parameters        */
+} pattern_set_info;
+
+typedef struct
+{
+    int input_dim;             /* number of variable input dimensions        */
+    int input_dim_sizes[MAX_NO_OF_VAR_I_DIM];  /* actual sizes of the input  */
+                                               /* dimensions                 */
+    int input_fixsize;         /* size of the fixed part of the in pattern   */
+                               /* or 0 if no input pattern present           */
+    int output_dim;            /* number of variable output dimensions       */
+    int output_dim_sizes[MAX_NO_OF_VAR_O_DIM]; /* actual sizes of the output */
+                                               /* dimensions                 */
+    int output_fixsize;        /* size of the fixed part of the out pattern  */
+                               /* or 0 if no output pattern present          */
+    int my_class;              /* class index of this pattern, if classes    */
+                               /* available, -1 otherwise                    */
+} pattern_descriptor;
+
+#ifdef __STDC__
+typedef double  FlintTypeParam;
+#else
+typedef float  FlintTypeParam;
+#endif
+
+
+
+/*#################################################
+
+GROUP: 3D-Kernel Definitions
+
+#################################################*/
+
+#define HAVE_QSORT
+
+struct   PosType  {
+  short  x,
+	 y,
+	 z;
+};
+
+
+
+#define  NO_OF_UNIT_CENTER_POS  1
+
+struct   PositionVector  {
+  float  x,
+	 y,
+	 z,
+	 w;
+};
+
+
+/* List of Inversion Units */
+struct UnitList{
+    int             no;
+    FlintType       act;
+    FlintType       i_act;
+    FlintType       im_act;
+    struct PosType  gridPos;
+    struct UnitList *next;
+    struct UnitList *prev;
+};
+
+/*#################################################
+
+GROUP: Constants for the parallel kernel
+
+#################################################*/
+
+/*  Topologic network types
+*/
+#define  NET_TYPE_GENERAL  0   /*  normal network presentation, no limitations  */
+#define  NET_TYPE_FF1      1   /*  feedforward net with limitations  */
+
+/*  MasPar modes
+*/
+#define  MASPAR_DISCONNECT  0
+#define  MASPAR_CONNECT  1
+
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/init_f.c snort-2.3.3.new/src/kernel_snns/init_f.c
--- snort-2.3.3/src/kernel_snns/init_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/init_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,2835 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/init_f.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Network Initialisation Functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 18.03.91
+
+  CHANGED BY     : Sven Doering, Ralf Huebner, Marc Seemann (Uni Tuebingen)
+  RCS VERSION    : $Revision: 2.23 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:30 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <math.h>
+#include <stdio.h>
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants             */
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel   */
+#include "kr_def.h"	 /*  Default Values                         */
+#include "kernel.h"	 /*  SNNS-Kernel Function Prototypes        */
+#include "glob_typ.h"    /*  Global Types                           */
+#include "random.h"	 /*  Randomize Library Function Prototypes  */
+#include "kr_mac.h"	 /*  Kernel Macros                          */
+#include "kr_art.h"      /*  Prototypes and global defs for ART     */
+#include "kr_art1.h"     /*  Prototypes and global defs for ART1    */
+#include "kr_art2.h"     /*  Prototypes and global defs for ART2    */
+#include "kr_amap.h"     /*  Prototypes and global defs for ARTMAP  */
+#include "krart_df.h"    /*  Definitions for ART functions          */
+#include "learn_f.h"     /*  For the RBF functions                  */
+#include "kr_ui.h"
+#include "cc_type.h"
+#include "cc_glob.h"      /* Definitions for cascade                 */
+#include "matrix.h"
+#include "kr_newpattern.h"
+
+#include "init_f.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_randomizeWeights
+
+  PURPOSE  : Initializes connection weights with uniform distributed 
+             random values.
+  RETURNS  : 
+  NOTES    : Function calls drand48(). <min> must be less then <max>.
+
+  UPDATE   : 05.04.94 by Sven Doering
+******************************************************************************/
+krui_err  INIT_randomizeWeights(float *parameterArray, int NoOfParams)
+{
+    register unsigned short    flags;
+    register struct Link   *link_ptr;
+    register struct Site   *site_ptr;
+    register struct Unit   *unit_ptr;
+    register FlintType     range, min_weight;
+    FlintType   max_weight;
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    min_weight = INIT_PARAM1( parameterArray );
+    max_weight = INIT_PARAM2( parameterArray ); 
+    range = max_weight - min_weight;
+
+    if (range == 0.0)  {
+	FOR_ALL_UNITS( unit_ptr )  {
+	    flags = unit_ptr->flags;
+
+	    if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+		&& (!IS_SPECIAL_UNIT(unit_ptr))) {
+		/*  unit is in use  */
+		unit_ptr->bias = min_weight;
+
+		if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES ) {
+		    /*  unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+			link_ptr->weight = min_weight;
+		}else{
+		    /*  unit has no sites   */
+		    if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS ) {
+			/*  unit has direct links   */
+			FOR_ALL_LINKS( unit_ptr, link_ptr )
+			    link_ptr->weight = min_weight;
+		    }
+		}
+	    }
+	}
+    } else  {
+	FOR_ALL_UNITS( unit_ptr )  {
+	    flags = unit_ptr->flags;
+
+	    if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE)
+		&& (!IS_SPECIAL_UNIT(unit_ptr))) {
+		/*  unit is in use  */
+		unit_ptr->bias = (FlintType) drand48() * range + min_weight;
+
+		if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES ) {
+		    /*  unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+			link_ptr->weight = 
+			    (FlintType)drand48() * range + min_weight;
+		} else  {
+		    /*  unit has no sites   */
+		    if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS ){
+			/*  unit has direct links   */
+			FOR_ALL_LINKS( unit_ptr, link_ptr )
+			    link_ptr->weight = 
+				(FlintType) drand48() * range + min_weight;
+		    }
+		}
+	    }
+	}
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_RM_randomizeWeights
+
+  PURPOSE  : Initializes connection weights between hidden units with uniform 
+             distributed random values. Connections from input units are not 
+	     changed. This kind of initialization is necessary for 
+	     autoassociative memory networks.
+  RETURNS  : 
+  NOTES    : Function calls drand48(). <min> must be less then <max>.
+
+  UPDATE   : 11.02.94
+******************************************************************************/
+krui_err  INIT_RM_randomizeWeights(float *parameterArray, int NoOfParams)
+{
+  register unsigned short    flags;
+  register struct Link   *link_ptr;
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+  register FlintType     range, min_weight;
+  FlintType   max_weight;
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) )
+    return( KRERR_NO_UNITS );  /*  there is nothing to do  */
+
+  min_weight = INIT_PARAM1( parameterArray );
+  max_weight = INIT_PARAM2( parameterArray ); 
+  range = max_weight - min_weight;
+
+  if (range == 0.0)  {
+    FOR_ALL_UNITS( unit_ptr )  {
+      flags = unit_ptr->flags;
+
+      if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE)
+	  && (!IS_SPECIAL_UNIT(unit_ptr)))
+        {  /*  unit is in use  */
+        unit_ptr->bias = min_weight;
+
+        if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES )
+          {  /*  unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+            if (!IS_INPUT_UNIT (link_ptr->to))
+              link_ptr->weight = min_weight;
+        }else
+          {       /*  unit has no sites   */
+          if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS )
+            {     /*  unit has direct links   */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+              if (!IS_INPUT_UNIT (link_ptr->to))
+              link_ptr->weight = min_weight;
+          }
+        }
+      }
+    }
+  }else  {
+    FOR_ALL_UNITS( unit_ptr )  {
+      flags = unit_ptr->flags;
+
+      if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE)
+	  && (!IS_SPECIAL_UNIT(unit_ptr)))
+        {     /*  unit is in use  */
+        unit_ptr->bias = (FlintType) drand48() * range + min_weight;
+
+        if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES )
+          {       /*  unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+            if (!IS_INPUT_UNIT (link_ptr->to))
+            link_ptr->weight = (FlintType) drand48() * range + min_weight;
+        }else  {
+          /*  unit has no sites   */
+          if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS )
+            {     /*  unit has direct links   */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+              if (!IS_INPUT_UNIT (link_ptr->to))
+              link_ptr->weight = (FlintType) drand48() * range + min_weight;
+          }
+        }
+      }
+    }
+  }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_randomizeWeights_perc
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  INIT_randomizeWeights_perc(float *parameterArray, int NoOfParams)
+{
+    register unsigned short    flags;
+    register struct Link   *link_ptr;
+    register struct Site   *site_ptr;
+    register struct Unit   *unit_ptr;
+    register FlintType     range, min_weight;
+    FlintType              max_weight;
+    FlintType              ar;
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    min_weight = INIT_PARAM1( parameterArray );
+    max_weight = INIT_PARAM2( parameterArray );
+    range = max_weight - min_weight;
+
+    /* compute no of predecessor Units */
+    FOR_ALL_UNITS( unit_ptr ){
+	unit_ptr->value_c=0.0;
+	FOR_ALL_LINKS( unit_ptr, link_ptr ){
+	    unit_ptr->value_c++;
+	}
+    }
+
+
+    if (range == 0.0)  {
+	FOR_ALL_UNITS( unit_ptr )  {
+	    flags = unit_ptr->flags;
+
+	    if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+		&& (!IS_SPECIAL_UNIT(unit_ptr))) {
+		/*  unit is in use  */
+		unit_ptr->bias = min_weight;
+
+		if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES ){
+		    /*  unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+			link_ptr->weight = min_weight;
+		} else  {
+		    /*  unit has no sites   */
+		    if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS ) {
+			/*  unit has direct links   */
+			FOR_ALL_LINKS( unit_ptr, link_ptr )
+			    link_ptr->weight = min_weight;
+		    }
+		}
+	    }
+	}
+    } else  {
+	FOR_ALL_UNITS( unit_ptr )  {
+	    flags = unit_ptr->flags;
+
+	    if ( ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+		&& (!IS_SPECIAL_UNIT(unit_ptr))) {
+		/*  unit is in use  */
+		unit_ptr->bias = 0.0;
+
+		if ( (flags & UFLAG_INPUT_PAT) == UFLAG_SITES ){
+		    /*  unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+			ar = unit_ptr->value_c ;
+			link_ptr->weight = 
+			    (FlintType) drand48() * 
+			    (max_weight/ar - min_weight/ar) + (min_weight/ar);
+		    }
+		} else  {
+		    /*  unit has no sites   */
+		    if ( (flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS ){
+			/*  unit has direct links   */
+
+			FOR_ALL_LINKS( unit_ptr, link_ptr ) {
+			    ar = unit_ptr->value_c ;
+			    link_ptr->weight = 
+				(FlintType) drand48() * 
+				(max_weight/ar - min_weight/ar) + 
+				(min_weight/ar);
+			}
+		    }
+		}
+	    }
+	}
+    }
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_Weights_CPNv32
+
+  PURPOSE  : Old (Version 3.2) style initialization. Initialization vectors are
+             taken from the RECTANGLE bounded by param1 and param2.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_Weights_CPNv32(float *parameterArray, int NoOfParams)
+{
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray  topo_ptr;
+    register FlintType  sum, amount, range;
+    FlintType min, max;
+    int  ret_code;
+
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    min = INIT_PARAM1( parameterArray );
+    max = INIT_PARAM2( parameterArray );
+    if(max < min){
+	range = min; min = max; max = range;
+    }
+    range = max - min;
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+
+    /*  initialize weights of the hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/*  this is a hidden unit  */
+
+	/*     initialize the weights to the Kohonen Layer         */
+	sum = 0.0;
+	if UNIT_HAS_SITES( unit_ptr ){
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )  {
+		link_ptr->weight = (FlintType) drand48() * range + min;
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+	}else{
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )  {
+		link_ptr->weight = (FlintType) drand48() * range + min;
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+	}
+
+	/* normalize the weightvector to the Kohonen Layer */
+	amount = 1.0 / sqrt( sum );
+
+	if UNIT_HAS_SITES( unit_ptr )
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		link_ptr->weight = link_ptr->weight * amount;
+	else
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		link_ptr->weight = link_ptr->weight * amount;
+    }
+
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/* this is a output unit */
+
+	/*     initialize the weights to the Grossberg Layer       */
+	if UNIT_HAS_SITES( unit_ptr ){
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		link_ptr->weight = (FlintType) drand48() * range + min;
+	}else{
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		link_ptr->weight = (FlintType) drand48() * range + min;
+	}
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_Weights_CPNv33
+
+  PURPOSE  : New (Version 3.3) style initialization. Initialization vectors are
+             taken from the CIRCLE bounded by param1 and param2.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_Weights_CPNv33(float *parameterArray, int NoOfParams)
+{
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray  topo_ptr;
+    register FlintType  sum, amount, range, intervall;
+    FlintType min, max, offset;
+    int  ret_code;
+
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    min = INIT_PARAM1( parameterArray );
+    max = INIT_PARAM2( parameterArray );
+    range = max - min;
+    if (((min < 0.0)) && ((max < 0.0)))
+    { intervall = 1.0; offset = -1.0;
+    } else if (((min < 0.0)) && (!(max < 0.0)))
+    { intervall = 2.0; offset = -1.0;
+    } else if ((!(min < 0.0)) && ((max < 0.0)))
+    { intervall = 2.0; offset = -1.0;
+    } else if ((!(min < 0.0)) && (!(max < 0.0)))
+    { intervall = 1.0; offset = 0.0;
+    }
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+
+    /*  initialize weights of the hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/*  this is a hidden unit  */
+
+	/*     initialize the weights to the Kohonen Layer         */
+	if UNIT_HAS_SITES( unit_ptr ){
+	    /* the unit has sites */
+          do { sum = 0.0;
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )  {
+		link_ptr->weight = (FlintType) drand48() * intervall + offset;
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+          } while ((sum > 1.0) || (sum == 0.0));
+	}else{
+	    /* the unit has direct links */
+          do { sum = 0.0;
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )  {
+		link_ptr->weight = (FlintType) drand48() * intervall + offset;
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+          } while ((sum > 1.0) || (sum == 0.0));
+	}
+
+	/* normalize the weightvector to the Kohonen Layer */
+	amount = 1.0 / sqrt( sum );
+
+	if UNIT_HAS_SITES( unit_ptr )
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		link_ptr->weight = link_ptr->weight * amount;
+	else
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		link_ptr->weight = link_ptr->weight * amount;
+    }
+
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/* this is a output unit */
+
+	/*     initialize the weights to the Grossberg Layer       */
+	if UNIT_HAS_SITES( unit_ptr ){
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		link_ptr->weight = (FlintType) drand48() * range + min;
+	}else{
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		link_ptr->weight = (FlintType) drand48() * range + min;
+	}
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : INIT_Weights_CPN_Rand_Pat
+
+  PURPOSE  : Initializes all weight vectors of the Kohonen layer with
+  random input patterns from the training set. The weights of the
+  Grossberg layer are all initialized to 1. 
+
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_Weights_CPN_Rand_Pat(float *parameterArray, int NoOfParams)
+{
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray  topo_ptr;
+    krui_err ret_code;
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    /* test if patterns available and valid:			*/
+    if (kr_TotalNoOfSubPatPairs() == 0)  
+	return( KRERR_NO_PATTERNS );	/* no patterns defined  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE))
+    {
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    /*  initialize weights of the hidden units  */
+
+    /* random initialization of Kohonen layer, the parameters are:
+     * use all patterns (0, kr_TotalNoOfPattern() - 1)
+     * unused learning rate (0.0)
+     * no learning cycles (0)
+     * shuffle pattern flag (1)
+     */
+    ret_code = RbfKohonenInit(0, kr_TotalNoOfPattern() - 1, 0.0, 0, 1);
+    if (ret_code != KRERR_NO_ERROR)
+	return ret_code;
+
+    /* now initialize the Grossberg layer with 1.0 weights: */
+    topo_ptr = topo_ptr_array + (NoOfInputUnits + NoOfHiddenUnits + 2);
+    while ((unit_ptr = *++topo_ptr) != NULL)
+    {
+	/* this is an output unit */
+
+	/* initialize the weights to the Grossberg Layer */
+	if UNIT_HAS_SITES( unit_ptr )
+	{
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		link_ptr->weight = (FlintType) 1.0;
+	}
+	else
+	{
+	    /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		link_ptr->weight = (FlintType) 1.0;
+	}
+    }
+
+    return KRERR_NO_ERROR;
+}
+
+/*****************************************************************************
+  FUNCTION : RbfInitSetCenter
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    : The pattern is loaded into the input layer and propagated to the 
+             output of the INPUT layer. After that, the weights of the links 
+	     leading to the <hidden_unit> are set to the output values of the 
+	     corresponding input units. (A center of a RBF is set).
+	     The value of <deviation> is used for symmetry breaking: it gives 
+	     the percentage of the maximum random change of the input pattern. 
+	     deviation 1.0 means 100% which means that an input value of x will
+	     lead to a stored weight between 0.0 and 2*x. A value of 0.0 will 
+	     not change the weights!
+	     The bias of the <hidden_unit> is set to 1.0 (parameter of the RBF)
+
+  UPDATE   : 
+******************************************************************************/
+void RbfInitSetCenter(int pattern_no, int sub_pat_no, 
+		      struct Unit *hidden_unit, float deviation, float bias)
+{
+    register struct Unit	*unit_ptr;
+    register struct Link	*link_ptr;
+    register Patterns	current_in_pattern;
+    register TopoPtrArray	topo_ptr;
+
+    /* calculate index of the input pattern in Pattern array:	*/
+    current_in_pattern = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    /* activate input units with the pattern and calculate the output value */
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *(++topo_ptr)) != NULL){
+
+	/* go through all input units, set activation and calculate output: */
+	unit_ptr -> act = *current_in_pattern++;
+	unit_ptr -> Out.output = unit_ptr -> out_func == OUT_IDENTITY 
+	    ? unit_ptr -> act : (*unit_ptr -> out_func) (unit_ptr -> act);
+    }
+
+    /* set the weights of the links: */
+    if (deviation == 0.0){
+	FOR_ALL_LINKS(hidden_unit, link_ptr){
+	    link_ptr -> weight = link_ptr -> to -> Out.output;
+	}
+    }else{
+	deviation /= 6.3137515;
+	FOR_ALL_LINKS(hidden_unit, link_ptr){
+	    link_ptr->weight = link_ptr->to->Out.output *
+		(1.0 + deviation * 
+		 tan(((float)drand48() * 2.8274334 - 1.4137167)));
+	}
+    }
+
+    hidden_unit->bias = bias;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : RbfInitBPCenter 
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    : The weights of the links leading to the <hidden_unit> are 
+             propagated back to the Output value of the corresponding input 
+	     units. Only the Out.output of the input units is set. The 
+	     activation remains unchanged.
+
+  UPDATE   : 
+******************************************************************************/
+void RbfInitBPCenter(struct Unit *hidden_unit)
+{
+    register struct Link	*curr_link;
+
+    FOR_ALL_LINKS(hidden_unit, curr_link){
+	curr_link -> to -> Out.output = curr_link -> weight;
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : RbfInitNetwork
+
+  PURPOSE  : Initialization Function for Use of Radial Basis Functions
+  RETURNS  : 
+  NOTES    : First initialization of centers and direct calculation of all 
+             weights as first step during learning.
+	     The initialization of a center consists of setting the 
+	     coordinates of the center (the weights of the links, leading to 
+	     it) and setting the RBF function parameter (bias of the unit) to 
+	     i_bias.
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  RbfInitNetwork(int start_pat, int end_pat, float i_bias, 
+			 float i_devi, float i_f_0, float i_f_1, 
+			 float i_smooth, int init_type)
+{
+    register struct Unit    *unit_ptr;
+    register struct Unit    *h_unit_ptr;
+    register struct Link    *link_ptr;
+    register Patterns       current_out_pattern;
+    register TopoPtrArray   topo_ptr;
+    register TopoPtrArray   topo_hidden_ptr;
+    register TopoPtrArray   topo_work;
+    register int	    hidden_units;
+    register int	    output_units;
+    register int	    unit_nr;
+    register int	    h_unit_nr;
+    register int	    abs_sub_nr;
+    register int	    pattern_anz;
+    int	                    pattern_no;
+    int                     sub_pat_no;
+    register float	    deviation;
+    register int	    abort;
+    register int	    tmp_err;
+    register int            start_sp;
+    register int            end_sp;
+
+    RbfFloatMatrix	    hidden_act;
+    RbfFloatMatrix	    t_hidden_act;
+    RbfFloatMatrix	    hidden_produkt;
+    RbfFloatMatrix	    inter_act;
+    RbfFloatMatrix	    hidden_sum;
+    RbfFloatMatrix	    m_p_inverse;
+    RbfFloatMatrix	    y_vektor;
+    RbfFloatMatrix	    weights_vektor;
+#ifdef RBF_MATRIX_TEST
+    RbfFloatMatrix	    alt_hidden_sum;
+    RbfFloatMatrix	    soll_einheit_sein;
+    int			    s,z;
+#endif
+    int			    malloc_fault;
+
+
+    abort = FALSE;
+
+    if (init_type == RBF_INIT_FULL){
+	fprintf(stderr,"RBF_Weights called, start initialization:\n");
+    }else{
+	fprintf(stderr,"RBF_Weights_Redo called, start initialization:\n");
+    }
+	
+    fprintf(stderr, "... preparing initialization\n");
+
+    /* count the units of the hidden layer (only one) and the output layer */
+    hidden_units = 0;
+    output_units = 0;
+    FOR_ALL_UNITS(unit_ptr){
+	if ((unit_ptr -> flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+	    if (unit_ptr -> flags & UFLAG_TTYP_HIDD)
+		hidden_units++;
+	    if (unit_ptr -> flags & UFLAG_TTYP_OUT)
+		output_units++; 
+	}
+    }
+
+    /* set <unit_ptr> to the NULL between first hidden and last input unit: */
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *(++topo_ptr)) != NULL);	/* empty loop!	*/
+
+    /* reference to first hidden unit */
+    topo_hidden_ptr = topo_ptr;
+    topo_hidden_ptr++;
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pat,end_pat);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+    {
+	if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+	    KernelErrorCode = KRERR_NP_WORKAROUND;
+	return (KernelErrorCode);
+    }
+    start_sp = kr_AbsPosOfFirstSubPat(start_pat);
+    end_sp = kr_AbsPosOfFirstSubPat(end_pat) + kr_NoOfSubPatPairs(end_pat) - 1;
+    pattern_anz = end_sp - start_sp + 1;
+
+    /* Output bias is treated as additional hidden unit	*/
+    hidden_units += 1;
+
+    /* Allocate memory for all matrixes: */
+    malloc_fault = 0;
+    if (!RbfAllocMatrix(pattern_anz, hidden_units, &hidden_act))
+	malloc_fault = 0;
+    else if (!RbfAllocMatrix(hidden_units, pattern_anz, &t_hidden_act))
+	malloc_fault = 1;
+    else if (!RbfAllocMatrix(hidden_units, hidden_units, &hidden_produkt))
+	malloc_fault = 2;
+    else if (!RbfAllocMatrix(hidden_units, hidden_units, &inter_act))
+	malloc_fault = 3;
+    else if (!RbfAllocMatrix(hidden_units, hidden_units, &hidden_sum))
+	malloc_fault = 4;
+    else if (!RbfAllocMatrix(pattern_anz, 1, &y_vektor))
+	malloc_fault = 5;
+    else if (!RbfAllocMatrix(hidden_units, 1, &weights_vektor))
+	malloc_fault = 6;
+    else if (!RbfAllocMatrix(hidden_units, pattern_anz, &m_p_inverse))
+	malloc_fault = 7;
+#ifdef RBF_MATRIX_TEST
+    else if (!RbfAllocMatrix(hidden_units, hidden_units, &alt_hidden_sum))
+	malloc_fault = 8;
+    else if (!RbfAllocMatrix(hidden_units,hidden_units,&soll_einheit_sein))
+	malloc_fault = 9;
+#endif
+
+
+    if (malloc_fault != 0){
+	if (malloc_fault >= 1)
+	    RbfFreeMatrix(&hidden_act);
+	if (malloc_fault >= 2)
+	    RbfFreeMatrix(&t_hidden_act);
+	if (malloc_fault >= 3)
+	    RbfFreeMatrix(&hidden_produkt);
+	if (malloc_fault >= 4)
+	    RbfFreeMatrix(&inter_act);
+	if (malloc_fault >= 5)
+	    RbfFreeMatrix(&hidden_sum);
+	if (malloc_fault >= 6)
+	    RbfFreeMatrix(&y_vektor);
+	if (malloc_fault >= 7)
+	    RbfFreeMatrix(&weights_vektor);
+#ifdef RBF_MATRIX_TEST
+	if (malloc_fault >= 8)
+	    RbfFreeMatrix(&alt_hidden_sum);
+	if (malloc_fault >= 9)
+	    RbfFreeMatrix(&soll_einheit_sein);
+#endif
+
+	return KRERR_INSUFFICIENT_MEM;
+    }
+
+    /* change the following line into '#if 1' to allow deviation only in  */
+    /* case that there are more hidden units than learn patterns	  */
+#if 0
+    /* test if more hidden units than learn patterns: */
+    if (hidden_units - 1 >= pattern_anz){
+
+	/* more hidden units than learn patterns symmetry breaking necessary!*/
+	deviation = i_devi;	/* maximum change = i_devi * activation	*/
+    }else{
+	/* less hidden units than learn patterns; no symmetry breaking	*/
+	deviation = 0.0;       
+    }
+#else
+    /* set deviation to parameter */
+    deviation = i_devi;
+	
+#endif
+
+    fprintf(stderr,"... compute activation of hidden layer on centers\n");
+
+    /* Now set the centers and fill the inter activation matrix: */
+    unit_nr = 0;
+    while ((unit_ptr = *(++topo_ptr)) != NULL){
+	/* set weights of links leading to <unit_ptr>: */
+	if (init_type == RBF_INIT_FULL){
+	    abs_sub_nr = (((pattern_anz-1)*unit_nr)/(hidden_units-2)) + 
+		         start_sp;
+	    kr_getSubPatternByNo(&pattern_no, &sub_pat_no, abs_sub_nr);
+	    RbfInitSetCenter(pattern_no, sub_pat_no, unit_ptr, 
+			     deviation, i_bias);
+	}else{
+	    RbfInitBPCenter(unit_ptr);
+	}
+
+	/* calculate activation of previously defined centers on the current */
+	/* pattern and store it into the inter activation matrix:	     */
+	topo_work = topo_hidden_ptr;
+	for (h_unit_nr = 0; h_unit_nr <= unit_nr; h_unit_nr++){
+	    h_unit_ptr = *(topo_work++);
+
+	    /* calculate activation: */
+	    h_unit_ptr -> act = h_unit_ptr -> Out.output =
+		(*h_unit_ptr -> act_func) (h_unit_ptr);
+
+	    /* store it into the symmetric matrix: */
+	    RbfMatrixSetValue(&inter_act, h_unit_nr, unit_nr,
+			      h_unit_ptr -> act * i_smooth);
+	    RbfMatrixSetValue(&inter_act, unit_nr, h_unit_nr,
+			      h_unit_ptr -> act * i_smooth);
+	}
+	unit_nr++;
+    }
+	
+    /* Add entrys for the additional bias: */
+    for (h_unit_nr = 0; h_unit_nr < hidden_units; h_unit_nr++){
+	RbfMatrixSetValue(&inter_act, h_unit_nr, hidden_units - 1, 
+			  i_smooth);
+	RbfMatrixSetValue(&inter_act, hidden_units - 1, h_unit_nr,
+			  i_smooth);
+    }
+
+    fprintf(stderr,"... compute activation of hidden layer on patterns\n");
+
+    /* Fill the hidden units activation matrix */
+    for (abs_sub_nr = start_sp; abs_sub_nr <= end_sp; abs_sub_nr++){
+	kr_getSubPatternByNo(&pattern_no, &sub_pat_no, abs_sub_nr);
+	RbfLearnForward(pattern_no, sub_pat_no);
+	topo_ptr = topo_hidden_ptr;
+	for (unit_nr = 0; unit_nr < hidden_units - 1; unit_nr++){
+	    RbfMatrixSetValue(&hidden_act, abs_sub_nr - start_sp, unit_nr,
+			      (*(topo_ptr++)) -> Out.output);
+	}
+    }
+	
+    /* Add entrys for the additional bias: */
+    for (h_unit_nr = 0; h_unit_nr < pattern_anz; h_unit_nr++){
+	RbfMatrixSetValue(&hidden_act, h_unit_nr, hidden_units - 1, 1.0);
+    }
+	
+    fprintf(stderr,"... calculate the moore-penrose inverse matrix\n");
+
+    /* Now calculate the Moore-Penrose Pseudoinverse: */
+    fprintf(stderr,"...... transposing\n");
+    RbfTranspMatrix(&t_hidden_act, &hidden_act);
+    fprintf(stderr,"...... multiplying\n");
+    RbfMulTranspMatrix(&hidden_produkt, &t_hidden_act);
+    fprintf(stderr,"...... adding\n");
+    RbfAddMatrix(&hidden_sum, &hidden_produkt, &inter_act);
+
+#ifdef RBF_MATRIX_TEST
+    RbfSetMatrix(&alt_hidden_sum, &hidden_sum);
+#endif
+
+    fprintf(stderr,"...... inverting\n");
+    if ((tmp_err = RbfInvMatrix(&hidden_sum)) != 1){
+	fprintf(stderr,"... impossible to invert matrix!\n");
+	abort = TRUE;
+    }
+
+#ifdef RBF_MATRIX_TEST
+    RbfMulMatrix(&soll_einheit_sein, &alt_hidden_sum, &hidden_sum);
+    printf("Einheitsmatrix:\n");
+    RbfPrintMatrix(&soll_einheit_sein, stdout);
+#endif
+
+    if (!abort){
+	fprintf(stderr,"...... multiplying\n");
+	RbfMulMatrix(&m_p_inverse, &hidden_sum, &t_hidden_act);
+
+	fprintf(stderr,
+		"... calculate weights between hidden and output layer\n");
+	
+	/* set topo_ptr to the NULL between hidden and output layer: */
+	topo_ptr = topo_hidden_ptr;
+	while(*(++topo_ptr) != NULL);
+
+	/* direct calc. of all weights of links leading to the output layer: */
+	unit_nr = 0;  /* counts the output units */
+	while((unit_ptr = *(++topo_ptr)) != NULL){
+
+	    /* fill the y_vektor with the desired outputs for all patterns: */
+	    for (abs_sub_nr = start_sp; abs_sub_nr <= end_sp; abs_sub_nr++){
+		kr_getSubPatternByNo(&pattern_no, &sub_pat_no, abs_sub_nr);
+		current_out_pattern = kr_getSubPatData(pattern_no,
+						       sub_pat_no,
+						       OUTPUT, NULL);
+		RbfMatrixSetValue(&y_vektor, abs_sub_nr - start_sp, 0,
+				  i_f_0 + (i_f_1 - i_f_0)*
+				  *(current_out_pattern + unit_nr));
+	    }
+
+	    /* calculate the weights, leading to the current output unit*/
+	    RbfMulMatrix(&weights_vektor, &m_p_inverse, &y_vektor);
+
+	    /* temporarely store the weights in the value_c field of	*/
+	    /* the corresponding hidden units:				*/
+	    topo_work = topo_hidden_ptr;
+	    h_unit_nr = 0;
+	    do {
+		(*(topo_work++)) -> value_c = 
+		    RbfMatrixGetValue(&weights_vektor, h_unit_nr++, 0); 
+	    } while (*topo_work != NULL);
+
+	    /* set the bias of the output unit:	*/
+	    unit_ptr->bias = 
+		RbfMatrixGetValue(&weights_vektor, hidden_units - 1, 0);
+
+	    /* set the weights of the links: */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		link_ptr -> weight = link_ptr -> to -> value_c;
+	    }
+	    unit_nr++;
+	}
+
+	fprintf(stderr,"Initialization done !\n");
+    }else{
+	if (tmp_err == 0)
+	    fprintf(stderr,"singular matrix !\n");
+	fprintf(stderr,"Initialization aborted !\n");
+    }
+    RbfFreeMatrix(&hidden_act);
+    RbfFreeMatrix(&t_hidden_act);
+    RbfFreeMatrix(&hidden_produkt);
+    RbfFreeMatrix(&inter_act);
+    RbfFreeMatrix(&hidden_sum);
+    RbfFreeMatrix(&y_vektor);
+    RbfFreeMatrix(&weights_vektor);
+    RbfFreeMatrix(&m_p_inverse);
+
+    if (abort){
+	return tmp_err == 0 ? KRERR_NO_ERROR : tmp_err;
+    }else{
+	return KRERR_NO_ERROR;
+    }
+}
+
+
+
+#ifdef RBF_INCLUDE_KOHONEN_CONVEX
+/*****************************************************************************
+  FUNCTION : RbfKohonenConvexInit
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void RbfKohonenConvexInit(int start_pattern,int end_pattern,float alpha_start,
+			  float alpha_increment,float learn_rate,int count)
+{
+	register float		scalar_prod;	/* act. scalar product	*/
+	register float		maximum;	/* max scalar product	*/
+	register struct Link	*link_ptr;	/* current Link		*/
+	register struct Unit	*unit_ptr;	/* current Unit		*/
+	register TopoPtrArray	topo_ptr;
+	register Patterns	current_in_pattern;	/* in pattern	*/
+	register int		pattern_no;
+	register int            sub_pat_no;
+	register TopoPtrArray	topo_hidden_ptr;/* first hidden Unit	*/
+	register float		alpha;		/* convex combination	*/
+	register struct Unit	*winner;	/* Unit who's links	*/
+						/* change		*/
+	register float		norm_alpha;	/* convex combination	*/
+	float			norm_init;	/* initialization value	*/
+	
+	/* search for the first hidden unit				*/
+	topo_ptr = topo_ptr_array;
+	while (*(++topo_ptr) != NULL);		/* empty loop!		*/
+
+	/* reference to first hidden unit				*/
+	topo_hidden_ptr = topo_ptr;
+	topo_hidden_ptr++;
+
+	/* initialize all weights leading to hidden units		*/
+	norm_init = 1.0 / (float) sqrt((float) NoOfInputUnits);
+	while ((unit_ptr = *(++topo_ptr)) != NULL)
+	{
+	    FOR_ALL_LINKS(unit_ptr, link_ptr)
+	    {
+		link_ptr -> weight = norm_init;
+	    }
+	}
+
+	/* do the kohonen training <count> times with increasing alpha	*/
+	for (alpha = alpha_start; count > 0; alpha += alpha_increment, count--)
+	{
+	    /* precalculate the constant value for the convex		*/
+	    /* combination method for the current alpha			*/
+	    norm_alpha = (1.0 - alpha) * norm_init;
+
+	    /* compute the necessary sub patterns */
+	    KernelErrorCode = kr_initSubPatternOrder(start_pattern,
+						     end_pattern);
+	    if(KernelErrorCode != KRERR_NO_ERROR)
+	    {
+		if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+		    KernelErrorCode = KRERR_NP_WORKAROUND;
+		return (KernelErrorCode);
+	    }
+
+	    /* present all input patterns and train the hidden layer */
+	    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no))
+	    {
+		/* calculate index of first component of input pattern */
+		current_in_pattern = kr_getSubPatData(pattern_no,
+						      sub_pat_no,
+						      INPUT, NULL);
+
+		/* activate input units with the pattern and calculate	*/
+		/* their output value:					*/
+		topo_ptr = topo_ptr_array;
+		while ((unit_ptr = *(++topo_ptr)) != NULL)
+		{
+		    /* go through all input units, set activation and	*/
+		    /* calculate output using the convex combination	*/
+		    /* method						*/
+		    unit_ptr -> act = *current_in_pattern++;
+		    unit_ptr -> Out.output = unit_ptr->out_func==OUT_IDENTITY 
+			? alpha * (unit_ptr -> act) + norm_alpha
+			: alpha * ((*unit_ptr -> out_func) (unit_ptr -> act))
+				+ norm_alpha;
+		}
+
+		/* determine the hidden unit with maximum scalar product*/
+		/* between its weights and the output of the input layer*/
+		winner = (struct Unit *) NULL;
+		maximum = (float) -MY_HUGE_VAL;	/* -oo, see init_f.ph	*/
+		topo_ptr = topo_hidden_ptr;
+		while ((unit_ptr = *(topo_ptr++)) != NULL)
+		{
+		    /* calculate scalar product of current hidden unit	*/
+		    scalar_prod = (float) 0.0;
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+		    {
+			scalar_prod += link_ptr -> weight * 
+				link_ptr -> to -> Out.output;
+		    }
+
+		    /* change winner if s.p. is > than the current best	*/
+		    if (scalar_prod > maximum)
+		    {
+			maximum = scalar_prod;
+			winner = unit_ptr;
+		    }
+		}
+
+		/* adjust weights of the hidden winner Unit		*/
+		if (winner != NULL)
+		{
+		    FOR_ALL_LINKS(winner, link_ptr)
+		    {
+			link_ptr -> weight += learn_rate * 
+			    (link_ptr->to->Out.output - link_ptr->weight);
+		    }
+		    printf("(%d,%d) ", winner -> unit_pos.x, 
+			winner -> unit_pos.y); 
+		}
+		else
+		{
+		    fprintf(stderr,"Internal error in RbfKohonenConvexInit\n");
+		}
+	    }
+	}
+}
+
+#endif
+
+krui_err RbfKohonenInit(int start_pattern, int end_pattern, float learn_rate, int count, int shuffle)
+{
+	register float		scalar_prod;	/* act. scalar product	*/
+	register float		maximum;	/* max scalar product	*/
+	register struct Link	*link_ptr;	/* current Link		*/
+	register struct Unit	*unit_ptr;	/* current Unit		*/
+	register TopoPtrArray	topo_ptr;
+	register Patterns	current_in_pattern;	/* in pattern	*/
+	int	         	pattern_no;
+	int                     sub_pat_no;
+	register int            start_sp;
+	register int            end_sp;
+	register int            act_sub_nr;
+	register TopoPtrArray	topo_hidden_ptr;/* first hidden Unit	*/
+	register TopoPtrArray	help_topo_ptr;
+	register struct Unit	*winner;	/* Unit who's links	*/
+						/* change		*/
+	float			norm_init;	/* initialization value	*/
+	register struct Unit	*hidden_unit;	/* current hidden unit	*/
+	register int		hidden_units;	/* number of hidden u.	*/
+	register int		act_hidden_num;	/* number of current hu.*/
+	int			reshuffle;	/* restore shuffled p.	*/
+
+#ifdef RBF_DEBUG
+	fprintf(stderr, "RBF_Weights_Kohonen called, start initialization:\n");
+#endif
+
+	/* search for the first hidden unit				*/
+	topo_ptr = topo_ptr_array;
+	while (*(++topo_ptr) != NULL);		/* empty loop!		*/
+
+	/* count hidden units and reference to first hidden unit	*/
+	topo_hidden_ptr = topo_ptr;
+	hidden_units = 0;
+	while (*(++topo_hidden_ptr) != NULL)
+		hidden_units++;
+	topo_hidden_ptr = topo_ptr;
+	topo_hidden_ptr++;
+
+	if (shuffle)
+	{
+	    reshuffle = FALSE;
+	    if (!kr_np_pattern(GET_SHUFFLE_FLAG, 0, 0))
+	    {
+		kr_np_pattern(PATTERN_SHUFFLE_ON, 0, 0);
+		reshuffle = TRUE;
+	    }
+	}
+
+	/* compute the necessary sub patterns */
+	KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+	if(KernelErrorCode != KRERR_NO_ERROR)
+	{
+	    if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+		KernelErrorCode = KRERR_NP_WORKAROUND;
+	    return (KernelErrorCode);
+	}
+
+	start_sp = kr_AbsPosOfFirstSubPat(start_pattern);
+	end_sp = kr_AbsPosOfFirstSubPat(end_pattern) + 
+	    kr_NoOfSubPatPairs(end_pattern) - 1;
+	
+#ifdef RBF_DEBUG
+	fprintf(stderr, "... init weights between input and hidden layer\n");
+#endif
+
+	/* initialize all weights leading to hidden units		*/
+	norm_init = 1.0 / (float) sqrt((float) NoOfInputUnits);
+	act_hidden_num = 0;
+	while ((hidden_unit = *(++topo_ptr)) != NULL)
+	{
+	    if (shuffle)
+	    {
+		/* shuffle						*/
+		if (!kr_getSubPatternByOrder(&pattern_no, &sub_pat_no))
+		    return KRERR_PATTERN_NO;
+	    }
+	    else
+	    {
+		/* do not shuffle					*/
+		act_sub_nr = start_sp + 
+		    ((end_sp-start_sp) * act_hidden_num) / (hidden_units - 1);
+		if (!kr_getSubPatternByNo(&pattern_no, &sub_pat_no, 
+					  act_sub_nr))
+		    return KRERR_PATTERN_NO;
+	    }
+
+	    /* calculate index of input pattern */
+	    current_in_pattern = kr_getSubPatData(pattern_no,
+						  sub_pat_no, INPUT,
+						  NULL);
+
+	    /* activate input units with the pattern and calculate	*/
+	    /* their output value:					*/
+	    help_topo_ptr = topo_ptr_array;
+	    while ((unit_ptr = *(++help_topo_ptr)) != NULL)
+	    {
+		/* go through all input units, set activation and	*/
+		/* calculate output using the convex combination	*/
+		/* method						*/
+		unit_ptr -> act = *current_in_pattern++;
+		unit_ptr -> Out.output = unit_ptr->out_func==OUT_IDENTITY 
+			? (unit_ptr -> act)
+			: ((*unit_ptr -> out_func) (unit_ptr -> act));
+	    }
+
+	    FOR_ALL_LINKS(hidden_unit, link_ptr)
+	    {
+		link_ptr -> weight = link_ptr -> to -> Out.output;
+	    }
+
+	    act_hidden_num++;
+	}
+
+	if (shuffle && reshuffle)
+	{
+	    kr_np_pattern(PATTERN_SHUFFLE_OFF, 0, 0);
+	}
+
+	/* do the kohonen training <count> times			*/
+#ifdef RBF_DEBUG
+	if (count > 0)
+	{
+	   fprintf(stderr, "... begin kohonen training\n");
+	}
+#endif
+	for (; count > 0; count--)
+	{
+	    /* compute the necessary sub patterns */
+	    KernelErrorCode = kr_initSubPatternOrder(start_pattern, 
+						     end_pattern);
+	    if(KernelErrorCode != KRERR_NO_ERROR)
+	    {
+		if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+		    KernelErrorCode = KRERR_NP_WORKAROUND;
+		return (KernelErrorCode);
+	    }
+
+	    /* present all input patterns and train the hidden layer	*/
+	    while(kr_getSubPatternByOrder(&pattern_no, &sub_pat_no))
+	    {
+		/* calculate index of input pattern */
+		current_in_pattern = kr_getSubPatData(pattern_no,
+						      sub_pat_no,
+						      INPUT, NULL);
+
+		/* activate input units with the pattern and calculate	*/
+		/* their output value:					*/
+		topo_ptr = topo_ptr_array;
+		while ((unit_ptr = *(++topo_ptr)) != NULL)
+		{
+		    /* go through all input units, set activation and	*/
+		    /* calculate output using the convex combination	*/
+		    /* method						*/
+		    unit_ptr -> act = *current_in_pattern++;
+		    unit_ptr -> Out.output = unit_ptr->out_func==OUT_IDENTITY 
+			? (unit_ptr -> act)
+			: ((*unit_ptr -> out_func) (unit_ptr -> act));
+		}
+
+		/* determine the hidden unit with maximum scalar product*/
+		/* between its weights and the output of the input layer*/
+		winner = (struct Unit *) NULL;
+		maximum = (float) -MY_HUGE_VAL;	/* -oo, see init_f.ph	*/
+		topo_ptr = topo_hidden_ptr;
+		while ((unit_ptr = *(topo_ptr++)) != NULL)
+		{
+		    /* calculate scalar product of current hidden unit	*/
+		    scalar_prod = (float) 0.0;
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+		    {
+			scalar_prod += link_ptr -> weight * 
+				link_ptr -> to -> Out.output;
+		    }
+
+		    /* change winner if s.p. is > than the current best	*/
+		    if (scalar_prod > maximum)
+		    {
+			maximum = scalar_prod;
+			winner = unit_ptr;
+		    }
+		}
+
+		/* adjust weights of the hidden winner Unit		*/
+		if (winner != NULL)
+		{
+		    FOR_ALL_LINKS(winner, link_ptr)
+		    {
+			link_ptr -> weight += learn_rate * 
+			    (link_ptr->to->Out.output - link_ptr->weight);
+		    }
+		}
+		else
+		{
+		    fprintf(stderr,"Internal error in RbfKohonenConvexInit\n");
+		}
+	    }
+	}
+#ifdef RBF_DEBUG
+	fprintf(stderr, "Initialization done\n");
+#endif
+	return KRERR_NO_ERROR;
+}
+
+krui_err RbfStartInit(float *parameterArray, int NoOfParams, int init_type)
+{
+	krui_err	ret_code;	/* error return code		*/
+	float		bias;		/* bias of hidden units		*/
+	float		deviation;	/* deviation of centers		*/
+	float		f_0_lin;	/* learning value for pattern==0*/
+	float		f_1_lin;	/* learning value for pattern==1*/
+	float		smoothness;	/* see documentation 		*/
+
+	float		learn_rate;	/* kohonen training rate	*/
+	int		count;		/* cycles for kohonen training  */
+
+	/* for future use, now uncommented: 				*/
+	/* check the number of input parameters				*/
+
+	/* test if patterns available and valid:			*/
+	if (kr_TotalNoOfSubPatPairs() == 0)  
+	    return( KRERR_NO_PATTERNS );	/* no patterns defined  */
+
+	/* test net topology:						*/
+	if (NetModified || (TopoSortID != TOPOLOGICAL_FF))
+	{
+	    ret_code = RbfTopoCheck();	/* in learn_f.c			*/
+
+	    if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+		return( ret_code );
+
+	    NetModified = FALSE;
+	}
+
+	switch(init_type)
+	{
+	    case RBF_INIT_FULL:
+	    case RBF_INIT_REINIT:
+		/* read input parameters:				*/
+		bias = INIT_PARAM4(parameterArray);
+		deviation = INIT_PARAM5(parameterArray);
+		f_0_lin = INIT_PARAM1(parameterArray);
+		f_1_lin = INIT_PARAM2(parameterArray);
+		smoothness = INIT_PARAM3(parameterArray);
+
+		/* call real initialization function:			*/
+		ret_code = RbfInitNetwork(0, kr_TotalNoOfPattern() - 1, bias, 
+			deviation, f_0_lin, f_1_lin, smoothness, init_type);
+		break;
+
+	    case RBF_INIT_KOHONEN:
+		/* read input parameters:				*/
+		count = (int) (INIT_PARAM1(parameterArray));
+		learn_rate = INIT_PARAM2(parameterArray);
+		ret_code = RbfKohonenInit(0, kr_TotalNoOfPattern() - 1,
+					  learn_rate, count, 
+					  INIT_PARAM3(parameterArray) != 0.0);
+		break;
+	}
+
+	return ret_code;
+}
+
+/*
+ * Use of initialization parameters:
+ * RBF_Weights: (5)
+ *   INIT_PARAM1: interpolation value for teaching pattern == 0.0
+ *                (see documentation)
+ *   INIT_PARAM2: interpolation value for teaching pattern == 1.0
+ *                (see documentation)
+ *   INIT_PARAM3: smoothness parameter
+ *   INIT_PARAM4: initialization bias of hidden units
+ *   INIT_PARAM5: deviation parameter for symmetry breaking
+ * RBF_Weights_redo: (3)
+ *   INIT_PARAM1: interpolation value for teaching pattern == 0.0
+ *                (see documentation)
+ *   INIT_PARAM2: interpolation value for teaching pattern == 1.0
+ *                (see documentation)
+ *   INIT_PARAM3: smoothness parameter
+ * RBF_Weights_Kohonen: (3)
+ *   INIT_PARAM1: number of cycles for the kohonen training
+ *   INIT_PARAM2: learn_rate for kohonen training
+ *   INIT_PARAM3: shuffle flag:
+ *                0.0 = the patterns are normally distributed over the links
+ *                      to the hidden units.
+ *             != 0.0 = the patterns to use are randomly taken from all
+ *                      available patterns.
+ */
+
+krui_err INIT_RBF_Weights(float *parameterArray, int NoOfParams)
+{
+	return RbfStartInit(parameterArray, NoOfParams, RBF_INIT_FULL);
+}
+
+krui_err INIT_RBF_Weights_redo(float *parameterArray, int NoOfParams)
+{
+	return RbfStartInit(parameterArray, NoOfParams, RBF_INIT_REINIT);
+}
+
+krui_err INIT_RBF_Weights_kohonen(float *parameterArray, int NoOfParams)
+{
+	return RbfStartInit(parameterArray, NoOfParams, RBF_INIT_KOHONEN);
+}
+
+
+
+
+/* Initializes an ART1 network
+*/
+krui_err INIT_Weights_ART1(float *parameterArray, int NoOfParams)
+{
+  register struct Unit    *unit_ptr;
+  register struct Link    *link_ptr;
+
+  TopoPtrArray            topo_cmp_ptr,
+                          topo_rec_ptr,
+                          topo_ptr;
+
+  int                     ret_code       = KRERR_NO_ERROR;
+
+  FlintType               beta;
+  FlintType               gamma;
+  double                  eta;
+
+  int                     j;
+
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+     ret_code = KRERR_NO_UNITS;
+     return( ret_code );         /*  there is nothing to do  */
+  } /*if*/
+
+  if (NoOfParams < 2) {
+     ret_code = KRERR_PARAMETERS;
+     return( ret_code );  /*  Not the same no. of input parameters */
+  } /*if*/
+
+  beta = parameterArray [0];
+  gamma = parameterArray [1];
+
+
+  if ((beta <= 0.0) || (gamma <= 0.0)) {
+     /* the parameters beta and gamma have to be greater than 0.0
+     */
+     ret_code = KRERR_PARAMETERS;
+     return (ret_code);
+  } /*if*/
+
+  ret_code = kr_topoSort (ART1_TOPO_TYPE);
+  if (ret_code != KRERR_NO_ERROR) {
+     NetModified = TRUE;
+     return (ret_code);
+  } /*if*/
+  NetModified = FALSE;
+
+
+  /* Now we will write the value of beta in each of the units of the
+     network for to be able to recall in the learning algorithm.
+     The value will be written to the bias field of the unit structure
+     which is not needed for ART 1 learning in any other way and which
+     has the property that it is written to the netfile when the network
+     is saved.
+  */
+  FOR_ALL_UNITS (unit_ptr) {
+     unit_ptr->bias = beta;
+  } /*FOR_ALL_UNITS*/
+
+  topo_cmp_ptr = topo_ptr_array + NoOfInputUnits + 2;
+  topo_rec_ptr = topo_cmp_ptr   + NoOfInputUnits + 1;
+
+
+  /* To initialize the bottom up weight values we have to choose one
+     value for each recognition unit. That is, each weight value for
+     a link to a recognition unit j is set to
+
+                     b(i,j) = alpha(j),
+
+     where the alpha(j) are to be choosen as follows
+
+          alpha(1) > alpha(2) > .... > alpha (M) where M is the no. of
+                                                 rec. unit.
+
+     and    0 < alpha(j) < 1/(beta + |I|)  for all 1 <= j <= M.
+
+     For this reason we partition gamma
+     into M parts (eta=(gamma/M) and init as follows
+
+      b(i,j) = alpha(1) = 1/(beta + (1.0 + j*eta) * |I|)
+      for all 1 <= j <= M
+  */
+
+  eta = gamma / Art1_NoOfRecUnits;
+
+  /* init weights from comparison units to recognition units */
+  topo_ptr = topo_rec_ptr;
+
+  j = 1;
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ART1_CMP_LAY) {
+           link_ptr->weight = ART1_LINK_CMP_REC(beta, (1.0+j*eta));
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+      j++;
+
+  } /*while*/
+
+
+  /* init weights from delay units to comparison units */
+  topo_ptr = topo_cmp_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ART1_DEL_LAY) {
+           link_ptr->weight = ART1_LINK_DEL_CMP;
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+
+  return (ret_code);
+
+} /* INIT_Weights_ART1 */
+
+
+
+
+
+/* Initializes an ART2 network
+*/
+krui_err INIT_Weights_ART2(float *parameterArray, int NoOfParams)
+{
+  register struct Unit    *unit_ptr;
+  register struct Link    *link_ptr;
+
+  TopoPtrArray            topo_p_ptr,
+                          topo_rec_ptr,
+                          topo_ptr;
+
+  int                     ret_code       = KRERR_NO_ERROR;
+
+  FlintType               param_d;
+  FlintType               gamma;
+
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+     ret_code = KRERR_NO_UNITS;
+     return( ret_code );         /*  there is nothing to do  */
+  } /*if*/
+
+  if (NoOfParams < 1) {
+     ret_code = KRERR_PARAMETERS;
+     return( ret_code );  /*  Not the same no. of input parameters */
+  } /*if*/
+
+  param_d = parameterArray [0];
+  gamma   = parameterArray [1];
+
+
+  if ((param_d <= 0.0) || (param_d >= 1.0) ||
+      (gamma < 1.0))
+  {
+     /* the parameters d has to fit the constraint 0 < d < 1,
+        gamma >= 1.0
+     */
+     ret_code = KRERR_PARAMETERS;
+     return (ret_code);
+  } /*if*/
+
+  ret_code = kr_topoSort (ART2_TOPO_TYPE);
+  if (ret_code != KRERR_NO_ERROR) {
+     NetModified = TRUE;
+     return (ret_code);
+  } /*if*/
+  NetModified = FALSE;
+
+
+  /* Now we will write the value of param_d in each of the units of the
+     network for to be able to recall in the learning algorithm.
+     The value will be written to the bias field of the unit structure
+     which is not needed for ART 2 learning in any other way and which
+     has the property that it is written to the netfile when the network
+     is saved.
+  */
+  FOR_ALL_UNITS (unit_ptr) {
+     unit_ptr->bias = param_d;
+  } /*FOR_ALL_UNITS*/
+
+  topo_p_ptr   = topo_ptr_array + 5*NoOfInputUnits + 6;
+  topo_rec_ptr = topo_ptr_array + 8*NoOfInputUnits + 9;
+
+  /*
+     The ART 2 bottom up links are initialized with the following values:
+
+         zij(0) = 1 / (gamma * (1-d) * SQRT(N))
+
+     where gamma is parameter gamma, d is parameter param_d, N
+     is the number of F1-nodes.
+
+     Choosing gamma as small as possible (gamma=1.0) biases the
+     ART2 system as much as possible toward choosing uncommited
+     nodes.
+  */
+
+
+
+  /* init weights from p units to recognition units (Bottom-Up-Weights) */
+  topo_ptr = topo_rec_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ART2_P_LAY) {
+           link_ptr->weight = ART2_LINK_P_REC(param_d, gamma);
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+  /* init weights from delay units to p units (Top-Down-Weights) */
+  topo_ptr = topo_p_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ART2_REC_LAY) {
+           link_ptr->weight = ART2_LINK_REC_P;
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+
+  return (ret_code);
+
+} /* INIT_Weights_ART2 */
+
+
+
+
+
+/* Initializes an ARTMAP network
+*/
+krui_err INIT_Weights_ARTMAP(float *parameterArray, int NoOfParams)
+{
+  register struct Unit    *unit_ptr;
+  register struct Link    *link_ptr;
+
+  TopoPtrArray            topo_cmpa_ptr,
+                          topo_reca_ptr,
+                          topo_cmpb_ptr,
+                          topo_recb_ptr,
+                          topo_map_ptr,
+                          topo_ptr;
+
+  int                     ret_code       = KRERR_NO_ERROR;
+
+  FlintType               beta_a, beta_b;
+  FlintType               gamma_a, gamma_b;
+  double                  eta_a, eta_b;
+
+  int                     j;
+
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+     ret_code = KRERR_NO_UNITS;
+     return( ret_code );         /*  there is nothing to do  */
+  } /*if*/
+
+  if (NoOfParams < 4) {
+     ret_code = KRERR_PARAMETERS;
+     return( ret_code );  /*  Not the same no. of input parameters */
+  } /*if*/
+
+  beta_a  = parameterArray [0];
+  gamma_a = parameterArray [1];
+  beta_b  = parameterArray [2];
+  gamma_b = parameterArray [3];
+
+
+  if ((beta_a <= 0.0) || (gamma_a <= 0.0) || 
+      (beta_b <= 0.0) || (gamma_b <= 0.0)) {
+     /* the parameters beta and gamma have to be greater than 0.0
+     */
+     ret_code = KRERR_PARAMETERS;
+     return (ret_code);
+  } /*if*/
+
+  ret_code = kr_topoSort (ARTMAP_TOPO_TYPE);
+  if (ret_code != KRERR_NO_ERROR) {
+     NetModified = TRUE;
+     return (ret_code);
+  } /*if*/
+  NetModified = FALSE;
+
+
+  /* Now we will write the value of beta in each of the units of the
+     network for to be able to recall in the learning algorithm.
+     The value will be written to the bias field of the unit structure
+     which is not needed for ART 1 learning in any other way and which
+     has the property that it is written to the netfile when the network
+     is saved.
+  */
+  FOR_ALL_UNITS (unit_ptr) {
+     switch (unit_ptr->lln) {
+     case ARTMAP_INPa_LAY:
+     case ARTMAP_CMPa_LAY:
+     case ARTMAP_RECa_LAY:
+     case ARTMAP_DELa_LAY:
+     case ARTMAP_RSTa_LAY:
+     case ARTMAP_SPECa_LAY:
+        unit_ptr->bias = beta_a;
+        break;
+     case ARTMAP_INPb_LAY:
+     case ARTMAP_CMPb_LAY:
+     case ARTMAP_RECb_LAY:
+     case ARTMAP_DELb_LAY:
+     case ARTMAP_RSTb_LAY:
+     case ARTMAP_SPECb_LAY:
+        unit_ptr->bias = beta_b;
+        break;
+     default:
+        break;
+     } /*switch*/
+  } /*FOR_ALL_UNITS*/
+
+  topo_cmpa_ptr = topo_ptr_array + ArtMap_NoOfInpUnits_a + 2;
+
+  topo_reca_ptr = topo_cmpa_ptr  + ArtMap_NoOfInpUnits_a + 1;
+
+  topo_cmpb_ptr = topo_reca_ptr  + 3*ArtMap_NoOfRecUnits_a
+                                 + ARTMAP_NO_OF_SPECa_UNITS
+                                 + ArtMap_NoOfInpUnits_b
+                                 + 8;
+
+  topo_recb_ptr = topo_cmpb_ptr  + ArtMap_NoOfInpUnits_b + 1;
+
+  topo_map_ptr  = topo_recb_ptr  + 3*ArtMap_NoOfRecUnits_b
+                                 + ARTMAP_NO_OF_SPECb_UNITS
+                                 + 7;
+
+
+  /* To initialize the bottom up weight values we have to choose one
+     value for each recognition unit. That is, each weight value for
+     a link to a recognition unit j is set to
+
+                     b(i,j) = alpha(j),
+
+     where the alpha(j) are to be choosen as follows
+
+          alpha(1) > alpha(2) > .... > alpha (M) where M is the no. of
+                                                 rec. unit.
+
+     and    0 < alpha(j) < 1/(beta + |I|)  for all 1 <= j <= M.
+
+     For this reason we partition gamma
+     into M parts (eta=(gamma/M) and init as follows
+
+      b(i,j) = alpha(1) = 1/(beta + (1.0 + j*eta) * |I|)
+      for all 1 <= j <= M
+  */
+
+  eta_a = gamma_a / ArtMap_NoOfRecUnits_a;
+  eta_b = gamma_b / ArtMap_NoOfRecUnits_b;
+
+  /* init weights from comparison units to recognition units for ARTa
+  */
+  topo_ptr = topo_reca_ptr;
+
+  j = 1;
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ARTMAP_CMPa_LAY) {
+           link_ptr->weight = ARTMAP_LINK_CMPa_RECa(beta_a, (1.0+j*eta_a));
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+      j++;
+
+  } /*while*/
+
+
+  /* init weights from delay units to comparison units for ARTa
+  */
+  topo_ptr = topo_cmpa_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ARTMAP_DELa_LAY) {
+           link_ptr->weight = ARTMAP_LINK_DELa_CMPa;
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+  /* init weights from comparison units to recognition units for ARTb
+  */
+  topo_ptr = topo_recb_ptr;
+
+  j = 1;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ARTMAP_CMPb_LAY) {
+           link_ptr->weight = ARTMAP_LINK_CMPb_RECb(beta_b, (1.0+j*eta_b));
+        } /*if*/
+
+     } /*FOR_ALL_LINKS*/
+
+     j++;
+
+  } /*while*/
+
+
+  /* init weights from delay units to comparison units */
+  topo_ptr = topo_cmpb_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ARTMAP_DELb_LAY) {
+           link_ptr->weight = ARTMAP_LINK_DELb_CMPb;
+        } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+  /* init weights from delay units of ARTa to Map field units
+  */
+  topo_ptr = topo_map_ptr;
+
+  while ((unit_ptr = *topo_ptr++) != NULL) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        ret_code = KRERR_TOPOLOGY;
+        return (ret_code);
+     } /*if*/
+
+     FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+        if (link_ptr->to->lln == ARTMAP_DELa_LAY) {
+           link_ptr->weight = ARTMAP_LINK_DELa_MAP;
+        } /*if*/
+
+     } /*FOR_ALL_LINKS*/
+
+  } /*while*/
+
+
+
+  return (ret_code);
+
+} /* INIT_Weights_ARTMAP */
+
+
+/*****************************************************************************
+  FUNCTION : INIT_CC_Weights
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_CC_Weights(float *parameterArray, int NoOfParams)
+{
+ cc_freeStorage(0,krui_getNoOfPatterns()-1,1);
+ return(INIT_randomizeWeights(parameterArray,NoOfParams));
+}
+
+/*****************************************************************************
+  FUNCTION : INIT_TACOMA_Weights
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 11.12.95 <Juergen Gatter>
+******************************************************************************/
+krui_err  INIT_TACOMA_Weights(float *parameterArray, int NoOfParams)
+{
+    return(INIT_randomizeWeights(parameterArray,NoOfParams));
+}
+
+
+/*****************************************************************************
+  FUNCTION : INIT_SOM_Rand_Pat
+
+  PURPOSE  : Initializes all weight vectors of the Kohonen layer with
+  random input patterns from the training set. 
+
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_SOM_Rand_Pat(float *parameterArray, int NoOfParams)
+{
+    krui_err ret_code;
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+	return( KRERR_NO_UNITS ); /*  there is nothing to do  */
+
+    /* test if patterns available and valid:			*/
+    if (kr_TotalNoOfSubPatPairs() == 0)  
+	return( KRERR_NO_PATTERNS );	/* no patterns defined  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE))
+    {
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code == KRERR_NO_OUTPUT_UNITS) 
+	    ret_code = KRERR_NO_ERROR;
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    /*  initialize weights of the hidden units  */
+
+    /* random initialization of Kohonen layer, the parameters are:
+     * use all patterns (0, kr_TotalNoOfPattern() - 1)
+     * unused learning rate (0.0)
+     * no learning cycles (0)
+     * shuffle pattern flag (1)
+     */
+    ret_code = RbfKohonenInit(0, kr_TotalNoOfPattern() - 1, 0.0, 0, 1);
+    if (ret_code != KRERR_NO_ERROR)
+	return ret_code;
+
+    return KRERR_NO_ERROR;
+}
+
+/*****************************************************************************
+  FUNCTION : INIT_SOM_Weights_v32
+
+  PURPOSE  : Old (Version 3.2) style initialization. Initialization vectors are
+             taken from the RECTANGLE bounded by param1 and param2.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_SOM_Weights_v32(float *parameterArray, int NoOfParams)
+{
+  register struct Unit *unit_ptr;
+  register struct Site *site_ptr;
+  register struct Link *link_ptr;
+  register TopoPtrArray  topo_ptr;
+
+  register FlintType  sum, amount, range;
+  FlintType min, max;
+  int  ret_code;
+
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) )
+    return( KRERR_NO_UNITS );  /*  there is nothing to do  */
+
+  min = INIT_PARAM1( parameterArray );
+  max = INIT_PARAM2( parameterArray );
+
+  if(max < min){
+      range = min; min = max; max = range;
+  }
+  range = max - min;
+
+  if (NetModified || (TopoSortID != TOPOLOGIC_TYPE))
+    {  /*  networt was modified or topologic array isn't initialized  */
+
+      ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+      if (ret_code == KRERR_NO_OUTPUT_UNITS) ret_code = KRERR_NO_ERROR;
+      if (ret_code != KRERR_NO_ERROR)
+	return( ret_code );
+      NetModified = FALSE;
+    }
+
+  topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+
+  /*  initialize weights of the hidden units  */
+  while ((unit_ptr = *++topo_ptr) != NULL)
+    { /*  this is a hidden unit  */
+      /***********************************************************/
+      /*     initialize the weights to the Kohonen Layer         */
+      /***********************************************************/
+    sum = 0.0;
+    if UNIT_HAS_SITES( unit_ptr )
+      { /* the unit has sites */
+      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )  {
+        link_ptr->weight = (FlintType) drand48() * range + min;
+        sum += link_ptr->weight * link_ptr->weight;
+      }
+    }
+    else
+      { /* the unit has direct links */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )  {
+        link_ptr->weight = (FlintType) drand48() * range + min;
+        sum += link_ptr->weight * link_ptr->weight;
+      }
+    }
+    /* normalize the weightvector to the Kohonen Layer */
+
+
+    amount = ((sum==0.0)? 0.0 : (1.0 / sqrt( sum )));
+   
+    unit_ptr->bias = 0.0;
+    unit_ptr->value_a = 0.0; /*initialisation is necessary for spanning tree */
+   
+    if UNIT_HAS_SITES( unit_ptr )
+      /* the unit has sites */
+      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+          link_ptr->weight = link_ptr->weight * amount;
+    else
+      /* the unit has direct links */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )
+        link_ptr->weight = link_ptr->weight * amount;
+  }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_SOM_Weights_const
+
+  PURPOSE  : constant initialization of Kohonen networks.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_SOM_Weights_const(float *parameterArray, int NoOfParams)
+{
+  register struct Unit *unit_ptr;
+  register struct Site *site_ptr;
+  register struct Link *link_ptr;
+  register TopoPtrArray  topo_ptr;
+
+  int  ret_code;
+
+
+  if ( (unit_array == NULL) || (NoOfUnits == 0) )
+    return( KRERR_NO_UNITS );  /*  there is nothing to do  */
+
+  if (NetModified || (TopoSortID != TOPOLOGIC_TYPE))
+    {  /*  networt was modified or topologic array isn't initialized  */
+
+      ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+      if (ret_code == KRERR_NO_OUTPUT_UNITS) ret_code = KRERR_NO_ERROR;
+      if (ret_code != KRERR_NO_ERROR)
+	return( ret_code );
+      NetModified = FALSE;
+    }
+
+  topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+
+  /*  initialize weights of the hidden units  */
+  while ((unit_ptr = *++topo_ptr) != NULL){
+      /*  this is a hidden unit  */
+      if UNIT_HAS_SITES( unit_ptr ){
+	  /* the unit has sites */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )  {
+	      link_ptr->weight = (FlintType) 1.0/sqrt(NoOfInputUnits);
+	  }
+      }else{
+	  /* the unit has direct links */
+	  FOR_ALL_LINKS( unit_ptr, link_ptr )  {
+	      link_ptr->weight = (FlintType) 1.0/sqrt(NoOfInputUnits);
+	  }
+      }
+
+      unit_ptr->bias = 0.0;
+      unit_ptr->value_a = 0.0; /*initialisation is necessary for spanning tree*/
+  }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_JE_Weights
+
+  PURPOSE  : initialization function for JORDAN / ELMAN networks
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+
+krui_err  INIT_JE_Weights (float *parameterArray, int NoOfParams)
+
+{
+  register unsigned short   flags    ;
+  register struct   Link   *link_ptr ;
+  register struct   Site   *site_ptr ;
+  register struct   Unit   *unit_ptr ;
+  FlintType                 range     , min_weight, max_weight ;
+  FlintType                 srl_weight, rec_weight, con_iact   ;
+
+
+  if ((unit_array == NULL) || (NoOfUnits == 0)) return (KRERR_NO_UNITS) ;  
+ 
+  if (NoOfParams != 5) return (KRERR_PARAMETERS) ;  
+
+  min_weight = INIT_PARAM1 (parameterArray) ;
+  max_weight = INIT_PARAM2 (parameterArray) ;
+                                              /* context units:              */
+  srl_weight = INIT_PARAM3 (parameterArray) ; /* self recurrent links        */
+  rec_weight = INIT_PARAM4 (parameterArray) ; /* other links to context units*/
+  con_iact   = INIT_PARAM5 (parameterArray) ; /* initial activation          */
+ 
+  range = max_weight - min_weight ;
+
+  /* if (range < 0.0) return (KRERR_PARAMETERS) ; */
+
+  FOR_ALL_UNITS (unit_ptr) 
+  {
+    flags = unit_ptr->flags ;
+
+    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE)
+    {
+      if (IS_HIDDEN_UNIT (unit_ptr) && IS_SPECIAL_UNIT (unit_ptr))
+      {
+        /* special hidden is the type of context units */
+
+        unit_ptr->bias        = 0.5 ;
+        unit_ptr->i_act       = con_iact ;
+        unit_ptr->act         = con_iact ;
+        unit_ptr->Out.output  = con_iact ;
+
+        if ((flags & UFLAG_INPUT_PAT) == UFLAG_SITES)
+        { 
+          /*  unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+            if (link_ptr->to == unit_ptr)
+	    { link_ptr->weight = srl_weight ; }
+            else
+            { link_ptr->weight = rec_weight ; }
+        }
+        else 
+        {
+          /*  unit has no sites   */
+          if ((flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS)
+          { /*  unit has direct links   */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+              if (link_ptr->to == unit_ptr)
+	      { link_ptr->weight = srl_weight ; }
+              else
+              { link_ptr->weight = rec_weight ; }
+          }
+        } /* else */
+      }
+      else
+      {
+        unit_ptr->bias = (FlintType) drand48() * range + min_weight ;
+
+        if ((flags & UFLAG_INPUT_PAT) == UFLAG_SITES)
+        { 
+          /*  unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+            link_ptr->weight = (FlintType) drand48() * range + min_weight ;
+        } 
+        else  
+        {
+          /*  unit has no sites   */
+          if ((flags & UFLAG_INPUT_PAT) == UFLAG_DLINKS)
+          { /*  unit has direct links   */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+              link_ptr->weight = (FlintType) drand48() * range + min_weight ;
+          }
+        } /* else */
+      } /* if */
+    } /* if */
+  } /* for */
+
+  return (KRERR_NO_ERROR) ;
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : INIT_Hebb
+
+  PURPOSE  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+
+krui_err INIT_Hebb(float *parameterArray, int NoOfParams)
+{
+  register struct Unit  *unit_ptr;
+  register struct Link  *link_ptr;
+  register Patterns     in_pat,  out_pat;
+  FlintType             BiasIn, BiasOut;
+  int                   pattern_no, sub_pat_no;
+  
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_UNITS  );         /*  there is nothing to do  */
+  } /*if*/
+  if ( (kr_TotalNoOfSubPatPairs() == 0) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_PATTERNS  );         /*  there is nothing to do  */
+  } /*if*/
+
+  NoOfInputUnits = krui_getNoOfInputUnits();
+  
+  /* init bias */
+  
+  BiasIn = parameterArray[0];
+  BiasOut= parameterArray[1];
+  
+  FOR_ALL_UNITS(unit_ptr) {
+    if (IS_INPUT_UNIT(unit_ptr)){
+      if (BiasIn == 1.0)   
+	unit_ptr->bias = (FlintType) log((double) NoOfOutputUnits); 
+      else 
+	unit_ptr->bias = BiasIn;
+    }
+    else if IS_OUTPUT_UNIT(unit_ptr) {
+      if (BiasOut == -1.0)   
+	unit_ptr->bias = (FlintType) log((double) NoOfInputUnits);
+      else 
+	unit_ptr->bias = BiasOut;
+    }
+  } /* for all units */
+  
+  /* init links */
+  
+  FOR_ALL_UNITS(unit_ptr)
+    FOR_ALL_LINKS(unit_ptr, link_ptr)
+      { link_ptr->weight = 0.0;
+      }
+  
+  /* compute the necessary sub patterns */
+  KernelErrorCode = kr_initSubPatternOrder(0, kr_TotalNoOfPattern() - 1);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+  {
+      if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+	  KernelErrorCode = KRERR_NP_WORKAROUND;
+      return (KernelErrorCode);
+  }
+
+  while(kr_getSubPatternByOrder(&pattern_no, &sub_pat_no))
+  {  /*  calc. startaddress of pattern entries  */
+      in_pat = kr_getSubPatData(pattern_no, sub_pat_no, INPUT, NULL);
+      out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, NULL);
+      
+      FOR_ALL_UNITS( unit_ptr )
+	  /*        if UNIT_IN_USE( unit_ptr )
+	   */      {
+	       if IS_INPUT_UNIT( unit_ptr )
+		   unit_ptr->act = *in_pat++;
+	       if IS_OUTPUT_UNIT( unit_ptr )
+		   unit_ptr->act = *out_pat++;
+	   }
+      
+      FOR_ALL_UNITS(unit_ptr)
+	  FOR_ALL_LINKS(unit_ptr, link_ptr)
+          { 
+	      link_ptr->weight += (unit_ptr->act) * (link_ptr->to->act);
+          } 
+  }/* all patterns */
+  
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : INIT_ClippHebb
+
+  PURPOSE  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_ClippHebb(float *parameterArray, int NoOfParams)
+{
+  register struct Unit *unit_ptr;
+  register struct Link *link_ptr;
+  register Patterns     in_pat,  out_pat;
+  FlintType             BiasIn, BiasOut; 
+  int                   pattern_no, sub_pat_no;
+  
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_UNITS  );         /*  there is nothing to do  */
+  } /*if*/
+  if ( (kr_TotalNoOfSubPatPairs() == 0) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_PATTERNS  );         /*  there is nothing to do  */
+  } /*if*/
+  
+  NoOfInputUnits = krui_getNoOfInputUnits();
+  
+  /* init bias */
+  BiasIn = parameterArray[0];
+  BiasOut= parameterArray[1];
+  
+  FOR_ALL_UNITS(unit_ptr) {
+    if (IS_INPUT_UNIT(unit_ptr)){
+      if (BiasIn == 1.0)   
+	unit_ptr->bias = (FlintType) log((double) NoOfOutputUnits); 
+      else 
+	unit_ptr->bias = BiasIn;
+    }
+    else if IS_OUTPUT_UNIT(unit_ptr) {
+      if (BiasOut == -1.0)   
+	unit_ptr->bias = (FlintType) log((double) NoOfInputUnits);
+      else 
+	unit_ptr->bias = BiasOut;
+    }
+  }
+  /* init links */
+  
+  FOR_ALL_UNITS(unit_ptr)
+    FOR_ALL_LINKS(unit_ptr, link_ptr)
+      { link_ptr->weight = 0.0;
+      }
+  
+  /* compute the necessary sub patterns */
+  KernelErrorCode = kr_initSubPatternOrder(0, kr_TotalNoOfPattern() - 1);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+  {
+      if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+	  KernelErrorCode = KRERR_NP_WORKAROUND;
+      return (KernelErrorCode);
+  }
+
+  while(kr_getSubPatternByOrder(&pattern_no, &sub_pat_no))
+  {  /*  calc. startaddress of pattern entries  */
+      in_pat = kr_getSubPatData(pattern_no, sub_pat_no, INPUT, NULL);
+      out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, NULL);
+
+      FOR_ALL_UNITS( unit_ptr )
+	  /*        if UNIT_IN_USE( unit_ptr ) */
+      {
+	  if IS_INPUT_UNIT( unit_ptr ) 
+	      unit_ptr->act = *in_pat++; 
+	  if IS_OUTPUT_UNIT( unit_ptr )
+	      unit_ptr->act = *out_pat++;
+      }
+      
+      FOR_ALL_UNITS(unit_ptr)
+	  FOR_ALL_LINKS(unit_ptr, link_ptr)
+	  { 
+	      if (link_ptr->weight == 0) { 
+		  link_ptr->weight += (unit_ptr->act) * (link_ptr->to->act); 
+	      }
+	      /*debugg*/
+	      /*	  fprintf(stderr, "jetzt gesetzte gewichte");
+			  fprintf(stderr, "%f", link_ptr->weight);     
+			  */ 
+	  } 
+  } /* all patterns */
+  
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : INIT_HOP_FixAct
+
+  PURPOSE  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err INIT_HOP_FixAct(float *parameterArray, int NoOfParams)
+{
+  register struct Unit       *unit_ptr;
+  register struct Link       *link_ptr;
+  register Patterns          in_pat;
+  
+  FlintType                  activity;
+  FlintType                  error_probability;
+  FlintType                   Bias;
+  FlintType                   activityHoch3;
+  int                         ret_code = KRERR_NO_ERROR;
+  int                        pattern_no, sub_pat_no;
+  
+  if (NoOfParams < 2) {
+    ret_code = KRERR_PARAMETERS;
+    return( ret_code );  /*  Not the same no. of input parameters */
+  } 
+  if ( (kr_TotalNoOfSubPatPairs() == 0) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_PATTERNS  );         /*  there is nothing to do  */
+  } /*if*/
+  
+  NoOfUnits = krui_getNoOfUnits();
+  
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_UNITS  );         /*  there is nothing to do  */
+  } 
+  
+  
+  activity  = (float)parameterArray [0]/(float)NoOfUnits;
+  error_probability = parameterArray [1]/100.0;
+  
+  
+  /* set bias to the value, that Amari published in Neur.Netw. Vol.2, 451-457 '89 */  
+  
+  activityHoch3 = ( FlintType ) pow( (double) activity, (double) 3.0 );
+  Bias = kr_TotalNoOfSubPatPairs()*( activityHoch3 ) + 0.5*activity*(1 - error_probability);
+  
+  FOR_ALL_UNITS(unit_ptr)
+    unit_ptr->bias = Bias;
+  
+  /* init links */
+  
+  FOR_ALL_UNITS(unit_ptr) {
+    FOR_ALL_LINKS(unit_ptr, link_ptr)
+      link_ptr->weight = 0.0;
+  }
+  
+  /* compute the necessary sub patterns */
+  KernelErrorCode = kr_initSubPatternOrder(0, kr_TotalNoOfPattern() - 1);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+  {
+      if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+	  KernelErrorCode = KRERR_NP_WORKAROUND;
+      return (KernelErrorCode);
+  }
+
+  while(kr_getSubPatternByOrder(&pattern_no, &sub_pat_no))
+  {  /*  calc. startaddress of pattern entries  */
+      in_pat = kr_getSubPatData(pattern_no, sub_pat_no, INPUT, NULL);
+
+      FOR_ALL_UNITS( unit_ptr ) {
+	if IS_INPUT_UNIT( unit_ptr )
+	  unit_ptr->act = *in_pat++;
+      }
+      
+      FOR_ALL_UNITS(unit_ptr) {
+	FOR_ALL_LINKS(unit_ptr, link_ptr)
+	  link_ptr->weight += (1.0/NoOfUnits)*(unit_ptr->act) * (link_ptr->to->act);
+      }
+    }/* all patterns */
+  
+  return(KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : PseudoInv
+
+  PURPOSE  : rekursive calculation of the Pseudoinverse 
+  NOTES    : Pseudoinverse calculation of the weights  (Hopfield) 
+             with Theorem of Greville ( Kohonen 87 )                          
+
+  UPDATE   : 
+******************************************************************************/
+krui_err   PseudoInv(RbfFloatMatrix *source, int NoOfColumns, RbfFloatMatrix *target )
+{
+  int            i,j;
+  int            malloc_fault;
+  float          qnorm;
+  krui_err       ret_code;
+  RbfFloatMatrix A;  /* source without last column                          */
+  RbfFloatMatrix PA; /* PseudoInverse of A                                  */
+  RbfFloatMatrix PP; /* auxiliary matrix with the same dimensions as PA     */
+  RbfFloatMatrix a;  /* last column of source                               */
+  RbfFloatMatrix p;  /* auxiliary vector with the same dimensions as 'a'    */
+  RbfFloatMatrix P;  /* aux. square matrix with the same nr. of rows as source*/
+  RbfFloatMatrix aux;
+  RbfFloatMatrix pT; /* transposed of 'p'  */
+  
+
+  NoOfInputUnits = krui_getNoOfInputUnits();
+  
+  if (NoOfColumns <= 1)
+
+    /* end of recursion */
+
+    if (NoOfColumns <= 0)
+      return(KRERR_NO_PATTERNS);
+    else {
+      /* a+ = aT / aT*a if a != 0 and
+	 = 0T        if a == 0      
+	 */
+      
+      qnorm = 0.0;
+      for (i = 0; i <= (source->rows - 1); i++)
+	qnorm += RbfMatrixGetValue(source, i, 0)*RbfMatrixGetValue(source, i, 0);
+      
+      for (i = 0; i <= (source->rows - 1); i++)
+	if (qnorm != 0.0)
+	  /* set the 1-st row of target to the 1-st column of source */
+	  RbfMatrixSetValue(target, 0, i, RbfMatrixGetValue(source, i, 0)/qnorm);
+	else 
+	  RbfMatrixSetValue(target, 0, i, RbfMatrixGetValue(source, i, 0));    
+    }
+  else
+    { 
+      /* recursion */
+      ret_code = PseudoInv(source, NoOfColumns - 1, target);
+      if (ret_code != KRERR_NO_ERROR)
+	return(ret_code);
+      malloc_fault = 0;
+      if (!RbfAllocMatrix(source->rows, NoOfColumns - 1, &A) ) 
+	malloc_fault = 1;
+      else if (!RbfAllocMatrix(NoOfColumns - 1, (source->rows), &PA))
+	malloc_fault = 2;
+      else if (!RbfAllocMatrix(source->rows, 1, &a))
+	malloc_fault = 3;
+      else if (!RbfAllocMatrix(source->rows, 1, &p))
+	malloc_fault = 4;
+      else if (!RbfAllocMatrix( source->rows, source->rows, &P ))
+	malloc_fault = 5;     
+      else if (!RbfAllocMatrix(NoOfColumns - 1, 1, &aux))
+	malloc_fault = 6;
+      else if (!RbfAllocMatrix(1, source->rows, &pT))
+	malloc_fault = 7;
+      else if (!RbfAllocMatrix(NoOfColumns - 1, (source->rows), &PP))
+	malloc_fault = 8;
+       
+      if (malloc_fault != 0) {
+	if (malloc_fault >= 2)
+	  RbfFreeMatrix(&A);
+	if (malloc_fault >= 3)
+	  RbfFreeMatrix(&PA);
+	if (malloc_fault >= 4)
+	  RbfFreeMatrix(&a);
+	if (malloc_fault >= 5)
+	  RbfFreeMatrix(&p);
+	if (malloc_fault >= 6)
+	  RbfFreeMatrix(&P);
+	if (malloc_fault >= 7)
+	  RbfFreeMatrix(&aux);
+	if (malloc_fault >= 8)
+	  RbfFreeMatrix(&pT);
+	return(KRERR_INSUFFICIENT_MEM);
+      }
+      
+      /* init matrices */
+      for (i = A.rows - 1 ; i>=0; i--){ 
+	for(j = A.columns - 1; j >=0; j--){
+	  RbfMatrixSetValue(&A, i, j, RbfMatrixGetValue(source, i, j));
+	}
+      }
+      
+       for (i = PA.rows - 1; i>=0; i--){ 
+	for(j = PA.columns - 1; j >=0; j--){
+	  RbfMatrixSetValue(&PA, i, j, RbfMatrixGetValue(target, i, j));
+	}
+      }
+     
+      for (i = a.rows - 1 ; i>=0; i--){ 
+	for(j = a.columns - 1; j >=0; j--){
+	  RbfMatrixSetValue(&a, i, j, RbfMatrixGetValue(source, i, NoOfColumns));
+	}
+      }
+
+
+      /* calculate  'p'  */
+      RbfMulMatrix(&P, &A, &PA);                                         /* P = A*PA   */
+      RbfMulScalarMatrix(&P, -1.0);                                      /* P = Id - P */
+      for (i = (P.rows -1) ; i>=0; i--) {                                 
+	RbfMatrixSetValue(&P, i, i, RbfMatrixGetValue(&P, i, i) + 1);
+      }
+      RbfMulMatrix(&p, &P, &a);                                           /* p = P*a   */
+      qnorm = RbfSquareOfNorm(&p);
+      if (qnorm != 0)
+	RbfMulScalarMatrix(&p, 1/qnorm);
+      else {
+	RbfMulMatrix(&aux, &PA, &a);
+	qnorm = RbfSquareOfNorm(&aux);
+	RbfTranspMatrix(&A, &PA);                                        /* A = PA transposed */
+	RbfMulMatrix(&p, &A, &aux);
+	RbfMulScalarMatrix(&p, 1/(1 + qnorm));
+      }
+      /* calculate target */
+      RbfTranspMatrix(&pT, &p);
+      RbfMulMatrix(&P, &a, &pT);                                         /* P = A*pT   */ 
+      RbfMulScalarMatrix(&P, -1.0);                                      /* P = Id - P */
+      for (i = (P.rows -1) ; i>=0; i--){                                 
+	RbfMatrixSetValue(&P, i, i, RbfMatrixGetValue(&P, i, i) + 1);
+      }
+      RbfMulMatrix(&PP, &PA, &P);
+      /* set target elements */
+      for (i = (PP.rows - 1) ; i>=0; i--)
+	{
+	  for (j = (PP.columns -1) ; j>=0; j--)
+	    RbfMatrixSetValue(target, i, j, RbfMatrixGetValue(&PP, i, j));
+	};
+      for (j = (PP.columns -1) ; j>=0; j--)
+	RbfMatrixSetValue(target, PP.rows , j, RbfMatrixGetValue(&pT, 0, j)); 
+      
+      /* free matrices */
+
+      RbfFreeMatrix(&PP);      
+      RbfFreeMatrix(&A);
+      RbfFreeMatrix(&PA);
+      RbfFreeMatrix(&a);
+      RbfFreeMatrix(&p);
+      RbfFreeMatrix(&P);
+      RbfFreeMatrix(&aux);
+      RbfFreeMatrix(&pT);
+
+      
+    }
+  return(KRERR_NO_ERROR);  
+}
+
+
+/*****************************************************************************
+  FUNCTION : INIT_PseudoInv
+
+  PURPOSE  : 
+  NOTES    : 
+             
+
+  UPDATE   : 
+******************************************************************************/
+
+krui_err INIT_PseudoInv(float *parameterArray, int NoOfParams)
+{
+  register struct Unit *unit_ptr;
+  register struct Link *link_ptr;
+  register Patterns     in_pat,  out_pat;
+  int          unit_no;
+  float       *ptr_to_W;
+  RbfFloatMatrix       X;  /* rows = NoOfInputUnits columns = kr_TotalNoOfSubPatPairs()*/
+  RbfFloatMatrix       PIofX;   /* is to store the Pseudoinverse of X */
+  RbfFloatMatrix       W;       /* stores the weights of the net */
+  RbfFloatMatrix       Y;       /* stores the output Patterns    */
+  int	      malloc_fault;
+  krui_err             ret_code = KRERR_NO_ERROR;
+  int                  pattern_no, sub_pat_no;
+  int                  end_sp;
+  int                  act_sub_nr;
+  
+  if ( (unit_array == NULL) || (NoOfUnits == 0) ) {
+    return( KRERR_NO_UNITS  );         /*  there is nothing to do  */
+  } /*if*/
+  
+  
+  NoOfInputUnits = krui_getNoOfInputUnits();
+  
+  NoOfOutputUnits = krui_getNoOfOutputUnits();
+  
+  /* init links */
+  
+  FOR_ALL_UNITS(unit_ptr)
+    FOR_ALL_LINKS(unit_ptr, link_ptr)
+      { link_ptr->weight = 0.0;
+      }
+  /* allocate memory for the matrices */
+  
+  malloc_fault = 0;
+  if (!RbfAllocMatrix(NoOfInputUnits, kr_TotalNoOfSubPatPairs(), &X))
+    malloc_fault = 1;
+  else if (!RbfAllocMatrix(NoOfOutputUnits, NoOfInputUnits, &W))
+    malloc_fault = 2;
+  else if (!RbfAllocMatrix(kr_TotalNoOfSubPatPairs(), NoOfInputUnits, &PIofX))
+    malloc_fault = 3;
+  else if (!RbfAllocMatrix(NoOfOutputUnits, kr_TotalNoOfSubPatPairs(), &Y))
+    malloc_fault = 4;
+  
+  if (malloc_fault != 0)
+    {
+      if (malloc_fault >= 2)
+	RbfFreeMatrix(&X);
+      if (malloc_fault >= 3)
+	RbfFreeMatrix(&W);
+      if (malloc_fault >= 4)
+	RbfFreeMatrix(&PIofX);
+      return(KRERR_INSUFFICIENT_MEM);
+    }
+  
+  RbfClearMatrix(&X, 0.0); 
+  RbfClearMatrix(&W, 0.0);  
+  RbfClearMatrix(&PIofX, 0.0);
+  RbfClearMatrix(&Y, 0.0);
+   
+  /* set X  and Y */
+  
+  end_sp = kr_TotalNoOfSubPatPairs() - 1;
+  for (act_sub_nr=0; act_sub_nr <= end_sp; act_sub_nr++)
+    {  /*  calc. startaddress of pattern entries  */
+	kr_getSubPatternByNo(&pattern_no, &sub_pat_no, act_sub_nr);
+	in_pat = kr_getSubPatData(pattern_no, sub_pat_no, INPUT, NULL);
+	out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, NULL);
+
+      for ( unit_no = 0; unit_no <= NoOfInputUnits -1; unit_no++)
+	RbfMatrixSetValue(&X, unit_no, act_sub_nr, *in_pat++);
+      for ( unit_no = 0; unit_no <= NoOfOutputUnits -1; unit_no++)
+	RbfMatrixSetValue(&Y, unit_no, act_sub_nr, *out_pat++);
+      
+    };
+  
+  /* calculate the Pseudoinverse of X */
+  
+  ret_code = PseudoInv(&X, X.columns, &PIofX);
+  if(ret_code != KRERR_NO_ERROR)
+    return(ret_code);
+  
+  /* calculate the weight matrix */
+  
+  RbfMulMatrix(&W, &Y, &PIofX);
+  
+  
+  /* set the corresponding link weights */
+  
+  ptr_to_W = W.field;
+  /* There is a full connection between the units */
+  FOR_ALL_UNITS(unit_ptr)     
+    FOR_ALL_LINKS(unit_ptr, link_ptr)
+      {
+	link_ptr->weight =  *ptr_to_W++ ;
+	/*debugg*/
+	/*	  fprintf(stderr, "jetzt gesetzte gewichte");
+		  fprintf(stderr, "%f", link_ptr->weight);     
+		  */ 
+      } 
+ 
+  /* free matrices */
+  
+  RbfFreeMatrix(&X);
+  RbfFreeMatrix(&W);
+  RbfFreeMatrix(&PIofX);
+  RbfFreeMatrix(&Y);
+  
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : ENZO_noinit
+
+  PURPOSE  : This initialization function doesn't initialize. This is to 
+             prevent initialization in the case that a function has to be set. 
+  NOTES    : 
+             
+
+  UPDATE   : 
+******************************************************************************/
+
+krui_err ENZO_noinit()
+{
+  return ( KRERR_NO_ERROR );
+}
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/init_f.h snort-2.3.3.new/src/kernel_snns/init_f.h
--- snort-2.3.3/src/kernel_snns/init_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/init_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,61 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/init_f.h,v $
+  SHORTNAME      : init_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : public header
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:18 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _INIT_F_DEFINED_
+#define  _INIT_F_DEFINED_
+
+
+extern krui_err  INIT_randomizeWeights(float *parameterArray, int NoOfParams);
+extern krui_err  INIT_RM_randomizeWeights(float*parameterArray,int NoOfParams);
+extern krui_err  INIT_randomizeWeights_perc(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_CPNv32(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_CPNv33(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_CPN_Rand_Pat(float *parameterArray, int NoOfParams);
+extern void RbfInitSetCenter(int pattern_no, int sub_pat_no, struct Unit *hidden_unit, float deviation, float bias);
+extern void RbfInitBPCenter(struct Unit *hidden_unit);
+extern krui_err  RbfInitNetwork(int start_pat, int end_pat, float i_bias, float i_devi, float i_f_0, float i_f_1, float i_smooth, int init_type);
+#ifdef RBF_INCLUDE_KOHONEN_CONVEX
+
+extern void RbfKohonenConvexInit(int start_pattern,int end_pattern,float alpha_start,
+	float alpha_increment,float learn_rate,int count);
+#endif
+extern krui_err RbfKohonenInit(int start_pattern, int end_pattern, float learn_rate, int count, int shuffle);
+extern krui_err RbfStartInit(float *parameterArray, int NoOfParams, int init_type);
+extern krui_err INIT_RBF_Weights(float *parameterArray, int NoOfParams);
+extern krui_err INIT_RBF_Weights_redo(float *parameterArray, int NoOfParams);
+extern krui_err INIT_RBF_Weights_kohonen(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_ART1(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_ART2(float *parameterArray, int NoOfParams);
+extern krui_err INIT_Weights_ARTMAP(float *parameterArray, int NoOfParams);
+extern krui_err INIT_CC_Weights(float *parameterArray, int NoOfParams);
+extern krui_err INIT_TACOMA_Weights(float *parameterArray, int NoOfParams);
+extern krui_err INIT_SOM_Rand_Pat(float *parameterArray, int NoOfParams);
+extern krui_err INIT_SOM_Weights_v32(float *parameterArray, int NoOfParams);
+extern krui_err INIT_SOM_Weights_const(float *parameterArray, int NoOfParams);
+extern krui_err INIT_JE_Weights (float *parameterArray, int NoOfParams) ;
+
+
+extern krui_err INIT_Hebb(float *parameterArray, int NoOfParams);
+extern krui_err INIT_ClippHebb(float *parameterArray, int NoOfParams);
+extern krui_err INIT_HOP_FixAct(float *parameterArray, int NoOfParams);
+extern krui_err INIT_PseudoInv(float *parameterArray, int NoOfParams);
+extern krui_err ENZO_noinit(void);
+#endif 
+
+/* 50 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/init_f.ph snort-2.3.3.new/src/kernel_snns/init_f.ph
--- snort-2.3.3/src/kernel_snns/init_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/init_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,78 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/init_f.ph,v $
+  SHORTNAME      : init_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : private header
+  NOTES          :
+
+  AUTHOR         : 
+  DATE           : 
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.14 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:19 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _INIT_F_DEFINED_
+#define  _INIT_F_DEFINED_
+
+/* begin global definition section */
+
+krui_err  INIT_randomizeWeights(float *parameterArray, int NoOfParams);
+krui_err INIT_RM_randomizeWeights(float*parameterArray, int NoOfParams);
+krui_err  INIT_randomizeWeights_perc(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_CPNv32(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_CPNv33(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_CPN_Rand_Pat(float *parameterArray, int NoOfParams);
+void RbfInitSetCenter(int pattern_no, int sub_pat_no, struct Unit *hidden_unit, float deviation, float bias);
+void RbfInitBPCenter(struct Unit *hidden_unit);
+krui_err  RbfInitNetwork(int start_pat, int end_pat, float i_bias, float i_devi, float i_f_0, float i_f_1, float i_smooth, int init_type);
+#ifdef RBF_INCLUDE_KOHONEN_CONVEX
+
+void RbfKohonenConvexInit(int start_pattern,int end_pattern,float alpha_start,
+	float alpha_increment,float learn_rate,int count);
+#endif
+krui_err RbfKohonenInit(int start_pattern, int end_pattern, float learn_rate, int count, int shuffle);
+krui_err RbfStartInit(float *parameterArray, int NoOfParams, int init_type);
+krui_err INIT_RBF_Weights(float *parameterArray, int NoOfParams);
+krui_err INIT_RBF_Weights_redo(float *parameterArray, int NoOfParams);
+krui_err INIT_RBF_Weights_kohonen(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_ART1(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_ART2(float *parameterArray, int NoOfParams);
+krui_err INIT_Weights_ARTMAP(float *parameterArray, int NoOfParams);
+krui_err INIT_CC_Weights(float *parameterArray, int NoOfParams);
+krui_err INIT_TACOMA_Weights(float *parameterArray, int NoOfParams);
+krui_err INIT_SOM_Rand_Pat(float *parameterArray, int NoOfParams);
+krui_err INIT_SOM_Weights_v32(float *parameterArray, int NoOfParams);
+krui_err INIT_SOM_Weights_const(float *parameterArray, int NoOfParams);
+krui_err INIT_JE_Weights (float *parameterArray, int NoOfParams) ;
+
+krui_err INIT_Hebb(float *parameterArray, int NoOfParams);
+krui_err INIT_ClippHebb(float *parameterArray, int NoOfParams);
+krui_err INIT_HOP_FixAct(float *parameterArray, int NoOfParams);
+krui_err INIT_PseudoInv(float *parameterArray, int NoOfParams);
+krui_err ENZO_noinit(void);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+#define  INIT_PARAM1( param )   param[ 0 ]  /*    contains the 1st initialisation parameter  */
+#define  INIT_PARAM2( param )   param[ 1 ]  /*    contains the 2nd initialisation parameter  */
+#define  INIT_PARAM3( param )   param[ 2 ]  /*    contains the 3rd initialisation parameter  */
+#define  INIT_PARAM4( param )   param[ 3 ]  /*    contains the 4th initialisation parameter  */
+#define  INIT_PARAM5( param )   param[ 4 ]  /*    contains the 5th initialisation parameter  */
+
+#define	 RBF_INIT_FULL		0
+#define	 RBF_INIT_REINIT	1
+#define  RBF_INIT_KOHONEN	2
+#define  MY_HUGE_VAL		1E20
+
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/kernel.c snort-2.3.3.new/src/kernel_snns/kernel.c
--- snort-2.3.3/src/kernel_snns/kernel.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kernel.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,4331 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kernel.c,v $
+  SHORTNAME      : kernel.c
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS Kernel
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 20.02.90
+ 
+  CHANGED BY     : Sven Doering, Michael Vogt, Guenter Mamier,Christine Bagdi,
+                   Thomas Gern
+  RCS VERSION    : $Revision: 2.24 $
+  LAST CHANGE    : $Date: 1998/05/15 13:12:06 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#include <config.h>
+#define  SNNS_KERNEL
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <memory.h>
+#include <math.h>
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants  */
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"	 /*  Default Values  */
+
+#ifndef rand
+#include "random.h"	 /*  Randomize Library Function Prototypes  */
+#endif
+
+#include "kernel.ph"	 /*  Function Prototypes  */
+#include "kr_mem.h"	 /*  Function Prototypes  */
+#include "kr_funcs.h"	 /*  Function Prototypes  */
+#include "kr_mac.h"	 /*  Kernel Macros  */
+#include "cc_glob.h"
+#include "kr_newpattern.h"
+#include "prun_f.h"
+#include "learn_f.h"
+#include "matrix.h"
+
+#ifdef MASPAR_KERNEL
+
+#include "kr_feedf.h"	 /*  Function Prototypes */
+
+#endif
+
+#include "kr_art.h"      /*  Function Prototypes  */
+#include "kr_art1.h"     /*  Prototypes and global defs for ART1  */
+#include "kr_art2.h"     /*  Prototypes and global defs for ART2  */
+#include "kr_amap.h"     /*  Prototypes and global defs for ARTMAP  */
+#include "kr_JordElm.h"
+
+/*****************************************************************************
+  FUNCTION : kr_countUnits
+
+  PURPOSE  : count units according to their topological type 
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void  kr_countUnits(struct Unit *unit_ptr, int mode)
+{
+  if (mode == UNIT_ADD)  {
+    /*  add unit  */
+    switch (unit_ptr->flags & UFLAG_TTYP_PAT)  {
+      case  UFLAG_TTYP_IN:
+        NoOfInputUnits++;
+        break;
+      case  UFLAG_TTYP_OUT:
+        NoOfOutputUnits++;
+        break;
+      case  UFLAG_TTYP_HIDD:
+        NoOfHiddenUnits++;
+        break;
+    }
+    return;
+  }
+  if (mode == UNIT_DELETE)  {
+    /*  delete unit  */
+    switch (unit_ptr->flags & UFLAG_TTYP_PAT)  {
+      case  UFLAG_TTYP_IN:
+        --NoOfInputUnits;
+        break;
+      case  UFLAG_TTYP_OUT:
+        --NoOfOutputUnits;
+        break;
+      case  UFLAG_TTYP_HIDD:
+        --NoOfHiddenUnits;
+        break;
+    }
+    return;
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_symbolCheck 
+
+  PURPOSE  : spell checker  (check identifiers for matching [A-Za-z]^[|, ]*
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+bool    kr_symbolCheck(char *symbol)
+{
+  register  char  c;
+
+
+  KernelErrorCode = KRERR_SYMBOL;
+
+  if (!isalpha( *symbol ))
+    /*	Symbol pattern invalid (must match [A-Za-z]^[|, ]*)  */
+    return( FALSE );
+
+  while ( (c = *(++symbol)) != '\0' )
+    {
+    if (!isgraph( c ))
+      /*  Symbol pattern invalid (must match [A-Za-z]^[|, ]*)  */
+      return( FALSE );
+
+    if ( c == '|' || c == ',')
+      /*  Symbol pattern invalid (must match [A-Za-z]^[|, ]*)  */
+      return( FALSE );
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  return( TRUE );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getUnitPtr
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns the pointer to the given unit, returns NULL if unit 
+             doesn't exist
+  UPDATE   : 
+******************************************************************************/
+struct Unit  *kr_getUnitPtr(int unit_no)
+{
+  struct Unit   *unit_ptr;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if ((unit_no != 0) &&
+      (unit_no >= MinUnitNo) && (unit_no <= MaxUnitNo) &&
+      UNIT_IN_USE( unit_ptr = unit_array + unit_no ))
+    return( unit_ptr );
+
+  /*  invalid unit no.  */
+  KernelErrorCode = KRERR_UNIT_NO;
+  return( NULL );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getUnitValues
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : Returns the value of the specified unit component
+  UPDATE   : 
+******************************************************************************/
+FlintType  kr_getUnitValues(int unit_no, int component_selector)
+{
+  struct Unit   *unit_ptr;
+
+  unit_ptr = kr_getUnitPtr( unit_no );
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( (FlintType) 0);    /*  invalid unit no.  */
+
+  switch (component_selector)
+    {
+    case SEL_UNIT_ACT:
+      return( (FlintType) unit_ptr->act );
+    case SEL_UNIT_OUT:
+      return( (FlintType) unit_ptr->Out.output );
+    case SEL_UNIT_IACT:
+      return( (FlintType) unit_ptr->i_act );
+    case SEL_UNIT_BIAS:
+      return( (FlintType) unit_ptr->bias );
+    case SEL_UNIT_VALA: 
+      return( (FlintType) unit_ptr->value_a );
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return ((FlintType) 0);    /*  invalid selector */
+  }
+}
+/*****************************************************************************
+  FUNCTION : kr_setUnitValues
+
+  PURPOSE  : Sets the value of the specified unit component
+  NOTES    :
+
+  RETURNS  : Returns the errorcode
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_setUnitValues(int unit_no, int component_selector, 
+			   FlintTypeParam value)
+{
+  struct Unit   *unit_ptr;
+
+  unit_ptr = kr_getUnitPtr( unit_no );
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );	  /*  invalid unit no.	*/
+
+  switch (component_selector)
+    {
+    case SEL_UNIT_ACT:
+      unit_ptr->act = (FlintType) value;
+      break;
+    case SEL_UNIT_OUT:
+      unit_ptr->Out.output = (FlintType) value;
+      break;
+    case SEL_UNIT_IACT:
+      unit_ptr->i_act = (FlintType) value;
+      break;
+    case SEL_UNIT_BIAS:
+      unit_ptr->bias = (FlintType) value;
+      break;
+    case SEL_UNIT_VALA: 
+      unit_ptr->value_a = (FlintType) value;
+      break;
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      break;   /*  invalid selector */
+  }
+
+  return( KernelErrorCode );
+}
+/*****************************************************************************
+  FUNCTION : kr_setAllUnitValues
+
+  PURPOSE  : Sets all unit components of the specified unit
+  NOTES    :
+
+  RETURNS  : Returns the errorcode
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_setAllUnitValues(int unit_no, FlintTypeParam out, 
+			      FlintTypeParam act, FlintTypeParam i_act, 
+			      FlintTypeParam bias)
+{
+  struct Unit   *unit_ptr;
+
+  unit_ptr = kr_getUnitPtr( unit_no );
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  unit_ptr->Out.output = (FlintType) out;
+  unit_ptr->act = (FlintType) act;
+  unit_ptr->i_act = (FlintType) i_act;
+  unit_ptr->bias = (FlintType) bias;
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_makeDefaultUnit
+
+  PURPOSE  : Creates a unit with default values
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : Thomas Gern, 07.09.95 -> actbuf is initialized
+******************************************************************************/
+int  kr_makeDefaultUnit(void)
+{
+  struct Unit  *unit_ptr;
+  FunctionPtr  func_ptr;
+  int  unit_no;
+  int  i;
+
+  if ((unit_no = krm_getUnit()) == 0)
+    return( KernelErrorCode );
+  unit_no = abs(unit_no);
+
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  (void) kr_setAllUnitValues( unit_no, (FlintTypeParam) DEF_OUT, DefaultIAct,
+			      DefaultIAct, DefaultBias );
+
+  unit_ptr = unit_array + unit_no;
+
+  unit_ptr->Ftype_entry = NULL;
+  unit_ptr->value_a = (FlintType) 0;          /*previous bias change*/
+  unit_ptr->value_b = (FlintType) 0;          /*previous bias slope*/
+  unit_ptr->value_c = (FlintType) 0;          /*actual bias slope*/
+
+  for (i = 0; i < MAX_BPTT_BACKSTEP; i++)
+    unit_ptr->actbuf[i] = 0.0;
+
+
+  if (DefaultUFuncAct == NULL)  {
+    if (!krf_funcSearch( krf_getCurrentNetworkFunc( ACT_FUNC ), 
+                         ACT_FUNC, &func_ptr))
+      return( KernelErrorCode );
+
+    DefaultUFuncAct = (ActFuncPtr) func_ptr;
+
+    if (!krf_funcSearch( krf_getCurrentNetworkFunc( ACT_FUNC ), 
+                         ACT_DERIV_FUNC, &func_ptr))
+      return( KernelErrorCode );
+
+    DefaultUFuncActDeriv = (ActDerivFuncPtr) func_ptr;
+    
+    if (!krf_funcSearch( krf_getCurrentNetworkFunc( ACT_FUNC ), 
+                         ACT_2_DERIV_FUNC, &func_ptr))
+      return( KernelErrorCode );
+
+    DefaultUFuncAct2Deriv = (ActDerivFuncPtr) func_ptr;
+    
+    if (!krf_funcSearch( krf_getCurrentNetworkFunc( OUT_FUNC ), 
+                         OUT_FUNC, &func_ptr))
+      return( KernelErrorCode );
+
+    DefaultUFuncOut = (OutFuncPtr) func_ptr;
+  }
+
+  unit_ptr->out_func = DefaultUFuncOut;       /*  default output function  */
+  unit_ptr->act_func = DefaultUFuncAct;       /*  default activation function */
+  unit_ptr->act_deriv_func = DefaultUFuncActDeriv; /* def. derivation actfunc */
+  unit_ptr->act_2_deriv_func = DefaultUFuncAct2Deriv; 	/*  default derivation act. function */
+  unit_ptr->unit_name= NULL;			/*  default is no unit name */
+  unit_ptr->subnet_no  = DefaultSubnetNo;
+  unit_ptr->layer_no   = DefaultLayerNo;
+  unit_ptr->unit_pos.x = DefaultPosX;
+  unit_ptr->unit_pos.y = DefaultPosY;
+
+  unit_ptr->unit_pos.z = DefaultPosZ;
+
+  /*  set unit flags  */
+  unit_ptr->flags = UFLAG_INITIALIZED | DefaultSType;
+
+  /*  count units  */
+  kr_countUnits( unit_ptr, UNIT_ADD );
+
+  return( unit_no );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_createUnit
+
+  PURPOSE  : Creates a user defined unit
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_createUnit(char *unit_name, char *out_func_name, char *act_func_name, 
+		   FlintTypeParam i_act, FlintTypeParam bias)
+{
+  FunctionPtr   out_func_ptr, act_func_ptr, act_deriv_func_ptr,
+                act_2_deriv_func_ptr;
+  char  *str_ptr;
+  int   unit_no;
+  struct Unit  *unit_ptr;
+
+
+
+  if (!kr_symbolCheck( unit_name ))
+    return( KernelErrorCode );	/*  Symbol pattern invalid 
+				    (must match [A-Za-z]^[|, ]*)  */
+
+  if ( !krf_funcSearch( out_func_name, OUT_FUNC, &out_func_ptr ) )
+    return( KernelErrorCode );
+  if ( !krf_funcSearch( act_func_name, ACT_FUNC, &act_func_ptr ) )
+    return( KernelErrorCode );
+
+  /*  set the derivation function of the activation function  */ 
+  if ( !krf_funcSearch( act_func_name, ACT_DERIV_FUNC, &act_deriv_func_ptr ))
+    return( KernelErrorCode );
+
+  /*  set the second derivation function of the activation function  */ 
+  if ( !krf_funcSearch( act_func_name, ACT_2_DERIV_FUNC, &act_2_deriv_func_ptr ))
+    return( KernelErrorCode );
+
+  if ( (str_ptr = krm_NTableInsertSymbol( unit_name, UNIT_SYM ) ) == NULL)
+    return( KernelErrorCode );
+
+  unit_no = kr_makeDefaultUnit();
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  (void) kr_setAllUnitValues( unit_no, (FlintTypeParam) DEF_OUT,
+			      i_act, i_act, bias );
+
+  unit_ptr = unit_array + unit_no;
+
+  unit_ptr->out_func  = (OutFuncPtr) out_func_ptr;
+  unit_ptr->act_func  = (ActFuncPtr) act_func_ptr;
+  unit_ptr->act_deriv_func = (ActDerivFuncPtr) act_deriv_func_ptr;
+  unit_ptr->act_2_deriv_func = (ActDerivFuncPtr) act_2_deriv_func_ptr;
+  unit_ptr->unit_name = str_ptr;
+
+  NetModified = TRUE;
+  return( unit_no );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_unitSetTType
+
+  PURPOSE  : Sets the topologic type of the unit
+  NOTES    :
+
+  RETURNS  : Returns the errorcode
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_unitSetTType(int unit_no, int UnitTType)
+{
+  struct  Unit	*unit_ptr;
+  int  intflags;
+
+  if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+    return( KernelErrorCode );
+
+  intflags = kr_TType2Flags( UnitTType );
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  if (((FlagWord) intflags == UFLAG_TTYP_SPEC_X) ||
+      ((FlagWord) intflags == UFLAG_TTYP_N_SPEC_X)) {
+      if ((FlagWord) intflags == UFLAG_TTYP_SPEC_X) {
+	  /*  the topologic type of the unit will change  */
+	  NetModified = TRUE;
+	  /*  count units  */
+	  kr_countUnits( unit_ptr, UNIT_DELETE );
+	  
+	  /*  change topologic type of the unit,  add special Flag  */
+	  unit_ptr->flags |= (FlagWord)  UFLAG_TTYP_SPEC;
+	  
+	  /*  count units  */
+	  kr_countUnits( unit_ptr, UNIT_ADD );
+      }else{
+	  if((unit_ptr->flags & UFLAG_TTYP_PAT)!= UFLAG_TTYP_SPEC){ 
+	      /*  the topologic type of the unit will change  */
+	      NetModified = TRUE;
+	      /*  count units  */
+	      kr_countUnits( unit_ptr, UNIT_DELETE );
+
+	      /*  change topologic type of the unit,  delete special Flag  */
+	      unit_ptr->flags &= (FlagWord)  ~UFLAG_TTYP_SPEC;
+	  
+	      /*  count units  */
+	      kr_countUnits( unit_ptr, UNIT_ADD );
+	  }
+      }
+  }else{
+      if ((unit_ptr->flags & UFLAG_TTYP_PAT) != (FlagWord) intflags) {  
+	  /*  the topologic type of the unit will change  */
+	  NetModified = TRUE;
+	  /*  count units  */
+	  kr_countUnits( unit_ptr, UNIT_DELETE );
+	  
+	  /*  change topologic type of the unit  */
+	  unit_ptr->flags &= ~UFLAG_TTYP_PAT;
+	  unit_ptr->flags |= (FlagWord)  intflags;
+	  
+	  /*  count units  */
+	  kr_countUnits( unit_ptr, UNIT_ADD );
+      }
+  }
+
+  return( KernelErrorCode );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_setSite
+
+  PURPOSE  : initialize the first/next site or the named site at the current 
+             unit for access
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_setSite(int mode, char *site_name)
+{
+  struct SiteTable  *stbl_ptr;
+
+  if (unitPtr == NULL)  {
+    KernelErrorCode = KRERR_UNIT_NO;
+    return( KernelErrorCode );
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (mode)  {
+    case  FIRST:
+      prevSitePtr = NULL;
+
+      if UNIT_HAS_SITES( unitPtr )
+	{  /*  Unit has sites  */
+	sitePtr = unitPtr->sites;
+	return( TRUE );
+      }
+      else  {
+	sitePtr = NULL;
+	return( FALSE );
+      }
+
+    case  NEXT:
+      if ((sitePtr == NULL) || (sitePtr->next == NULL))  return( FALSE );
+
+      prevSitePtr = sitePtr;
+      sitePtr	  = sitePtr->next;
+      return( TRUE );
+
+    case  NAME:
+      if (!UNIT_HAS_SITES( unitPtr ))
+	{  /*  Current unit doesn't have sites  */
+	KernelErrorCode = KRERR_NO_SITES;
+	return( KernelErrorCode );
+      }
+
+      if ((stbl_ptr = krm_STableSymbolSearch( site_name )) == NULL)
+	{  /*	site name isn't defined */
+	KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+	return( KernelErrorCode );
+      }
+
+      for (sitePtr = unitPtr->sites, prevSitePtr = NULL;
+	   sitePtr != NULL;
+	   prevSitePtr = sitePtr, sitePtr = sitePtr->next)
+	if (sitePtr->site_table == stbl_ptr)
+	  return( KRERR_NO_ERROR );  /*  site was found  */
+
+      sitePtr = prevSitePtr = NULL;
+
+      /*  Current unit doesn't have a site with this name  */
+      KernelErrorCode = KRERR_NO_SUCH_SITE;  
+      return( KernelErrorCode );
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( KernelErrorCode );
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getUnit
+
+  PURPOSE  : returns the number of the first/next/current unit of the unit array
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_getUnit(int mode)
+{
+  register struct Unit   *unit_ptr;
+
+
+  if (NoOfUnits == 0)  return( 0 );
+
+  switch (mode)
+    {
+    case  FIRST:
+      unitNo = MinUnitNo;
+      unitPtr = unit_array + MinUnitNo;
+
+      if UNIT_HAS_SITES( unitPtr )
+	{  /*  Initialize current site pointer to the first available site */
+	prevSitePtr = NULL;
+	sitePtr = unitPtr->sites;
+      }
+      else
+	{  /*  No sites available  */
+	prevSitePtr = NULL;
+	sitePtr     = NULL;
+      }
+
+      return( unitNo );
+
+    case  NEXT:
+      unit_ptr = unitPtr;
+      if ((unit_ptr - unit_array) >= MaxUnitNo)  return( 0 );
+
+      while (!UNIT_IN_USE( ++unit_ptr )) ;
+
+      unitNo = unit_ptr - unit_array;
+      unitPtr = unit_ptr;
+
+      if UNIT_HAS_SITES( unit_ptr )
+	{  /*  Initialize current site pointer to the first available site */
+	prevSitePtr = NULL;
+	sitePtr = unit_ptr->sites;
+      }
+      else
+	{  /*  No sites available  */
+	prevSitePtr = NULL;
+	sitePtr     = NULL;
+      }
+
+      return( unitNo );
+
+    case  CURRENT:
+      return( unitNo );
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( 0 );
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_setCurrUnit
+
+  PURPOSE  : initializes the given unit for access
+  NOTES    :
+
+  RETURNS  : Returns the errorcode 
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_setCurrUnit(int unit_no)
+{
+  struct Unit   *unit_ptr;
+
+
+  if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+    return( KernelErrorCode );
+
+  unitNo = unit_no;
+  unitPtr = unit_ptr;
+
+  if UNIT_HAS_SITES( unit_ptr )
+    {  /*  Initialize current site pointer to the first available site */
+    prevSitePtr = NULL;
+    sitePtr = unit_ptr->sites;
+  }
+  else
+    {  /*  No sites available  */
+    prevSitePtr = NULL;
+    sitePtr	= NULL;
+  }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getPredecessorUnit
+
+  PURPOSE  : Returns the no. of first, next or current predecessor unit of the
+             current unit/site and the connection weight
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_getPredecessorUnit(int mode, FlintType *weight, float* val_a, float* val_b, float* val_c)
+{
+  static struct Link  *link_ptr = NULL;
+
+
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return( 0 );
+  }
+
+  switch (mode)
+    {
+    case  FIRST:  /*  first predecessor link wanted  */
+      if UNIT_HAS_SITES( unitPtr )
+	{
+	if (sitePtr == NULL)
+	  /*  site not initialized  */
+	  link_ptr = unitPtr->sites->links;
+	else
+	  link_ptr = sitePtr->links;
+      }
+      else
+	link_ptr = (struct Link *) unitPtr->sites;
+
+      linkPtr = link_ptr;
+      prevLinkPtr = NULL;
+      if (link_ptr == NULL)  return( 0 );  /*  No inputs   */
+
+      *weight = link_ptr->weight;
+      *val_a  = link_ptr->value_a;
+      *val_b  = link_ptr->value_b;
+      *val_c  = link_ptr->value_c;
+      return( link_ptr->to - unit_array );  /*	Return unit number  */
+
+    case  NEXT:
+      if (link_ptr == NULL)
+	 {  /*	no current link  */
+	 KernelErrorCode = KRERR_NO_CURRENT_LINK;
+	 return( 0 );
+       }
+
+      prevLinkPtr = link_ptr;
+      if ((linkPtr = link_ptr = link_ptr->next) == NULL)
+	{
+	prevLinkPtr = NULL;
+	return( 0 );  /*  no successor unit  */
+      }
+
+
+      *weight = link_ptr->weight;
+      *val_a  = link_ptr->value_a;
+      *val_b  = link_ptr->value_b;
+      *val_c  = link_ptr->value_c;
+      return( link_ptr->to - unit_array );  /*	Return unit number  */
+
+    case  CURRENT:
+      if (link_ptr == NULL)
+	 {  /*	no current link  */
+	 KernelErrorCode = KRERR_NO_CURRENT_LINK;
+	 return( 0 );
+       }
+
+      *weight = link_ptr->weight;
+      *val_a  = link_ptr->value_a;
+      *val_b  = link_ptr->value_b;
+      *val_c  = link_ptr->value_c;
+      return( link_ptr->to - unit_array );  /*	Return unit number  */
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( 0 );
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_searchOutputConnection
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static int  kr_searchOutputConnection(struct Unit *start_unit_ptr, 
+				      struct Unit *source_unit_ptr, 
+				      FlintType *weight)
+{
+  register struct  Link  *link_ptr, *prev_link_ptr;
+  register struct  Unit  *source_unit;
+  register struct  Site  *site_ptr, *prev_site_ptr;
+  register struct  Unit  *unit_ptr;
+
+
+  source_unit = source_unit_ptr;
+
+  if ((sitePtr != NULL))
+    {  /*  current unit has sites, so search for another connection at the
+	   other sites of the unit  */
+    for (site_ptr = sitePtr->next, prev_site_ptr = sitePtr;
+	 site_ptr != NULL;
+	 prev_site_ptr = site_ptr, site_ptr = site_ptr->next)
+      for (link_ptr = site_ptr->links, prev_link_ptr = NULL;
+	   link_ptr != NULL;
+	   prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+	if (link_ptr->to == source_unit)
+	  {
+	  sitePtr = site_ptr;  /*  set current site  */
+	  prevSitePtr = prev_site_ptr;	/*  set previous site  */
+	  linkPtr = link_ptr;  /*  set current link  */
+	  prevLinkPtr = prev_link_ptr;	/*  set previous link  */
+
+	  *weight = link_ptr->weight;
+	  return( unitNo );
+        }
+
+    start_unit_ptr++;  /*  no connection found at the current site,
+                           so start search at the next units  */
+  }
+
+  for(unit_ptr = start_unit_ptr; unit_ptr <= unit_array + MaxUnitNo; unit_ptr++)
+    if UNIT_IN_USE( unit_ptr )
+       {
+       if UNIT_HAS_DIRECT_INPUTS( unit_ptr )
+	 {
+	 for (link_ptr = (struct Link *) unit_ptr->sites, prev_link_ptr = NULL;
+	      link_ptr != NULL;
+	      prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+	   if (link_ptr->to == source_unit)
+	     {
+	     unitPtr = unit_ptr;  /*  set current unit pointer	*/
+	     unitNo = unit_ptr - unit_array;  /*  set current unit no.	*/
+	     sitePtr = prevSitePtr = NULL;  /*	no current site  */
+	     linkPtr = link_ptr;  /*  set current link	*/
+	     prevLinkPtr = prev_link_ptr;  /*  set previous link  */
+
+	     *weight = link_ptr->weight;
+	     return( unitNo );
+	   }
+       }
+       else
+	 if UNIT_HAS_SITES( unit_ptr )
+	   {
+	   for (site_ptr = unit_ptr->sites, prev_site_ptr = NULL;
+		site_ptr != NULL;
+		prev_site_ptr = site_ptr, site_ptr = site_ptr->next)
+	     for (link_ptr = site_ptr->links, prev_link_ptr = NULL;
+		  link_ptr != NULL;
+		  prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+	       if (link_ptr->to == source_unit)
+		 {
+		 unitPtr = unit_ptr;  /*  set current unit pointer  */
+		 unitNo = unit_ptr - unit_array;  /*  set current unit no.  */
+		 sitePtr = site_ptr;  /*  set current site  */
+		 prevSitePtr = prev_site_ptr;  /*  set previous site  */
+		 linkPtr = link_ptr;  /*  set current link  */
+		 prevLinkPtr = prev_link_ptr;  /*  set previous link  */
+
+		 *weight = link_ptr->weight;
+		 return( unitNo );
+	       }
+	 }
+    }
+
+  /*  no successor unit found  */
+  unitPtr = NULL; unitNo = 0;  /*  no current unit  */
+  sitePtr = prevSitePtr = NULL;  /*  no current site  */
+  linkPtr = prevLinkPtr = NULL;  /*  no current link  */
+
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getSuccessorUnit
+
+  PURPOSE  : Returns the no. of first or next succecessor unit of the
+             given unit and the connection strenght.
+             Sets the current unit/site.
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_getSuccessorUnit(int mode, int source_unit_no, FlintType *weight)
+{
+  static struct Unit  *source_unit_ptr,
+		      *current_unit_ptr = NULL;
+  static struct Site  *current_site_ptr = NULL;
+  int  unit_no;
+
+
+  switch (mode)
+    {
+    case  FIRST:  /*  first successor link wanted  */
+      if ((source_unit_ptr = kr_getUnitPtr( source_unit_no )) == NULL)
+	return( KernelErrorCode );
+
+      sitePtr = NULL;  /*  no current Site  */
+      unit_no = kr_searchOutputConnection( unit_array + MinUnitNo,
+					   source_unit_ptr, weight );
+      current_unit_ptr = unitPtr;
+      current_site_ptr = sitePtr;
+
+      return( unit_no );
+
+    case  NEXT:  /*  next successor link wanted  */
+      if (current_unit_ptr == NULL)
+	{  /*  no current unit	*/
+	KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+	return( 0 );
+      }
+
+      sitePtr = current_site_ptr;
+
+      unit_no = kr_searchOutputConnection( current_unit_ptr + 1,
+					   source_unit_ptr, weight );
+      current_unit_ptr = unitPtr;
+      current_site_ptr = sitePtr;
+
+      return( unit_no );
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( 0 );
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_areConnected
+
+  PURPOSE  : True if there exists a connection between source unit 
+             <source_unit_no> and target unit <target_unit_no>, otherwise false.
+	     If there exist a  connection between these units, kr_areConnected 
+	     returns the connection strength also.
+  NOTES    : This function is slow (Units are backward chained only)
+  IMPORTANT: If there exist a connection, the current unit and site will be
+	     set to the target unit/site.
+
+  RETURNS  : Returns FALSE if unit doesn't exist.
+  UPDATE   : 
+******************************************************************************/
+bool  kr_areConnected(int source_unit_no, int target_unit_no, FlintType *weight)
+{
+  register struct  Link  *link_ptr, *prev_link_ptr;
+  register struct  Unit  *source_unit_ptr;
+  register struct  Site  *site_ptr, *prev_site_ptr;
+  struct  Unit	*target_unit_ptr;
+
+
+  if ( (source_unit_ptr = kr_getUnitPtr( source_unit_no ) ) == NULL)
+    return( FALSE );    /*  invalid unit #  */
+  if ( (target_unit_ptr = kr_getUnitPtr( target_unit_no ) ) == NULL)
+    return( FALSE );    /*  invalid unit #  */
+
+  if UNIT_HAS_DIRECT_INPUTS( target_unit_ptr )
+    {
+    for(link_ptr = (struct Link *) target_unit_ptr->sites, prev_link_ptr = NULL;
+	 link_ptr != NULL;
+	 prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+      if (link_ptr->to == source_unit_ptr)
+	{  /*  connection found  */
+	unitPtr = target_unit_ptr;  /*	set current unit pointer  */
+	unitNo = target_unit_no;  /*  set current unit no.  */
+	sitePtr = prevSitePtr = NULL;  /*  no current site  */
+	linkPtr = link_ptr;  /*  set current link  */
+	prevLinkPtr = prev_link_ptr;  /*  set previous link  */
+
+	*weight = link_ptr->weight;
+	return( TRUE );
+      }
+  }
+  else
+    if UNIT_HAS_SITES( target_unit_ptr )
+      for (site_ptr = target_unit_ptr->sites, prev_site_ptr = NULL;
+	   site_ptr != NULL;
+	   prev_site_ptr = site_ptr, site_ptr = site_ptr->next)
+	for (link_ptr = site_ptr->links, prev_link_ptr = NULL;
+	     link_ptr != NULL;
+	     prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+	  if (link_ptr->to == source_unit_ptr)
+	    {  /*  connection found  */
+	    unitPtr = target_unit_ptr;	/*  set current unit pointer  */
+	    unitNo = target_unit_no;  /*  set current unit no.	*/
+	    sitePtr = site_ptr;  /*  set current site  */
+	    prevSitePtr = prev_site_ptr;  /*  set previous site  */
+	    linkPtr = link_ptr;  /*  set current link  */
+	    prevLinkPtr = prev_link_ptr;  /*  set previous link  */
+
+	    *weight = link_ptr->weight;
+	    return( TRUE );
+	  }
+
+  /*  no successor unit found  */
+  unitPtr = NULL; unitNo = 0;  /*  no current unit  */
+  sitePtr = prevSitePtr = NULL;  /*  no current site  */
+  linkPtr = prevLinkPtr = NULL;  /*  no current link  */
+
+  return( FALSE );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_isConnected
+
+  PURPOSE  : 
+  NOTES    : If there exists a connection between the two units, the current 
+             link is set to the link between the two units.
+  RETURNS  : True if there exists a connection between source unit 
+             <source_unit_no> and the current unit/site, otherwise false.
+  UPDATE   : 
+******************************************************************************/
+bool  kr_isConnected(int source_unit_no, FlintType *weight)
+{
+  register struct  Link  *link_ptr, *prev_link_ptr;
+  register struct  Unit  *source_unit_ptr;
+  struct  Link	*start_link_ptr;
+
+
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return( FALSE );
+  }
+  if ((source_unit_ptr = kr_getUnitPtr( source_unit_no ) ) == NULL)
+    return( FALSE );  /*  invalid unit #  */
+
+  if UNIT_HAS_DIRECT_INPUTS( unitPtr )
+    start_link_ptr = (struct Link *) unitPtr->sites;
+  else
+    if UNIT_HAS_SITES( unitPtr )
+      start_link_ptr = sitePtr->links;
+    else
+      return( FALSE );
+
+  for (link_ptr = start_link_ptr, prev_link_ptr = NULL;
+       link_ptr != NULL;
+       prev_link_ptr = link_ptr, link_ptr = link_ptr->next)
+    if (link_ptr->to == source_unit_ptr)
+      {  /*  connection found  */
+      linkPtr = link_ptr;  /*  set current link  */
+      prevLinkPtr = prev_link_ptr;  /*	set previous link  */
+
+      *weight = link_ptr->weight;
+      return( TRUE );
+    }
+
+  /*  no successor unit found  */
+  linkPtr = prevLinkPtr = NULL;  /*  no current link  */
+
+  return( FALSE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getLinkWeight
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : Returns the link weight of the current link
+  UPDATE   : 
+******************************************************************************/
+FlintType  kr_getLinkWeight(void)
+{
+  if (linkPtr != NULL)	return( linkPtr->weight );
+
+  KernelErrorCode = KRERR_NO_CURRENT_LINK;
+  return( (FlintType) 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_setLinkWeight
+
+  PURPOSE  : Sets the link weight of the current link
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  kr_setLinkWeight(FlintTypeParam weight)
+{
+  if (linkPtr != NULL)
+    {
+    linkPtr->weight = weight;
+    return;
+  }
+
+  KernelErrorCode = KRERR_NO_CURRENT_LINK;
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_createLink 
+
+  PURPOSE  : Creates a link between source unit and the current unit/site 
+  NOTES    : kr_createLink DO NOT set the current link
+             If you want to create a link and its unknown if there exists 
+	     already a connection between the two units, use krui_createLink 
+	     and test the return code, instead of the sequence kr_isConnected 
+	     and kr_createLink
+  RETURNS  : Returns an error code:
+             - if memory allocation fails
+             - if source unit doesn't exist or
+             - if there exists already a connection between current unit/site 
+	     and the source unit
+             0 otherwise.    
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_createLink(int source_unit_no, FlintTypeParam weight)
+{
+  register struct Link	*link_ptr;
+  register struct Unit	*source_unit_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return( KernelErrorCode );
+  }
+
+  if ((source_unit_ptr = kr_getUnitPtr( source_unit_no ) ) == NULL)
+    return( KernelErrorCode );	/*  invalid unit #  */
+
+  switch ((int) (unitPtr->flags & UFLAG_INPUT_PAT))
+    {
+    case  UFLAG_NO_INP:  /*  current unit doesn't have inputs  */
+      if ((link_ptr = krm_getLink()) == NULL)
+	return( KernelErrorCode );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = NULL;
+
+      unitPtr->sites = (struct Site *) link_ptr;
+      unitPtr->flags |= UFLAG_DLINKS;  /*  unit has direkt inputs now  */
+
+      break;
+
+    case  UFLAG_DLINKS:  /*  current unit has direct inputs  */
+      FOR_ALL_LINKS( unitPtr, link_ptr )
+	if (link_ptr->to == source_unit_ptr)
+	  {  /*  there exists already a connection  */
+	  KernelErrorCode = KRERR_ALREADY_CONNECTED;
+	  return( KRERR_ALREADY_CONNECTED );
+	}
+
+      if ((link_ptr = krm_getLink()) == NULL)
+	return( KernelErrorCode );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = (struct Link *) unitPtr->sites;
+      unitPtr->sites   = (struct Site *) link_ptr;
+
+      break;
+
+    case  UFLAG_SITES:	/*  current unit has sites  */
+      FOR_ALL_LINKS_AT_SITE( sitePtr, link_ptr )
+	if (link_ptr->to == source_unit_ptr)
+	  {  /*  there exists already a connection  */
+	  KernelErrorCode = KRERR_ALREADY_CONNECTED;
+	  return( KRERR_ALREADY_CONNECTED );
+	}
+
+      if ((link_ptr = krm_getLink()) == NULL)
+	return( KernelErrorCode );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = (struct Link *) sitePtr->links;
+      sitePtr->links   = link_ptr;
+
+      break;
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( KernelErrorCode );
+  }
+
+  NetModified = TRUE;
+  return( KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_createLinkWithAdditionalParameters
+
+  PURPOSE  : Creates a link between source unit and the current unit/site 
+             and sets the values for value_a, value_b and value_c.
+  NOTES    : this version returns pointer to the new link and no error value.
+             This means that you have to use the routine as follows :
+               NewLink=kr_createLinkWithAdditionalParameters(...);
+               if (KernelErrorCode!=KRERR_NO_ERROR) return(KernelErroCode);
+             
+             See notes of kr_createLink, too
+
+  UPDATE   : 13.05.96 <Juergen Gatter>
+******************************************************************************/
+ struct Link*  kr_createLinkWithAdditionalParameters
+                      (int source_unit_no, FlintTypeParam weight,
+                       float val_a,float val_b,float val_c)
+{
+  register struct Link	*link_ptr=NULL;
+  register struct Unit	*source_unit_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return ( link_ptr );
+  }
+
+  if ((source_unit_ptr = kr_getUnitPtr( source_unit_no ) ) == NULL)
+    return ( link_ptr );	/*  invalid unit #  */
+
+  switch ((int) (unitPtr->flags & UFLAG_INPUT_PAT))
+    {
+    case  UFLAG_NO_INP:  /*  current unit doesn't have inputs  */
+      if ((link_ptr = krm_getLink()) == NULL)
+	return ( link_ptr );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = NULL;
+      link_ptr->value_a = val_a;
+      link_ptr->value_b = val_b;
+      link_ptr->value_c = val_c;
+
+      unitPtr->sites = (struct Site *) link_ptr;
+      unitPtr->flags |= UFLAG_DLINKS;  /*  unit has direkt inputs now  */
+
+      break;
+
+    case  UFLAG_DLINKS:  /*  current unit has direct inputs  */
+      FOR_ALL_LINKS( unitPtr, link_ptr )
+	if (link_ptr->to == source_unit_ptr)
+	  {  /*  there exists already a connection  */
+	  KernelErrorCode = KRERR_ALREADY_CONNECTED;
+	  return( link_ptr );
+	}
+
+      if ((link_ptr = krm_getLink()) == NULL)
+	return( link_ptr );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = (struct Link *) unitPtr->sites;
+      link_ptr->value_a = val_a;
+      link_ptr->value_b = val_b;
+      link_ptr->value_c = val_c;
+      unitPtr->sites   = (struct Site *) link_ptr;
+
+      break;
+
+    case  UFLAG_SITES:	/*  current unit has sites  */
+      FOR_ALL_LINKS_AT_SITE( sitePtr, link_ptr )
+	if (link_ptr->to == source_unit_ptr)
+	  {  /*  there exists already a connection  */
+	  KernelErrorCode = KRERR_ALREADY_CONNECTED;
+	  return( link_ptr );
+	}
+
+      if ((link_ptr = krm_getLink()) == NULL)
+	return( link_ptr );
+
+      link_ptr->to     = source_unit_ptr;
+      link_ptr->weight = (FlintType) weight;
+      link_ptr->next   = (struct Link *) sitePtr->links;
+      link_ptr->value_a = val_a;
+      link_ptr->value_b = val_b;
+      link_ptr->value_c = val_c;
+      sitePtr->links   = link_ptr;
+
+      break;
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( link_ptr );
+  }
+
+  NetModified = TRUE;
+  return( link_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_deleteLink 
+
+  PURPOSE  : Deletes the current link
+  NOTES    : To delete a link between the current unit/site and the source unit
+             <source_unit_no>, call krui_isConnected( source_unit_no ) and
+             krui_deleteLink()
+
+  RETURNS  : Returns the errorcode
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_deleteLink(void)
+{
+  register struct Link	 *next_link_ptr;
+
+
+  if (linkPtr == NULL)
+    {  /*  no current link  */
+    KernelErrorCode = KRERR_NO_CURRENT_LINK;
+    return( KernelErrorCode );
+  }
+
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return( KernelErrorCode );
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  switch ((int) (unitPtr->flags & UFLAG_INPUT_PAT))
+    {
+    case  UFLAG_NO_INP:  /*  current unit doesn't have inputs  */
+      KernelErrorCode = KRERR_UNIT_NO_INPUTS;
+      return( KernelErrorCode );
+
+    case  UFLAG_DLINKS:  /*  current unit has direct inputs  */
+      next_link_ptr = linkPtr->next;
+      krm_releaseLink( linkPtr );
+      linkPtr = next_link_ptr;
+
+      if (prevLinkPtr != NULL)	/*  current link isn't first link at the unit */
+	prevLinkPtr->next = next_link_ptr;  /*	chain previous link pointer
+						with next link pointer	*/
+      else
+	{  /*  current link is the first link at the unit  */
+	unitPtr->sites = (struct Site *) next_link_ptr;
+	if (next_link_ptr == NULL)
+	  unitPtr->flags &= (~UFLAG_INPUT_PAT);  /* last input deleted: 
+						    the unit has no inputs now*/
+      }
+
+      NetModified = TRUE;
+      return( KRERR_NO_ERROR );
+
+    case  UFLAG_SITES:	/*  current unit has sites  */
+      next_link_ptr = linkPtr->next;
+      krm_releaseLink( linkPtr );
+      linkPtr = next_link_ptr;
+
+      if (prevLinkPtr != NULL)	/*  current link isn't first link at the unit */
+	prevLinkPtr->next = next_link_ptr;  /*	chain previous link pointer
+						with next link pointer	*/
+      else  /*	current link is the first link at the unit  */
+	sitePtr->links = next_link_ptr;
+
+      NetModified = TRUE;
+      return( KRERR_NO_ERROR );
+   }
+
+  KernelErrorCode = KRERR_PARAMETERS;
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_deleteAllLinks
+
+  PURPOSE  : Deletes all input links at current unit/site
+  NOTES    : 
+
+  RETURNS  : Returns the errorcode
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_deleteAllLinks(int mode)
+{
+  if (unitPtr == NULL)
+    {  /*  no current unit  */
+    KernelErrorCode = KRERR_NO_CURRENT_UNIT;
+    return( KernelErrorCode );
+  }
+
+  linkPtr = NULL;
+  NetModified = TRUE;
+
+  switch (mode)
+    {
+    case  INPUTS:  /*  delete all inputs  */
+      if UNIT_HAS_DIRECT_INPUTS( unitPtr )
+	{
+	krm_releaseAllLinks( (struct Link *) unitPtr->sites );
+	unitPtr->sites = NULL;
+	unitPtr->flags &= (~UFLAG_INPUT_PAT);  /*  unit don't has inputs now  */
+
+	return( KernelErrorCode );
+      }
+
+      if UNIT_HAS_SITES( unitPtr )
+	{
+	krm_releaseAllLinks( sitePtr->links );
+	sitePtr->links = NULL;	/*  site has no inputs now   */
+
+	return( KernelErrorCode );
+      }
+
+      return( KernelErrorCode );
+
+    case  OUTPUTS:  /*	delete all outputs  */
+      kr_deleteAllOutputLinks( unitPtr );
+
+      return( KernelErrorCode );
+  }
+
+  KernelErrorCode = KRERR_PARAMETERS;
+  return( KernelErrorCode );
+}
+
+
+
+
+
+
+
+
+/*#################################################
+
+GROUP: Low-Level Kernel Functions
+
+#################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : kr_deleteAllInputs
+
+  PURPOSE  : delete all links and sites at the given unit
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void    kr_deleteAllInputs(struct Unit *unit_ptr)
+{
+  register struct Site	*site_ptr;
+
+
+  if (UNIT_HAS_SITES( unit_ptr ))
+    {   /*  Unit has sites  */
+    FOR_ALL_SITES( unit_ptr, site_ptr )
+      /*  Release all links   */
+      krm_releaseAllLinks( site_ptr->links );
+
+    krm_releaseAllSites( unit_ptr->sites );
+  }
+  else
+    {   /*  Unit don't has sites   */
+    if (UNIT_HAS_DIRECT_INPUTS( unit_ptr ))
+      krm_releaseAllLinks( (struct Link *) unit_ptr->sites );
+  }
+
+  unit_ptr->sites = NULL;
+
+  /*  The unit has no inputs now  */
+  unit_ptr->flags &= (~UFLAG_INPUT_PAT);
+}
+
+/*****************************************************************************
+  FUNCTION : kr_deleteAllOutputLinks
+
+  PURPOSE  : Deletes all output links at <source_unit>
+  NOTES    : This function is slow
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  kr_deleteAllOutputLinks(struct Unit *source_unit_ptr)
+{
+  register struct Link   *link_ptr,
+                         *pred_link_ptr;
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )
+      if UNIT_HAS_SITES( unit_ptr )
+        {  /*  unit has sites  */
+	FOR_ALL_SITES( unit_ptr, site_ptr )
+          for (link_ptr = site_ptr->links, pred_link_ptr = NULL;
+               link_ptr != NULL;
+               pred_link_ptr = link_ptr, link_ptr = link_ptr->next)
+
+            if (link_ptr->to == source_unit_ptr)
+              {     /*  Connection between unit and source_unit found   */
+              if (pred_link_ptr == NULL)
+                site_ptr->links = link_ptr->next;
+              else
+                pred_link_ptr->next = link_ptr->next;
+
+              krm_releaseLink( link_ptr );
+
+              break;    /*  next site/unit  */
+	    }
+      }
+      else  /*	unit has no sites   */
+	if UNIT_HAS_DIRECT_INPUTS( unit_ptr )
+          for (link_ptr = (struct Link *) unit_ptr->sites, pred_link_ptr = NULL;
+               link_ptr != NULL;
+               pred_link_ptr = link_ptr, link_ptr = link_ptr->next)
+            if (link_ptr->to == source_unit_ptr)
+              {     /*  Connection between unit and source_unit found   */
+              if (pred_link_ptr == NULL)
+                {
+                unit_ptr->sites = (struct Site *) link_ptr->next;
+                if (link_ptr->next == NULL)
+                  /*  The unit has no inputs now  */
+                  unit_ptr->flags &= (~UFLAG_INPUT_PAT);
+	      }
+              else
+                pred_link_ptr->next = link_ptr->next;
+
+              krm_releaseLink( link_ptr );
+
+              break;    /*  next unit  */
+	    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_copyOutputLinks
+
+  PURPOSE  : Copies all output links at <source_unit> to <new_unit>.
+  NOTES    : This function is slow
+
+  RETURNS  : Returns error code if memory allocation fails.
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_copyOutputLinks(struct Unit *source_unit_ptr, 
+				    struct Unit *new_unit_ptr)
+{
+  register struct Link   *link_ptr,
+			 *new_link;
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )
+      if UNIT_HAS_DIRECT_INPUTS( unit_ptr )
+	FOR_ALL_LINKS( unit_ptr, link_ptr )
+	  if (link_ptr->to == source_unit_ptr)
+	    {  /*  Connection between unit and source_unit found   */
+	    if ( (new_link = krm_getLink() ) == NULL)
+	      return( KernelErrorCode );
+
+	    memcpy( (char *) new_link, (char *) link_ptr, LINK_SIZE );
+	    new_link->next = (struct Link *) unit_ptr->sites;
+	    unit_ptr->sites = (struct Site *) new_link;
+
+	    new_link->to = new_unit_ptr;
+	    new_link->weight = link_ptr->weight;
+	    break;    /*  next unit  */
+	  }
+      else
+	if UNIT_HAS_SITES( unit_ptr )
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	    if (link_ptr->to == source_unit_ptr)
+	      {  /*  Connection between unit and source_unit found   */
+	      if ( (new_link = krm_getLink() ) == NULL)
+		return( KernelErrorCode );
+
+	      new_link->next = site_ptr->links;
+	      site_ptr->links = new_link;
+
+	      new_link->to = new_unit_ptr;
+	      new_link->weight = link_ptr->weight;
+
+	      break;	/*  next site/unit  */
+	    }
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_copyInputLinks
+
+  PURPOSE  : Copy all input links from <source_unit> to <new_unit>
+  NOTES    : 
+
+  RETURNS  : Returns error code 
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_copyInputLinks(struct Unit *source_unit_ptr, 
+				   struct Unit *new_unit_ptr)
+{
+  register struct Link	 *link_ptr, *new_link,
+			 *last_link_ptr;
+  register struct Site	 *source_site_ptr, *dest_site_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if UNIT_HAS_DIRECT_INPUTS( source_unit_ptr )
+    {
+    last_link_ptr = new_link = NULL;
+    FOR_ALL_LINKS( source_unit_ptr, link_ptr )
+      {
+      if ((new_link = krm_getLink()) == NULL)
+	{
+	new_unit_ptr->sites = (struct Site *) last_link_ptr;
+	return( KernelErrorCode );
+      }
+
+      memcpy( (char *) new_link, (char *) link_ptr, LINK_SIZE );
+      new_link->next = last_link_ptr;
+      last_link_ptr = new_link;
+    }
+
+    new_unit_ptr->sites = (struct Site *) new_link;
+    new_unit_ptr->flags &= ~UFLAG_INPUT_PAT;
+    if (new_link != NULL)  new_unit_ptr->flags |= UFLAG_DLINKS;
+  }
+  else
+    if UNIT_HAS_SITES( source_unit_ptr )
+      FOR_ALL_SITES( source_unit_ptr, source_site_ptr )
+	FOR_ALL_SITES( new_unit_ptr, dest_site_ptr )
+	  if (source_site_ptr->site_table == dest_site_ptr->site_table)
+	    {
+	    last_link_ptr = new_link = NULL;
+	    FOR_ALL_LINKS_AT_SITE( source_site_ptr, link_ptr )
+	      {
+	      if ((new_link = krm_getLink()) == NULL)
+		{
+		dest_site_ptr->links = last_link_ptr;
+		return( KernelErrorCode );
+	      }
+
+	      memcpy( (char *) new_link, (char *) link_ptr, LINK_SIZE );
+	      new_link->next = last_link_ptr;
+	      last_link_ptr = new_link;
+	      }
+
+	    dest_site_ptr->links = new_link;
+	  }
+
+  return( KernelErrorCode );
+}
+
+
+
+
+/*#################################################
+
+GROUP: Site Name/Func functions
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : kr_searchUnitSite
+
+  PURPOSE  : search for a site at a unit
+  NOTES    : 
+
+  RETURNS  : Returns the site or NULL
+  UPDATE   : 
+******************************************************************************/
+struct Site *kr_searchUnitSite(struct Unit *unit_ptr,struct SiteTable *stbl_ptr)
+{
+  register struct Site	*site_ptr;
+
+  FOR_ALL_SITES( unit_ptr, site_ptr )
+    if (site_ptr->site_table == stbl_ptr)
+      return( site_ptr );
+
+  return( NULL );   /*  there is no site at this unit with this name    */
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_searchNetSite
+
+  PURPOSE  : searches for a site in the network
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_searchNetSite(struct SiteTable *stbl_ptr)
+{
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+
+
+  if (NoOfUnits == 0)
+    return( 0 ); /*  no units -> no sites */
+
+  FOR_ALL_UNITS( unit_ptr )
+    if (UNIT_HAS_SITES( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {  /*  unit has sites and is in use  */
+      FOR_ALL_SITES( unit_ptr, site_ptr )
+        if (site_ptr->site_table == stbl_ptr)
+          return( unit_ptr - unit_array );  /*  return unit no. */
+    }
+
+  return( 0 );  /*  site isn't in use   */
+}
+
+
+/*#################################################
+
+GROUP: Link Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_jogWeights
+
+  PURPOSE  : Add random uniform distributed values to connection weights.
+             <minus> must be less then <plus>.
+             New:
+             Value and range depends on the given parameters and the current
+             weight. e.g.:
+             -0.02, 0.04 means that the new weight will be in the range of
+             100-2% to 100+4% = 98% to 104% of its previous value.
+
+  NOTES    : The old way of just adding noise may be achieved by defining
+             -DJOGWEIGHTS_BY_ADDING during compilation
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  kr_jogWeights(FlintTypeParam minus, FlintTypeParam plus)
+{
+  register  struct Link   *link_ptr;
+  FlagWord	flags;
+  struct Unit   *unit_ptr;
+  struct Site   *site_ptr;
+  register FlintType  range, min;
+
+
+  if (NoOfUnits == 0)  return;  /*  no. units  */
+  range = plus - minus;
+  min = minus;
+
+  FOR_ALL_UNITS( unit_ptr )  {
+    flags = unit_ptr->flags;
+
+      if(((flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+	  && !IS_SPECIAL_UNIT(unit_ptr))
+      /*  unit is in use  */
+      if (flags & UFLAG_DLINKS)
+	/*  unit has direct links   */
+	FOR_ALL_LINKS( unit_ptr, link_ptr )
+#ifdef JOGWEIGHTS_BY_ADDING
+          link_ptr->weight += (FlintType) drand48() * range + min;
+#else
+          link_ptr->weight += link_ptr->weight * ((FlintType) drand48() * range + min);
+      
+#endif
+	  else
+	if (flags & UFLAG_SITES)
+	  /*  unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+#ifdef JOGWEIGHTS_BY_ADDING
+            link_ptr->weight += (FlintType) drand48() * range + min;
+#else
+            link_ptr->weight += link_ptr->weight * ((FlintType) drand48() * range + min);
+#endif
+  }
+}
+
+/*****************************************************************************
+
+  GROUP: correlation
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : kr_getCorrelatedHiddens
+  PURPOSE  : calculate correlation coefficients between all non-special
+             hidden units, determine the two hidden units with maximum
+	     correlation, return the pointers to these units and their
+	     correlation coefficient.
+	     If no such units exist return NULL pointers instead of unit 
+	     pointers.
+
+	     calculate correlation coefficients between all non-special
+             hidden units of the current network over all pattern. 
+             Store these values into the 
+	     kr_CorrMatrix in the following way:
+
+	     for all non-special hidden units c and r 
+             (c, r = unit_array indexed from first hidden unit)
+	     with r > c
+	     kr_CorrMatrix[row=r][column=c] = 
+	         correlation coefficient between these two units, based on 
+		 unit output values for all patterns of the current pattern set.
+
+	     Note that the following values are not set since they are obsolete:
+	     kr_CorrMatrix[row=n][column=n] == 1
+	     kr_CorrMatrix[row=c][column=r] == kr_CorrMatrix[row=r][column=c]
+
+  NOTES    : mean in value_b, stddev in value_c
+  RETURNS  : kernel error code
+******************************************************************************/
+
+static krui_err kr_getCorrelatedHiddens(struct Unit **hn1, struct Unit **hn2, 
+					double *res_corr)
+{
+    static RbfFloatMatrix kr_CorrMatrix = {0, 0, NULL, NULL};
+
+    int no_of_layers;
+
+    struct Unit *unit_ptr;
+    struct Unit *unit_ptr2;
+    struct Unit *first_hidden;
+    int pattern_no, sub_pat_no, no_of_patterns;
+    int MyNoOfHidden;
+    int col, row;
+    double covadd;
+    double corr;
+    double mincorr, maxcorr;
+    int mincorrcol, mincorrrow;
+    int maxcorrcol, maxcorrrow;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) &&
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+    /* initialize value_b and value_c of each unit */
+    MyNoOfHidden = 0;
+    first_hidden = NULL;
+    FOR_ALL_UNITS (unit_ptr) 
+	if (IS_HIDDEN_UNIT (unit_ptr))
+	{
+	    MyNoOfHidden++;
+	    if (!first_hidden)
+		first_hidden = unit_ptr;
+	    if (! IS_SPECIAL_UNIT (unit_ptr)) 
+	    {
+		unit_ptr->value_b = 0;
+		unit_ptr->value_c = 0;
+	    }
+	}
+
+    /* allocate space for new correlation matrix if necessary: */
+    if (kr_CorrMatrix.rows < MyNoOfHidden || 
+	kr_CorrMatrix.columns < MyNoOfHidden)
+    {
+	if (kr_CorrMatrix.field != NULL)
+	    RbfFreeMatrix(&kr_CorrMatrix);
+
+	if (!RbfAllocMatrix(MyNoOfHidden, MyNoOfHidden, &kr_CorrMatrix))
+	{
+	    KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	    return KernelErrorCode;
+	}
+    }
+
+    /* reset correlation matrix */
+    RbfClearMatrix(&kr_CorrMatrix, 0.0);
+	
+    /* compute the necessary sub patterns (allways work on all patterns) */
+    KernelErrorCode = 
+	kr_initSubPatternOrder(0, kr_np_pattern(PATTERN_GET_NUMBER, 0, 0) - 1);
+    if (KernelErrorCode != KRERR_NO_ERROR) 
+    {
+	if (KernelErrorCode == KRERR_NP_NO_TRAIN_SCHEME)
+	    KernelErrorCode = KRERR_NP_WORKAROUND;
+	return (KernelErrorCode);
+    }
+
+    /* calculate total number of subpatterns */
+    no_of_patterns = 0;
+
+    /* calculate the following values:
+       sum(x)   -> value_b
+       sum(x^2) -> value_c
+       sum(x*y) -> matrix[col for x][row for y]
+
+       x and y are output values of arbitraty hidden units
+     */
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no)) {
+        /* propagate pattern through net */
+        propagateNetForward (pattern_no, sub_pat_no);
+	no_of_patterns++;
+
+        /* calculate mean for all units */
+        FOR_ALL_UNITS (unit_ptr)
+            if (! IS_SPECIAL_UNIT (unit_ptr) && IS_HIDDEN_UNIT (unit_ptr))
+	    {
+		/* sum up x and x^2 */
+                unit_ptr->value_b += unit_ptr->Out.output;
+		unit_ptr->value_c += unit_ptr->Out.output * unit_ptr->Out.output;
+
+		col = unit_ptr - first_hidden;
+		
+		/* sum up x*y */
+		FOR_ALL_UNITS (unit_ptr2)
+		    if (! IS_SPECIAL_UNIT (unit_ptr2) 
+			&& IS_HIDDEN_UNIT (unit_ptr2)
+			&& unit_ptr2 > unit_ptr)
+		    {
+			row = unit_ptr2 - first_hidden;
+			covadd = (unit_ptr->Out.output * unit_ptr2->Out.output);
+			RbfMatrixSetValue(&kr_CorrMatrix, row, col,
+			    RbfMatrixGetValue(&kr_CorrMatrix, row, col) + covadd);
+		    }
+	    }
+    }
+
+    /* now finish computation of correlation matrix. compute:
+
+       matrix[col for x][row for y] = 
+       (n * sum(x*y) - sum(x) * sum(y))   /
+       sqrt((n * sum(x^2) - sum^2(x)) * (n * sum(y^2) - sum^2(y)))
+
+       also find minimum and maximum correlation (hint: 0 means not correlated, 
+       1.0 means correlated -1.0 means anti-correlated
+    */
+    mincorr = maxcorr = 0.0;
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr) && IS_HIDDEN_UNIT (unit_ptr)) 
+	{
+	    col = unit_ptr - first_hidden;
+	    
+	    FOR_ALL_UNITS (unit_ptr2)
+		if (! IS_SPECIAL_UNIT (unit_ptr2) 
+		    && IS_HIDDEN_UNIT (unit_ptr2)
+		    && unit_ptr2 > unit_ptr)
+		{
+		    row = unit_ptr2 - first_hidden;
+		    corr = no_of_patterns * RbfMatrixGetValue(&kr_CorrMatrix, row, col)
+			- unit_ptr->value_b * unit_ptr2->value_b;
+		    corr /= sqrt(
+			(no_of_patterns * unit_ptr->value_c 
+			 - unit_ptr->value_b * unit_ptr->value_b)
+			*(no_of_patterns * unit_ptr2->value_c 
+			  - unit_ptr2->value_b * unit_ptr2->value_b)
+			);
+		    RbfMatrixSetValue(&kr_CorrMatrix, row, col, corr);
+
+		    if (corr > maxcorr)
+		    {
+			maxcorr = corr;
+			maxcorrcol = col;
+			maxcorrrow = row;
+		    }
+		    if (corr < mincorr)
+		    {
+			mincorr = corr;
+			mincorrcol = col;
+			mincorrrow = row;
+		    }
+		}
+	}
+    
+#ifdef CORR_DEBUG
+    RbfPrintMatrix(&kr_CorrMatrix, stderr);
+#endif
+
+    if (-mincorr > maxcorr && -mincorr > 0.0)
+    {
+	*res_corr = -mincorr;
+	*hn1 = first_hidden + mincorrcol;
+	*hn2 = first_hidden + mincorrrow;
+    }
+    else if (maxcorr > -mincorr && maxcorr > 0.0)
+    {
+	*res_corr = maxcorr;
+	*hn1 = first_hidden + maxcorrcol;
+	*hn2 = first_hidden + maxcorrrow;
+    }
+    else
+    {
+	*res_corr = 0.0;
+	*hn1 = *hn2 = NULL;
+    }
+	
+    return (KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_jogCorrWeights
+
+  PURPOSE  : Add uniform distributed random values to connection weights of
+             highly correlated, non-special hidden units.
+             <minus> must be less then <plus>.
+	     The two hidden units with maximum positive or negative correlation 
+	     with an absolute value higher then mincorr are searched. The 
+	     incoming weights of one of these units are jogged.
+
+             New:
+             Value and range depends on the given parameters and the current
+             weight. e.g.:
+             -0.02, 0.04 means that the new weight will be in the range of
+             100-2% to 100+4% = 98% to 104% of its previous value.
+
+  NOTES    : The old way of just adding noise may be achieved by defining
+             -DJOGWEIGHTS_BY_ADDING during compilation
+
+  RETURNS  : error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus, 
+			    FlintTypeParam mincorr)
+{
+    register  struct Link   *link_ptr;
+    FlagWord	flags;
+    struct Unit   *unit_ptr = NULL;
+    struct Unit   *unit_ptr1 = NULL;
+    struct Unit   *unit_ptr2 = NULL;
+    double         correlation;
+    struct Site   *site_ptr;
+    register FlintType  range, min;
+    double maxweight;
+
+    if (NoOfUnits == 0)  return KRERR_NO_UNITS;  /*  no. units  */
+    range = plus - minus;
+    min = minus;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if (kr_getCorrelatedHiddens(&unit_ptr1, &unit_ptr2, &correlation) 
+	!= KRERR_NO_ERROR)
+	return KernelErrorCode;
+
+    if (unit_ptr1 == NULL || unit_ptr2 == NULL || fabs(correlation) < mincorr)
+	return KRERR_NO_ERROR;
+
+    unit_ptr = drand48() > 0.5 ? unit_ptr2 : unit_ptr1;
+
+#ifdef CORR_DEBUG
+    printf("maximum correlation is %g between %s and %s, jogging %s\n", 
+	   correlation,
+	   unit_ptr1->unit_name == NULL ? "noname" : unit_ptr1->unit_name,
+	   unit_ptr2->unit_name == NULL ? "noname" : unit_ptr2->unit_name,
+	   unit_ptr->unit_name == NULL ? "noname" : unit_ptr->unit_name);
+#endif
+
+    flags = unit_ptr->flags;
+
+    if(((flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+       && !IS_SPECIAL_UNIT(unit_ptr))
+	/*  unit is in use  */
+	if (flags & UFLAG_DLINKS)
+	{
+	    /*  unit has direct links   */
+	    maxweight = 0.0;
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+	    {
+		if (fabs(link_ptr->weight) > maxweight)
+		    maxweight = fabs(link_ptr->weight);
+	    }
+	    if (maxweight > 1.0)
+		maxweight = 1.0;
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+                link_ptr->weight += 
+		    maxweight * ((FlintType) drand48() * range + min);
+	}
+	else
+	{
+	    if (flags & UFLAG_SITES)
+		/*  unit has sites  */
+		FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+#ifdef JOGWEIGHTS_BY_ADDING
+		    link_ptr->weight += (FlintType) drand48() * range + min;
+#else
+                    link_ptr->weight += 
+			link_ptr->weight * ((FlintType) drand48() * range + min);
+#endif
+	}
+
+    return KRERR_NO_ERROR;		    
+}
+
+
+
+/*#################################################
+
+GROUP: Site Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_createDefaultSite
+
+  PURPOSE  : Creates a new site with default initialisation
+  NOTES    : 
+
+  RETURNS  : the new site 
+  UPDATE   : 
+******************************************************************************/
+struct Site  *kr_createDefaultSite(void)
+{
+  struct Site   *site_ptr;
+
+
+  if ( (site_ptr = krm_getSite() ) == NULL)   return( NULL );
+
+  site_ptr->links = NULL;
+  site_ptr->next  = NULL;
+
+  return( site_ptr );
+}
+
+
+
+/*#################################################
+
+GROUP: Unit Functions
+
+#################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : kr_unitNameSearch
+
+  PURPOSE  : Searches for a unit with the given symbol pointer.
+  NOTES    : 
+
+  RETURNS  : Returns the first unit no. if a unit with the given name was found,
+             0 otherwise
+ 
+  UPDATE   : 
+******************************************************************************/
+int  kr_unitNameSearch(int min_unit_no, char *unit_symbol_ptr)
+{
+  register char   *symbol;
+  register struct Unit   *unit_ptr;
+
+
+  if ((symbol = unit_symbol_ptr) == NULL)
+    return( 0 );
+
+  /*  search for symbol pointer  */
+  for (unit_ptr = unit_array + min_unit_no; unit_ptr <= unit_array + MaxUnitNo; unit_ptr++)
+    if UNIT_IN_USE( unit_ptr )
+      if (unit_ptr->unit_name == symbol)
+        return( unit_ptr - unit_array );
+
+  return( 0 );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_copyUnitFrame
+
+  PURPOSE  : copy the source unit with sites, but no links
+  NOTES    : 
+
+  RETURNS  : Returns the error code 
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_copyUnitFrame(struct Unit *source_unit_ptr, 
+				 struct Unit *new_unit_ptr)
+{
+  struct Site	*site_ptr,
+		*new_site_ptr,
+		*last_site_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  memcpy( (char *) new_unit_ptr, (char *) source_unit_ptr, UNIT_SIZE );
+
+  if (source_unit_ptr->unit_name != NULL)
+    (void) krm_NTableInsertSymbol( source_unit_ptr->unit_name, UNIT_SYM );
+
+  /*  unit has no inputs now  */
+  new_unit_ptr->flags &= ~UFLAG_INPUT_PAT;
+  new_unit_ptr->sites = NULL;
+
+  if UNIT_HAS_SITES( source_unit_ptr )
+    {  /*  Copy all sites, but no links.  */
+    last_site_ptr = new_site_ptr = NULL;
+    FOR_ALL_SITES( source_unit_ptr, site_ptr )  {
+      if ((new_site_ptr = krm_getSite()) == NULL)  {
+	new_unit_ptr->sites = last_site_ptr;
+	return( KernelErrorCode );
+      }
+
+      memcpy( (char *) new_site_ptr, (char *) site_ptr, SITE_SIZE );
+      new_site_ptr->links = NULL;
+      new_site_ptr->next = last_site_ptr;
+      last_site_ptr = new_site_ptr;
+    }
+
+    new_unit_ptr->sites = new_site_ptr;
+    if (new_site_ptr != NULL)  new_unit_ptr->flags |= UFLAG_SITES;
+  }
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_removeUnit
+
+  PURPOSE  : Remove unit and all links from network
+  NOTES    : 
+
+  RETURNS  : Returns the error code 
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_removeUnit(struct Unit *unit_ptr)
+{
+
+  /*  delete inputs   */
+  kr_deleteAllInputs( unit_ptr );
+  /*  delete output links */
+  kr_deleteAllOutputLinks( unit_ptr );
+  /*  check references to the unit symbol   */
+  krm_NTableReleaseSymbol( unit_ptr->unit_name, UNIT_SYM );
+  /*  count units  */
+  kr_countUnits( unit_ptr, UNIT_DELETE );
+  /*  delete Unit */
+  krm_releaseUnit( unit_ptr - unit_array );
+
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_copyUnit
+
+  PURPOSE  : Copy a given unit, according to the copy mode
+             1. copy unit (with it sites, if available) and input/output links
+             2. copy unit (with it sites, if available) and input links
+             3. copy unit (with it sites, if available) and output links
+             4. copy unit (with it sites, if available) but no links
+	     Function has no effect on the current unit.
+  NOTES    : Copying of output links is slow.
+             If return code < 0, an error occured.
+
+  RETURNS  : Returns the unit number of the new unit or error message < 0 , 
+             if errors occured.
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_copyUnit(int copy_mode, int source_unit)
+{
+  struct Unit	*source_unit_ptr,
+		*new_unit_ptr;
+  int  new_unit_no;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if ((source_unit_ptr = kr_getUnitPtr( source_unit )) == NULL)
+    return( KernelErrorCode );
+  if ((new_unit_no = krm_getUnit()) == 0)
+    return( KernelErrorCode );
+  if (new_unit_no != abs(new_unit_no)){
+      /* new unit block allocated; need to update unit pointer */
+      new_unit_no = abs(new_unit_no);
+      source_unit_ptr = kr_getUnitPtr( source_unit );
+  }
+
+  new_unit_ptr = unit_array + new_unit_no;
+
+  /*  copy unit (with it sites, if available) but no input/output links  */
+  if (kr_copyUnitFrame( source_unit_ptr, new_unit_ptr ) != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  switch (copy_mode)
+    {
+    case ONLY_UNIT:
+      break;
+
+    case ONLY_INPUTS:
+    /*	copy unit (with it sites, if available) and input links */
+      (void) kr_copyInputLinks( source_unit_ptr, new_unit_ptr );
+      break;
+
+    case ONLY_OUTPUTS:
+    /*  copy unit (with it sites, if available) and output links    */
+      (void) kr_copyOutputLinks( source_unit_ptr, new_unit_ptr);
+      break;
+
+    case INPUTS_AND_OUTPUTS:
+    /*  copy unit (with it sites, if available) and input/output links  */
+      if (kr_copyOutputLinks( source_unit_ptr, new_unit_ptr) != KRERR_NO_ERROR)
+	break;
+
+      (void) kr_copyInputLinks( source_unit_ptr, new_unit_ptr );
+      break;
+
+    default:
+      KernelErrorCode = KRERR_COPYMODE;
+  }
+
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    {
+    kr_removeUnit( new_unit_ptr );  /*	delete Unit  */
+    return( KernelErrorCode );
+  }
+  else
+    {  /*  Successful copy   */
+    new_unit_ptr->flags = source_unit_ptr->flags;  /*  copy flags  */
+    /*  count units  */
+    kr_countUnits( new_unit_ptr, UNIT_ADD );
+    NetModified = TRUE;
+    return( new_unit_no );
+  }
+}
+
+/*#################################################
+
+GROUP: Ftype Unit Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_changeFtypeUnits
+
+  PURPOSE  : changes all units in the network with the given functionality type
+             to the new functions of the (new) functionality type
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void   kr_changeFtypeUnits(struct FtypeUnitStruct *Ftype_entry)
+{
+  register struct Unit   *unit_ptr;
+
+
+  if (NoOfUnits == 0)  return;  /*  no units  */
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )
+      {     /*  unit is in use  */
+      if (unit_ptr->Ftype_entry == Ftype_entry)
+	{  /*  unit with this type was found. Now change the transfer functions
+	       of the unit to the modified functionality type */
+        unit_ptr->act_func = Ftype_entry->act_func;
+        unit_ptr->out_func = Ftype_entry->out_func;
+        unit_ptr->act_deriv_func = Ftype_entry->act_deriv_func;
+        unit_ptr->act_2_deriv_func = Ftype_entry->act_2_deriv_func;
+        }
+      }
+
+  NetModified = TRUE;
+}
+
+/*****************************************************************************
+  FUNCTION : kr_deleteUnitsFtype
+
+  PURPOSE  : delete the functionality type of the units with the given type
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  kr_deleteUnitsFtype(struct FtypeUnitStruct *ftype_ptr)
+{
+  register struct Unit   *unit_ptr;
+
+
+  if (NoOfUnits == 0)  return;  /*  no units  */
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )
+      /*  unit is in use  */
+      if (unit_ptr->Ftype_entry == ftype_ptr)
+        unit_ptr->Ftype_entry = NULL;
+}
+
+/*****************************************************************************
+  FUNCTION : kr_makeFtypeUnit
+
+  PURPOSE  : create a new unit with the given functionality type
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_makeFtypeUnit(char *Ftype_symbol)
+{
+  register struct Site	*ftype_site, *site_ptr;
+  struct Unit  *unit_ptr;
+  struct FtypeUnitStruct  *ftype_ptr;
+  int  unit_no;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (!kr_symbolCheck( Ftype_symbol ))
+    return( KernelErrorCode );
+
+  if ((ftype_ptr = krm_FtypeSymbolSearch( Ftype_symbol ) ) == NULL)
+    {  /*  Ftype name isn't defined    */
+    KernelErrorCode = KRERR_FTYPE_SYMBOL;
+    return( KernelErrorCode );
+  }
+
+  unit_no = kr_makeDefaultUnit();
+  if (KernelErrorCode != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  unit_ptr = unit_array + unit_no;
+
+  unit_ptr->Ftype_entry = ftype_ptr;
+  unit_ptr->out_func    = ftype_ptr->out_func;
+  unit_ptr->act_func    = ftype_ptr->act_func;
+  unit_ptr->act_deriv_func = ftype_ptr->act_deriv_func;
+  unit_ptr->act_2_deriv_func = ftype_ptr->act_2_deriv_func;
+
+  ftype_site = ftype_ptr->sites;
+
+  /*  make sites  */
+  while (ftype_site != NULL)
+    {   /*  Ftype has sites */
+    if ((site_ptr = krm_getSite()) == NULL)
+      {  /*  memory alloc failed */
+      krm_releaseAllSites( unit_ptr->sites );
+      unit_ptr->sites = NULL;
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( KernelErrorCode );
+    }
+
+    site_ptr->next = unit_ptr->sites;
+    unit_ptr->sites = site_ptr;
+
+    site_ptr->site_table = ftype_site->site_table;
+    ftype_site = ftype_site->next;
+  }
+
+  if (ftype_ptr->sites != NULL)
+    unit_ptr->flags |= UFLAG_SITES;     /*  unit has now sites  */
+
+  return( unit_no );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_FtypeSiteSearch
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : returns TRUE, if there exists the given site at the given ftype 
+             entry
+  UPDATE   : 
+******************************************************************************/
+bool  kr_FtypeSiteSearch(struct Site *ftype_first_site, 
+			 struct SiteTable *site_table_ptr)
+{
+  register struct  Site      *site_ptr;
+
+
+  for (site_ptr = ftype_first_site; site_ptr != NULL; site_ptr = site_ptr->next)
+    if (site_ptr->site_table == site_table_ptr)
+      return( TRUE );
+
+  return( FALSE );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_changeFtypeUnit
+
+  PURPOSE  : change the properties of the given unit to the properties of the
+             given F-Type 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void    kr_changeFtypeUnit(struct Unit *unit_ptr, 
+			   struct FtypeUnitStruct *ftype_ptr)
+{
+  FlagWord	flags;
+  struct  Site  *site_ptr,
+                *pred_site_ptr,
+                *tmp_ptr,
+                *ftype_site;
+
+
+  unit_ptr->out_func = ftype_ptr->out_func;
+  unit_ptr->act_func = ftype_ptr->act_func;
+  unit_ptr->act_deriv_func = ftype_ptr->act_deriv_func;
+  unit_ptr->act_2_deriv_func = ftype_ptr->act_2_deriv_func;
+
+  flags = unit_ptr->flags & UFLAG_INPUT_PAT;
+
+  switch (flags)
+    {
+    case  UFLAG_NO_INP:
+      /*  Unit has no inputs  */
+      if (ftype_ptr->sites != NULL)
+        /*    Ftype has sites, delete unit's Ftype  */
+        unit_ptr->Ftype_entry = NULL;
+      else
+        /*    Ftype and unit don't have sites */
+        unit_ptr->Ftype_entry = ftype_ptr;    /* unit accept Ftype and inputs */
+
+      return;     /*  done !  */
+
+    case  UFLAG_SITES:
+      /*  Unit has sites  */
+      ftype_site = ftype_ptr->sites;
+      if (ftype_site == NULL)
+        {  /* unit has sites, but Ftype hasn't sites, 
+	      delete unit's Ftype and all inputs  */
+        unit_ptr->Ftype_entry = NULL;
+
+        kr_deleteAllInputs( unit_ptr );
+        unit_ptr->flags = UFLAG_INITIALIZED;  /*  unit has no inputs now !    */
+        }
+      else
+        {     /*  both unit and Ftype have sites: check sites  */
+        unit_ptr->Ftype_entry = ftype_ptr;
+
+        site_ptr = unit_ptr->sites;
+        pred_site_ptr = NULL;
+
+        do
+          {
+          if ( ! kr_FtypeSiteSearch( ftype_site, site_ptr->site_table ))
+            {  /*  Ftype and unit site definitions are not equivalent: 
+		   remove site    */
+            if (pred_site_ptr == NULL)
+              {   /*  this is the first site at the unit  */
+              unit_ptr->sites = site_ptr->next;
+
+              if (site_ptr->next == NULL)
+                /*  unit don't has any inputs   */
+                unit_ptr->flags &= (~UFLAG_INPUT_PAT);
+              }
+            else
+              {   /*  this site isn't the first site at the unit  */
+              pred_site_ptr->next = site_ptr->next;
+              pred_site_ptr = site_ptr;
+              }
+
+	    /*  work with temporary pointer and get */
+            tmp_ptr = site_ptr;
+
+	    /*  next site pointer BEFORE krm_releaseSite    */
+            site_ptr = site_ptr->next;
+
+	    /*  (important in a multiprocessor system   */
+            krm_releaseAllLinks( tmp_ptr->links );    
+            krm_releaseSite( tmp_ptr );
+            /*    delete unit's Ftype */
+            unit_ptr->Ftype_entry = NULL;
+            }
+          else
+            {
+            pred_site_ptr = site_ptr;
+            site_ptr = site_ptr->next;
+            }
+          }
+        while (site_ptr != NULL);
+
+        if (unit_ptr->sites == NULL)
+          unit_ptr->flags = UFLAG_INITIALIZED;  /*  unit has no inputs now !  */
+        }
+
+      return;
+
+
+    case  UFLAG_DLINKS:
+    /*  Unit has direct links   */
+      if (ftype_ptr->sites != NULL)
+        { /*  unit has direct links, but Ftype entry has sites: delete links  */
+        unit_ptr->Ftype_entry = NULL;
+
+        kr_deleteAllInputs( unit_ptr );
+        unit_ptr->flags = UFLAG_INITIALIZED;  /*  unit has no inputs now !    */
+        }
+      else
+        { /* unit has direct links and Ftype has no sites: use direct links  */
+        unit_ptr->Ftype_entry = ftype_ptr;
+        }
+
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_changeFtypeSites
+
+  PURPOSE  : change a site at the F-Type
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void    kr_changeFtypeSites(struct FtypeUnitStruct *Ftype_entry, 
+			    struct SiteTable *old_site_table, 
+			    struct SiteTable *new_site_table)
+{
+  struct Unit   *unit_ptr;
+  struct Site   *site_ptr;
+
+
+  if (NoOfUnits == 0)  return;  /*  no units  */
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )
+      {     /*  unit is in use  */
+      if (unit_ptr->Ftype_entry == Ftype_entry)
+        {
+	FOR_ALL_SITES( unit_ptr, site_ptr )
+          if (site_ptr->site_table == old_site_table)
+            site_ptr->site_table = new_site_table;
+      }
+    }
+
+  NetModified = TRUE;
+}
+
+
+/*#################################################
+
+GROUP: Miscellanous
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_flags2TType
+
+  PURPOSE  : translate unit flags to the topological type of the unit
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_flags2TType(int flags)
+{
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (flags)
+    {
+    case UFLAG_TTYP_UNKN:  return( UNKNOWN );
+    case UFLAG_TTYP_IN  :  return( INPUT );
+    case UFLAG_TTYP_OUT :  return( OUTPUT );
+    case UFLAG_TTYP_DUAL:  return( DUAL );
+    case UFLAG_TTYP_HIDD:  return( HIDDEN );
+    case UFLAG_TTYP_SPEC:  return( SPECIAL );
+    case UFLAG_TTYP_SPEC_I: return (SPECIAL_I) ;
+    case UFLAG_TTYP_SPEC_O: return (SPECIAL_O) ;
+    case UFLAG_TTYP_SPEC_H: return (SPECIAL_H) ;
+    case UFLAG_TTYP_SPEC_D: return (SPECIAL_D) ;
+      /* case UFLAG_TTYP_SPEC_X and 
+	 case UFLAG_TTYP_N_SPEC_X are no true TType*/
+    
+    default: KernelErrorCode = KRERR_TTYPE;
+	     return( UNKNOWN );
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_TType2Flags
+
+  PURPOSE  : translate the topological type to unit flags
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_TType2Flags(int ttype)
+{
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (ttype)
+    {
+    case UNKNOWN:  return( UFLAG_TTYP_UNKN );
+    case INPUT	:  return( UFLAG_TTYP_IN );
+    case OUTPUT :  return( UFLAG_TTYP_OUT );
+    case DUAL	:  return( UFLAG_TTYP_DUAL );
+    case HIDDEN :  return( UFLAG_TTYP_HIDD );
+    case SPECIAL:  return( UFLAG_TTYP_SPEC );
+    case SPECIAL_I: return (UFLAG_TTYP_SPEC_I) ;
+    case SPECIAL_O: return (UFLAG_TTYP_SPEC_O) ;
+    case SPECIAL_H: return (UFLAG_TTYP_SPEC_H) ;
+    case SPECIAL_D: return (UFLAG_TTYP_SPEC_D) ;
+    case SPECIAL_X: return (UFLAG_TTYP_SPEC_X) ;
+    case N_SPECIAL_X: return (UFLAG_TTYP_N_SPEC_X) ;
+    default:  KernelErrorCode = KRERR_TTYPE;
+	      /*  return( KernelErrorCode );  */
+	      return( -1 );
+  }
+}
+/*****************************************************************************
+  FUNCTION : kr_updateUnitOutputs
+
+  PURPOSE  : update the outputs of all units in the network
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void    kr_updateUnitOutputs(void)
+{
+  register struct Unit   *unit_ptr;
+
+
+  FOR_ALL_UNITS( unit_ptr )
+    if ( (unit_ptr->flags & UFLAG_INITIALIZED) == UFLAG_INITIALIZED)
+      {     /*  unit is in use and enabled  */
+      if (unit_ptr->out_func == NULL)
+        /*  Identity Function   */
+        unit_ptr->Out.output = unit_ptr->act;
+      else
+        unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+      }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getNoOfUnits
+
+  PURPOSE  : returns the no. of units of the specified topologic type
+             (i.e. Input, Hidden, Output or Special units)
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_getNoOfUnits(int UnitTType)
+{
+  register struct Unit   *unit_ptr;
+  register int   no_of_units;
+  register FlagWord      ttyp_flg;
+  int   flg;
+
+
+  if ((NoOfUnits == 0) || ((flg = kr_TType2Flags( UnitTType )) == -1))
+    return( 0 );  /*  no units or this topologic type doesn't exist  */
+
+  ttyp_flg = (FlagWord) flg;
+  no_of_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if ( ((unit_ptr->flags & UFLAG_TTYP_PAT) == ttyp_flg) &&
+         UNIT_IN_USE( unit_ptr ) )
+      no_of_units++;
+
+  return( no_of_units );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_getNoOfSpecialUnits
+
+  PURPOSE  : returns the no. of special units of the specified topologic type
+             (i.e. Input, Hidden, Output or Special units)
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+int  kr_getNoOfSpecialUnits(int UnitTType)
+{
+  register struct Unit   *unit_ptr;
+  register int   no_of_units;
+  register FlagWord      ttyp_flg;
+  int   flg;
+
+
+  if ((NoOfUnits == 0) || ((flg = kr_TType2Flags( UnitTType )) == -1))
+    return( 0 );  /*  no units or this topologic type doesn't exist  */
+
+  ttyp_flg = (FlagWord) flg;
+  no_of_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if ( ((unit_ptr->flags & UFLAG_TTYP_PAT) == (ttyp_flg | UFLAG_TTYP_SPEC)) &&
+         UNIT_IN_USE( unit_ptr ) )
+      no_of_units++;
+
+  return( no_of_units );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_forceUnitGC
+
+  PURPOSE  : force unit array garbage collection
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  kr_forceUnitGC(void)
+{
+  krm_unitArrayGC();
+}
+
+
+/*#################################################
+
+GROUP: Functions default presettings
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : kr_getUnitDefaults
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : Returns information about the unit default settings. 
+  UPDATE   : 
+******************************************************************************/
+void	kr_getUnitDefaults(FlintType *act, FlintType *bias, int *ttflags, 
+			   int *subnet_no, int *layer_no, char **act_func, 
+			   char **out_func)
+{
+  static char  activation_func[FUNCTION_NAME_MAX_LEN],
+               output_func[FUNCTION_NAME_MAX_LEN];
+
+
+  *act          = DefaultIAct;
+  *bias         = DefaultBias;
+  *ttflags	= (int) DefaultSType;
+  *subnet_no    = DefaultSubnetNo;
+  *layer_no     = DefaultLayerNo;
+
+  strcpy( activation_func, krf_getCurrentNetworkFunc( ACT_FUNC ) );
+  *act_func = activation_func;
+  strcpy( output_func, krf_getCurrentNetworkFunc( OUT_FUNC ) );
+  *out_func = output_func;
+}
+
+/*****************************************************************************
+  FUNCTION : kr_setUnitDefaults
+
+  PURPOSE  : Changes the unit default settings.
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_setUnitDefaults(FlintTypeParam act, FlintTypeParam bias, 
+			     int ttflags, int subnet_no, int layer_no, 
+			     char *act_func, char *out_func)
+{
+  FunctionPtr  act_func_ptr,
+               act_deriv_func_ptr,
+               act_2_deriv_func_ptr,
+               out_func_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+
+  if (!krf_funcSearch( act_func, ACT_FUNC, &act_func_ptr))
+    return( KernelErrorCode );
+  if (!krf_funcSearch( act_func, ACT_DERIV_FUNC, &act_deriv_func_ptr))
+    return( KernelErrorCode );
+  if (!krf_funcSearch( act_func, ACT_2_DERIV_FUNC, &act_2_deriv_func_ptr))
+    return( KernelErrorCode );
+  if (!krf_funcSearch( out_func, OUT_FUNC, &out_func_ptr))
+    return( KernelErrorCode );
+
+  if (krf_setCurrentNetworkFunc( act_func, ACT_FUNC ) != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+  if (krf_setCurrentNetworkFunc( out_func, OUT_FUNC ) != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  DefaultIAct       = (FlintType) act;
+  DefaultBias       = (FlintType) bias;
+  DefaultSType	    = (FlagWord) ttflags;
+  DefaultPosX       = DEF_POS_X;
+  DefaultPosY       = DEF_POS_Y;
+
+  DefaultPosZ       = DEF_POS_Z;
+
+
+  DefaultSubnetNo   = subnet_no;
+  DefaultLayerNo    = layer_no;
+
+  DefaultUFuncOut   = (OutFuncPtr) out_func_ptr;
+  DefaultUFuncAct   = (ActFuncPtr) act_func_ptr;
+  DefaultUFuncActDeriv = (ActDerivFuncPtr) act_deriv_func_ptr;
+  DefaultUFuncAct2Deriv = (ActDerivFuncPtr) act_2_deriv_func_ptr;
+
+  return( KernelErrorCode );
+}
+
+
+/*#################################################
+
+GROUP: Topological Sorting Functions
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : clr_T_flags
+
+  PURPOSE  : Clears the 'touch' (refresh) flag of all units
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static void  clr_T_flags(void)
+{
+  register struct Unit   *unit_ptr;
+
+
+  FOR_ALL_UNITS( unit_ptr )
+    if (UNIT_IN_USE( unit_ptr ))
+      {
+      unit_ptr->flags &= ~UFLAG_REFRESH;
+      unit_ptr->lln = 0;
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : DepthFirst1
+
+  PURPOSE  : Depth search routine for topological sorting
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static void  DepthFirst1(struct Unit *unit_ptr, int depth)
+{
+  struct Site   *site_ptr;
+  struct Link   *link_ptr;
+
+
+  if (unit_ptr->flags & UFLAG_REFRESH)
+    {  /*  the 'touch' flag is set: don't continue search  */
+    if (unit_ptr->lln == 0)
+      {  /*  logical layer no. isn't set => Cycle found  */
+      topo_msg.no_of_cycles++;
+      if (topo_msg.error_code == KRERR_NO_ERROR)
+	{  /*  remember the cycle unit	*/
+        topo_msg.src_error_unit = unit_ptr - unit_array;
+        topo_msg.error_code = KRERR_CYCLES;
+      }
+    }
+
+    return;
+  }
+  else
+    /*	set the 'touch' flag  */
+    unit_ptr->flags |= UFLAG_REFRESH;
+
+  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+    {
+    case  UFLAG_DLINKS:   /*  unit has direct links  */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )
+	DepthFirst1( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+
+    case  UFLAG_SITES:	/*  unit has sites  */
+	FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	  DepthFirst1( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+  }
+
+  /*  remember the depth (for cycle detection and statistics)  */
+  unit_ptr->lln = depth;  
+  *global_topo_ptr++ = unit_ptr;  /*  store sorted unit pointer  */
+}
+
+/*****************************************************************************
+  FUNCTION : DepthFirst2
+
+  PURPOSE  : Depth search routine for topology check function
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static void  DepthFirst2(struct Unit *unit_ptr, int depth)
+{
+  struct Site   *site_ptr;
+  struct Link   *link_ptr;
+
+
+  if (unit_ptr->flags & UFLAG_REFRESH)
+    {  /*  the 'touch' flag is set: don't continue search  */
+    if (unit_ptr->lln == 0)
+      {  /*  logical layer no. isn't set => Cycle found  */
+      topo_msg.no_of_cycles++;
+      if (topo_msg.error_code == KRERR_NO_ERROR)
+	{  /*  remember the cycle unit	*/
+        topo_msg.src_error_unit = unit_ptr - unit_array;
+        topo_msg.error_code = KRERR_CYCLES;
+      }
+    }
+
+    return;
+  }
+  else
+    /*	set the 'touch' flag  */
+    unit_ptr->flags |= UFLAG_REFRESH;
+
+  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+    {
+    case  UFLAG_DLINKS:   /*  unit has direct links  */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )
+	DepthFirst2( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+
+    case  UFLAG_SITES:	/*  unit has sites  */
+      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	DepthFirst2( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+  }
+
+  /*  remember the depth (for cycle detection and statistics)  */
+  unit_ptr->lln = depth;
+
+  /*  store highest layer no.  */
+  if (depth > topo_msg.no_of_layers)  topo_msg.no_of_layers = depth;
+}
+
+/*****************************************************************************
+  FUNCTION : DepthFirst3
+
+  PURPOSE  : Depth search routine for topological sorting in feedforward networks
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static void  DepthFirst3(struct Unit *unit_ptr, int depth)
+{
+  struct Site   *site_ptr;
+  struct Link   *link_ptr;
+
+
+  if (unit_ptr->flags & UFLAG_REFRESH)
+    {  /*  the 'touch' flag is set: don't continue search  */
+    topo_msg.src_error_unit = unit_ptr - unit_array; /*  store unit number  */
+
+    if IS_OUTPUT_UNIT( unit_ptr )
+      {  /*  this output unit has a output connection to another unit  */
+      if (topo_msg.error_code == KRERR_NO_ERROR)
+        topo_msg.error_code = KRERR_O_UNITS_CONNECT;
+    }
+    else
+      if (unit_ptr->lln == 0)
+        {  /*  logical layer no. isn't set => Cycle found  */
+        topo_msg.no_of_cycles++;
+        if (topo_msg.error_code == KRERR_NO_ERROR)
+          topo_msg.error_code = KRERR_CYCLES;
+      }
+
+    return;
+  }
+  else
+    /*	set the 'touch' flag  */
+    unit_ptr->flags |= UFLAG_REFRESH;
+
+  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+    {
+    case  UFLAG_DLINKS:   /*  unit has direct links  */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )
+	DepthFirst3( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+
+    case  UFLAG_SITES:	/*  unit has sites  */
+      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	DepthFirst3( link_ptr->to, depth + 1 );  /*  increase depth  */
+
+      break;
+  }
+
+  /*  remember the depth (for cycle detection and statistics)  */
+  unit_ptr->lln = depth;
+
+  /*  store only hidden units  */
+  if IS_HIDDEN_UNIT( unit_ptr )
+    *global_topo_ptr++ = unit_ptr;  /*	store sorted unit pointer  */
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoSortT
+
+  PURPOSE  : Sort units topological (general version) and stores the
+             pointers to this units in the topologic array
+  NOTES    : Units are not sorted by their topologic type (that's not possible 
+             in the general case)
+
+  RETURNS  : error code
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_topoSortT(void)
+{
+  register struct Unit	 *unit_ptr;
+  int	io_units;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+  clr_T_flags();    /*	reset units 'touch' flags  */
+  global_topo_ptr = topo_ptr_array;  /*  initialize global pointer */
+
+  /*  limit left side of the topological array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  put all input units in the topologic array  */
+  io_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      io_units++;	/*  there is a input unit  */
+
+  if ((NoOfInputUnits = io_units) == 0)
+    {  /*  no input units */
+    KernelErrorCode = KRERR_NO_INPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  begin depth search at the first output unit  */
+  io_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if ( IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ) )
+      {
+      io_units++;  /*  there is a output unit  */
+
+      /*  sort the units topological (using depth search algorithm, 
+	  starting at this output unit */
+      DepthFirst1( unit_ptr, 1 );  
+      if (topo_msg.error_code != KRERR_NO_ERROR)
+        {  /*  stop if an error occured  */
+        KernelErrorCode = topo_msg.error_code;
+        return( KernelErrorCode );
+      }
+    }
+
+  if ((NoOfOutputUnits = io_units) == 0)
+    {  /*  no output units */
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  limit right side of the topologic array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  calc. no. of sorted units  */
+  no_of_topo_units = (global_topo_ptr - topo_ptr_array) - 2;
+
+  /*  search for dead units i.e. units without inputs  */
+  FOR_ALL_UNITS( unit_ptr )
+    if ( !(unit_ptr->flags &  (UFLAG_REFRESH | UFLAG_TTYP_SPEC)) &&
+         UNIT_IN_USE( unit_ptr ) )
+      {
+      topo_msg.no_of_dead_units++;
+      if (topo_msg.src_error_unit == 0)
+        topo_msg.src_error_unit = unit_ptr - unit_array; /* store the unit no.*/
+    }
+
+  if (topo_msg.no_of_dead_units != 0)
+    KernelErrorCode = KRERR_DEAD_UNITS;
+
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoSortT
+
+  PURPOSE  : Sorts units topological in feed-forward networks and stores the
+             pointers to these units in the topologic array in the following 
+	     order:
+	     - input,
+	     - hidden and
+	     - output units
+
+             This function make following assumtions (like all learning 
+	     functions for feed-forward networks):
+             a) input units doesn't have input connections to other units and
+             b) output units doesn't have outputs connections to other units.
+  NOTES    : 
+
+  RETURNS  : error code
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_topoSortFF(void)
+{
+  register struct Unit	 *unit_ptr;
+  int	io_units;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+  clr_T_flags();    /*	reset units 'touch' flags  */
+  global_topo_ptr = topo_ptr_array;  /*  initialize global pointer */
+
+  /*  limit left side of the topological array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  put all input units in the topologic array  */
+  io_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {
+      if UNIT_HAS_INPUTS( unit_ptr )
+	{  /*  this input unit has a connection to another unit  */
+
+	/*  store the unit no.  */
+	topo_msg.dest_error_unit = unit_ptr - unit_array;  
+
+	KernelErrorCode = KRERR_I_UNITS_CONNECT;  /*  input unit has input  */
+        return( KernelErrorCode );
+      }
+
+      io_units++;	/*  there is a input unit  */
+      *global_topo_ptr++ = unit_ptr;  /*  save input unit  */
+    }
+
+  if ((NoOfInputUnits = io_units) == 0)
+    {  /*  no input units */
+    KernelErrorCode = KRERR_NO_INPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  limit input units in the topological array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  begin depth search at the first output unit  */
+  io_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {
+      io_units++;	/*  there is a output unit  */
+
+      /*  sort the units topological (using depth search algorithm, 
+	  starting at this output unit */
+      DepthFirst3( unit_ptr, 1 );  
+      if (topo_msg.error_code != KRERR_NO_ERROR)
+        {  /*  stop if an error occured  */
+        KernelErrorCode = topo_msg.error_code;
+        return( KernelErrorCode );
+      }
+    }
+
+  if ((NoOfOutputUnits = io_units) == 0)
+    {  /*  no output units */
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  limit hidden units in the topological array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  put all output units in the topological array  */
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_OUTPUT_UNIT(unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      *global_topo_ptr++ = unit_ptr;  /*  save output unit  */
+
+  /*  limit right side of the topologic array with NULL pointer  */
+  *global_topo_ptr++ = NULL;
+
+  /*  calc. no. of sorted units  */
+  no_of_topo_units = (global_topo_ptr - topo_ptr_array) - 4;
+
+  /*  search for dead units i.e. units without inputs  */
+  FOR_ALL_UNITS( unit_ptr )
+    if (!(unit_ptr->flags & (UFLAG_REFRESH | UFLAG_TTYP_SPEC)) && UNIT_IN_USE( unit_ptr ))
+      {
+      topo_msg.no_of_dead_units++;
+      if (topo_msg.src_error_unit == 0)
+        topo_msg.src_error_unit = unit_ptr - unit_array;  /*  store unit no.  */
+    }
+
+  if (topo_msg.no_of_dead_units != 0)
+    KernelErrorCode = KRERR_DEAD_UNITS;
+
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoSortIHO
+
+  PURPOSE  : Sort units by their topologic type, i.e. Input, Hidden, Output 
+             units and stores the pointers to this units in the topologic array.
+  NOTES    : 
+
+  RETURNS  : error code 
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_topoSortIHO(void)
+{
+  TopoPtrArray     topo_ptr;
+  register struct Unit   *unit_ptr;
+  int  no_of_units;
+  int has_no_dual;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+  topo_ptr = topo_ptr_array;
+
+  /*  limit left side of the topological array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  /*  get input units  */
+  no_of_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {
+      *topo_ptr++ = unit_ptr;
+      no_of_units++;
+    }
+
+
+  if ((NoOfInputUnits = no_of_units) == 0)
+    {
+    KernelErrorCode = KRERR_NO_INPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  limit input units in the topological array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  /*  get hidden units  */
+  no_of_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_HIDDEN_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {
+      *topo_ptr++ = unit_ptr;
+      no_of_units++;
+    }
+
+  if ((NoOfHiddenUnits = no_of_units) == 0)
+    {
+    /* In special case for DUAL units */ 
+    FOR_ALL_UNITS( unit_ptr )
+      if (IS_DUAL_UNIT( unit_ptr ) )
+        has_no_dual = FALSE;
+    if ( has_no_dual ){ 
+	KernelErrorCode = KRERR_NO_HIDDEN_UNITS;
+	return( KernelErrorCode );
+    }
+  }
+
+  /*  limit hidden units in the topological array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  /*  get output units  */
+  no_of_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {
+      *topo_ptr++ = unit_ptr;
+      no_of_units++;
+    }
+
+  if ((NoOfOutputUnits = no_of_units) == 0)
+    {
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  limit right side of the topologic array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  /*  calc. no. of sorted units  */
+  no_of_topo_units = (topo_ptr - topo_ptr_array) - 4;
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_topoSortLOG() 
+
+  PURPOSE  : Sort units by their logical Layer- and Unitnumber
+
+  NOTES    : 
+
+  RETURNS  : error code 
+  UPDATE   : 
+******************************************************************************/
+
+static int llncompare(const struct Unit **a, const struct Unit **b)
+{ 
+  int llndiff, lundiff;
+
+  llndiff = ((*a)->lln - (*b)->lln);
+  lundiff = ((*a)->lun - (*b)->lun);
+  return(llndiff != 0 ? llndiff : lundiff);
+}
+
+static krui_err  kr_topoSortLOG(void)
+{
+  struct Unit      *unit_ptr;
+  TopoPtrArray     topo_ptr;
+  TopoPtrArray     topo_ptr_save;
+  int              no_of_units = 0;
+
+  topo_ptr = topo_ptr_array;
+  *topo_ptr++ = (struct Unit *) NULL;
+
+  
+  FOR_ALL_UNITS( unit_ptr )
+    if ( (unit_ptr->flags & UFLAG_IN_USE) == UFLAG_IN_USE) 
+      {
+      *topo_ptr = unit_ptr;
+      topo_ptr++;
+      no_of_units++;
+      }
+  *topo_ptr = (struct Unit *) NULL;
+  topo_ptr_save = topo_ptr;
+
+  no_of_topo_units = no_of_units;
+  topo_ptr = topo_ptr_array;
+  topo_ptr++;
+  qsort(topo_ptr, no_of_units, sizeof(*topo_ptr), 
+	(int (*)(const void *, const void *)) llncompare);
+
+  /* insert NULL pointer between input units and rest */
+  topo_ptr = topo_ptr_save;
+  while (*topo_ptr == (struct Unit *) NULL ||
+         !(IS_INPUT_UNIT(*topo_ptr)))
+  {
+      *(topo_ptr + 1) = *topo_ptr;
+      topo_ptr--;
+  }
+  topo_ptr++;
+  *topo_ptr = (struct Unit *) NULL;
+  topo_ptr_save++;
+
+  /* insert NULL pointer between output units and rest */
+  topo_ptr = topo_ptr_save;
+  while (*topo_ptr == (struct Unit *) NULL ||
+         (IS_OUTPUT_UNIT(*topo_ptr)))
+  {
+      *(topo_ptr + 1) = *topo_ptr;
+      topo_ptr--;
+  }
+  topo_ptr++;
+  *topo_ptr = (struct Unit *) NULL;
+  topo_ptr_save++;
+
+  /* create pointers from units to topo_ptr_array */
+  topo_ptr = topo_ptr_array;
+  while (topo_ptr != topo_ptr_save)
+  {
+      if (*topo_ptr != (struct Unit *) NULL)
+      {
+          (*topo_ptr) -> TD.my_topo_ptr = topo_ptr;
+      }
+      topo_ptr++;
+  }
+  return (KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoSort
+
+  PURPOSE  : 
+
+    Sort units according to the given mode:
+    TOPOLOGICAL:
+      Sort units topological (general version) and stores the
+      pointers to this units in the topologic array.
+      NOTE: Units are not sorted by their topologic type (that's not
+	    possible in general case).
+
+    TOPOLOGICAL_FF:
+      Sorts unit topological in feed-forward networks and stores the
+      pointers to this units in the topologic array in the following order:
+       - input,
+       - hidden and
+       - output units
+
+      This function make following assumtions (like all learning functions for
+      feed-forward networks):
+       a) input units doesn't have input connections to other units and
+       b) output units doesn't have outputs connections to other units.
+
+    TOPOLOGIC_TYPE:
+      Sort units by their topologic type, i.e. Input, Hidden, Output units and
+      stores the pointers to this units in the topologic array.
+
+    TOPOLOGIC_LOGICAL:
+      Sort Units according to their logical Layers- and Unitsnumbers.
+      The entry TD.my_topo_ptr in every unit is set to point to coresponding
+      entry in the topo_ptr_array.
+
+    ART1_TOPO_TYPE:
+      Sort units in ART1 manner. For informations about the structure of
+      ART1 networks see Diplomarbeit No.929; Kai-Uwe Herrmann; University of
+      Stuttgart; Germany 1992. The pointers are sorted as follows:
+
+      NULL, pointers to input units, NULL, pointers to comparison units,
+      NULL, pointers to recognition units, NULL, pointers to delay units,
+      NULL, pointers to local reset units, NULL, pointers to special units,
+      NULL, NULL, ...
+
+    ART2_TOPO_TYPE:
+      Sort units in ART2 manner. For informations about the structure of
+      ART2 networks see Diplomarbeit No.929; Kai-Uwe Herrmann; University of
+      Stuttgart; Germany 1992. The pointers are sorted as follows:
+
+      NULL, pointers to input units, NULL, pointers to w units,
+      NULL, pointers to x units, NULL, pointers to u units,
+      NULL, pointers to v units, NULL, pointers to p units,
+      NULL, pointers to q units, NULL, pointers to r units,
+      NULL, pointers to recognition units, NULL, pointers to delay units,
+      NULL, pointers to local reset units, NULL, pointers to special units,
+      NULL, NULL, ...
+
+    ARTMAP_TOPO_TYPE:
+      Sort units in ARTMAP manner. For informations about the structure of
+      ARTMAP networks see Diplomarbeit No.929; Kai-Uwe Herrmann; University of
+      Stuttgart; Germany 1992. The pointers are sorted as follows:
+
+      NULL, ARTa inp units, NULL, ARTa cmp units, NULL, ARTa rec units ...,
+      NULL, ARTb inp units, NULL, ARTb cmp units, NULL, ARTb rec units ...,
+      NULL, map field units, NULL, map field special units, NULL
+
+  NOTES    : 
+
+  RETURNS  : error code 
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_topoSort(int topo_sorting_mode)
+{
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+  TopoSortID = NOT_SORTED;
+  if (NoOfUnits == 0)
+    {  /*  No units defined  */
+    KernelErrorCode = KRERR_NO_UNITS;
+    return( KernelErrorCode );
+  }
+
+
+  if (krm_allocUnitTopoArray( NoOfUnits + 15) != KRERR_NO_ERROR)
+    return( KernelErrorCode );
+
+  /*  clear error codes  */
+  topo_msg.no_of_cycles = topo_msg.no_of_dead_units =
+  topo_msg.dest_error_unit = topo_msg.src_error_unit = 0;
+  topo_msg.error_code = KRERR_NO_ERROR;
+
+  switch (topo_sorting_mode)
+    {
+    case  TOPOLOGICAL:
+	(void) kr_topoSortT();
+	break;
+    case  TOPOLOGICAL_FF:
+	(void) kr_topoSortFF();
+	break;
+    case  TOPOLOGIC_TYPE:
+	(void) kr_topoSortIHO();
+	break;
+    case  TOPOLOGIC_LOGICAL:
+        KernelErrorCode = kr_topoSortLOG();
+        break;
+    case  ART1_TOPO_TYPE:
+        KernelErrorCode = kra1_sort ();
+        break;
+
+    case ART2_TOPO_TYPE:
+        KernelErrorCode = kra2_sort ();
+        break;
+
+    case ARTMAP_TOPO_TYPE:
+        KernelErrorCode = kram_sort ();
+        break;
+    case TOPOLOGICAL_CC:
+        (void) cc_topoSort(TOPOLOGICAL_CC);
+        break; 
+    case TOPOLOGICAL_BCC:
+        (void) cc_topoSort(TOPOLOGICAL_BCC);
+        break;
+    case TOPOLOGICAL_JE:
+	KernelErrorCode = kr_topoSortJE () ;
+	break ;
+
+    default:
+	KernelErrorCode = KRERR_TOPOMODE;
+    }
+
+  if ((KernelErrorCode == KRERR_NO_ERROR) || 
+      (KernelErrorCode == KRERR_DEAD_UNITS))
+    TopoSortID = topo_sorting_mode;
+
+  return( KernelErrorCode );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoCheck
+
+  PURPOSE  : Checks the topology of the network:
+             a) counts the number of layers of the network and
+	     b) determines if the network has cycles.
+  NOTES    : 
+
+  RETURNS  : Returns the no. of layers of the network.
+  UPDATE   : 
+******************************************************************************/
+int  kr_topoCheck(void)
+{
+  struct Unit   *unit_ptr;
+  bool      o_units;
+
+
+  topo_msg.no_of_cycles = topo_msg.no_of_dead_units =
+  topo_msg.dest_error_unit = topo_msg.src_error_unit =
+  topo_msg.no_of_layers = 0;
+  topo_msg.error_code = KernelErrorCode = KRERR_NO_ERROR;
+
+  if (NoOfUnits == 0)
+    {  /*  no units defined  */
+    KernelErrorCode = KRERR_NO_UNITS;
+    return( KernelErrorCode );
+  }
+
+  clr_T_flags();    /*	reset units 'touch' flags  */
+
+  /*  begin depth search at the first output unit  */
+  o_units = FALSE;
+  FOR_ALL_UNITS( unit_ptr )
+    if ( IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ) )
+      {
+      o_units = TRUE;
+      DepthFirst2( unit_ptr, 1 );
+      if (topo_msg.error_code != KRERR_NO_ERROR)
+        {  /*  stop if an error occured  */
+        KernelErrorCode = topo_msg.error_code;
+        return( KernelErrorCode );
+      }
+    }
+      
+  if (!o_units)
+    {  /*  no output units */
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS;
+    return( KernelErrorCode );
+  }
+
+  /*  return the no. of layers of the network  */
+  return( topo_msg.no_of_layers );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_makeUnitPermutation
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_makeUnitPermutation(void)
+{
+  register struct Unit   *unit_ptr;
+  register int	   no_of_units, i;
+  TopoPtrArray     topo_ptr,  t_ptr1,  t_ptr2;
+
+
+  TopoSortID = NOT_SORTED;
+  if (NoOfUnits == 0)  return( KRERR_NO_UNITS );  /*  no units defined	*/
+
+  if ( krm_allocUnitTopoArray( NoOfUnits + 2) != 0)
+    return( KRERR_INSUFFICIENT_MEM );
+
+  topo_ptr = topo_ptr_array;
+
+  /*  limit left side of the topological array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  /*  initialize permutation array  */
+  FOR_ALL_UNITS( unit_ptr )
+    if ( (unit_ptr->flags & UFLAG_INITIALIZED) == UFLAG_INITIALIZED)
+      /*  unit is in use and enabled  */
+      *topo_ptr++ = unit_ptr;
+
+  no_of_topo_units = topo_ptr - topo_ptr_array;  /* calc no. of sorted units */
+  no_of_units = no_of_topo_units;
+
+  topo_ptr = topo_ptr_array;
+  /*  permutate unit order  */
+  for (i = 0; i < no_of_units; i++)
+    {
+    t_ptr1 = topo_ptr + (lrand48() % no_of_units);
+    t_ptr2 = topo_ptr + (lrand48() % no_of_units);
+
+    unit_ptr = *t_ptr1;
+    *t_ptr1 = *t_ptr2;
+    *t_ptr2 = unit_ptr;
+    }
+
+  /*  limit right side of the topologic array with NULL pointer  */
+  *topo_ptr++ = NULL;
+
+  TopoSortID = PERMUTATION;
+  NetModified = FALSE;
+
+  return( KRERR_NO_ERROR );
+}
+
+
+/*#################################################
+
+GROUP: Functions for pattern management
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_IOCheck
+
+  PURPOSE  :  Count the no. of input and output units and return an error code
+              if the no. do not fit to the loaded patterns.
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_IOCheck(void)
+{
+  register struct Unit   *unit_ptr;
+  register int  no_of_i_units, no_of_o_units;
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  /*  count no. of input and output units  */
+  no_of_i_units = no_of_o_units = 0;
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr ){
+      if IS_INPUT_UNIT( unit_ptr )
+        no_of_i_units++;
+      if IS_OUTPUT_UNIT( unit_ptr )
+          no_of_o_units++;
+    }
+  NoOfInputUnits = no_of_i_units;
+  NoOfOutputUnits = no_of_o_units;
+
+  return( KernelErrorCode );
+}
+
+/*#################################################
+
+GROUP: other functions
+
+#################################################*/
+
+ /*****************************************************************************
+  FUNCTION :  kr_NA_Error
+
+  PURPOSE  : calculates the error for the network-analyzer tool
+  NOTES    : 
+
+  RETURNS  : Returns the float value of the error
+  UPDATE   : 
+******************************************************************************/
+
+float kr_NA_Error(int currentPattern, int error_unit, int error, bool ave)
+{
+  register struct   Unit *unit_ptr, *error_unit_ptr ;
+  register Patterns       out_pat  ;
+  register float          error_lin, error_sqr, error_su, devit ;
+  int                     pattern_no, sub_pat_no;
+
+
+  kr_initSubPatternOrder(currentPattern, currentPattern);
+  kr_getSubPatternByOrder(&pattern_no, &sub_pat_no);
+  out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT, NULL);
+
+  error_lin = 0 ;
+  error_sqr= 0 ;
+  error_su  = 0 ;
+
+  if (error_unit != 0)
+    error_unit_ptr = kr_getUnitPtr (error_unit) ;
+    
+  FOR_ALL_UNITS (unit_ptr)
+  {
+    if (IS_OUTPUT_UNIT (unit_ptr))
+    {
+      devit = (float) (*(out_pat++) - unit_ptr->Out.output) ;
+      error_lin += fabs (devit) ;
+      error_sqr += devit * devit ;  
+
+      if (unit_ptr == error_unit_ptr) error_su = fabs (devit) ;
+    }
+  }
+ 
+
+  switch (error)
+  {
+    case NA_ERROR_LIN : 
+    {
+      if (ave) return (error_lin / (float) NoOfOutputUnits);
+      else        return (error_lin) ; 
+      break ; 
+    }
+
+    case NA_ERROR_SQR : 
+    {
+      if (ave) return (error_sqr / (float) NoOfOutputUnits);
+      else        return (error_sqr) ;
+      break ; 
+    }
+
+    case NA_ERROR_SU :
+    {
+      return (error_su) ;
+      break ;
+    }
+  }
+  /* Only for the warning */
+  return(0.0);
+}
+
+/*#################################################
+
+GROUP: Functions for handeling network propagation,
+       update and learning functions.
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : kr_callNetworkFunctionSTD
+
+  PURPOSE  : calls the current network function
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+static krui_err  kr_callNetworkFunctionSTD(int type, float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray, 
+					   int *NoOfOutParams, 
+					   int start_pattern, int end_pattern)
+{
+  FunctionPtr  func_ptr;
+  NetFunctionPtr  net_func_ptr;
+  char  *curr_func;
+  int size;
+
+
+  if ( (curr_func = krf_getCurrentNetworkFunc( type )) == NULL)
+    return( KernelErrorCode );
+  if (!krf_funcSearch( curr_func, type, &func_ptr ) )
+    return( KernelErrorCode );
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  net_func_ptr = (NetFunctionPtr) func_ptr;
+
+  switch (type)  {
+    case  UPDATE_FUNC:
+      KernelErrorCode = 
+	  (*(UpdateFuncPtr)net_func_ptr) ( parameterInArray, NoOfInParams );
+      return( KernelErrorCode );
+
+    case TEST_FUNC:
+    case  LEARN_FUNC:
+      if (kr_TotalNoOfPattern() == 0)
+	{  /*  no patterns defined  */
+	KernelErrorCode = KRERR_NO_PATTERNS;
+	return( KernelErrorCode );
+      }
+      if ((start_pattern < 0) || (end_pattern >= kr_TotalNoOfPattern()) )
+	{  /*  Invalid pattern number  */
+	KernelErrorCode = KRERR_PATTERN_NO;
+	return( KernelErrorCode );
+      }
+
+      /* check whether sub pattern fits onto network */
+      if (NetModified)
+	  kr_IOCheck();
+      size = kr_SizeOfInputSubPat();
+      if (NoOfInputUnits != size)
+      {
+	  if (size < 0)
+	      KernelErrorCode = size;
+	  else
+	      KernelErrorCode = KRERR_NP_DOES_NOT_FIT;
+	  return KernelErrorCode;
+      }
+      size = kr_SizeOfOutputSubPat();
+      if (NoOfOutputUnits != size)
+      {
+	  if (size < 0)
+	      KernelErrorCode = size;
+	  else if (size == 0)
+	      KernelErrorCode = KRERR_NP_NO_OUTPUT_PATTERN;
+	  else
+	      KernelErrorCode = KRERR_NP_DOES_NOT_FIT;
+	  return KernelErrorCode;
+      }
+
+      /*  call current learning function  */
+      KernelErrorCode = 
+	  (*(LearnFuncPtr)net_func_ptr) (start_pattern, end_pattern,
+					 parameterInArray, NoOfInParams,
+					 parameterOutArray, NoOfOutParams);
+
+      if (KernelErrorCode == KRERR_NO_ERROR)
+	{  /*  learning function has initialized the network  */
+	NetInitialize = FALSE;
+	LearnFuncHasChanged = FALSE;
+      }
+
+      return( KernelErrorCode );
+
+    case (FF_LEARN_FUNC | LEARN_FUNC):
+
+      /* check whether sub pattern fits onto network */
+      if (NetModified)
+	  kr_IOCheck();
+      size = kr_SizeOfInputSubPat();
+      if (NoOfInputUnits != size)
+      {
+	  if (size < 0)
+	      KernelErrorCode = size;
+	  else
+	      KernelErrorCode = KRERR_NP_DOES_NOT_FIT;
+	  return KernelErrorCode;
+      }
+      size = kr_SizeOfOutputSubPat();
+      if (NoOfOutputUnits != size)
+      {
+	  if (size < 0)
+	      KernelErrorCode = size;
+	  else if (size == 0)
+	      KernelErrorCode = KRERR_NP_NO_OUTPUT_PATTERN;
+	  else
+	      KernelErrorCode = KRERR_NP_DOES_NOT_FIT;
+	  return KernelErrorCode;
+      }
+      /*  call embedded feed forward learning function for pruning */
+      KernelErrorCode = 
+	  (*(LearnFuncPtr) net_func_ptr) (start_pattern, end_pattern,
+					  parameterInArray, NoOfInParams,
+					  parameterOutArray, NoOfOutParams);
+
+      if (KernelErrorCode == KRERR_NO_ERROR)
+	  /*  learning function has initialized the network  */
+      { 
+	  NetInitialize = FALSE;
+	  LearnFuncHasChanged = FALSE;
+      }
+
+      return( KernelErrorCode );
+
+    case  INIT_FUNC:
+      NetInitialize = TRUE;
+      KernelErrorCode = 
+	  (*(InitFuncPtr)net_func_ptr) ( parameterInArray, NoOfInParams );
+
+      return( KernelErrorCode );
+
+   default:
+     KernelErrorCode = KRERR_PARAMETERS;
+     return( KernelErrorCode );
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_callNetworkFunction
+
+  PURPOSE  : calls the current network function
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_callNetworkFunction(int type, float *parameterInArray, 
+				 int NoOfInParams, float **parameterOutArray, 
+				 int *NoOfOutParams, int start_pattern, 
+				 int end_pattern)
+{
+#ifdef MASPAR_KERNEL
+  static struct NetFuncParameters  net_func_params;
+#endif
+
+  krui_err dummy;
+  if (NoOfUnits == 0)
+    {  /*  No Units defined  */
+    KernelErrorCode = KRERR_NO_UNITS;
+    return( KRERR_NO_UNITS );
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (specialNetworkType)  {
+    case NET_TYPE_GENERAL:
+      /*  normal network presentation  */
+      /*  the result of this call has been void which is not compatible */
+      /*  to the declaration; therefor the dummy error variable is included */
+      dummy = kr_callNetworkFunctionSTD( type, parameterInArray, NoOfInParams,
+                                        parameterOutArray, NoOfOutParams,
+                                        start_pattern, end_pattern );
+      break;
+
+#ifdef MASPAR_KERNEL
+    case NET_TYPE_FF1:
+
+      /*  feedforward net on MasPar  */
+      net_func_params.start_pattern_no = start_pattern;
+      net_func_params.end_pattern_no   = end_pattern;
+      net_func_params.no_of_input_parameters = NoOfInParams;
+
+      memcpy( net_func_params.input_parameters, parameterInArray,
+              sizeof (float) * NoOfInParams );
+
+      (void) krff_callMasParNetworkFunction( type, &net_func_params );
+
+      if (NoOfOutParams != NULL)
+        *NoOfOutParams = net_func_params.no_of_output_parameters;
+      if (parameterOutArray != NULL)
+        *parameterOutArray = net_func_params.output_parameters;
+
+      break;
+#endif
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+  }
+
+  return( KernelErrorCode );
+}
+
+
+
+#ifdef HAVE_QSORT
+static int  transTableCompare( const void *node1, const void *node2)
+{
+  short  z1, z2;
+
+  z1=((struct TransTable *) node1)->z;
+  z2=((struct TransTable *) node2)->z;
+
+  if (z1 < z2)  return -1;
+  if (z1 > z2)  return 1;
+  return 0;
+}
+#endif
+
+krui_err  kr_xyTransTable(int op, int *x, int *y, int z)
+{
+  struct TransTable  *transTablePtr,
+                     *new_transTable,
+                     transTableEntry;
+
+
+  switch(op)  {
+    case OP_TRANSTABLE_GET:
+      if (transTable != NULL)  {
+
+#ifdef HAVE_QSORT
+        transTableEntry.z = z;
+        transTablePtr = 
+	    (struct TransTable *) bsearch( &transTableEntry,
+					  (struct TransTable *) transTable,
+					  transTableSize,
+					  sizeof(struct TransTable),
+					  transTableCompare );
+#else
+	for (transTablePtr = transTable;
+             transTablePtr < (transTable + transTableSize);
+             transTablePtr++)
+          if (transTablePtr->z == z)  break;
+
+          if (transTablePtr == (transTable + transTableSize))
+            transTablePtr=NULL;
+#endif
+
+        if (transTablePtr == NULL)  {
+          *x = *y = 0;
+        }
+        else  {
+          *x=transTablePtr->x;
+          *y=transTablePtr->y;
+        }
+      }
+      else  {
+        *x = *y = 0;
+      }
+
+      KernelErrorCode = KRERR_NO_ERROR;
+      return( KRERR_NO_ERROR );
+
+    case OP_TRANSTABLE_SET:
+      if (transTable == NULL)  {
+        if((new_transTable =
+           (struct TransTable *) malloc( sizeof(struct TransTable) )) == NULL){
+          KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+          return( KRERR_INSUFFICIENT_MEM );
+        }
+
+        transTable=new_transTable;
+
+        transTable->z = z;
+        transTable->x = *x;
+        transTable->y = *y;
+        transTableSize=1;
+      }
+      else  {
+#ifdef HAVE_QSORT
+        transTableEntry.z = z;
+        transTablePtr = 
+	    (struct TransTable *) bsearch( &transTableEntry,
+					  (struct TransTable *) transTable,
+					  transTableSize,
+					  sizeof(struct TransTable),
+					  transTableCompare );
+#else
+    	for (transTablePtr = transTable;
+             transTablePtr < (transTable + transTableSize);
+             transTablePtr++)
+          if (transTablePtr->z == z)  break;
+
+          if (transTablePtr == (transTable + transTableSize))
+            transTablePtr=NULL;
+#endif
+
+        if (transTablePtr == NULL)  {
+          if ((new_transTable = 
+	       (struct TransTable *) realloc( (void *) transTable,
+		sizeof(struct TransTable) * (transTableSize + 1) )) == NULL)  {
+            KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+            return( KRERR_INSUFFICIENT_MEM );
+          }
+
+          transTable=new_transTable;
+
+          transTable[transTableSize].z = z;
+          transTable[transTableSize].x = *x;
+          transTable[transTableSize].y = *y;
+          ++transTableSize;
+
+#ifdef HAVE_QSORT
+          qsort( (struct TransTable *) transTable,
+                 transTableSize,
+                 sizeof(struct TransTable),
+                 transTableCompare );
+#endif
+        }
+        else  {
+          transTablePtr->x = *x;
+          transTablePtr->y = *y;
+        }
+      }
+
+      KernelErrorCode=KRERR_NO_ERROR;
+      return( KRERR_NO_ERROR );
+
+    case OP_TRANSTABLE_CLEAR:
+      if (transTable != NULL)  {
+        free( (void *) transTable );
+        transTable = NULL;
+        transTableSize = 0;
+      }
+
+      KernelErrorCode=KRERR_NO_ERROR;
+      return( KRERR_NO_ERROR );
+
+    default:
+      KernelErrorCode=KRERR_PARAMETERS;
+      return( KRERR_PARAMETERS );
+  }
+}
+
+
+/*#################################################
+
+GROUP: Functions for the parallel kernel
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : kr_setSpecialNetworkType
+
+  PURPOSE  : Sets the topologic type of the current network and checks the 
+             topology of the current network.
+	     Returns an error if the topologic type of the current network  
+	     doesn't fit to this type.
+	     Topologic types are:
+	     - NET_TYPE_GENERAL
+	     general purpose network type with no limitations
+	     - NET_TYPE_FF1
+	     feedforward network with fully connected units in
+	     neighbour layers
+  NOTES    : 
+
+  RETURNS  : Returns error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_setSpecialNetworkType(int net_type)
+{
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (net_type == specialNetworkType)  return( KRERR_NO_ERROR );
+
+  if (NoOfUnits == 0)
+    {  /*  no units defined  */
+    KernelErrorCode = KRERR_NO_UNITS;
+    return( KernelErrorCode );
+  }
+
+  switch (net_type)  {
+    case  NET_TYPE_GENERAL:
+
+      switch (specialNetworkType)  {
+        case  NET_TYPE_FF1:
+          /*  change special network presentation to standard presentation  */
+
+#ifdef  MASPAR_KERNEL
+          (void) krff_standardNetPresentationFF1();
+          specialNetworkType = NET_TYPE_GENERAL;
+#else
+          KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+#endif
+          break;
+
+        default:
+          KernelErrorCode = KRERR_PARAMETERS;
+      }
+
+      break;
+
+    case  NET_TYPE_FF1:
+      /*  change standart network presentation to special presentation  */
+#ifdef  MASPAR_KERNEL
+      (void) krff_determineNetFF1Params();
+      /*  change internal network presentation	*/
+      if (KernelErrorCode != KRERR_NO_ERROR)  break;
+
+      (void) krff_initMasPar();
+      if (KernelErrorCode != KRERR_NO_ERROR)  break;
+
+      (void) krff_changeNetPresentationFF1();
+
+#else
+      KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+#endif
+      break;
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+  }
+
+  if (KernelErrorCode == KRERR_NO_ERROR)
+    specialNetworkType = net_type;
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getSpecialNetworkType
+
+  PURPOSE  : Returns the special topologic type of the current network, if set.
+  NOTES    : 
+
+  RETURNS  : Returns the special topologic type of the current network, if set.
+  UPDATE   : 
+******************************************************************************/
+int  kr_getSpecialNetworkType(void)
+{
+  return( specialNetworkType );
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_validateOperation
+
+  PURPOSE  : Validate a network modifying operation according to
+             the kernel mode 
+  NOTES    : 
+
+  RETURNS  : error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_validateOperation(void)
+{
+  switch (specialNetworkType)
+    {
+    case NET_TYPE_GENERAL:
+      /*  normal network presentation, no limitations  */
+      KernelErrorCode = KRERR_NO_ERROR;
+      break;
+    case NET_TYPE_FF1:
+      /*  feedforward net with limitations  */
+      KernelErrorCode = KRERR_MODE_FF1_INVALID_OP;
+      break;
+  }
+
+  return( KernelErrorCode );
+}
+
+
+/* #############################################################
+ 
+  Functions for the MasPar kernel
+
+############################################################# */
+
+#ifdef  MASPAR_KERNEL
+/*****************************************************************************
+  FUNCTION : kr_initMasPar
+
+  PURPOSE  : Connects and Disconnects the MasPar.
+             The mode switches are:  MASPAR_CONNECT and MASPAR_DISCONNECT.
+  NOTES    : 
+
+  RETURNS  : error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_initMasPar(int mode )
+{
+  if (specialNetworkType == NET_TYPE_GENERAL)  {
+    KernelErrorCode = KRERR_NOT_PARALLEL_MODE;
+    return( KernelErrorCode );
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (mode)
+    {
+    case  MASPAR_CONNECT:
+      /*  connect maspar  */
+      if (krff_initMasPar() == KRERR_NO_ERROR)
+        masParStatus = MASPAR_CONNECT;
+
+      break;
+    case  MASPAR_DISCONNECT:
+      /*  disconnect maspar  */
+      masParStatus = MASPAR_DISCONNECT;
+
+      break;
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+  }
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getMasParStatus
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : Returns the Status of the MasPar or an error code
+  UPDATE   : 
+******************************************************************************/
+krui_err  kr_getMasParStatus(void)
+{
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  return( masParStatus );
+}
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/kernel.ddt snort-2.3.3.new/src/kernel_snns/kernel.ddt
--- snort-2.3.3/src/kernel_snns/kernel.ddt	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kernel.ddt	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,623 @@
+
+kernel.o: config.h
+kernel.o: alloca.h
+kernel.o: getcwd.h
+kernel.o: strdup.h
+kernel.o: lrand48.h
+kernel.o: kr_typ.h
+kernel.o: glob_typ.h
+kernel.o: ext_typ.h
+kernel.o: kr_const.h
+kernel.o: kr_def.h
+kernel.o: random.h
+kernel.o: kernel.ph
+kernel.o: kr_mem.h
+kernel.o: kr_funcs.h
+kernel.o: kr_mac.h
+kernel.o: cc_glob.h
+kernel.o: kr_newpattern.h
+kernel.o: prun_f.h
+kernel.o: learn_f.h
+kernel.o: matrix.h
+kernel.o: kr_art.h
+kernel.o: kr_art1.h
+kernel.o: kr_art2.h
+kernel.o: kr_amap.h
+kernel.o: kr_JordElm.h
+kr_io.o: config.h
+kr_io.o: alloca.h
+kr_io.o: getcwd.h
+kr_io.o: strdup.h
+kr_io.o: lrand48.h
+kr_io.o: kr_typ.h
+kr_io.o: glob_typ.h
+kr_io.o: ext_typ.h
+kr_io.o: kr_const.h
+kr_io.o: kr_def.h
+kr_io.o: kr_ui.h
+kr_io.o: krui_typ.h
+kr_io.o: kernel.h
+kr_io.o: kr_mac.h
+kr_io.o: version.h
+kr_io.o: dlvq_learn.h
+kr_io.o: kr_io.ph
+kr_io.o: kr_newpattern.h
+kr_io.o: cc_glob.h
+kr_io.o: cc_mac.h
+kr_mem.o: config.h
+kr_mem.o: alloca.h
+kr_mem.o: getcwd.h
+kr_mem.o: strdup.h
+kr_mem.o: lrand48.h
+kr_mem.o: kr_typ.h
+kr_mem.o: glob_typ.h
+kr_mem.o: ext_typ.h
+kr_mem.o: kernel.h
+kr_mem.o: kr_const.h
+kr_mem.o: kr_def.h
+kr_mem.o: kr_mem.ph
+kr_mem.o: kr_mac.h
+kr_ui.o: config.h
+kr_ui.o: alloca.h
+kr_ui.o: getcwd.h
+kr_ui.o: strdup.h
+kr_ui.o: lrand48.h
+kr_ui.o: random.h
+kr_ui.o: kr_typ.h
+kr_ui.o: glob_typ.h
+kr_ui.o: ext_typ.h
+kr_ui.o: kr_const.h
+kr_ui.o: kr_def.h
+kr_ui.o: kr_io.h
+kr_ui.o: kr_funcs.h
+kr_ui.o: kernel.h
+kr_ui.o: kr_mem.h
+kr_ui.o: kr_ui.ph
+kr_ui.o: krui_typ.h
+kr_ui.o: version.h
+kr_ui.o: kr_mac.h
+kr_ui.o: kr_newpattern.h
+kr_ui.o: kr_inversion.h
+kr_ui.o: cc_glob.h
+kr_ui.o: cc_display.h
+kr_ui.o: trans_f.h
+kr_ui.o: learn_f.h
+kr_inversion.o: config.h
+kr_inversion.o: alloca.h
+kr_inversion.o: getcwd.h
+kr_inversion.o: strdup.h
+kr_inversion.o: lrand48.h
+kr_inversion.o: kr_typ.h
+kr_inversion.o: glob_typ.h
+kr_inversion.o: ext_typ.h
+kr_inversion.o: kr_const.h
+kr_inversion.o: kernel.h
+kr_inversion.o: kr_def.h
+kr_inversion.o: kr_mac.h
+kr_inversion.o: kr_inversion.ph
+art_ui.o: config.h
+art_ui.o: alloca.h
+art_ui.o: getcwd.h
+art_ui.o: strdup.h
+art_ui.o: lrand48.h
+art_ui.o: kr_typ.h
+art_ui.o: glob_typ.h
+art_ui.o: ext_typ.h
+art_ui.o: kr_ui.h
+art_ui.o: krui_typ.h
+art_ui.o: kr_const.h
+art_ui.o: kernel.h
+art_ui.o: art_typ.h
+art_ui.o: kr_art.h
+art_ui.o: kr_art1.h
+art_ui.o: kr_art2.h
+art_ui.o: kr_amap.h
+art_ui.o: krart_df.h
+art_ui.o: art_ui.h
+kr_art.o: config.h
+kr_art.o: alloca.h
+kr_art.o: getcwd.h
+kr_art.o: strdup.h
+kr_art.o: lrand48.h
+kr_art.o: krart_df.h
+kr_art.o: kr_const.h
+kr_art.o: kr_mac.h
+kr_art.o: kr_def.h
+kr_art.o: kr_typ.h
+kr_art.o: glob_typ.h
+kr_art.o: ext_typ.h
+kr_art.o: kr_funcs.h
+kr_art.o: kernel.h
+kr_art.o: kr_art.ph
+kr_art1.o: config.h
+kr_art1.o: alloca.h
+kr_art1.o: getcwd.h
+kr_art1.o: strdup.h
+kr_art1.o: lrand48.h
+kr_art1.o: kr_const.h
+kr_art1.o: kr_mac.h
+kr_art1.o: kr_def.h
+kr_art1.o: kr_typ.h
+kr_art1.o: glob_typ.h
+kr_art1.o: ext_typ.h
+kr_art1.o: kr_funcs.h
+kr_art1.o: kernel.h
+kr_art1.o: kr_art.h
+kr_art1.o: krart_df.h
+kr_art1.o: kr_art1.ph
+kr_art2.o: config.h
+kr_art2.o: alloca.h
+kr_art2.o: getcwd.h
+kr_art2.o: strdup.h
+kr_art2.o: lrand48.h
+kr_art2.o: kr_const.h
+kr_art2.o: kr_mac.h
+kr_art2.o: kr_def.h
+kr_art2.o: kr_typ.h
+kr_art2.o: glob_typ.h
+kr_art2.o: ext_typ.h
+kr_art2.o: kr_funcs.h
+kr_art2.o: kernel.h
+kr_art2.o: kr_art.h
+kr_art2.o: krart_df.h
+kr_art2.o: kr_art2.ph
+kr_amap.o: config.h
+kr_amap.o: alloca.h
+kr_amap.o: getcwd.h
+kr_amap.o: strdup.h
+kr_amap.o: lrand48.h
+kr_amap.o: kr_const.h
+kr_amap.o: kr_mac.h
+kr_amap.o: kr_def.h
+kr_amap.o: kr_typ.h
+kr_amap.o: glob_typ.h
+kr_amap.o: ext_typ.h
+kr_amap.o: kr_funcs.h
+kr_amap.o: kernel.h
+kr_amap.o: kr_art.h
+kr_amap.o: krart_df.h
+kr_amap.o: kr_amap.ph
+kr_pat_parse.o: config.h
+kr_pat_parse.o: alloca.h
+kr_pat_parse.o: getcwd.h
+kr_pat_parse.o: strdup.h
+kr_pat_parse.o: lrand48.h
+kr_pat_parse.o: kr_typ.h
+kr_pat_parse.o: glob_typ.h
+kr_pat_parse.o: ext_typ.h
+kr_pat_parse.o: kernel.h
+kr_pat_parse.o: kr_pat_scan.h
+kr_pat_parse.o: kr_newpattern.h
+kr_pat_parse.o: kr_pat_parse.ph
+kr_newpattern.o: config.h
+kr_newpattern.o: alloca.h
+kr_newpattern.o: getcwd.h
+kr_newpattern.o: strdup.h
+kr_newpattern.o: lrand48.h
+kr_newpattern.o: kr_typ.h
+kr_newpattern.o: glob_typ.h
+kr_newpattern.o: ext_typ.h
+kr_newpattern.o: kr_mac.h
+kr_newpattern.o: random.h
+kr_newpattern.o: kernel.h
+kr_newpattern.o: kr_const.h
+kr_newpattern.o: kr_funcs.h
+kr_newpattern.o: dlvq_learn.h
+kr_newpattern.o: kr_newpattern.ph
+kr_newpattern.o: kr_pat_scan.h
+kr_newpattern.o: kr_pat_parse.h
+kr_JordElm.o: config.h
+kr_JordElm.o: alloca.h
+kr_JordElm.o: getcwd.h
+kr_JordElm.o: strdup.h
+kr_JordElm.o: lrand48.h
+kr_JordElm.o: kr_typ.h
+kr_JordElm.o: glob_typ.h
+kr_JordElm.o: ext_typ.h
+kr_JordElm.o: kr_const.h
+kr_JordElm.o: kr_def.h
+kr_JordElm.o: kr_mac.h
+kr_JordElm.o: kernel.h
+kr_JordElm.o: kr_JordElm.ph
+kr_pat_scan.o: y.tab.h
+kr_pat_scan.o: glob_typ.h
+kr_pat_scan.o: kr_typ.h
+kr_pat_scan.o: ext_typ.h
+kr_pat_scan.o: kernel.h
+kr_pat_scan.o: kr_newpattern.h
+kr_pat_scan.o: kr_pat_parse.h
+kr_pat_scan.o: kr_pat_scan.ph
+func_tbl.o: config.h
+func_tbl.o: alloca.h
+func_tbl.o: getcwd.h
+func_tbl.o: strdup.h
+func_tbl.o: lrand48.h
+func_tbl.o: kr_typ.h
+func_tbl.o: glob_typ.h
+func_tbl.o: ext_typ.h
+func_tbl.o: kr_const.h
+func_tbl.o: learn_f.h
+func_tbl.o: init_f.h
+func_tbl.o: trans_f.h
+func_tbl.o: remap_f.h
+func_tbl.o: update_f.h
+func_tbl.o: arttr_f.h
+func_tbl.o: tbl_func.h
+func_tbl.o: kr_td.h
+func_tbl.o: cc_learn.h
+func_tbl.o: tacoma_learn.h
+func_tbl.o: cc_type.h
+func_tbl.o: dlvq_learn.h
+func_tbl.o: prun_f.h
+func_tbl.o: stochastic_learn_f.h
+func_tbl.o: scaled_conj_grad.h
+func_tbl.o: func_tbl.ph
+init_f.o: config.h
+init_f.o: alloca.h
+init_f.o: getcwd.h
+init_f.o: strdup.h
+init_f.o: lrand48.h
+init_f.o: kr_typ.h
+init_f.o: glob_typ.h
+init_f.o: ext_typ.h
+init_f.o: kr_const.h
+init_f.o: kr_def.h
+init_f.o: kernel.h
+init_f.o: random.h
+init_f.o: kr_mac.h
+init_f.o: kr_art.h
+init_f.o: kr_art1.h
+init_f.o: kr_art2.h
+init_f.o: kr_amap.h
+init_f.o: krart_df.h
+init_f.o: learn_f.h
+init_f.o: kr_ui.h
+init_f.o: krui_typ.h
+init_f.o: cc_type.h
+init_f.o: cc_glob.h
+init_f.o: matrix.h
+init_f.o: kr_newpattern.h
+init_f.o: init_f.ph
+kr_td.o: config.h
+kr_td.o: alloca.h
+kr_td.o: getcwd.h
+kr_td.o: strdup.h
+kr_td.o: lrand48.h
+kr_td.o: kr_typ.h
+kr_td.o: glob_typ.h
+kr_td.o: ext_typ.h
+kr_td.o: kr_const.h
+kr_td.o: kr_def.h
+kr_td.o: kernel.h
+kr_td.o: kr_mac.h
+kr_td.o: kr_newpattern.h
+kr_td.o: kr_td.ph
+kr_funcs.o: config.h
+kr_funcs.o: alloca.h
+kr_funcs.o: getcwd.h
+kr_funcs.o: strdup.h
+kr_funcs.o: lrand48.h
+kr_funcs.o: kr_typ.h
+kr_funcs.o: glob_typ.h
+kr_funcs.o: ext_typ.h
+kr_funcs.o: kr_const.h
+kr_funcs.o: kr_def.h
+kr_funcs.o: kr_funcs.ph
+kr_funcs.o: kernel.h
+kr_funcs.o: func_tbl.h
+learn_f.o: config.h
+learn_f.o: alloca.h
+learn_f.o: getcwd.h
+learn_f.o: strdup.h
+learn_f.o: lrand48.h
+learn_f.o: kr_typ.h
+learn_f.o: glob_typ.h
+learn_f.o: ext_typ.h
+learn_f.o: kr_const.h
+learn_f.o: kr_def.h
+learn_f.o: kernel.h
+learn_f.o: kr_mac.h
+learn_f.o: kr_ui.h
+learn_f.o: krui_typ.h
+learn_f.o: kr_art.h
+learn_f.o: kr_art1.h
+learn_f.o: kr_art2.h
+learn_f.o: kr_amap.h
+learn_f.o: krart_df.h
+learn_f.o: kr_newpattern.h
+learn_f.o: kr_JordElm.h
+learn_f.o: prun_f.h
+learn_f.o: learn_f.ph
+prun_f.o: config.h
+prun_f.o: alloca.h
+prun_f.o: getcwd.h
+prun_f.o: strdup.h
+prun_f.o: lrand48.h
+prun_f.o: kr_typ.h
+prun_f.o: glob_typ.h
+prun_f.o: ext_typ.h
+prun_f.o: kr_const.h
+prun_f.o: kr_def.h
+prun_f.o: kernel.h
+prun_f.o: kr_mac.h
+prun_f.o: kr_funcs.h
+prun_f.o: kr_newpattern.h
+prun_f.o: matrix.h
+prun_f.o: learn_f.h
+prun_f.o: prun_f.ph
+tbl_func.o: config.h
+tbl_func.o: alloca.h
+tbl_func.o: getcwd.h
+tbl_func.o: strdup.h
+tbl_func.o: lrand48.h
+tbl_func.o: kr_typ.h
+tbl_func.o: glob_typ.h
+tbl_func.o: ext_typ.h
+tbl_func.o: kr_const.h
+tbl_func.o: func_mac.h
+tbl_func.o: tbl_func.ph
+tbl_func.o: sigmoid.tbl
+trans_f.o: config.h
+trans_f.o: alloca.h
+trans_f.o: getcwd.h
+trans_f.o: strdup.h
+trans_f.o: lrand48.h
+trans_f.o: kr_typ.h
+trans_f.o: glob_typ.h
+trans_f.o: ext_typ.h
+trans_f.o: kr_const.h
+trans_f.o: func_mac.h
+trans_f.o: kr_mac.h
+trans_f.o: cc_mac.h
+trans_f.o: trans_f.ph
+update_f.o: config.h
+update_f.o: alloca.h
+update_f.o: getcwd.h
+update_f.o: strdup.h
+update_f.o: lrand48.h
+update_f.o: kr_typ.h
+update_f.o: glob_typ.h
+update_f.o: ext_typ.h
+update_f.o: kr_const.h
+update_f.o: kr_def.h
+update_f.o: kernel.h
+update_f.o: kr_ui.h
+update_f.o: krui_typ.h
+update_f.o: kr_mem.h
+update_f.o: random.h
+update_f.o: kr_mac.h
+update_f.o: krart_df.h
+update_f.o: kr_art1.h
+update_f.o: kr_art2.h
+update_f.o: kr_amap.h
+update_f.o: kr_art.h
+update_f.o: kr_td.h
+update_f.o: cc_glob.h
+update_f.o: cc_mac.h
+update_f.o: dlvq_learn.h
+update_f.o: update_f.ph
+update_f.o: kr_JordElm.h
+update_f.o: func_mac.h
+update_f.o: kr_newpattern.h
+remap_f.o: config.h
+remap_f.o: alloca.h
+remap_f.o: getcwd.h
+remap_f.o: strdup.h
+remap_f.o: lrand48.h
+remap_f.o: glob_typ.h
+remap_f.o: remap_f.ph
+matrix.o: config.h
+matrix.o: alloca.h
+matrix.o: getcwd.h
+matrix.o: strdup.h
+matrix.o: lrand48.h
+matrix.o: matrix.ph
+matrix.o: glob_typ.h
+arttr_f.o: config.h
+arttr_f.o: alloca.h
+arttr_f.o: getcwd.h
+arttr_f.o: strdup.h
+arttr_f.o: lrand48.h
+arttr_f.o: kr_typ.h
+arttr_f.o: glob_typ.h
+arttr_f.o: ext_typ.h
+arttr_f.o: kr_def.h
+arttr_f.o: kr_const.h
+arttr_f.o: func_mac.h
+arttr_f.o: kr_art.h
+arttr_f.o: kr_art1.h
+arttr_f.o: kr_art2.h
+arttr_f.o: kr_amap.h
+arttr_f.o: krart_df.h
+arttr_f.o: arttr_f.ph
+cc_learn.o: config.h
+cc_learn.o: alloca.h
+cc_learn.o: getcwd.h
+cc_learn.o: strdup.h
+cc_learn.o: lrand48.h
+cc_learn.o: random.h
+cc_learn.o: kr_typ.h
+cc_learn.o: glob_typ.h
+cc_learn.o: ext_typ.h
+cc_learn.o: kr_const.h
+cc_learn.o: kr_def.h
+cc_learn.o: kernel.h
+cc_learn.o: kr_mac.h
+cc_learn.o: kr_ui.h
+cc_learn.o: krui_typ.h
+cc_learn.o: cc_type.h
+cc_learn.o: cc_mac.h
+cc_learn.o: cc_learn.ph
+cc_learn.o: cc_glob.h
+cc_learn.o: kr_newpattern.h
+cc_learn.o: cc_modify.h
+cc_learn.o: cc_prune.h
+cc_learn.o: cc_display.h
+cc_learn.o: tacoma_learn.h
+cc_prune.o: config.h
+cc_prune.o: alloca.h
+cc_prune.o: getcwd.h
+cc_prune.o: strdup.h
+cc_prune.o: lrand48.h
+cc_prune.o: random.h
+cc_prune.o: kr_typ.h
+cc_prune.o: glob_typ.h
+cc_prune.o: ext_typ.h
+cc_prune.o: kr_const.h
+cc_prune.o: kr_def.h
+cc_prune.o: kernel.h
+cc_prune.o: kr_mac.h
+cc_prune.o: kr_ui.h
+cc_prune.o: krui_typ.h
+cc_prune.o: cc_type.h
+cc_prune.o: cc_mac.h
+cc_prune.o: cc_glob.h
+cc_prune.o: kr_newpattern.h
+cc_prune.o: cc_prune.ph
+cc_modify.o: config.h
+cc_modify.o: alloca.h
+cc_modify.o: getcwd.h
+cc_modify.o: strdup.h
+cc_modify.o: lrand48.h
+cc_modify.o: random.h
+cc_modify.o: kr_typ.h
+cc_modify.o: glob_typ.h
+cc_modify.o: ext_typ.h
+cc_modify.o: kr_const.h
+cc_modify.o: kr_def.h
+cc_modify.o: kernel.h
+cc_modify.o: kr_mac.h
+cc_modify.o: kr_ui.h
+cc_modify.o: krui_typ.h
+cc_modify.o: cc_type.h
+cc_modify.o: cc_mac.h
+cc_modify.o: kr_newpattern.h
+cc_modify.o: cc_modify.ph
+cc_modify.o: cc_glob.h
+cc_glob.o: config.h
+cc_glob.o: alloca.h
+cc_glob.o: getcwd.h
+cc_glob.o: strdup.h
+cc_glob.o: lrand48.h
+cc_glob.o: kr_typ.h
+cc_glob.o: glob_typ.h
+cc_glob.o: ext_typ.h
+cc_glob.o: kr_const.h
+cc_glob.o: kr_def.h
+cc_glob.o: random.h
+cc_glob.o: kr_mac.h
+cc_glob.o: kernel.h
+cc_glob.o: kr_ui.h
+cc_glob.o: krui_typ.h
+cc_glob.o: kr_newpattern.h
+cc_glob.o: cc_mac.h
+cc_glob.o: cc_type.h
+cc_glob.o: cc_modify.h
+cc_glob.o: cc_display.h
+cc_glob.o: cc_glob.ph
+cc_display.o: config.h
+cc_display.o: alloca.h
+cc_display.o: getcwd.h
+cc_display.o: strdup.h
+cc_display.o: lrand48.h
+cc_display.o: kr_typ.h
+cc_display.o: glob_typ.h
+cc_display.o: ext_typ.h
+cc_display.o: kr_const.h
+cc_display.o: kr_def.h
+cc_display.o: kr_mac.h
+cc_display.o: kernel.h
+cc_display.o: kr_ui.h
+cc_display.o: krui_typ.h
+cc_display.o: kr_newpattern.h
+cc_display.o: cc_mac.h
+cc_display.o: cc_type.h
+cc_display.o: cc_glob.h
+cc_display.o: cc_display.ph
+tacoma_learn.o: config.h
+tacoma_learn.o: alloca.h
+tacoma_learn.o: getcwd.h
+tacoma_learn.o: strdup.h
+tacoma_learn.o: lrand48.h
+tacoma_learn.o: random.h
+tacoma_learn.o: kr_typ.h
+tacoma_learn.o: glob_typ.h
+tacoma_learn.o: ext_typ.h
+tacoma_learn.o: kr_const.h
+tacoma_learn.o: kr_def.h
+tacoma_learn.o: kernel.h
+tacoma_learn.o: kr_mac.h
+tacoma_learn.o: kr_ui.h
+tacoma_learn.o: krui_typ.h
+tacoma_learn.o: cc_type.h
+tacoma_learn.o: cc_mac.h
+tacoma_learn.o: cc_glob.h
+tacoma_learn.o: cc_display.h
+tacoma_learn.o: kr_newpattern.h
+tacoma_learn.o: cc_learn.ph
+tacoma_learn.o: tacoma_learn.ph
+dlvq_learn.o: config.h
+dlvq_learn.o: alloca.h
+dlvq_learn.o: getcwd.h
+dlvq_learn.o: strdup.h
+dlvq_learn.o: lrand48.h
+dlvq_learn.o: kr_typ.h
+dlvq_learn.o: glob_typ.h
+dlvq_learn.o: ext_typ.h
+dlvq_learn.o: kr_const.h
+dlvq_learn.o: kr_def.h
+dlvq_learn.o: kernel.h
+dlvq_learn.o: kr_ui.h
+dlvq_learn.o: krui_typ.h
+dlvq_learn.o: kr_mac.h
+dlvq_learn.o: cc_mac.h
+dlvq_learn.o: kr_newpattern.h
+dlvq_learn.o: cc_glob.h
+dlvq_learn.o: dlvq_type.h
+dlvq_learn.o: dlvq_learn.ph
+stochastic_learn_f.o: config.h
+stochastic_learn_f.o: alloca.h
+stochastic_learn_f.o: getcwd.h
+stochastic_learn_f.o: strdup.h
+stochastic_learn_f.o: lrand48.h
+stochastic_learn_f.o: kr_typ.h
+stochastic_learn_f.o: glob_typ.h
+stochastic_learn_f.o: ext_typ.h
+stochastic_learn_f.o: kr_const.h
+stochastic_learn_f.o: kr_def.h
+stochastic_learn_f.o: kernel.h
+stochastic_learn_f.o: kr_mac.h
+stochastic_learn_f.o: kr_art.h
+stochastic_learn_f.o: kr_art1.h
+stochastic_learn_f.o: kr_art2.h
+stochastic_learn_f.o: kr_amap.h
+stochastic_learn_f.o: krart_df.h
+stochastic_learn_f.o: learn_f.h
+stochastic_learn_f.o: stochastic_learn_f.ph
+stochastic_learn_f.o: random.h
+stochastic_learn_f.o: kr_newpattern.h
+scaled_conj_grad.o: config.h
+scaled_conj_grad.o: alloca.h
+scaled_conj_grad.o: getcwd.h
+scaled_conj_grad.o: strdup.h
+scaled_conj_grad.o: lrand48.h
+scaled_conj_grad.o: kr_typ.h
+scaled_conj_grad.o: glob_typ.h
+scaled_conj_grad.o: ext_typ.h
+scaled_conj_grad.o: kr_const.h
+scaled_conj_grad.o: kernel.h
+scaled_conj_grad.o: kr_mac.h
+scaled_conj_grad.o: learn_f.h
+scaled_conj_grad.o: scaled_conj_grad.ph
+scaled_conj_grad.o: kr_newpattern.h
+make_tbl.o: config.h
+make_tbl.o: alloca.h
+make_tbl.o: getcwd.h
+make_tbl.o: strdup.h
+make_tbl.o: lrand48.h
+calc_err.o: config.h
+calc_err.o: alloca.h
+calc_err.o: getcwd.h
+calc_err.o: strdup.h
+calc_err.o: lrand48.h
+calc_err.o: sigmoid.tbl
diff -Naur snort-2.3.3/src/kernel_snns/kernel.h snort-2.3.3.new/src/kernel_snns/kernel.h
--- snort-2.3.3/src/kernel_snns/kernel.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kernel.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,418 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kernel.h,v $
+  SHORTNAME      : kernel.h
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS Kernel Function Prototypes
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 20.02.90
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Christine Bagdi
+  RCS VERSION    : $Revision: 2.14 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:21 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _KENREL_DEFINED_
+#define  _KENREL_DEFINED_
+
+
+/*#################################################
+
+GROUP:  Parallel kernel functions
+
+#################################################*/
+
+#ifdef  MASPAR_KERNEL
+/*  Connects and Disconnects the MasPar.
+    The mode switches are:  MASPAR_CONNECT and MASPAR_DISCONNECT. */
+extern krui_err  kr_initMasPar( int  mode );
+
+/* Returns the Status of the MasPar or an error code.*/
+extern krui_err  kr_getMasParStatus( void );
+#endif
+
+/*  Validate a network modifying operation according to
+    the kernel mode. */
+extern krui_err  kr_validateOperation( void );
+
+/*  Sets the topologic type of the current network.
+    Returns an error if the topologic type of the current network  
+    doesn't fit to this type.
+    Topologic types are:
+      - NET_TYPE_GENERAL
+        general purpose network type with no limitations
+      - NET_TYPE_FF1
+        feedforward network with fully connected units in
+        neighbour layers */
+extern krui_err  kr_setSpecialNetworkType( int  net_type );
+
+/*  Returns the special topologic type of the current network, if set. */
+extern int  kr_getSpecialNetworkType( void );
+
+/*  Creates a user defined unit. */
+extern int  kr_createUnit(char *unit_name, char *out_func_name, 
+			  char *act_func_name, FlintTypeParam i_act, 
+			  FlintTypeParam  bias );
+
+/*  Deletes all input links at current unit/site. */
+extern krui_err  kr_deleteAllLinks( int  mode );
+
+
+/*  Deletes the current link.
+    NOTE: To delete a link between the current unit/site and the source unit
+      <source_unit_no>, call krui_isConnected( source_unit_no ) and
+      krui_deleteLink(). */
+extern krui_err  kr_deleteLink( void );
+
+
+/*  Creates a link between source unit and the current unit/site.
+    Returns an error code:
+     - if memory allocation fails
+     - if source unit doesn't exist or
+     - if there exists already a connection between current unit/site and
+       the source unit
+    0 otherwise.
+    kr_createLink DO NOT set the current link.
+
+NOTE: If you want to create a link and its unknown if there exists already a
+      connection between the two units, use krui_createLink and test the return
+      code, instead of the sequence kr_isConnected and kr_createLink. */
+extern krui_err  kr_createLink( int  source_unit_no, FlintTypeParam  weight );
+
+/* Creates a link between source unit and the current unit/site 
+   and sets the values for value_a, value_b and value_c. 
+   Returns pointer to new unit */
+
+extern struct Link*  kr_createLinkWithAdditionalParameters(int source_unit_no, 
+		    FlintTypeParam weight,float val_a,float val_b,float val_c);
+
+/*  Sets the link weight of the current link*/
+extern void  kr_setLinkWeight( FlintTypeParam	weight );
+
+
+/*  Returns the link weight of the current link.*/
+extern FlintType  kr_getLinkWeight( void );
+
+
+/*  True if there exists a connection between source unit <source_unit_no>
+    and the current unit/site, otherwise false.
+    NOTE: If there exists a connection between the two units, the current 
+      link is set to the link between the two units.*/
+extern bool  kr_isConnected( int  source_unit_no, FlintType   *weight );
+
+
+/*  True if there exists a connection between source unit <source_unit_no>
+    and target unit <target_unit_no>, otherwise false. If there exist a
+    connection between these units, kr_areConnected returns the connection
+    strength also.
+    Returns FALSE if unit doesn't exist.
+    IMPORTANT: If there exist a connection, the current unit and site will be
+	   set to the target unit/site.
+    NOTE: This function is slow (Units are backward chained only).*/
+extern bool  kr_areConnected( int  source_unit_no, int  target_unit_no,
+			     FlintType   *weight );
+
+/*  Returns the no. of first or next succecessor unit of the given unit and 
+    the connection strenght. Sets the current unit/site.*/
+extern int  kr_getSuccessorUnit(int mode, int source_unit_no, 
+				FlintType  *weigth );
+
+
+/*  initialize the first/next site or the named site at the current unit
+    for access */
+extern int  kr_setSite( int  mode, char  *site_name );
+
+/*  initializes the given unit for access*/
+extern krui_err  kr_setCurrUnit( int  unit_no );
+
+/*  returns the number of the first/next/current unit of the unit array*/
+extern int  kr_getUnit( int  mode );
+
+/*  Returns the no. of first, next or current predecessor unit of the
+    current unit/site and the connection weight. Value a-c is returned too, but 
+    not used by most of the routines.(change by J.G.) */
+extern int  kr_getPredecessorUnit( int  mode, FlintType  *weight, float* val_a, 
+				   float* val_b, float* val_c);
+
+/*  Remove unit and all links from network.*/
+extern krui_err  kr_removeUnit( struct Unit  *unit_ptr );
+
+/*  Returns the value of the specified unit component.*/
+extern FlintType   kr_getUnitValues( int  unit_no, int  component_selector );
+
+/*  Sets the value of the specified unit component.*/
+extern krui_err  kr_setUnitValues( int  unit_no, int  component_selector,
+				  FlintTypeParam  value );
+
+/*  Sets all unit components of the specified unit.*/
+extern krui_err  kr_setAllUnitValues( int unit_no, FlintTypeParam out, 
+				     FlintTypeParam act, FlintTypeParam i_act, 
+				     FlintTypeParam bias );
+
+/*  delete all inputs at the given unit*/
+extern void kr_deleteAllInputs( struct Unit  *unit_ptr );
+
+/*  Deletes all output links at <source_unit>
+    NOTE: This function is slow.*/
+extern void kr_deleteAllOutputLinks( struct Unit  *source_unit_ptr );
+
+/*  search for a site at a unit */
+extern struct Site *kr_searchUnitSite( struct Unit  *unit_ptr, 
+				      struct SiteTable  *stbl_ptr );
+
+/*  search for a site at a unit and returns also the predecessor site ptr */
+extern void kr_searchUnitSiteWithPred( struct Unit  *unit_ptr, 
+				      struct SiteTable  *stbl_ptr,
+				      struct Site  * *Rsite_ptr, 
+				      struct Site  * *Rsite_pred_ptr );
+
+/*  searches for a site in the network */
+extern int kr_searchNetSite( struct SiteTable  *stbl_ptr );
+
+/*  Creates a new site with default initialisation*/
+extern struct Site *kr_createDefaultSite( void );
+
+/*  returns the pointer to the given unit, returns NULL if unit doesn't exist*/
+extern struct Unit *kr_getUnitPtr( int  unit_no );
+
+/*  Searches for a unit with the given symbol pointer.
+    Returns the first unit no. if a unit with the given name was found,
+    0 otherwise. */
+extern int kr_unitNameSearch( int  min_unit_no, char  *unit_symbol_ptr );
+
+/*  Creates a unit with default values.*/
+extern int  kr_makeDefaultUnit( void );
+
+
+/*  Copy a given unit, according to the copy mode
+        1. copy unit (with it sites, if available) and input/output links
+        2. copy unit (with it sites, if available) and input links
+        3. copy unit (with it sites, if available) and output links
+        4. copy unit (with it sites, if available) but no input/output links
+
+    Returns the unit number of the new unit or error message < 0 , if errors 
+    occured. Function has no effect on the current unit.
+
+    NOTE: Copying of output links is slow.
+      If return code < 0, an error occured.*/
+extern krui_err  kr_copyUnit( int  copy_mode, int  source_unit );
+
+/*  Sets the topologic type of the unit.*/
+extern krui_err  kr_unitSetTType( int  unit_no, int  UnitTType );
+
+
+/*  changes all units in the network with the given functionality type
+    to the new functions of the (new) functionality type */
+extern void kr_changeFtypeUnits( struct  FtypeUnitStruct  *Ftype_entry );
+
+/*   delete the functionality type of the units with the given type*/
+extern void kr_deleteUnitsFtype( struct  FtypeUnitStruct  *ftype_ptr );
+
+/*  create a new unit with the given functionality type*/
+extern int  kr_makeFtypeUnit( char  *Ftype_symbol );
+
+/*  returns TRUE, if there exists the given site at the given ftype entry*/
+extern bool kr_FtypeSiteSearch( struct  Site  *ftype_first_site, struct  SiteTable  *site_table_ptr );
+
+/*  change the properties of the given unit to the properties of the
+    given F-Type */
+extern void kr_changeFtypeUnit( struct  Unit  *unit_ptr, struct  FtypeUnitStruct  *ftype_ptr );
+
+/*  change a site at the F-Type*/
+extern void kr_changeFtypeSites( struct  FtypeUnitStruct  *Ftype_entry, 
+                          struct  SiteTable  *old_site_table,
+                          struct  SiteTable  *new_site_table );
+
+/*  spell checker  (check identifiers for matching [A-Za-z]^[|, ]*)*/
+extern bool kr_symbolCheck( char    *symbol );
+
+/*  translate unit flags to the topological type of the unit*/
+extern int kr_flags2TType( int  flags );
+
+/*  translate the topological type to unit flags*/
+extern int kr_TType2Flags( int  ttype );
+
+/*  update the outputs of all units in the network*/
+extern void kr_updateUnitOutputs( void );
+
+/*  returns the no. of units of the specified topologic type
+    (i.e. Input, Hidden, Output or Special units)*/
+extern int kr_getNoOfUnits( int  UnitTType );
+
+/*  returns the no. of special units of the specified topologic type
+    (i.e. Input, Hidden, Output or Special units)*/
+extern int kr_getNoOfSpecialUnits( int  UnitTType );
+
+/*  force unit array garbage collection*/
+extern void  kr_forceUnitGC( void );
+
+
+/*#################################################
+
+GROUP: Topological Sorting Functions
+
+#################################################*/
+
+
+/*  Sort units according to the given mode:
+    TOPOLOGICAL:
+      Sort units topological (general version) and stores the
+      pointers to this units in the topologic array.
+      NOTE: Units are not sorted by their topologic type (that's not
+	    possible in general case).
+
+    TOPOLOGICAL_FF:
+      Sorts unit topological in feed-forward networks and stores the
+      pointers to this units in the topologic array in the following order:
+       - input,
+       - hidden and
+       - output units
+
+      This function make following assumtions (like all learning functions for
+      feed-forward networks):
+       a) input units doesn't have input connections to other units and
+       b) output units doesn't have outputs connections to other units.
+
+    TOPOLOGIC_TYPE:
+      Sort units by their topologic type, i.e. Input, Hidden, Output units and
+      stores the pointers to this units in the topologic array. */
+extern krui_err kr_topoSort( int sort_mode );
+
+
+/*  Checks the topology of the network:
+     a) counts the number of layers of the network and
+     b) determines if the network has cycles.
+
+    Returns the no. of layers of the network.*/
+extern int kr_topoCheck( void );
+
+/*  Count the no. of input and output units and return an error code
+    if the no. do not fit to the loaded patterns.*/
+extern krui_err  kr_IOCheck( void );
+
+extern krui_err  kr_makeUnitPermutation( void );
+
+/*#################################################
+
+GROUP: Other functions
+
+#################################################*/
+
+/*  Add random uniform distributed values to connection weights.
+    <minus> must be less then <plus>.*/
+extern void kr_jogWeights( FlintTypeParam  minus, FlintTypeParam  plus );
+extern krui_err kr_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus, 
+				  FlintTypeParam mincorr);
+
+/*  calls a network function */
+extern krui_err  kr_callNetworkFunction(int type, float *parameterInArray, 
+					int  NoOfInParams,
+					float  * *parameterOutArray, 
+					int  *NoOfOutParams, int start_pattern,
+					int  end_pattern );
+
+/*  Returns information about the unit default settings. */
+extern void kr_getUnitDefaults( FlintType *act, FlintType *bias, int *ttflags,
+			       int  *subnet_no, int  *layer_no, 
+			       char * *act_func, char * *out_func );
+
+/*  Changes the unit default settings. */
+extern krui_err kr_setUnitDefaults( FlintTypeParam  act, FlintTypeParam  bias,
+				   int  ttflags, int subnet_no, int  layer_no, 
+				   char  *act_func_ptr, char  *out_func_ptr );
+
+/* for the network-analyzer tool
+*/
+extern float kr_NA_Error(int currentPattern,
+			 int error_unit, int error, bool ave);
+
+
+/*#################################################
+
+GROUP: Global Var's
+
+#################################################*/
+
+extern bool  NetModified,    /*  TRUE, if the network topology was modified  */
+             NetInitialize,  /*  TRUE, if the network has been initialized   */
+        LearnFuncHasChanged ;/*  TRUE, if the learning function has changed  */
+
+extern FlagWord  DefaultSType;  /*  default topological type	*/
+
+extern int  NoOfUnits,	/*  no. of units in the network  */
+            MinUnitNo,	/*  the first (lowest) used unit no. in the network */
+            MaxUnitNo,	/*  the last (highest) used unit no. in the network */
+            NoOfInputUnits,	/*  no. of input units	*/
+            NoOfOutputUnits,    /*  no. of output units  */
+            NoOfHiddenUnits,	/*  no. of hidden units  */
+            TopoSortID;         /*  topologic mode identifier  */
+
+extern UnitArray   unit_array;  /*  the unit array  */
+
+extern TopoPtrArray topo_ptr_array;  /* pointers to topological sorted units
+					used by kr_topoSort()  */
+
+extern int  no_of_topo_units;  /*  no. of unit pointers in topo_ptr_array  */
+
+
+/*  Kernel Interface Error Code */
+extern krui_err  KernelErrorCode;
+
+/*  File I/O: Line number of the network file. */
+extern int  lineno;
+
+/*  Stores the error codes and messages of the topologic sorting and network 
+    checking functions. */
+extern struct TopologicMessages  topo_msg;
+
+
+/*  Pointers and numbers for storing the current unit, site or link.
+    Used by unit/site/link searching routines. */
+extern struct Unit  *unitPtr;
+extern struct Site  *sitePtr,
+	            *prevSitePtr;
+extern struct Link  *linkPtr,
+	            *prevLinkPtr;
+extern int  unitNo;
+
+
+extern int   specialNetworkType;   /* stores the topologic type of a network */
+
+extern float MinimumError;      /* best recognition rate */
+extern float Temperature;      /* Temperature for Simulated Annealing */
+
+#ifdef MASPAR_KERNEL
+
+/*#################################################
+
+GROUP:  Global var's of the parallel MasPar kernel
+
+#################################################*/
+
+extern int   masParStatus;        /*  holds the status of the MasPar */
+
+/*  stores the topologic description of a feedforward network */
+extern struct FFnetDescriptor  descrFFnet,
+                               descrFFnetIO;
+
+#endif
+
+
+/*#################################################
+
+GROUP:  3D-Functions
+
+#################################################*/
+
+extern krui_err  kr_xyTransTable(int op, int *x, int *y, int z);
+
+
+
+#endif  /* _KERNEL_DEFINED_ */
+
+/* 411 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kernel.ph snort-2.3.3.new/src/kernel_snns/kernel.ph
--- snort-2.3.3/src/kernel_snns/kernel.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kernel.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,498 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kernel.ph,v $
+  SHORTNAME      : kernel.ph
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS Kernel Function Prototypes
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 20.02.90
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier,Christine Bagdi
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:22 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _KENREL_DEFINED_
+#define  _KENREL_DEFINED_
+
+/* begin global definition section */
+
+/*#################################################
+
+GROUP:  Parallel kernel functions
+
+#################################################*/
+
+#ifdef  MASPAR_KERNEL
+/*  Connects and Disconnects the MasPar.
+    The mode switches are:  MASPAR_CONNECT and MASPAR_DISCONNECT. */
+krui_err  kr_initMasPar( int  mode );
+
+/* Returns the Status of the MasPar or an error code. */
+krui_err  kr_getMasParStatus( void );
+#endif
+
+/*  Validate a network modifying operation according to the kernel mode. */
+krui_err  kr_validateOperation( void );
+
+/*  Sets the topologic type of the current network.
+    Returns an error if the topologic type of the current network  
+    doesn't fit to this type.
+    Topologic types are:
+      - NET_TYPE_GENERAL
+        general purpose network type with no limitations
+      - NET_TYPE_FF1
+        feedforward network with fully connected units in
+        neighbour layers */
+krui_err  kr_setSpecialNetworkType( int  net_type );
+
+/*  Returns the special topologic type of the current network, if set. */
+int  kr_getSpecialNetworkType( void );
+
+/*  Creates a user defined unit. */
+int  kr_createUnit( char  *unit_name, char *out_func_name, char *act_func_name,
+		   FlintTypeParam  i_act, FlintTypeParam  bias );
+
+/*  Deletes all input links at current unit/site. */
+krui_err  kr_deleteAllLinks( int  mode );
+
+/*  Deletes the current link.
+    NOTE: To delete a link between the current unit/site and the source unit
+      <source_unit_no>, call krui_isConnected( source_unit_no ) and
+      krui_deleteLink(). */
+krui_err  kr_deleteLink( void );
+
+/*  Creates a link between source unit and the current unit/site.
+    Returns an error code:
+     - if memory allocation fails
+     - if source unit doesn't exist or
+     - if there exists already a connection between current unit/site and
+       the source unit
+    0 otherwise.
+    kr_createLink DO NOT set the current link.
+   NOTE: If you want to create a link and its unknown if there exists already a
+      connection between the two units, use krui_createLink and test the return
+      code, instead of the sequence kr_isConnected and kr_createLink. */
+krui_err  kr_createLink( int  source_unit_no, FlintTypeParam  weight );
+
+/* Creates a link between source unit and the current unit/site 
+   and sets the values for value_a, value_b and value_c. 
+   Returns pointer to new unit */
+struct Link*  kr_createLinkWithAdditionalParameters(int source_unit_no, 
+			FlintTypeParam weight,
+                       float val_a,float val_b,float val_c);
+
+/*  Sets the link weight of the current link */
+void  kr_setLinkWeight( FlintTypeParam	weight );
+
+/*  Returns the link weight of the current link. */
+FlintType  kr_getLinkWeight( void );
+
+/*  True if there exists a connection between source unit <source_unit_no>
+    and the current unit/site, otherwise false.
+    NOTE: If there exists a connection between the two units, the current 
+      link is set to the link between the two units. */
+bool  kr_isConnected( int  source_unit_no, FlintType   *weight );
+
+/*  True if there exists a connection between source unit <source_unit_no>
+    and target unit <target_unit_no>, otherwise false. If there exist a
+    connection between these units, kr_areConnected returns the connection
+    strength also.
+    Returns FALSE if unit doesn't exist.
+    IMPORTANT: If there exist a connection, the current unit and site will be
+	   set to the target unit/site.
+    NOTE: This function is slow (Units are backward chained only). */
+bool  kr_areConnected( int  source_unit_no, int  target_unit_no, 
+		      FlintType   *weight );
+
+/*  Returns the no. of first or next succecessor unit of the
+    given unit and the connection strenght.
+    Sets the current unit/site. */
+int  kr_getSuccessorUnit( int  mode, int  source_unit_no, FlintType  *weigth );
+
+/*  initialize the first/next site or the named site at the current unit
+    for access */
+int  kr_setSite( int  mode, char  *site_name );
+
+/*  initializes the given unit for access */
+krui_err  kr_setCurrUnit( int  unit_no );
+
+/*  returns the number of the first/next/current unit of the unit array */
+int  kr_getUnit( int  mode );
+
+/*  Returns the no. of first, next or current predecessor unit of the
+    current unit/site and the connection weight. */
+int  kr_getPredecessorUnit( int  mode, FlintType  *weight, float* val_a, 
+			    float* val_b, float* val_c);
+
+/*  Remove unit and all links from network. */
+krui_err  kr_removeUnit( struct Unit  *unit_ptr );
+
+/*  Returns the value of the specified unit component. */
+FlintType   kr_getUnitValues( int  unit_no, int  component_selector );
+
+/*  Sets the value of the specified unit component. */
+krui_err  kr_setUnitValues( int  unit_no, int  component_selector,
+			   FlintTypeParam  value );
+
+/*  Sets all unit components of the specified unit. */
+krui_err  kr_setAllUnitValues( int unit_no, FlintTypeParam out, 
+			      FlintTypeParam act,
+			      FlintTypeParam i_act, FlintTypeParam bias );
+
+/*  delete all inputs at the given unit */
+void kr_deleteAllInputs( struct Unit  *unit_ptr );
+
+/*  Deletes all output links at <source_unit>
+    NOTE: This function is slow. */
+void kr_deleteAllOutputLinks( struct Unit  *source_unit_ptr );
+
+/*  search for a site at a unit */
+struct Site *kr_searchUnitSite( struct Unit  *unit_ptr, 
+			       struct SiteTable  *stbl_ptr );
+
+/*  search for a site at a unit and returns also the predecessor site ptr */
+void kr_searchUnitSiteWithPred( struct Unit  *unit_ptr, 
+			       struct SiteTable  *stbl_ptr,
+			       struct Site  * *Rsite_ptr, 
+			       struct Site  * *Rsite_pred_ptr );
+
+/*  searches for a site in the network  */
+int kr_searchNetSite( struct SiteTable  *stbl_ptr );
+
+/*  Creates a new site with default initialisation */
+struct Site *kr_createDefaultSite( void );
+
+/* returns the pointer to the given unit, returns NULL if unit doesn't exist */
+struct Unit *kr_getUnitPtr( int  unit_no );
+
+/*  Searches for a unit with the given symbol pointer.
+    Returns the first unit no. if a unit with the given name was found,
+    0 otherwise.*/
+int kr_unitNameSearch( int  min_unit_no, char  *unit_symbol_ptr );
+
+/*  Creates a unit with default values. */
+int  kr_makeDefaultUnit( void );
+
+
+/*  Copy a given unit, according to the copy mode
+        1. copy unit (with it sites, if available) and input/output links
+        2. copy unit (with it sites, if available) and input links
+        3. copy unit (with it sites, if available) and output links
+        4. copy unit (with it sites, if available) but no input/output links
+
+    Returns the unit number of the new unit or error message < 0 , if errors 
+    occured. Function has no effect on the current unit.
+    NOTE: Copying of output links is slow.
+      If return code < 0, an error occured.*/
+krui_err  kr_copyUnit( int  copy_mode, int  source_unit );
+
+/*  Sets the topologic type of the unit. */
+krui_err  kr_unitSetTType( int  unit_no, int  UnitTType );
+
+
+/*  changes all units in the network with the given functionality type
+    to the new functions of the (new) functionality type */
+void kr_changeFtypeUnits( struct  FtypeUnitStruct  *Ftype_entry );
+
+/*   delete the functionality type of the units with the given type */
+void kr_deleteUnitsFtype( struct  FtypeUnitStruct  *ftype_ptr );
+
+/*  create a new unit with the given functionality type */
+int  kr_makeFtypeUnit( char  *Ftype_symbol );
+
+/*  returns TRUE, if there exists the given site at the given ftype entry */
+bool kr_FtypeSiteSearch( struct  Site  *ftype_first_site, 
+			struct  SiteTable  *site_table_ptr );
+
+/*  change the properties of the given unit to the properties of the
+    given F-Type */
+void kr_changeFtypeUnit( struct  Unit  *unit_ptr, 
+			struct  FtypeUnitStruct  *ftype_ptr );
+
+/*  change a site at the F-Type */
+void kr_changeFtypeSites( struct  FtypeUnitStruct  *Ftype_entry, 
+                          struct  SiteTable  *old_site_table,
+                          struct  SiteTable  *new_site_table );
+
+/*  spell checker  (check identifiers for matching [A-Za-z]^[|, ]*) */
+bool kr_symbolCheck( char    *symbol );
+
+/*  translate unit flags to the topological type of the unit */
+int kr_flags2TType( int  flags );
+
+/*  translate the topological type to unit flags */
+int kr_TType2Flags( int  ttype );
+
+/*  update the outputs of all units in the network */
+void kr_updateUnitOutputs( void );
+
+/*  returns the no. of units of the specified topologic type
+    (i.e. Input, Hidden, Output or Special units) */
+int kr_getNoOfUnits( int  UnitTType );
+
+/*  returns the no. of special units of the specified topologic type
+    (i.e. Input, Hidden, Output or Special units) */
+int kr_getNoOfSpecialUnits( int  UnitTType );
+
+/*  force unit array garbage collection */
+void  kr_forceUnitGC( void );
+
+
+/*#################################################
+
+GROUP: Topological Sorting Functions
+
+#################################################*/
+
+
+/*  Sort units according to the given mode:
+    TOPOLOGICAL:
+      Sort units topological (general version) and stores the
+      pointers to this units in the topologic array.
+      NOTE: Units are not sorted by their topologic type (that's not
+	    possible in general case).
+
+    TOPOLOGICAL_FF:
+      Sorts unit topological in feed-forward networks and stores the
+      pointers to this units in the topologic array in the following order:
+       - input,
+       - hidden and
+       - output units
+
+      This function make following assumtions (like all learning functions for
+      feed-forward networks):
+       a) input units doesn't have input connections to other units and
+       b) output units doesn't have outputs connections to other units.
+
+    TOPOLOGIC_TYPE:
+      Sort units by their topologic type, i.e. Input, Hidden, Output units and
+      stores the pointers to this units in the topologic array. */
+krui_err kr_topoSort( int sort_mode );
+
+
+/*  Checks the topology of the network:
+     a) counts the number of layers of the network and
+     b) determines if the network has cycles.
+    Returns the no. of layers of the network. */
+int kr_topoCheck( void );
+
+/*  Count the no. of input and output units and return an error code
+    if the no. do not fit to the loaded patterns. */
+krui_err  kr_IOCheck( void );
+
+krui_err  kr_makeUnitPermutation( void );
+
+
+/*#################################################
+
+GROUP: Other functions
+
+#################################################*/
+
+
+/*  Add random uniform distributed values to connection weights.
+    <minus> must be less then <plus>. */
+void kr_jogWeights( FlintTypeParam  minus, FlintTypeParam  plus );
+krui_err kr_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus, 
+			   FlintTypeParam mincorr);
+
+/*  calls a network function */
+krui_err  kr_callNetworkFunction( int  type, float  *parameterInArray, 
+				 int  NoOfInParams, float * *parameterOutArray,
+				 int  *NoOfOutParams,
+				 int  start_pattern, int  end_pattern );
+
+/*  Returns information about the unit default settings. */
+void kr_getUnitDefaults( FlintType  *act, FlintType  *bias, int	 *ttflags, 
+			int  *subnet_no, int  *layer_no, 
+			char * *act_func, char * *out_func );
+
+/*  Changes the unit default settings. */
+krui_err kr_setUnitDefaults( FlintTypeParam  act, FlintTypeParam  bias, 
+			    int  ttflags, int  subnet_no, int  layer_no, 
+			    char  *act_func_ptr, char  *out_func_ptr );
+
+/* for the network-analyzer tool
+*/
+float kr_NA_Error(int currentPattern, int error_unit, int error, bool ave);
+
+/*#################################################
+
+GROUP: Global Var's
+
+#################################################*/
+
+bool	NetModified = FALSE,   /* TRUE, if the network topology was modified */
+        NetInitialize = TRUE,  /* TRUE, if the network has been initialized  */
+        LearnFuncHasChanged = TRUE;  /* TRUE, if the learning func changed  */
+
+FlagWord  DefaultSType   = DEF_STYPE;  /*  default topological type	*/
+
+int  NoOfUnits	 = 0,    /*  no. of units in the network  */
+     MinUnitNo	 = 0,    /*  the first (lowest) used unit no. in the network */
+     MaxUnitNo	 = 0,	 /*  the last (highest) used unit no. in the network */
+     NoOfInputUnits   = 0,	/*  no. of input units	*/
+     NoOfOutputUnits  = 0,      /*  no. of output units  */
+     NoOfHiddenUnits  = 0,	/*  no. of hidden units  */
+     TopoSortID       = NOT_SORTED;  /*  topologic mode identifier  */
+
+UnitArray     unit_array       = NULL;  /* the unit array  */
+
+TopoPtrArray  topo_ptr_array   = NULL;  /* pointers to topological sorted units
+					   used by kr_topoSort()  */
+
+int  no_of_topo_units = 0;  /*  no. of unit pointers in the topo_ptr_array  */
+
+
+
+/*  Kernel Interface Error Code */
+krui_err  KernelErrorCode = KRERR_NO_ERROR;
+
+/*  File I/O: Line number of the network file. */
+int  lineno = 0;
+
+/*  Stores the error codes and messages of the
+    topologic sorting and network checking
+    functions. */
+struct TopologicMessages  topo_msg;
+
+
+/*  Pointers and numbers for storing the current unit, site or link.
+    Used by unit/site/link searching routines. */
+struct Unit  *unitPtr = NULL;
+struct Site  *sitePtr = NULL,
+	     *prevSitePtr = NULL;
+struct Link  *linkPtr = NULL,
+	     *prevLinkPtr = NULL;
+int  unitNo = 0;
+
+
+int   specialNetworkType = NET_TYPE_GENERAL; /* topologic type of a network  */
+
+float MinimumError = 1000000;     /* best recognition rate */
+float Temperature;                /* temperature for Simulated Annealing */
+
+#ifdef MASPAR_KERNEL
+
+/*#################################################
+
+GROUP:  Global var's of the parallel MasPar kernel
+
+#################################################*/
+
+int   masParStatus = MASPAR_DISCONNECT;   /*  holds the status of the MasPar */
+
+/* stores the topologic description of a feedforward network */
+struct FFnetDescriptor  descrFFnet,
+                        descrFFnetIO;
+
+#endif
+
+/*#################################################
+
+GROUP:  3D-Functions
+
+#################################################*/
+
+krui_err  kr_xyTransTable(int op, int *x, int *y, int z);
+
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/*#################################################
+
+GROUP: Local Vars
+
+#################################################*/
+
+/*  topological sorting: global pointer to the topologic array
+    (reduces memory consumption in the recursive depth search routine) */
+static TopoPtrArray	global_topo_ptr;
+
+static int  DefaultSubnetNo  = DEF_SUBNET_NO,	 /*  default subnet no.  */
+            DefaultLayerNo   = DEF_LAYER_NO,	 /*  default layer no.	*/
+            DefaultPosX      = DEF_POS_X,	 /*  default x-position  */
+            DefaultPosY      = DEF_POS_Y;	 /*  default y-position  */
+
+static int  DefaultPosZ = DEF_POS_Z;	 /*  default z-position  */
+
+
+static FlintType
+     DefaultIAct      = DEF_I_ACT,	 /*  default initial activation  */
+     DefaultBias      = DEF_BIAS;	 /*  default bias */
+
+
+static OutFuncPtr  DefaultUFuncOut  = NULL; /*  default output function     */
+static ActFuncPtr  DefaultUFuncAct  = NULL; /*  default activation function */
+
+/*  default derivation act. function  */
+static ActDerivFuncPtr	DefaultUFuncActDeriv = NULL;
+
+/*  default second derivation act. function  */
+static ActDerivFuncPtr	DefaultUFuncAct2Deriv = NULL;
+
+
+struct TransTable  *transTable = NULL;
+int transTableSize = 0;
+
+
+
+
+/*#################################################
+
+GROUP: Macros
+
+#################################################*/
+
+
+
+/*#################################################
+
+GROUP: Functions 
+
+#################################################*/
+
+/* count units according to their topological type */
+static void  kr_countUnits(struct Unit *unit_ptr, int mode);
+
+/*  */
+static int  kr_searchOutputConnection(struct Unit *start_unit_ptr, 
+				      struct Unit *source_unit_ptr, 
+				      FlintType *weight);
+
+/* Copies all output links at <source_unit> to <new_unit>. */
+static krui_err  kr_copyOutputLinks(struct Unit *source_unit_ptr, 
+				    struct Unit *new_unit_ptr);
+
+/* Copy all input links from <source_unit> to <new_unit> */
+static krui_err  kr_copyInputLinks(struct Unit *source_unit_ptr, 
+				   struct Unit *new_unit_ptr);
+
+/* copy the source unit with sites, but no links */
+static krui_err kr_copyUnitFrame(struct Unit *source_unit_ptr, 
+				 struct Unit *new_unit_ptr);
+
+/* calculate correlated hidden units */
+static krui_err kr_getCorrelatedHiddens(struct Unit **hn1, struct Unit **hn2, 
+					double *res_corr);
+
+/*  calls the current network function */
+static krui_err  kr_callNetworkFunctionSTD(int type, float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray, 
+					   int *NoOfOutParams, 
+					   int start_pattern, int end_pattern);
+
+
+/* end private definition section */
+
+#endif  /* _KERNEL_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/kr_amap.c snort-2.3.3.new/src/kernel_snns/kr_amap.c
--- snort-2.3.3/src/kernel_snns/kr_amap.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_amap.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,6172 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_amap.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Functions for ARTMAP networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:33 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+
+
+
+#ifndef NULL /* if NULL pointer is not defined include stdio.h */
+#include <stdio.h>
+#endif
+
+#include <string.h>
+
+#include "kr_const.h"
+#include "kr_mac.h"
+#include "kr_def.h"
+#include "kr_typ.h"
+#include "kr_funcs.h"
+#include "kernel.h"
+#include "glob_typ.h"
+#include "kr_art.h"     /*  Function prototypes for ART networks */
+#include "krart_df.h"   /*  Definitions for ART networks */
+#include "kr_amap.ph"
+
+
+
+/*#################################################
+
+GROUP: ARTMAP kernel functions
+       by Kai-Uwe Herrmann
+
+#################################################*/
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err kram_init_i_act (double rhoa, double rhob, double rho)
+{
+   int                    ret_code = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      switch (unit_ptr->lln) {
+
+      case ARTMAP_SPECa_LAY:
+         switch (unit_ptr->lun) {
+         case ARTMAP_G1a_UNIT :
+            unit_ptr->i_act = 0.0;
+            break;
+         case ARTMAP_RIa_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ARTMAP_RGa_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ARTMAP_RHOa_UNIT :
+            unit_ptr->i_act = (FlintType) rhoa;
+            break;
+         default :
+            unit_ptr->i_act = 0.0;
+            break;
+         } /*switch*/
+         break;
+
+      case ARTMAP_SPECb_LAY:
+         switch (unit_ptr->lun) {
+         case ARTMAP_G1b_UNIT :
+            unit_ptr->i_act = 0.0;
+            break;
+         case ARTMAP_RIb_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ARTMAP_RGb_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ARTMAP_RHOb_UNIT :
+            unit_ptr->i_act = (FlintType) rhob;
+            break;
+         default :
+            unit_ptr->i_act = 0.0;
+            break;
+         } /*switch*/
+         break;
+
+      case ARTMAP_SPEC_LAY:
+         switch (unit_ptr->lun) {
+         case ARTMAP_G_UNIT:
+            unit_ptr->i_act = 1.0;
+            break;
+         case ARTMAP_RHO_UNIT:
+            unit_ptr->i_act = (FlintType) rho;
+            break;
+         default:
+            unit_ptr->i_act = 0.0;
+            break;
+         } /*switch*/
+         break;
+
+      default :
+         unit_ptr->i_act = 0.0;
+         break;
+      } /*switch*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+} /* kram_init_i_act () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err  kram_sort (void)
+{
+   krui_err             ret_code    = KRERR_NO_ERROR;
+
+   TopoPtrArray         topo_ptr = topo_ptr_array;
+
+   int                  no_of_cmpa_units  = 0;
+   int                  no_of_dela_units  = 0;
+   int                  no_of_rsta_units  = 0;
+   int                  no_of_speca_units = 0;
+   int                  no_of_cmpb_units  = 0;
+   int                  no_of_delb_units  = 0;
+   int                  no_of_rstb_units  = 0;
+   int                  no_of_specb_units = 0;
+   int                  no_of_map_units   = 0;
+   int                  no_of_spec_units  = 0;
+
+
+
+   /* initialize ARTMAP sorting
+   */
+   krart_init_sorting ();
+
+   /* get no of input units
+   */
+   NoOfInputUnits = krart_get_NoOfInputUnits ();
+
+   if (NoOfInputUnits == 0) {
+      ret_code = KRERR_NO_INPUT_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   /* insert the initial NULL-ptr into the topo ptr array
+   */
+   *topo_ptr++ = NULL;
+
+   /**********  determine unit types for ARTa and insert them into topo ptr array
+   **********/
+
+   /* determine input units of ARTa
+   */
+   ret_code = kram_get_InpUnits_a (&topo_ptr, &ArtMap_NoOfInpUnits_a);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (ArtMap_NoOfInpUnits_a == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa input");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine comparison units of ARTa
+   */
+   ret_code = kram_get_CmpUnits_a (&topo_ptr, &no_of_cmpa_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_cmpa_units != ArtMap_NoOfInpUnits_a) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa comparison");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine recognition units of ARTa
+   */
+   ret_code = kram_get_RecUnits_a (&topo_ptr, &ArtMap_NoOfRecUnits_a);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (ArtMap_NoOfRecUnits_a == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa recognition");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine delay units of ARTa
+   */
+   ret_code = kram_get_DelUnits_a (&topo_ptr, &no_of_dela_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_dela_units != ArtMap_NoOfRecUnits_a + 3) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa delay");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine local reset units of ARTa
+   */
+   ret_code = kram_get_RstUnits_a (&topo_ptr, &no_of_rsta_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_rsta_units != ArtMap_NoOfRecUnits_a) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa reset");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine special units of ARTa
+   */
+   ret_code = kram_get_SpecUnits_a (&topo_ptr, &no_of_speca_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_speca_units != ARTMAP_NO_OF_SPECa_UNITS) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTa special");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /**********  determine unit types for ARTb  and insert them into topo ptr array
+   **********/
+
+   /* determine input units of ARTb
+   */
+   ret_code = kram_get_InpUnits_b (&topo_ptr, &ArtMap_NoOfInpUnits_b);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (ArtMap_NoOfInpUnits_b == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb input");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine comparison units of ARTb
+   */
+   ret_code = kram_get_CmpUnits_b (&topo_ptr, &no_of_cmpb_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_cmpb_units != ArtMap_NoOfInpUnits_b) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb comparison");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+
+   /* determine recognition units of ARTb
+   */
+   ret_code = kram_get_RecUnits_b (&topo_ptr, &ArtMap_NoOfRecUnits_b);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (ArtMap_NoOfRecUnits_b == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb recognition");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine delay units of ARTb
+   */
+   ret_code = kram_get_DelUnits_b (&topo_ptr, &no_of_delb_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_delb_units != ArtMap_NoOfRecUnits_b + 3) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb delay");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine local reset units of ARTb
+   */
+   ret_code = kram_get_RstUnits_b (&topo_ptr, &no_of_rstb_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_rstb_units != ArtMap_NoOfRecUnits_b) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb reset");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine special units of ARTb
+   */
+   ret_code = kram_get_SpecUnits_b (&topo_ptr, &no_of_specb_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_specb_units != ARTMAP_NO_OF_SPECb_UNITS) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("ARTb special");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+
+   /**********  determine unit types for MAP-Field and insert them into topo ptr array
+   **********/
+
+   /* determine map units
+   */
+   ArtMap_map_layer = topo_ptr;
+   ret_code = kram_get_MapUnits (&topo_ptr,&no_of_map_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_map_units != ArtMap_NoOfRecUnits_b) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("map");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine special units
+   */
+   ret_code = kram_get_SpecUnits (&topo_ptr, &no_of_spec_units);;
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_spec_units != 10) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("Map Field special");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+   *topo_ptr   = NULL;  /* set second NULL pointer at the end */
+
+
+
+
+
+
+
+   /* check if the logical type of really all units is determined
+   */
+   if (krart_check_undeterminedUnits ()) {
+      ret_code = topo_msg.error_code;
+      return (ret_code);
+   } /*if*/
+
+
+   /* Now check the topo ptr array
+   */
+   ret_code = kram_TopoPtrArray ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check the sites
+   */
+
+   ret_code = kram_Sites ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check link structure
+   */
+
+   topo_ptr = topo_ptr_array + 1;
+
+   /* Check links of inpa units
+   */
+   ret_code = kram_LinksToInpUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of cmpa units
+   */
+   ret_code = kram_LinksToCmpUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of reca units
+   */
+   ret_code = kram_LinksToRecUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of dela units and d1a, d2a, d3a
+   */
+   ret_code = kram_LinksToDelUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of rsta units
+   */
+   ret_code = kram_LinksToRstUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of special units of ARTa
+   */
+   ret_code = kram_LinksToSpecUnits_a (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of inpb units
+   */
+   ret_code = kram_LinksToInpUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of cmpb units
+   */
+   ret_code = kram_LinksToCmpUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of recb units
+   */
+   ret_code = kram_LinksToRecUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of delb units and d1b, d2b, d3b
+   */
+   ret_code = kram_LinksToDelUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of rstb units
+   */
+   ret_code = kram_LinksToRstUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of special units of ARTb
+   */
+   ret_code = kram_LinksToSpecUnits_b (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of map units
+   */
+   ret_code = kram_LinksToMapUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of special units of MAPFIELD
+   */
+   ret_code = kram_LinksToSpecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+
+
+   /* initialize the fix weights of ARTMAP
+   */
+
+   ret_code = kram_init_fix_weights ();
+
+   return (ret_code);
+
+} /* kram_sort () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+int   kram_getClassNo (void)
+{
+    TopoPtrArray   topo_ptr = ArtMap_map_layer;
+    int            i;
+
+    /* if ARTMAP sorting wasn't performed then return negative value
+       to indicate mistake
+    */
+    if (topo_ptr == NULL) {
+       return (-1);
+    } /*if*/
+
+    /* look for winning unit */
+    for (i = 1; (i <= ArtMap_NoOfRecUnits_b) || ((*topo_ptr)->act >= 0.9);
+         i++, topo_ptr++
+        );
+
+    if ((i > ArtMap_NoOfRecUnits_b) && ((*topo_ptr)->act < 0.9)) {
+       return (-1);
+    } else {
+       return (topo_ptr - ArtMap_map_layer + 1);
+    } /*if*/
+
+} /* kram_getClassNo () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kram_AllMapUnitsActive (void)
+{
+    TopoPtrArray   topo_ptr = ArtMap_map_layer;
+
+    if (topo_ptr == NULL) {
+       return (FALSE);
+    } /*if*/
+
+    while (*topo_ptr != NULL) {
+       if ((*topo_ptr)->act < 0.9) {
+          return (FALSE);
+       } /*if*/
+    } /*while*/
+
+    return (TRUE);
+
+} /* kram_AllMapUnitsActive () */
+/*___________________________________________________________________________*/
+
+
+
+/************* functions to determine units of ARTa
+*************/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_InpUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                   ret_code = KRERR_NO_ERROR;
+
+   register struct Unit       *unit_src_ptr, *unit_trg_ptr;
+   register struct Site       *site_trg_ptr;
+   register struct Link       *link_trg_ptr;
+
+   int                        count_links;
+
+   /* for the inpa units it is characteristical that they have got 5
+      links to other units while the ones of ARTb just have 4
+   */
+
+   *no_of_units = 0;
+   FOR_ALL_UNITS (unit_src_ptr) {
+
+      if (IS_INPUT_UNIT (unit_src_ptr)) {
+
+         if (UNIT_HAS_INPUTS (unit_src_ptr)) {
+            topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+            topo_msg.dest_error_unit = unit_src_ptr-unit_array;
+            topo_msg.src_error_unit = 0;
+            return (topo_msg.error_code);
+         } /*if*/
+
+         count_links = 0;
+
+         FOR_ALL_UNITS (unit_trg_ptr) {
+
+            if (UNIT_HAS_SITES (unit_trg_ptr)) {
+               FOR_ALL_SITES_AND_LINKS (unit_trg_ptr, site_trg_ptr, link_trg_ptr) {
+                  if (link_trg_ptr->to == unit_src_ptr) {
+                     count_links++;
+                  } /*if*/
+               } /*FOR_ALL_SITES_AND_LINKS*/
+            } else {
+               FOR_ALL_LINKS (unit_trg_ptr, link_trg_ptr) {
+                  if (link_trg_ptr->to == unit_src_ptr) {
+                     count_links++;
+                  } /*if*/
+               } /*FOR_ALL_LINKS*/
+            } /*if*/
+
+         } /*FOR_ALL_UNITS*/
+
+         if (count_links == 5) {
+
+            if (!(CHECK_ACT_FUNC (unit_src_ptr, ARTMAP_ACTF_INPa))) {
+               TOPO_MSG_ACT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_src_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            (*no_of_units)++;
+            **topo_ptr = unit_src_ptr;
+            unit_src_ptr->lln = ARTMAP_INPa_LAY;
+            (*topo_ptr)++;
+            unit_src_ptr->flags |= UFLAG_REFRESH;
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_InpUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_CmpUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   struct Unit              *unit_src_ptr;
+   register struct Link     *link_ptr;
+   struct Link              *link_src_ptr;
+
+   bool                     is_cmpa_unit;
+   bool                     has_link_to_inpa;
+   bool                     has_link_to_other_than_inpa;
+
+
+   *no_of_units = 0;
+
+   /* look for a reca unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!IS_SPECIAL_UNIT (unit_ptr)) {
+         /* we can continue the search, 'cause reca units have got
+            ttype special
+         */
+         continue;
+      } /*if*/
+
+      /* the recognition unit is not supposed to have sites
+      */
+      if (UNIT_HAS_SITES (unit_ptr)) {
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+      } /*if*/
+
+
+      /* unit_ptr points to a recogniton unit.
+         we follow the incoming links of this unit. if the source unit we
+         got by doing this has the following properties, this is a comparison
+         unit of ARTa
+                - has no sites
+                - has incoming link from inpa unit
+                - has incoming link from other than inpa unit
+      */
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+         unit_src_ptr = link_ptr->to;
+
+         is_cmpa_unit                 = FALSE;
+         has_link_to_inpa             = FALSE;
+         has_link_to_other_than_inpa  = FALSE;
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_src_ptr)) {
+
+            FOR_ALL_LINKS (unit_src_ptr, link_src_ptr) {
+
+               if (link_src_ptr->to->lln == ARTMAP_INPa_LAY) {
+                  has_link_to_inpa = TRUE;
+               } else {
+                  has_link_to_other_than_inpa = TRUE;
+               } /*if*/
+
+               if (has_link_to_inpa && has_link_to_other_than_inpa) {
+                  is_cmpa_unit = TRUE;
+                  break;
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+         } /*if*/
+
+         if (is_cmpa_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_src_ptr, ARTMAP_ACTF_CMPa))) {
+               TOPO_MSG_ACT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_src_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            unit_src_ptr->lln = ARTMAP_CMPa_LAY;
+            (*no_of_units)++;
+            **topo_ptr = unit_src_ptr;
+            unit_src_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+
+         } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+      if (*no_of_units > 0) {
+         /* stop searching for reca unit */
+         break;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_CmpUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_RecUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                   ret_code   = KRERR_NO_ERROR;
+
+   register struct Unit       *unit_ptr;
+   register struct Link       *link_ptr;
+
+   bool                       is_reca_unit;
+
+
+   *no_of_units = 0;
+
+   /* properties of reca units:
+          - has no sites
+          - has incoming links from cmpa units
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_SPECIAL_UNIT (unit_ptr)) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } /*if*/
+
+         is_reca_unit = FALSE;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if (link_ptr->to->lln == ARTMAP_CMPa_LAY) {
+               is_reca_unit = TRUE;
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (is_reca_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RECa))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_RECa_LAY;
+            **topo_ptr = unit_ptr;
+            (*no_of_units)++;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+    } /*FOR_ALL_UNITS*/
+
+    return (ret_code);
+
+} /* kram_get_RecUnits_a */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_DelUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code      = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+   struct Link              *this_link = NULL;
+
+   int                      count_links;
+   int                      no_of_dela_units = 0;
+   bool                     got_d1a_unit     = FALSE;
+   bool                     got_d2a_unit     = FALSE;
+   bool                     got_d3a_unit     = FALSE;
+
+
+   *no_of_units = 0;
+
+   /* the dela units each have got just one incoming link from their
+      corresponding reca unit. They don't have sites.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ((! (UNIT_REFRESHED (unit_ptr))) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         count_links = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            count_links++;
+            this_link = link_ptr;
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_links == 1) && (this_link->to->lln == ARTMAP_RECa_LAY)) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_DELa))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_DELa_LAY;
+            unit_ptr->lun = ARTMAP_DELa_REC_UNIT;
+            no_of_dela_units++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   /* now we are looking for d1a which has to have links to all dela units
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         count_links = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                (link_ptr->to->lun == ARTMAP_DELa_REC_UNIT))
+            {
+               count_links ++;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (count_links == no_of_dela_units) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Da))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_DELa_LAY;
+            unit_ptr->lun = ARTMAP_D1a_UNIT;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            got_d1a_unit = TRUE;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+            /* Now we can break the search, 'cause we got the d1a unit */
+            break;
+
+         } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d1a_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: d1 (=d1a)");
+   } /*if*/
+
+
+   /* Now we are looking for the d2a unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                (link_ptr->to->lun == ARTMAP_D1a_UNIT)
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Da))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_DELa_LAY;
+               unit_ptr->lun = ARTMAP_D2a_UNIT;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               got_d2a_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+
+               /* we can break the search for the d2a unit */
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d2a_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: d2 (=d2a)");
+   } /*if*/
+
+
+   /* Now we are looking for the d3a unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                (link_ptr->to->lun == ARTMAP_D2a_UNIT)
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Da))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_DELa_LAY;
+               unit_ptr->lun = ARTMAP_D3a_UNIT;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               got_d3a_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+
+               /* we can break the search for the d3a unit */
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d3a_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: d3 (=d3a)");
+   } /*if*/
+
+   *no_of_units = no_of_dela_units + 3;
+
+   return (ret_code);
+
+} /* kram_get_DelUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_RstUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code   = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Site     *site_ptr;
+   register struct Link     *link_ptr;
+
+   bool                     has_link_to_itself,
+                            has_link_to_dela_unit;
+
+   /* each rsta unit has got sites, a link to itself, one from a dela unit
+      and one from the rga unit which wasn't determined yet.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_SITES (unit_ptr))) {
+
+         has_link_to_itself = FALSE;
+         has_link_to_dela_unit = FALSE;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            if (link_ptr->to == unit_ptr) {
+               has_link_to_itself = TRUE;
+            } /*if*/
+
+            if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                (link_ptr->to->lun == ARTMAP_DELa_REC_UNIT)
+               )
+            {
+               has_link_to_dela_unit = TRUE;
+            } /*if*/
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if (has_link_to_itself && has_link_to_dela_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RSTa))) {
+                TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                 TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_RSTa_LAY;
+            (*no_of_units)++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_RstUnits_a () */
+/*___________________________________________________________________________*/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_SpecUnits_a (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Site     *site_ptr;
+   register struct Link     *link_ptr;
+
+   TopoPtrArray             topo_spec_ptr = *topo_ptr;
+
+   bool                     got_g1a_unit    = FALSE;
+   bool                     got_ria_unit    = FALSE;
+   bool                     got_rca_unit    = FALSE;
+   bool                     got_rga_unit    = FALSE;
+   bool                     got_cla_unit    = FALSE;
+   bool                     got_nca_unit    = FALSE;
+   bool                     got_rhoa_unit   = FALSE;
+   bool                     got_g2a_unit    = FALSE;
+
+   bool                     links_to_rsta_units,
+                            links_to_d3a_unit,
+                            links_to_reca_units,
+                            links_to_cmpa_units,
+                            links_to_inpa_units;
+
+
+   *no_of_units = 0;
+
+   /* looking for special units of ARTa */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ( (!(UNIT_REFRESHED (unit_ptr))) &&
+           (!got_g1a_unit || !got_ria_unit || !got_rca_unit ||
+            !got_cla_unit || !got_nca_unit || !got_g2a_unit
+           )
+         )
+      {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+
+
+            /* if a unit with sites does have links from inpa units
+               and reca units this can only be the g1a unit
+            */
+            links_to_reca_units = FALSE;
+            links_to_inpa_units = FALSE;
+            links_to_cmpa_units = FALSE;
+
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ARTMAP_RECa_LAY:
+                  links_to_reca_units = TRUE;
+                  break;
+               case ARTMAP_INPa_LAY:
+                  links_to_inpa_units = TRUE;
+                  break;
+               case ARTMAP_CMPa_LAY:
+                  links_to_cmpa_units = TRUE;
+                  break;
+               } /*switch*/
+
+               if ((links_to_reca_units && links_to_inpa_units) ||
+                   (links_to_reca_units && !links_to_cmpa_units)
+                  )
+               {
+                  /* we found the g1a or the ria unit */
+                  break;
+               } /*if*/
+
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+            if (links_to_reca_units && links_to_inpa_units) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_G1a))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECa_LAY;
+               unit_ptr->lun = ARTMAP_G1a_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 2) = unit_ptr;
+               got_g1a_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               (*topo_ptr)++;
+
+            } else {
+
+               if (links_to_inpa_units && !links_to_cmpa_units) {
+
+                  /* if there are links to the inpa units but none to the
+                     reca units then we found the ria unit
+                  */
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RIa))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  unit_ptr->lln = ARTMAP_SPECa_LAY;
+                  unit_ptr->lun = ARTMAP_RIa_UNIT;
+                  (*no_of_units)++;
+                  *(topo_spec_ptr + 3) = unit_ptr;
+                  got_ria_unit = TRUE;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+
+               } /*if*/
+
+            } /*if*/
+
+         } else {
+
+            /* unit has direct inputs */
+
+            links_to_rsta_units = FALSE;
+            links_to_d3a_unit   = FALSE;
+            links_to_cmpa_units = FALSE;
+            links_to_inpa_units = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ARTMAP_INPa_LAY:
+                  links_to_inpa_units = TRUE;
+                  break;
+               case ARTMAP_CMPa_LAY:
+                  links_to_cmpa_units = TRUE;
+                  break;
+               case ARTMAP_DELa_LAY:
+                  if (link_ptr->to->lun == ARTMAP_D3a_UNIT) {
+                     links_to_d3a_unit = TRUE;
+                  } /*if*/
+                  break;
+                case ARTMAP_RSTa_LAY:
+                   links_to_rsta_units = TRUE;
+                   break;
+                } /*switch*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (links_to_inpa_units && !got_g2a_unit) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_G2a))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECa_LAY;
+               unit_ptr->lun = ARTMAP_G2a_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 7) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_g2a_unit = TRUE;
+               continue;
+            } /*if*/
+
+
+            if (links_to_cmpa_units && !links_to_inpa_units &&
+                !got_rca_unit
+               )
+            {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RCa))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECa_LAY;
+               unit_ptr->lun = ARTMAP_RCa_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 4) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_rca_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+
+            if (links_to_d3a_unit && !got_cla_unit) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_CLa))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECa_LAY;
+               unit_ptr->lun = ARTMAP_CLa_UNIT;
+               (*no_of_units)++;
+               *topo_spec_ptr = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_cla_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+
+            if (links_to_rsta_units && !links_to_cmpa_units &&
+                !got_nca_unit
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_NCa))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECa_LAY;
+               unit_ptr->lun = ARTMAP_NCa_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 1) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_nca_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   /* the rga and the rhoa unit remain to be determined */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr))) {
+
+         /* looking for rga unit */
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_SPECa_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_RIa_UNIT)
+                  )
+               {
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RGa))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                     TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  /* this is the rga unit */
+                  unit_ptr->lln = ARTMAP_SPECa_LAY;
+                  unit_ptr->lun = ARTMAP_RGa_UNIT;
+                  (*no_of_units)++;
+                  *(topo_spec_ptr + 5) = unit_ptr;
+                  got_rga_unit =TRUE;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+                  break;
+
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+         } /*if*/
+
+      } else {
+
+         /* looking for rhoa unit via ria */
+
+         if ((unit_ptr->lln == ARTMAP_SPECa_LAY) &&
+             (unit_ptr->lun == ARTMAP_RIa_UNIT)
+            )
+         {
+             FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+                if (link_ptr->to->lln != ARTMAP_INPa_LAY) {
+
+                   if (!(CHECK_ACT_FUNC (link_ptr->to, ARTMAP_ACTF_RHOa))) {
+                      TOPO_MSG_ACT_FUNC (link_ptr->to);
+                   } /*if*/
+
+                   if (!(CHECK_OUT_FUNC (link_ptr->to, ARTMAP_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (link_ptr->to);
+                   } /*if*/
+
+                   /* the link_ptr->to unit is the rhoa unit */
+
+                   link_ptr->to->lln = ARTMAP_SPECa_LAY;
+                   link_ptr->to->lun = ARTMAP_RHOa_UNIT;
+                   (*no_of_units)++;
+                   *(topo_spec_ptr + 6) = link_ptr->to;
+                   (*topo_ptr)++;
+                   got_rhoa_unit = TRUE;
+                   link_ptr->to->flags |= UFLAG_REFRESH;
+                   break;
+
+                } /*if*/
+
+             } /*FOR_ALL_SITES_AND_LINKS*/
+
+          } /*if*/
+
+       } /*if*/
+
+       if (got_rga_unit && got_rhoa_unit) {
+          break;
+       } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_cla_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: cl (=cla)");
+   } /*if*/
+
+   if (!got_nca_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: nc (=nca)");
+   } /*if*/
+
+   if (!got_ria_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: ri (=ria)");
+   } /*if*/
+
+   if (!got_rca_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: rc (=rca)");
+   } /*if*/
+
+   if (!got_rga_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: rg (=rga)");
+   } /*if*/
+
+   if (!got_g1a_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: g1 (=g1a)");
+   } /*if*/
+
+   if (!got_rhoa_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: rho (=rhoa)");
+   } /*if*/
+
+   if (!got_g2a_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTa: g2 (=g2a)");
+   } /*if*/
+
+
+   return (ret_code);
+
+} /* kram_get_SpecUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*************** functions to determine units of ARTb
+***************/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_InpUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                   ret_code = KRERR_NO_ERROR;
+
+   register struct Unit       *unit_src_ptr, *unit_trg_ptr;
+   register struct Site       *site_trg_ptr;
+   register struct Link       *link_trg_ptr;
+
+   int                        count_links;
+
+   /* for the inpb units it is characteristical that they have got 2
+      links to other units while the ones of ARTa have 3
+   */
+
+   *no_of_units = 0;
+   FOR_ALL_UNITS (unit_src_ptr) {
+
+      if (IS_INPUT_UNIT (unit_src_ptr)) {
+
+         if (UNIT_HAS_INPUTS (unit_src_ptr)) {
+            topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+            topo_msg.dest_error_unit = unit_src_ptr-unit_array;
+            topo_msg.src_error_unit = 0;
+            return (topo_msg.error_code);
+         } /*if*/
+
+         count_links = 0;
+
+         FOR_ALL_UNITS (unit_trg_ptr) {
+
+            if (UNIT_HAS_SITES (unit_trg_ptr)) {
+               FOR_ALL_SITES_AND_LINKS (unit_trg_ptr, site_trg_ptr, link_trg_ptr) {
+                  if (link_trg_ptr->to == unit_src_ptr) {
+                     count_links++;
+                  } /*if*/
+               } /*FOR_ALL_SITES_AND_LINKS*/
+            } else {
+               FOR_ALL_LINKS (unit_trg_ptr, link_trg_ptr) {
+                  if (link_trg_ptr->to == unit_src_ptr) {
+                     count_links++;
+                  } /*if*/
+               } /*FOR_ALL_LINKS*/
+            } /*if*/
+
+         } /*FOR_ALL_UNITS*/
+
+         if (count_links == 4) {
+
+            if (!(CHECK_ACT_FUNC (unit_src_ptr, ARTMAP_ACTF_INPb))) {
+               TOPO_MSG_ACT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_src_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            (*no_of_units)++;
+            **topo_ptr = unit_src_ptr;
+            unit_src_ptr->lln = ARTMAP_INPb_LAY;
+            (*topo_ptr)++;
+            unit_src_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_InpUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_CmpUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   struct Unit              *unit_src_ptr;
+   register struct Link     *link_ptr;
+   struct Link              *link_src_ptr;
+
+   bool                     is_cmpb_unit;
+   bool                     has_link_to_inpb;
+   bool                     has_link_to_other_than_inpb;
+
+
+   *no_of_units = 0;
+
+   /* look for a recb unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!IS_SPECIAL_UNIT (unit_ptr)) {
+         continue;
+      } /*if*/
+
+      /* the recognition unit is not supposed to have sites
+      */
+      if (UNIT_HAS_SITES (unit_ptr)) {
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+      } /*if*/
+
+
+      /* unit_ptr points to a recogniton unit.
+         we follow the incoming links of this unit. if the source unit we
+         got by doing this has the following properties, this is a comparison
+         unit of ARTb
+                - has no sites
+                - has incoming link from inpb unit
+      */
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+         unit_src_ptr = link_ptr->to;
+
+         is_cmpb_unit                = FALSE;
+         has_link_to_inpb            = FALSE;
+         has_link_to_other_than_inpb = FALSE;
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_src_ptr)) {
+
+            FOR_ALL_LINKS (unit_src_ptr, link_src_ptr) {
+
+               if (link_src_ptr->to->lln == ARTMAP_INPb_LAY) {
+                  has_link_to_inpb = TRUE;
+               } else {
+                  has_link_to_other_than_inpb = TRUE;
+               } /*if*/
+
+               if (has_link_to_inpb && has_link_to_other_than_inpb) {
+                  is_cmpb_unit = TRUE;
+                  break;
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+         } /*if*/
+
+         if (is_cmpb_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_src_ptr, ARTMAP_ACTF_CMPb))) {
+               TOPO_MSG_ACT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_src_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_src_ptr);
+            } /*if*/
+
+            unit_src_ptr->lln = ARTMAP_CMPb_LAY;
+            (*no_of_units)++;
+            **topo_ptr = unit_src_ptr;
+            unit_src_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+
+         } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+      if (*no_of_units > 0) {
+         /* stop searching for reca unit */
+         break;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_CmpUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_RecUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                   ret_code   = KRERR_NO_ERROR;
+
+   register struct Unit       *unit_ptr;
+   register struct Link       *link_ptr;
+
+   bool                       is_recb_unit;
+
+
+   *no_of_units = 0;
+
+   /* properties of recb units:
+          - has no sites
+          - has incoming links from cmpb units
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_SPECIAL_UNIT (unit_ptr)) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } /*if*/
+
+         is_recb_unit = FALSE;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if (link_ptr->to->lln == ARTMAP_CMPb_LAY) {
+               is_recb_unit = TRUE;
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (is_recb_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RECb))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_RECb_LAY;
+            **topo_ptr = unit_ptr;
+            (*no_of_units)++;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+    } /*FOR_ALL_UNITS*/
+
+    return (ret_code);
+
+} /* kram_get_RecUnits_b */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_DelUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code      = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_links;
+   int                      no_of_delb_units = 0;
+   bool                     has_link_to_recb_unit;
+   bool                     got_d1b_unit     = FALSE;
+   bool                     got_d2b_unit     = FALSE;
+   bool                     got_d3b_unit     = FALSE;
+
+
+   *no_of_units = 0;
+
+   /* the delb units each have got just two incoming links, one of which
+      is from their corresponding reca unit. They don't have sites.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ((! (UNIT_REFRESHED (unit_ptr))) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         count_links = 0;
+         has_link_to_recb_unit = FALSE;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            count_links++;
+            if (link_ptr->to->lln == ARTMAP_RECb_LAY) {
+               has_link_to_recb_unit = TRUE;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_links == 2) && (has_link_to_recb_unit)) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_DELb))) {
+              TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_DELb_LAY;
+            unit_ptr->lun = ARTMAP_DELb_REC_UNIT;
+            no_of_delb_units++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   /* now we are looking for d1b which has to have links to all delb units
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         count_links = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                (link_ptr->to->lun == ARTMAP_DELb_REC_UNIT))
+            {
+               count_links ++;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (count_links == no_of_delb_units) {
+
+            /* in this case we don't really check the Activation and
+               output function, we use it to detemine the correct unit
+               (d1b) 'cause the d1 unit has the same properties as
+               d1b except its activation function.
+            */
+            if ((CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Db)) &&
+                (CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))
+               )
+            {
+               unit_ptr->lln = ARTMAP_DELb_LAY;
+               unit_ptr->lun = ARTMAP_D1b_UNIT;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               got_d1b_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+
+               /* Now we can break the search, 'cause we got the d1b unit */
+               break;
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d1b_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: d1 (=d1b)");
+   } /*if*/
+
+
+   /* Now we are looking for the d2b unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                (link_ptr->to->lun == ARTMAP_D1b_UNIT)
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Db))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_DELb_LAY;
+               unit_ptr->lun = ARTMAP_D2b_UNIT;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               got_d2b_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+
+               /* we can break the search for the d2b unit */
+               break;
+
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d2b_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: d2 (=d2b)");
+   } /*if*/
+
+
+   /* Now we are looking for the d3b unit */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                (link_ptr->to->lun == ARTMAP_D2b_UNIT)
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_Db))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_DELb_LAY;
+               unit_ptr->lun = ARTMAP_D3b_UNIT;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               got_d3b_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+
+               /* we can break the search for the d3b unit */
+               break;
+
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_d3b_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: d3 (=d3b)");
+   } /*if*/
+
+
+   *no_of_units = no_of_delb_units + 3;
+
+   return (ret_code);
+
+} /* kram_get_DelUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_RstUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                 ret_code   = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Site     *site_ptr;
+   register struct Link     *link_ptr;
+
+   bool                     has_link_to_itself,
+                            has_link_to_delb_unit;
+
+   /* each rstb unit has got sites, a link to itself, one from a delb unit
+      and one from the rgb unit which wasn't determined yet.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_SITES (unit_ptr))) {
+
+         has_link_to_itself = FALSE;
+         has_link_to_delb_unit = FALSE;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            if (link_ptr->to == unit_ptr) {
+               has_link_to_itself = TRUE;
+            } /*if*/
+
+            if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                (link_ptr->to->lun == ARTMAP_DELb_REC_UNIT)
+               )
+            {
+               has_link_to_delb_unit = TRUE;
+            } /*if*/
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if (has_link_to_itself && has_link_to_delb_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RSTb))) {
+                TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                 TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_RSTb_LAY;
+            (*no_of_units)++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_RstUnits_b () */
+/*___________________________________________________________________________*/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_SpecUnits_b (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit     *unit_ptr;
+   register struct Site     *site_ptr;
+   register struct Link     *link_ptr;
+
+   TopoPtrArray             topo_spec_ptr = *topo_ptr;
+
+   bool                     got_g1b_unit    = FALSE;
+   bool                     got_rib_unit    = FALSE;
+   bool                     got_rcb_unit    = FALSE;
+   bool                     got_rgb_unit    = FALSE;
+   bool                     got_clb_unit    = FALSE;
+   bool                     got_ncb_unit    = FALSE;
+   bool                     got_rhob_unit   = FALSE;
+   bool                     got_g2b_unit    = FALSE;
+
+   bool                     links_to_rstb_units,
+                            links_to_d3b_unit,
+                            links_to_recb_units,
+                            links_to_cmpb_units,
+                            links_to_inpb_units;
+
+
+   *no_of_units = 0;
+
+   /* looking for special units of ARTb */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ( (!(UNIT_REFRESHED (unit_ptr))) &&
+           (!got_g1b_unit || !got_rib_unit || !got_rcb_unit ||
+            !got_clb_unit || !got_ncb_unit || !got_g2b_unit
+           )
+         )
+      {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+
+
+            /* if a unit with sites does have links from inpb units
+               and recb units this can only be the g1b unit
+            */
+            links_to_recb_units = FALSE;
+            links_to_inpb_units = FALSE;
+
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+               if (link_ptr->to->lln == ARTMAP_RECb_LAY) {
+                  links_to_recb_units = TRUE;
+               } /*if*/
+
+               if (link_ptr->to->lln == ARTMAP_INPb_LAY) {
+                  links_to_inpb_units = TRUE;
+               } /*if*/
+
+               if (links_to_inpb_units) {
+                  /* we found the g1b unit */
+                  break;
+               } /*if*/
+
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+            if (links_to_recb_units && links_to_inpb_units) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_G1b))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECb_LAY;
+               unit_ptr->lun = ARTMAP_G1b_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 2) = unit_ptr;
+               got_g1b_unit = TRUE;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               (*topo_ptr)++;
+
+            } else {
+
+               if (links_to_inpb_units) {
+
+                  /* if there are links to the inpb units but none to the
+                     recb units then we found the rib unit
+                  */
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RIb))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  unit_ptr->lln = ARTMAP_SPECb_LAY;
+                  unit_ptr->lun = ARTMAP_RIb_UNIT;
+                  (*no_of_units)++;
+                  *(topo_spec_ptr + 3) = unit_ptr;
+                  got_rib_unit = TRUE;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+
+               } /*if*/
+
+            } /*if*/
+
+         } else {
+
+            /* unit has direct inputs */
+
+            links_to_rstb_units = FALSE;
+            links_to_d3b_unit   = FALSE;
+            links_to_cmpb_units = FALSE;
+            links_to_inpb_units = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ARTMAP_INPb_LAY:
+                  links_to_inpb_units = TRUE;
+                  break;
+               case ARTMAP_CMPb_LAY:
+                  links_to_cmpb_units = TRUE;
+                  break;
+               case ARTMAP_DELb_LAY:
+                  if (link_ptr->to->lun == ARTMAP_D3b_UNIT) {
+                     links_to_d3b_unit = TRUE;
+                  } /*if*/
+                  break;
+               case ARTMAP_RSTb_LAY:
+                  links_to_rstb_units = TRUE;
+                  break;
+                } /*switch*/
+
+
+            } /*FOR_ALL_LINKS*/
+
+
+            if (links_to_inpb_units && !got_g2b_unit) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_G2b))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECb_LAY;
+               unit_ptr->lun = ARTMAP_G2b_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 7) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_g2b_unit = TRUE;
+               continue;
+            } /*if*/
+
+
+            if (links_to_cmpb_units && !links_to_inpb_units &&
+                !got_rcb_unit
+               )
+            {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RCb))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECb_LAY;
+               unit_ptr->lun = ARTMAP_RCb_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 4) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_rcb_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+
+            if (links_to_d3b_unit && !got_clb_unit) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_CLb))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECb_LAY;
+               unit_ptr->lun = ARTMAP_CLb_UNIT;
+               (*no_of_units)++;
+               *topo_spec_ptr = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_clb_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+
+            if (links_to_rstb_units && !links_to_cmpb_units &&
+                !got_ncb_unit
+               )
+            {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_NCb))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lln = ARTMAP_SPECb_LAY;
+               unit_ptr->lun = ARTMAP_NCb_UNIT;
+               (*no_of_units)++;
+               *(topo_spec_ptr + 1) = unit_ptr;
+               (*topo_ptr)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               got_ncb_unit = TRUE;
+               continue;
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   /* the rgb and the rhob unit remain to be determined */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr))) {
+
+         /* looking for rgb unit */
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_SPECb_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_RIb_UNIT)
+                  )
+               {
+
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RGb))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                     TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                   /* this is the rgb unit */
+                   unit_ptr->lln = ARTMAP_SPECb_LAY;
+                   unit_ptr->lun = ARTMAP_RGb_UNIT;
+                   (*no_of_units)++;
+                   *(topo_spec_ptr + 5) = unit_ptr;
+                   got_rgb_unit =TRUE;
+                   (*topo_ptr)++;
+                   unit_ptr->flags |= UFLAG_REFRESH;
+                   break;
+
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+         } /*if*/
+
+      } else {
+
+         /* looking for rhob unit via ria */
+
+         if ((unit_ptr->lln == ARTMAP_SPECb_LAY) &&
+             (unit_ptr->lun == ARTMAP_RIb_UNIT)
+            )
+         {
+             FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+                if (link_ptr->to->lln != ARTMAP_INPb_LAY) {
+
+                   if (!(CHECK_ACT_FUNC (link_ptr->to, ARTMAP_ACTF_RHOb))) {
+                      TOPO_MSG_ACT_FUNC (link_ptr->to);
+                   } /*if*/
+
+                   if (!(CHECK_OUT_FUNC (link_ptr->to, ARTMAP_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (link_ptr->to);
+                   } /*if*/
+
+                   /* the link_ptr->to unit is the rhoa unit */
+
+                   /* the link_ptr->to unit is the rhob unit */
+
+                   link_ptr->to->lln = ARTMAP_SPECb_LAY;
+                   link_ptr->to->lun = ARTMAP_RHOb_UNIT;
+                   (*no_of_units)++;
+                   *(topo_spec_ptr + 6) = link_ptr->to;
+                   (*topo_ptr)++;
+                   got_rhob_unit = TRUE;
+                   link_ptr->to->flags |= UFLAG_REFRESH;
+                   break;
+
+                } /*if*/
+
+             } /*FOR_ALL_SITES_AND_LINKS*/
+
+          } /*if*/
+
+       } /*if*/
+
+       if (got_rgb_unit && got_rhob_unit) {
+          break;
+       } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_clb_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: cl (=clb)");
+   } /*if*/
+
+   if (!got_ncb_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: nc (=ncb)");
+   } /*if*/
+
+   if (!got_rib_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: ri (=rib)");
+   } /*if*/
+
+   if (!got_rcb_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: rc (=rcb)");
+   } /*if*/
+
+   if (!got_rgb_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: rg (=rgb)");
+   } /*if*/
+
+   if (!got_g1b_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: g1 (=g1b)");
+   } /*if*/
+
+   if (!got_rhob_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: rho (=rhob)");
+   } /*if*/
+
+   if (!got_g2b_unit) {
+      TOPO_MSG_UNIT_MISSING ("ARTb: g2 (=g2b)");
+   } /*if*/
+
+
+   return (ret_code);
+
+} /* kram_get_SpecUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/*************** functions to determine units of map field of ARTMAP net
+***************/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_get_MapUnits (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+   krui_err                ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit    *unit_ptr;
+   register struct Link    *link_ptr;
+
+   bool                    has_link_to_dela_unit,
+                           has_link_to_delb_unit;
+
+   *no_of_units = 0;
+
+   /* looking for map units. These units have got incoming
+      links from the dela units and the delb units. They have
+      no sites.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (!(UNIT_REFRESHED (unit_ptr)) && (UNIT_HAS_DIRECT_INPUTS (unit_ptr))) {
+
+         has_link_to_dela_unit = FALSE;
+         has_link_to_delb_unit = FALSE;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if (link_ptr->to->lln == ARTMAP_DELa_LAY) {
+               has_link_to_dela_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (link_ptr->to->lln == ARTMAP_DELb_LAY) {
+               has_link_to_delb_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (has_link_to_dela_unit && has_link_to_delb_unit) {
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (has_link_to_dela_unit && has_link_to_delb_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_MAP))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+            unit_ptr->lln = ARTMAP_MAP_LAY;
+            (*no_of_units)++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kram_get_MapUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_get_SpecUnits (TopoPtrArray *topo_ptr, int *no_of_units)
+{
+    krui_err                  ret_code  = KRERR_NO_ERROR;
+
+    register struct Unit       *unit_ptr;
+    register struct Site       *site_ptr;
+    register struct Link       *link_ptr;
+
+    TopoPtrArray               topo_spec_ptr = *topo_ptr;
+
+    bool                       has_links_to_reca_units,
+                               has_links_to_inpa_units,
+                               has_link_to_cla_unit,
+                               has_link_to_nca_unit,
+                               has_link_to_itself,
+                               has_links_to_map_units,
+                               has_link_to_rhoa_unit,
+                               has_link_to_delb_unit,
+                               has_link_to_rga_unit;
+
+    bool                       got_d1_unit    = FALSE;
+    bool                       got_cl_unit    = FALSE;
+    bool                       got_nc_unit    = FALSE;
+    bool                       got_G_unit     = FALSE;
+    bool                       got_rb_unit    = FALSE;
+    bool                       got_rm_unit    = FALSE;
+    bool                       got_rg_unit    = FALSE;
+    bool                       got_rho_unit   = FALSE;
+    bool                       got_qu_unit    = FALSE;
+    bool                       got_drho_unit  = FALSE;
+
+
+    FOR_ALL_UNITS (unit_ptr) {
+
+       if (!(UNIT_REFRESHED (unit_ptr))) {
+
+          if (UNIT_HAS_SITES (unit_ptr)) {
+
+             /* G, rb or qu unit */
+
+             has_links_to_reca_units = FALSE;
+             has_links_to_inpa_units = FALSE;
+
+             FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+                switch (link_ptr->to->lln) {
+                case ARTMAP_RECa_LAY:
+                   has_links_to_reca_units = TRUE;
+                   break;
+                case ARTMAP_INPa_LAY:
+                   has_links_to_inpa_units = TRUE;
+                   break;
+                } /*if*/
+
+             } /*FOR_ALL_SITES_AND_LINKS*/
+
+             if (has_links_to_reca_units && !got_G_unit) {
+
+                if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_G))) {
+                   TOPO_MSG_ACT_FUNC (unit_ptr);
+                } /*if*/
+
+                if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                   TOPO_MSG_OUT_FUNC (unit_ptr);
+                } /*if*/
+
+                /* This is the G unit */
+                unit_ptr->lln = ARTMAP_SPEC_LAY;
+                unit_ptr->lun = ARTMAP_G_UNIT;
+                *(topo_spec_ptr + 3) = unit_ptr;
+                (*topo_ptr)++;
+                (*no_of_units)++;
+                unit_ptr->flags |= UFLAG_REFRESH;
+                got_G_unit = TRUE;
+                continue;
+
+              } /*if*/
+
+
+             if (has_links_to_inpa_units && !got_qu_unit) {
+
+                if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_QU))) {
+                   TOPO_MSG_ACT_FUNC (unit_ptr);
+                } /*if*/
+
+                if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                   TOPO_MSG_OUT_FUNC (unit_ptr);
+                } /*if*/
+
+                /* This is the qu unit */
+                unit_ptr->lln = ARTMAP_SPEC_LAY;
+                unit_ptr->lun = ARTMAP_QU_UNIT;
+                *(topo_spec_ptr + 8) = unit_ptr;
+                (*topo_ptr)++;
+                (*no_of_units)++;
+                unit_ptr->flags |= UFLAG_REFRESH;
+                got_qu_unit = TRUE;
+                continue;
+
+              } /*if*/
+
+              if (!got_rb_unit) {
+
+                if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RB))) {
+                   TOPO_MSG_ACT_FUNC (unit_ptr);
+                } /*if*/
+
+                if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                   TOPO_MSG_OUT_FUNC (unit_ptr);
+                } /*if*/
+
+                /* This is the rb unit */
+                unit_ptr->lln = ARTMAP_SPEC_LAY;
+                unit_ptr->lun = ARTMAP_RB_UNIT;
+                *(topo_spec_ptr + 4) = unit_ptr;
+                (*topo_ptr)++;
+                (*no_of_units)++;
+                unit_ptr->flags |= UFLAG_REFRESH;
+                got_rb_unit = TRUE;
+
+              } /*if*/
+
+          }  else {
+
+              /* unit has no sites, so this is the cl, nc, rho, rm,
+                 drho or rg unit
+              */
+
+              has_link_to_cla_unit   = FALSE;
+              has_link_to_nca_unit   = FALSE;
+              has_link_to_itself     = FALSE;
+              has_links_to_map_units = FALSE;
+              has_link_to_rhoa_unit  = FALSE;
+              has_link_to_delb_unit  = FALSE;
+              has_link_to_rga_unit   = FALSE;
+
+
+              FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+                 switch (link_ptr->to->lln) {
+                 case ARTMAP_SPECa_LAY :
+
+                    switch (link_ptr->to->lun) {
+                    case ARTMAP_CLa_UNIT:
+                       has_link_to_cla_unit = TRUE;
+                       break;
+                    case ARTMAP_NCa_UNIT:
+                       has_link_to_nca_unit = TRUE;
+                       break;
+                    case ARTMAP_RHOa_UNIT:
+                       has_link_to_rhoa_unit = TRUE;
+                       break;
+                    case ARTMAP_RGa_UNIT:
+                       has_link_to_rga_unit = TRUE;
+                       break;
+                    } /*switch*/
+
+                    break;
+
+                 case ARTMAP_MAP_LAY:
+                    has_links_to_map_units = TRUE;
+                    break;
+
+                 case ARTMAP_DELb_LAY:
+                    has_link_to_delb_unit = TRUE;
+                    break;
+
+                 default:
+                    if (link_ptr->to == unit_ptr) {
+                       has_link_to_itself = TRUE;
+                    } /*if*/
+
+                 } /*switch*/
+
+              } /*FOR_ALL_LINKS*/
+
+              if (has_link_to_cla_unit && !got_cl_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_CL))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_CL_UNIT;
+                 ArtMap_cl_unit = unit_ptr;
+                 *(topo_spec_ptr + 1) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_cl_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (has_link_to_nca_unit && !got_nc_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_NC))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_NC_UNIT;
+                 ArtMap_nc_unit = unit_ptr;
+                 *(topo_spec_ptr + 2) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_nc_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (has_link_to_itself && !got_rho_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RHO))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_RHO_UNIT;
+                 *(topo_spec_ptr + 7) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_rho_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (has_links_to_map_units && !got_rm_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RM))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_RM_UNIT;
+                 *(topo_spec_ptr + 5) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_rm_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (has_link_to_rga_unit && has_link_to_rhoa_unit &&
+                  ! got_drho_unit
+                 )
+              {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_DRHO))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_DRHO_UNIT;
+                 *(topo_spec_ptr + 9) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_drho_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (has_link_to_delb_unit && !got_d1_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_D1))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_D1_UNIT;
+                 *topo_spec_ptr = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_d1_unit = TRUE;
+                 continue;
+
+              } /*if*/
+
+              if (!got_rg_unit) {
+
+                 if (!(CHECK_ACT_FUNC (unit_ptr, ARTMAP_ACTF_RG))) {
+                    TOPO_MSG_ACT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 if (!(CHECK_OUT_FUNC (unit_ptr, ARTMAP_OUTFUNC))) {
+                    TOPO_MSG_OUT_FUNC (unit_ptr);
+                 } /*if*/
+
+                 unit_ptr->lln = ARTMAP_SPEC_LAY;
+                 unit_ptr->lun = ARTMAP_RG_UNIT;
+                 *(topo_spec_ptr + 6) = unit_ptr;
+                 (*topo_ptr)++;
+                 (*no_of_units)++;
+                 unit_ptr->flags |= UFLAG_REFRESH;
+                 got_rg_unit = TRUE;
+
+              } /*if*/
+
+          } /*if (UNIT_HAS_SITES)*/
+
+       } /* if (!UNIT_REFRESHED)*/
+
+    } /*FOR_ALL_UNITS*/
+
+   if (!got_cl_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: cl");
+   } /*if*/
+
+   if (!got_nc_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: nc");
+   } /*if*/
+
+   if (!got_rb_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: rb");
+   } /*if*/
+
+   if (!got_rm_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: rm");
+   } /*if*/
+
+   if (!got_rg_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: rg");
+   } /*if*/
+
+   if (!got_G_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: G");
+   } /*if*/
+
+   if (!got_d1_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: d1");
+   } /*if*/
+
+   if (!got_rho_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: rho");
+   } /*if*/
+
+   if (!got_qu_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: qu");
+   } /*if*/
+
+   if (!got_drho_unit) {
+      TOPO_MSG_UNIT_MISSING ("MAP: drho");
+   } /*if*/
+
+    return (ret_code);
+
+} /* kram_get_SpecUnits */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/**************** funciton for checking topo ptr array of ARTMAP net
+****************/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_TopoPtrArray (void)
+{
+   TopoPtrArray    topo_inpa_cmpa_sep,
+                   topo_cmpa_reca_sep,
+                   topo_reca_dela_sep,
+                   topo_dela_rsta_sep,
+                   topo_rsta_speca_sep,
+                   topo_speca_inpb_sep,
+                   topo_inpb_cmpb_sep,
+                   topo_cmpb_recb_sep,
+                   topo_recb_delb_sep,
+                   topo_delb_rstb_sep,
+                   topo_rstb_specb_sep,
+                   topo_specb_map_sep,
+                   topo_map_spec_sep,
+                   topo_ptr_array_end;
+
+   int             ret_code = KRERR_NO_ERROR;
+
+
+   topo_inpa_cmpa_sep = topo_ptr_array + ArtMap_NoOfInpUnits_a + 1;
+   topo_cmpa_reca_sep = topo_inpa_cmpa_sep + ArtMap_NoOfInpUnits_a + 1;
+   topo_reca_dela_sep = topo_cmpa_reca_sep + ArtMap_NoOfRecUnits_a + 1;
+   topo_dela_rsta_sep = topo_reca_dela_sep + ArtMap_NoOfRecUnits_a + 4;
+   topo_rsta_speca_sep = topo_dela_rsta_sep + ArtMap_NoOfRecUnits_a + 1;
+   topo_speca_inpb_sep = topo_rsta_speca_sep + ARTMAP_NO_OF_SPECa_UNITS + 1;
+   topo_inpb_cmpb_sep = topo_speca_inpb_sep + ArtMap_NoOfInpUnits_b + 1;
+   topo_cmpb_recb_sep = topo_inpb_cmpb_sep + ArtMap_NoOfInpUnits_b + 1;
+   topo_recb_delb_sep = topo_cmpb_recb_sep + ArtMap_NoOfRecUnits_b + 1;
+   topo_delb_rstb_sep = topo_recb_delb_sep + ArtMap_NoOfRecUnits_b + 4;
+   topo_rstb_specb_sep = topo_delb_rstb_sep + ArtMap_NoOfRecUnits_b + 1;
+   topo_specb_map_sep = topo_rstb_specb_sep + ARTMAP_NO_OF_SPECb_UNITS + 1;
+   topo_map_spec_sep = topo_specb_map_sep + ArtMap_NoOfRecUnits_b + 1;
+
+   topo_ptr_array_end = topo_map_spec_sep + ARTMAP_NO_OF_SPEC_UNITS + 1;
+
+   if ((*topo_ptr_array != NULL)      ||
+       (*topo_inpa_cmpa_sep != NULL)  ||
+       (*topo_cmpa_reca_sep != NULL)  ||
+       (*topo_reca_dela_sep != NULL)  ||
+       (*topo_dela_rsta_sep != NULL)  ||
+       (*topo_rsta_speca_sep != NULL) ||
+       (*topo_speca_inpb_sep != NULL) ||
+       (*topo_inpb_cmpb_sep != NULL)  ||
+       (*topo_cmpb_recb_sep != NULL)  ||
+       (*topo_recb_delb_sep != NULL)  ||
+       (*topo_delb_rstb_sep != NULL)  ||
+       (*topo_rstb_specb_sep != NULL) ||
+       (*topo_specb_map_sep != NULL)  ||
+       (*topo_map_spec_sep != NULL)   ||
+       (*topo_ptr_array_end != NULL)  ||
+       (*(topo_ptr_array_end+1) != NULL)
+      )
+   {
+      ARTMAP_RETURN_NET_ERROR (ret_code);
+   } /*if*/
+
+
+   return (ret_code);
+
+
+} /* kram_TopoPtrArray */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/****************** function for checking sites of ARTMAP network
+******************/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_Sites (void)
+{
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+
+   TopoPtrArray           topo_rsta_ptr,
+                          topo_g1a_ptr,
+                          topo_ria_ptr,
+                          topo_rstb_ptr,
+                          topo_g1b_ptr,
+                          topo_rib_ptr,
+                          topo_G_ptr,
+                          topo_rb_ptr,
+                          topo_qu_ptr;
+
+   bool                   got_site1,
+                          got_site2;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+
+
+   topo_rsta_ptr = topo_ptr_array + 2*ArtMap_NoOfInpUnits_a +
+                   2*ArtMap_NoOfRecUnits_a + 8;
+   topo_g1a_ptr  = topo_rsta_ptr + ArtMap_NoOfRecUnits_a + 3;
+   topo_ria_ptr  = topo_g1a_ptr + 1;
+   topo_rstb_ptr = topo_ria_ptr + 5 + 2*ArtMap_NoOfInpUnits_b +
+                   2*ArtMap_NoOfRecUnits_b + 8;
+   topo_g1b_ptr  = topo_rstb_ptr + ArtMap_NoOfRecUnits_b + 3;
+   topo_rib_ptr  = topo_g1b_ptr + 1;
+   topo_G_ptr    = topo_rib_ptr + 5 + ArtMap_NoOfRecUnits_b + 5;
+   topo_rb_ptr   = topo_G_ptr + 1;
+   topo_qu_ptr   = topo_rb_ptr + 4;
+
+   /* check sites of local reset units of ARTa
+   */
+   while ((unit_ptr = *topo_rsta_ptr++) != NULL) {
+
+      got_site1 = FALSE;
+      got_site2 = FALSE;
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         FOR_ALL_SITES (unit_ptr, site_ptr) {
+
+            if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RSTa_SELF)) && (!got_site1)) {
+               got_site1 = TRUE;
+               continue;
+            } /*if*/
+
+            if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RSTa_SIGNAL)) && (!got_site2)) {
+               got_site2 = TRUE;
+               continue;
+            } /*if*/
+
+            TOPO_MSG_SITE_FUNC (unit_ptr);
+
+         } /*FOR_ALL_SITES*/
+
+
+         if (!got_site1 || !got_site2) {
+            TOPO_MSG_SITE_MISSING  (unit_ptr);
+         } /*if*/
+
+
+      } else {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } /*if*/
+
+   } /*while*/
+
+
+
+   /* Check sites of unit Gain 1 of ARTa */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_g1a_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_g1a_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_g1a_ptr, site_ptr) {
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_INPa_G1a)) && (!got_site1)) {
+         got_site1 = TRUE;
+         continue;
+      } /*if*/
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RECa_G1a)) && (!got_site2)) {
+         got_site2 = TRUE;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_SITE_FUNC (*topo_g1a_ptr);
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING  (*topo_g1a_ptr);
+   } /*if*/
+
+
+   /* Check sites of unit RIa */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_ria_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_ria_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_ria_ptr, site_ptr) {
+
+      if (CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RIa)) {
+         if (!got_site1) {
+            got_site1 = TRUE;
+         } else {
+            if (!got_site2) {
+               got_site2 = TRUE;
+            } else {
+               TOPO_MSG_SITE_FUNC (*topo_ria_ptr);
+            } /*if*/
+         } /*if*/
+      } /*if*/
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_ria_ptr);
+   } /*if*/
+
+
+
+   /* check sites of local reset units of ARTb
+   */
+   while ((unit_ptr = *topo_rstb_ptr++) != NULL) {
+
+      got_site1 = FALSE;
+      got_site2 = FALSE;
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         FOR_ALL_SITES (unit_ptr, site_ptr) {
+
+            if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RSTb_SELF)) && (!got_site1)) {
+               got_site1 = TRUE;
+               continue;
+            } /*if*/
+
+            if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RSTb_SIGNAL)) && (!got_site2)) {
+               got_site2 = TRUE;
+               continue;
+            } /*if*/
+
+            TOPO_MSG_SITE_FUNC (unit_ptr);
+
+         } /*FOR_ALL_SITES*/
+
+
+         if (!got_site1 || !got_site2) {
+            TOPO_MSG_SITE_MISSING (unit_ptr);
+         } /*if*/
+
+
+      } else {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } /*if*/
+
+   } /*while*/
+
+
+
+   /* Check sites of unit Gain 1 of ARTb */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_g1b_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_g1b_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_g1b_ptr, site_ptr) {
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_INPb_G1b)) && (!got_site1)) {
+         got_site1 = TRUE;
+         continue;
+      } /*if*/
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RECb_G1b)) && (!got_site2)) {
+         got_site2 = TRUE;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_SITE_FUNC (*topo_g1b_ptr);
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_g1b_ptr);
+   } /*if*/
+
+
+   /* Check sites of unit RIb */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_rib_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_rib_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_rib_ptr, site_ptr) {
+
+      if (CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RIb)) {
+         if (!got_site1) {
+            got_site1 = TRUE;
+         } else {
+            if (!got_site2) {
+               got_site2 = TRUE;
+            } else {
+               TOPO_MSG_SITE_FUNC (*topo_rib_ptr);
+            } /*if*/
+         } /*if*/
+      } /*if*/
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_rib_ptr);
+   } /*if*/
+
+
+
+
+   /* Check sites of unit G */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_G_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_G_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_G_ptr, site_ptr) {
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_ARTa_G)) && (!got_site1)) {
+         got_site1 = TRUE;
+         continue;
+      } /*if*/
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_ARTb_G)) && (!got_site2)) {
+         got_site2 = TRUE;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_SITE_FUNC (*topo_G_ptr);
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_G_ptr);
+   } /*if*/
+
+
+
+
+   /* Check sites of unit rb */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_rb_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_rb_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_rb_ptr, site_ptr) {
+
+      if (CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_RB)) {
+         if (!got_site1) {
+            got_site1 = TRUE;
+         } else {
+            if (!got_site2) {
+               got_site2 = TRUE;
+            } else {
+               TOPO_MSG_SITE_FUNC (*topo_rb_ptr);
+            } /*if*/
+         } /*if*/
+      } /*if*/
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_rb_ptr);
+   } /*if*/
+
+
+
+
+   /* Check sites of unit qu */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_qu_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_qu_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_qu_ptr, site_ptr) {
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_CMPa_QU)) && (!got_site1)) {
+         got_site1 = TRUE;
+         continue;
+      } /*if*/
+
+      if ((CHECK_SITE_FUNC (site_ptr, ARTMAP_SITEF_INPa_QU)) && (!got_site2)) {
+         got_site2 = TRUE;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_SITE_FUNC (*topo_qu_ptr);
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_qu_ptr);
+   } /*if*/
+
+
+
+
+   return (ret_code);
+
+} /* kram_Sites () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+
+
+
+/*####################  functions for checking links of ARTa
+####################*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_LinksToInpUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+         topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+         topo_msg.dest_error_unit = unit_ptr-unit_array;
+         topo_msg.src_error_unit = 0;
+         ret_code = topo_msg.error_code;
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToInpUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToCmpUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_inp,
+                            count_spec,
+                            count_del;
+
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each comparison unit has a link to exactly one input unit which itself
+        is connected to only this comparison unit and no other.
+      - each comparison unit is linked to the gain 1 unit
+      - each comparison unit is linked to each delay unit that corresponds to
+        a recognition unit
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_inp = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_DELa_LAY:
+               if (link_ptr->to->lun == ARTMAP_DELa_REC_UNIT) {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               break;
+            case ARTMAP_INPa_LAY:
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_inp++;
+               break;
+            case ARTMAP_SPECa_LAY:
+               if (link_ptr->to->lun != ARTMAP_G1a_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               count_spec++;
+               break;
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_inp != 1) || (count_spec != 1) ||
+             (count_del != ArtMap_NoOfRecUnits_a)
+            )
+         {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToCmpUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToRecUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_cmp;
+   int                      count_rst;
+   int                      count_rg;
+   int                      count_g2;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each recognition unit is linked to all comparison units
+      - each recognition unit is linked to the reset general unit
+      - each recognition unit is linked to exactly one local reset unit which
+        itself is linked to only this recognition unit.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_cmp = 0;
+         count_rst = 0;
+         count_rg  = 0;
+         count_g2  = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_CMPa_LAY:
+               count_cmp++;
+               break;
+            case ARTMAP_RSTa_LAY:
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_rst++;
+               break;
+            case ARTMAP_SPECa_LAY:
+               switch (link_ptr->to->lun) {
+               case ARTMAP_RGa_UNIT:
+                  count_rg++;
+                  break;
+               case ARTMAP_G2a_UNIT:
+                  count_g2++;
+                  break;
+               default:
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  break;
+               } /*switch*/
+               break;
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_rst != 1) || (count_rg != 1) || (count_g2 != 1) ||
+             (count_cmp != ArtMap_NoOfInpUnits_a)
+            )
+         {
+           TOPO_MSG_LINK_MISSING  (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToRecUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToDelUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_rec;
+   int                      count_del;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* There are different cases to distinguish
+      1. the delay unit is one that corresponds to a recogniton unit
+         then
+              - it has only one incoming link which comes from the corresponding
+                recognition unit
+
+      2. it is the first other delay unit then
+              - it has links to all delay units that correspond to a
+                recognition unit
+      3. it is the second other delay unit then
+              - it has exactly one link to the first other delay unit
+      4. it is the third other delay unit then
+              - it has exactly one link to the second other delay unit.
+   */
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         switch (unit_ptr->lun) {
+
+         case ARTMAP_DELa_REC_UNIT:
+
+            count_rec = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if (link_ptr->to->lln == ARTMAP_RECa_LAY) {
+
+                  count_rec++;
+                  if (UNIT_REFRESHED (link_ptr->to)) {
+                     TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  } else {
+                     link_ptr->to->flags |= UFLAG_REFRESH;
+                  } /*if*/
+
+               } else {
+
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_rec != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D1a_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_DELa_REC_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != ArtMap_NoOfRecUnits_a) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D2a_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_D1a_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D3a_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELa_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_D2a_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         default :
+            ARTMAP_RETURN_NET_ERROR (ret_code);
+         } /* switch */
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToDelUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToRstUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_spec;
+   int                      count_del;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each local reset unit is linked to via site 1
+      - each local reset unit is linked to the reset general unit via site 2
+      - each local reset unit is linked to exactly one delay unit that
+        corresponds to a recognition unit and which itself is linked
+        to only this local reset unit, via site 2.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } else {
+
+         count_rst = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         site_ptr1 = NULL;
+         site_ptr2 = NULL;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_RSTa_LAY:
+
+               count_rst++;
+
+               if (link_ptr->to != unit_ptr) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr1 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ARTMAP_DELa_LAY:
+
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               link_ptr->to->flags |= UFLAG_REFRESH;
+
+               count_del++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ARTMAP_SPECa_LAY:
+
+               if (link_ptr->to->lun != ARTMAP_RGa_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               count_spec++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if ((count_rst != 1) || (count_spec != 1) || (count_del != 1)) {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToRstUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToSpecUnits_a (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_del;
+   int                      count_inp;
+   int                      count_rec;
+   int                      count_cmp;
+   int                      count_ri;
+   int                      count_rc;
+   int                      count_rg;
+   int                      count_rho;
+   int                      count_g2;
+   int                      count_drho;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* topo_ptr points to classified unit which has two links:
+      1. to d3a unit
+      2. to reset general unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_del = 0;
+   count_rg  = 0;
+   count_g2  = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ARTMAP_DELa_LAY:
+
+         count_del++;
+
+         if (link_ptr->to->lun != ARTMAP_D3a_UNIT) {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_SPECa_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_RGa_UNIT:
+            count_rg++;
+            break;
+         case ARTMAP_G2a_UNIT:
+            count_g2++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /* switch */
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_del != 1) || (count_rg != 1) || count_g2 != 1) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to not classifiable unit which is linked to all
+      local reset units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rst = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_RSTa_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_rst++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rst != ArtMap_NoOfRecUnits_a) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to Gain 1 unit which is linked to all input units
+      via site 1 and to all recognition units via site 2
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rec = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_RECa_LAY :
+
+         count_rec++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_INPa_LAY :
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_inp != ArtMap_NoOfInpUnits_a) ||
+       (count_rec != ArtMap_NoOfRecUnits_a)
+      )
+   {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset I unit which is linked to all input units
+      via one site and to the RHO unit via the other site
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rho = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_INPa_LAY:
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_SPECa_LAY:
+
+         if (link_ptr->to->lun != ARTMAP_RHOa_UNIT) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         count_rho++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr2 == site_ptr1) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_inp != ArtMap_NoOfInpUnits_a) || (count_rho != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset C unit which is linked to all comparison units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_cmp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_CMPa_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_cmp++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_cmp != ArtMap_NoOfInpUnits_a) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to reset general unit which is linked to
+      the reset I unit and the reset C unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_ri = 0;
+   count_rc = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_SPECa_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      if (link_ptr->to->lun == ARTMAP_RIa_UNIT) {
+         count_ri++;
+         continue;
+      } /*if*/
+
+      if (link_ptr->to->lun == ARTMAP_RCa_UNIT) {
+         count_rc++;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+   } /*FOR_ALL_LINKS*/
+
+
+   if ((count_ri != 1) || (count_rc != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+
+   /* topo_ptr points to RHOa unit which has an incoming link
+      from itself and one from the drho unit.
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rho = 0;
+   count_drho = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ARTMAP_SPECa_LAY:
+         if (link_ptr->to->lun == ARTMAP_RHOa_UNIT) {
+            count_rho++;
+         } else {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         }  /*if*/
+         break;
+      case ARTMAP_SPEC_LAY:
+         if (link_ptr->to->lun == ARTMAP_DRHO_UNIT) {
+            count_drho++;
+         } else {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*if*/
+         break;
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_rho != 1) || (count_drho != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+
+   /* topo_ptr points to g2a unit which has incoming links
+      from all inpa units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+     if (link_ptr->to->lln == ARTMAP_INPa_LAY) {
+        count_inp++;
+     } else {
+        TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+     } /*if*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_inp != ArtMap_NoOfInpUnits_a) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+   (*topo_ptr)++;  /* increment topo_ptr to next used position in array */
+
+   return (ret_code);
+
+} /* kram_LinksToSpecUnits_a () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/************* functions for checking links of ARTb
+*************/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kram_LinksToInpUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+         topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+         topo_msg.dest_error_unit = unit_ptr-unit_array;
+         topo_msg.src_error_unit = 0;
+         ret_code = topo_msg.error_code;
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToInpUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToCmpUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_inp,
+                            count_spec,
+                            count_del;
+
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each comparison unit has a link to exactly one input unit which itself
+        is connected to only this comparison unit and no other.
+      - each comparison unit is linked to the gain 1 unit
+      - each comparison unit is linked to each delay unit that corresponds to
+        a recognition unit
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_inp = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_DELb_LAY:
+               if (link_ptr->to->lun == ARTMAP_DELb_REC_UNIT) {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               break;
+            case ARTMAP_INPb_LAY:
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_inp++;
+               break;
+            case ARTMAP_SPECb_LAY:
+               if (link_ptr->to->lun != ARTMAP_G1b_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               count_spec++;
+               break;
+            default :
+              TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_inp != 1) || (count_spec != 1) ||
+             (count_del != ArtMap_NoOfRecUnits_b)
+            )
+         {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToCmpUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToRecUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_cmp;
+   int                      count_rst;
+   int                      count_rg;
+   int                      count_g2;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each recognition unit is linked to all comparison units
+      - each recognition unit is linked to the reset general unit
+      - each recognition unit is linked to exactly one local reset unit which
+        itself is linked to only this recognition unit.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_cmp = 0;
+         count_rst = 0;
+         count_rg  = 0;
+         count_g2  = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_CMPb_LAY:
+               count_cmp++;
+               break;
+            case ARTMAP_RSTb_LAY:
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_rst++;
+               break;
+            case ARTMAP_SPECb_LAY:
+               switch (link_ptr->to->lun) {
+               case ARTMAP_RGb_UNIT:
+                  count_rg++;
+                  break;
+               case ARTMAP_G2b_UNIT:
+                  count_g2++;
+                  break;
+               default:
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  break;
+               } /*switch*/
+               break;
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_rst != 1) || (count_rg != 1) || (count_g2 != 1) ||
+             (count_cmp != ArtMap_NoOfInpUnits_b)
+            )
+         {
+            TOPO_MSG_LINK_MISSING  (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToRecUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToDelUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_rec;
+   int                      count_del;
+   int                      count_map;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* There are different cases to distinguish
+      1. the delay unit is one that corresponds to a recogniton unit
+         then
+              - it has  one incoming link which comes from the corresponding
+                recognition unit
+              - and one incoming link, which comes from the corresponding
+                map-unit.
+
+      2. it is the first other delay unit then
+              - it has links to all delay units that correspond to a
+                recognition unit
+      3. it is the second other delay unit then
+              - it has exactly one link to the first other delay unit
+      4. it is the third other delay unit then
+              - it has exactly one link to the second other delay unit.
+   */
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         ARTMAP_RETURN_NET_ERROR (ret_code);
+
+      } else {
+
+         switch (unit_ptr->lun) {
+
+         case ARTMAP_DELb_REC_UNIT:
+
+            count_rec = 0;
+            count_map = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ARTMAP_RECb_LAY:
+                  count_rec++;
+                  if (UNIT_REFRESHED (link_ptr->to)) {
+                     TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  } else {
+                     link_ptr->to->flags |= UFLAG_REFRESH;
+                  } /*if*/
+                  break;
+               case ARTMAP_MAP_LAY:
+                  count_map++;
+                  if (UNIT_REFRESHED (link_ptr->to)) {
+                     TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  } else {
+                     link_ptr->to->flags |= UFLAG_REFRESH;
+                  } /*if*/
+                  break;
+               default:
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*switch*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if ((count_rec != 1) || (count_map != 1)) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D1b_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_DELb_REC_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != ArtMap_NoOfRecUnits_b) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D2b_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_D1b_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_D3b_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+                   (link_ptr->to->lun == ARTMAP_D2b_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         default :
+            ARTMAP_RETURN_NET_ERROR (ret_code);
+         } /* switch */
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToDelUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToRstUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_spec;
+   int                      count_del;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each local reset unit is linked to via site 1
+      - each local reset unit is linked to the reset general unit via site 2
+      - each local reset unit is linked to exactly one delay unit that
+        corresponds to a recognition unit and which itself is linked
+        to only this local reset unit, via site 2.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } else {
+
+         count_rst = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         site_ptr1 = NULL;
+         site_ptr2 = NULL;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ARTMAP_RSTb_LAY:
+
+               count_rst++;
+
+               if (link_ptr->to != unit_ptr) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr1 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ARTMAP_DELb_LAY:
+
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               link_ptr->to->flags |= UFLAG_REFRESH;
+
+               count_del++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ARTMAP_SPECb_LAY:
+
+               if (link_ptr->to->lun != ARTMAP_RGb_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               count_spec++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if ((count_rst != 1) || (count_spec != 1) || (count_del != 1)) {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToRstUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToSpecUnits_b (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_del;
+   int                      count_inp;
+   int                      count_rec;
+   int                      count_cmp;
+   int                      count_ri;
+   int                      count_rc;
+   int                      count_rg;
+   int                      count_rho;
+   int                      count_g2;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* topo_ptr points to classified unit which has two links:
+      1. to d3b unit
+      2. to reset general unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_del = 0;
+   count_rg  = 0;
+   count_g2  = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ARTMAP_DELb_LAY:
+
+         count_del++;
+
+         if (link_ptr->to->lun != ARTMAP_D3b_UNIT) {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_SPECb_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_RGb_UNIT:
+            count_rg++;
+            break;
+         case ARTMAP_G2b_UNIT:
+            count_g2++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /* switch */
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_del != 1) || (count_rg != 1) || (count_g2 != 1))
+   {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to not classifiable unit which is linked to all
+      local reset units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rst = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_RSTb_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_rst++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rst != ArtMap_NoOfRecUnits_b) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to Gain 1 unit which is linked to all input units
+      via site 1 and to all recognition units via site 2
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rec = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_RECb_LAY :
+
+         count_rec++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_INPb_LAY :
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_inp != ArtMap_NoOfInpUnits_b) ||
+       (count_rec != ArtMap_NoOfRecUnits_b)
+      )
+   {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset I unit which is linked to all input units
+      via one site and to the RHO unit via the other site
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rho = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_INPb_LAY:
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_SPECb_LAY:
+
+         if (link_ptr->to->lun != ARTMAP_RHOb_UNIT) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         count_rho++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr2 == site_ptr1) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_inp != ArtMap_NoOfInpUnits_b) || (count_rho != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset C unit which is linked to all comparison units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_cmp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_CMPb_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_cmp++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_cmp != ArtMap_NoOfInpUnits_b) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to reset general unit which is linked to
+      the reset I unit and the reset C unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_ri = 0;
+   count_rc = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ARTMAP_SPECb_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      if (link_ptr->to->lun == ARTMAP_RIb_UNIT) {
+         count_ri++;
+         continue;
+      } /*if*/
+
+      if (link_ptr->to->lun == ARTMAP_RCb_UNIT) {
+         count_rc++;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+   } /*FOR_ALL_LINKS*/
+
+
+   if ((count_ri != 1) || (count_rc != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+
+   /* topo_ptr points to RHOb unit which has an incoming links
+      from itself
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rho = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ARTMAP_SPECb_LAY:
+         if (link_ptr->to->lun == ARTMAP_RHOb_UNIT) {
+            count_rho++;
+         } else {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         }  /*if*/
+         break;
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rho != 1) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+
+   /* topo_ptr points to g2b unit which has incoming links
+      from all inpb units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+     if (link_ptr->to->lln == ARTMAP_INPb_LAY) {
+        count_inp++;
+     } else {
+        TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+     } /*if*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_inp != ArtMap_NoOfInpUnits_b) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   (*topo_ptr)++;  /* increment topo_ptr to next used position in array */
+
+   return (ret_code);
+
+} /* kram_LinksToSpecUnits_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*********** functions to check links of map field of ARTMAP net
+***********/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToMapUnits (TopoPtrArray *topo_ptr)
+{
+
+   krui_err                  ret_code    = KRERR_NO_ERROR;
+
+   register struct Unit      *unit_ptr;
+   register struct Link      *link_ptr;
+
+   int                       count_dela,
+                             count_delb,
+                             count_G;
+
+
+   /* - each map unit is linked to all dela units
+      - each map unit is linked to its corresponding delb unit
+      - each map unit is linked to the G unit
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+      } /*if*/
+
+      count_dela = 0;
+      count_delb = 0;
+      count_G    = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+         switch (link_ptr->to->lln) {
+         case ARTMAP_DELa_LAY:
+            if (link_ptr->to->lun == ARTMAP_DELa_REC_UNIT) {
+               count_dela++;
+            } else {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            break;
+         case ARTMAP_DELb_LAY:
+            if ((link_ptr->to->lun == ARTMAP_DELb_REC_UNIT) &&
+                (!UNIT_REFRESHED (link_ptr->to))
+               )
+            {
+               count_delb++;
+               link_ptr->to->flags |= UFLAG_REFRESH;
+            } else {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            break;
+         case ARTMAP_SPEC_LAY:
+            if (link_ptr->to->lun == ARTMAP_G_UNIT) {
+               count_G++;
+            } else {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*switch*/
+
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_dela != ArtMap_NoOfRecUnits_a) ||
+          (count_delb != 1) || (count_G != 1)
+         )
+      {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kram_LinksToMapUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kram_LinksToSpecUnits (TopoPtrArray *topo_ptr)
+{
+    krui_err                  ret_code  = KRERR_NO_ERROR;
+
+    register struct Unit      *unit_ptr;
+    register struct Site      *site_ptr;
+    struct Site               *site_ptr1,
+                              *site_ptr2;
+    register struct Link      *link_ptr;
+
+    TopoPtrArray              topo_d1_ptr,
+                              topo_cl_ptr,
+                              topo_nc_ptr,
+                              topo_G_ptr,
+                              topo_rb_ptr,
+                              topo_rm_ptr,
+                              topo_rg_ptr,
+                              topo_rho_ptr,
+                              topo_qu_ptr,
+                              topo_drho_ptr;
+
+    int                       count_delb,
+                              count_d1,
+                              count_cla,
+                              count_clb,
+                              count_nca,
+                              count_ncb,
+                              count_reca,
+                              count_recb,
+                              count_map,
+                              count_rb,
+                              count_rho,
+                              count_rm,
+                              count_inpa,
+                              count_cmpa,
+                              count_qu,
+                              count_rhoa,
+                              count_drho,
+                              count_rg,
+                              count_rga;
+
+    /* let's set the special topo pointers
+    */
+    topo_d1_ptr      = *topo_ptr;
+    topo_cl_ptr      = topo_d1_ptr + 1;
+    topo_nc_ptr      = topo_cl_ptr + 1;
+    topo_G_ptr       = topo_nc_ptr + 1;
+    topo_rb_ptr      = topo_G_ptr + 1;
+    topo_rm_ptr      = topo_rb_ptr + 1;
+    topo_rg_ptr      = topo_rm_ptr + 1;
+    topo_rho_ptr     = topo_rg_ptr + 1;
+    topo_qu_ptr      = topo_rho_ptr + 1;
+    topo_drho_ptr    = topo_qu_ptr + 1;
+
+
+    /* first we check the links to the d1 unit :
+       it has inputs from all delb units.
+    */
+    count_delb = 0;
+    unit_ptr   = *topo_d1_ptr;
+
+    if (UNIT_HAS_SITES (unit_ptr)) {
+       TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+    } /*if*/
+
+    FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+       if ((link_ptr->to->lln == ARTMAP_DELb_LAY) &&
+           (link_ptr->to->lun == ARTMAP_DELb_REC_UNIT)
+          )
+       {
+          count_delb++;
+       } else {
+          TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+       } /*if*/
+
+    } /*FOR_ALL_LINKS*/
+
+    if (count_delb != ArtMap_NoOfRecUnits_b) {
+       TOPO_MSG_LINK_MISSING (unit_ptr);
+    } /*if*/
+
+
+    /* next we check the links to the cl unit
+       it has inputs from the cla, the clb unit and the rg unit
+    */
+
+    count_cla   = 0;
+    count_clb   = 0;
+    count_rg    = 0;
+    unit_ptr    = *topo_cl_ptr;
+
+    if (UNIT_HAS_SITES (unit_ptr)) {
+       TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+    } /*if*/
+
+    FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+       switch (link_ptr->to->lln) {
+       case ARTMAP_SPECa_LAY:
+          if (link_ptr->to->lun == ARTMAP_CLa_UNIT) {
+             count_cla++;
+          } else {
+             TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+          } /*if*/
+          break;
+       case ARTMAP_SPECb_LAY:
+          if (link_ptr->to->lun == ARTMAP_CLb_UNIT) {
+             count_clb++;
+          } else {
+             TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+          } /*if*/
+          break;
+       case ARTMAP_SPEC_LAY:
+          if (link_ptr->to->lun == ARTMAP_RG_UNIT) {
+             count_rg++;
+          } else {
+             TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+          } /*if*/
+          break;
+       default:
+          TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+       } /*switch*/
+
+    } /*FOR_ALL_LINKS*/
+
+    if ((count_cla != 1) || (count_clb != 1) || (count_rg != 1)) {
+       TOPO_MSG_LINK_MISSING (unit_ptr);
+    } /*if*/
+
+
+    /* next we check the links of the nc unit:
+       it has inputs from the nca and the ncb unit
+    */
+
+    count_nca = 0;
+    count_ncb = 0;
+    unit_ptr  = *topo_nc_ptr;
+
+    if (UNIT_HAS_SITES (unit_ptr)) {
+       TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+    } /*if*/
+
+    FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+       switch (link_ptr->to->lln) {
+       case ARTMAP_SPECa_LAY:
+          if (link_ptr->to->lun == ARTMAP_NCa_UNIT) {
+             count_nca++;
+          } else {
+             TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+          } /*if*/
+          break;
+       case ARTMAP_SPECb_LAY:
+          if (link_ptr->to->lun == ARTMAP_NCb_UNIT) {
+             count_ncb++;
+          } else {
+             TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+          } /*if*/
+          break;
+       default:
+          TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+       } /*switch*/
+
+    } /*FOR_ALL_LINKS*/
+
+    if ((count_nca != 1) || (count_ncb != 1)) {
+       TOPO_MSG_LINK_MISSING (unit_ptr);
+    } /*if*/
+
+
+    /* next we check the links to the G unit
+       it has inputs from all reca to one of its sites and from the recb
+       units to the other site.
+    */
+
+    count_reca   = 0;
+    count_recb   = 0;
+    unit_ptr     = *topo_G_ptr;
+    site_ptr1 = NULL;
+    site_ptr2 = NULL;
+
+    if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+       TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+    } /*if*/
+
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_RECb_LAY :
+
+         count_recb++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_RECa_LAY :
+
+         count_reca++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_reca != ArtMap_NoOfRecUnits_a) ||
+       (count_recb != ArtMap_NoOfRecUnits_b)
+      )
+   {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* next we check the links of the rb unit
+      which  has one link from the d1 unit to one of its sites and
+      one link from the rho unit to the other site.
+   */
+
+
+    count_d1     = 0;
+    count_rho    = 0;
+    unit_ptr     = *topo_rb_ptr;
+    site_ptr1 = NULL;
+    site_ptr2 = NULL;
+
+    if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+       TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+    } /*if*/
+
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      if (link_ptr->to->lln == ARTMAP_SPEC_LAY) {
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_D1_UNIT:
+            count_d1++;
+
+            if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+               TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+            } /*if*/
+
+            site_ptr2 = site_ptr;
+
+            if (site_ptr1 == site_ptr2) {
+               TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ARTMAP_RHO_UNIT:
+            count_rho++;
+
+            if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+               TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+            } /*if*/
+
+            site_ptr1 = site_ptr;
+
+            if (site_ptr1 == site_ptr2) {
+               TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+            } /*if*/
+
+            break;
+
+         default :
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+         } /*switch*/
+
+      } else {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_d1 != 1) || (count_rho != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* next we check the links to the rm unit
+      it has inputs from all map units
+   */
+
+   count_map  = 0;
+   unit_ptr   = *topo_rm_ptr;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln == ARTMAP_MAP_LAY) {
+         count_map++;
+      } else {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_map != ArtMap_NoOfRecUnits_b) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* next we check the links to the rg unit
+      it has inputs from the rb and the rm unit
+   */
+
+   count_rb   = 0;
+   count_rm   = 0;
+   unit_ptr   = *topo_rg_ptr;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_SPEC_LAY :
+         switch (link_ptr->to->lun) {
+         case ARTMAP_RB_UNIT:
+            count_rb++;
+            break;
+         case ARTMAP_RM_UNIT:
+            count_rm++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*switch*/
+         break;
+
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         break;
+
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_rb != 1) || (count_rm != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* next we check the links to the rho unit
+      it has inputs just from itself
+   */
+
+   count_rho = 0;
+   unit_ptr  = *topo_rho_ptr;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (unit_ptr == link_ptr->to) {
+         count_rho++;
+      } else {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rho != 1) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* next we check the links to the qu unit
+      it has inputs from all inpa units to one of its sites and
+      from all cmpa units to the other site.
+   */
+
+   count_inpa  = 0;
+   count_cmpa  = 0;
+   unit_ptr    = *topo_qu_ptr;
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ARTMAP_INPa_LAY :
+
+         count_inpa++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ARTMAP_CMPa_LAY :
+
+         count_cmpa++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_inpa != ArtMap_NoOfInpUnits_a) ||
+       (count_cmpa != ArtMap_NoOfInpUnits_a)
+      )
+   {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* finally we check the links to the drho unit
+      it has inputs from itself, from the rg unit, from the qu unit
+      and from the rhoa unit
+   */
+
+   count_drho   = 0;
+   count_rg     = 0;
+   count_qu     = 0;
+   count_rhoa   = 0;
+   count_rga    = 0;
+   count_clb    = 0;
+   unit_ptr     = *topo_drho_ptr;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ARTMAP_SPEC_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_DRHO_UNIT:
+            count_drho++;
+            break;
+         case ARTMAP_RG_UNIT:
+            count_rg++;
+            break;
+         case ARTMAP_QU_UNIT:
+            count_qu++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_SPECa_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_RHOa_UNIT:
+            count_rhoa++;
+            break;
+         case ARTMAP_RGa_UNIT:
+            count_rga++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_SPECb_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ARTMAP_CLb_UNIT:
+            count_clb++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+
+         break;
+
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_drho != 1) || (count_rg   != 1) ||
+       (count_qu   != 1) || (count_rhoa != 1) ||
+       (count_rga  != 1) || (count_clb  != 1)
+      )
+   {
+       TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+   return (ret_code);
+
+
+} /* kram_LinksToSpecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* NOTE: Don't call this function unless net has been topologically sorted
+         with type ARTMAP_TOPO_TYPE
+*/
+
+static krui_err kram_init_fix_weights (void)
+{
+
+   int                    ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+   register struct Link   *link_ptr;
+
+
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               kram_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_LINKS*/
+
+         } else {
+
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+               kram_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+} /* kram_init_fix_weights () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static void  kram_set_fix_weight (struct Unit *src_unit, struct Unit *trgt_unit, FlintType *weight)
+{
+   switch (src_unit->lln) {
+
+   case ARTMAP_INPa_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_CMPa_LAY:
+         *weight = ARTMAP_LINK_INPa_CMPa;
+         break;
+      case ARTMAP_SPECa_LAY:
+         switch (trgt_unit->lun) {
+         case ARTMAP_G1a_UNIT:
+            *weight = ARTMAP_LINK_INPa_G1a;
+            break;
+         case ARTMAP_RIa_UNIT:
+            *weight = ARTMAP_LINK_INPa_RIa;
+            break;
+         case ARTMAP_G2a_UNIT:
+            *weight = ARTMAP_LINK_INPa_G2a;
+            break;
+         } /*switch*/
+         break;
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_INPa_QU;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_CMPa_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_SPECa_LAY:
+         *weight = ARTMAP_LINK_CMPa_RCa;
+         break;
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_CMPa_QU;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_RECa_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_DELa_LAY:
+         *weight = ARTMAP_LINK_RECa_DELa;
+         break;
+      case ARTMAP_SPECa_LAY:
+         *weight = ARTMAP_LINK_RECa_G1a;
+         break;
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_RECa_G;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_DELa_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_DELa_LAY:
+         *weight = ARTMAP_LINK_DELa_DELa;
+         break;
+      case ARTMAP_RSTa_LAY:
+         *weight = ARTMAP_LINK_DELa_RSTa;
+         break;
+      case ARTMAP_SPECa_LAY:
+         *weight = ARTMAP_LINK_DELa_CLa;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_RSTa_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_RECa_LAY:
+         *weight = ARTMAP_LINK_RSTa_RECa;
+         break;
+      case ARTMAP_RSTa_LAY:
+         *weight = ARTMAP_LINK_RSTa_RSTa;
+         break;
+      case ARTMAP_SPECa_LAY:
+         *weight = ARTMAP_LINK_RSTa_NCa;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_SPECa_LAY:
+
+      switch (src_unit->lun) {
+
+      case ARTMAP_CLa_UNIT:
+
+         *weight = ARTMAP_LINK_CLa_CL;
+         break;
+
+      case ARTMAP_NCa_UNIT:
+
+         *weight = ARTMAP_LINK_NCa_NC;
+         break;
+
+      case ARTMAP_G1a_UNIT:
+
+         *weight = ARTMAP_LINK_G1a_CMPa;
+         break;
+
+      case ARTMAP_RIa_UNIT:
+
+         *weight = ARTMAP_LINK_RIa_RGa;
+         break;
+
+      case ARTMAP_RCa_UNIT:
+
+         *weight = ARTMAP_LINK_RCa_RGa;
+         break;
+
+      case ARTMAP_RGa_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_RECa_LAY:
+            *weight = ARTMAP_LINK_RGa_RECa;
+            break;
+         case ARTMAP_RSTa_LAY:
+            *weight = ARTMAP_LINK_RGa_RSTa;
+            break;
+         case ARTMAP_SPECa_LAY:
+            *weight = ARTMAP_LINK_RGa_CLa;
+            break;
+         case ARTMAP_SPEC_LAY:
+            *weight = ARTMAP_LINK_RGa_DRHO;
+         } /*switch*/
+         break;
+
+      case ARTMAP_RHOa_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_SPECa_LAY:
+            switch (trgt_unit->lun) {
+            case ARTMAP_RIa_UNIT:
+               *weight = ARTMAP_LINK_RHOa_RIa;
+               break;
+            case ARTMAP_RHOa_UNIT:
+               *weight = ARTMAP_LINK_RHOa_RHOa;
+               break;
+            } /*switch*/
+            break;
+         case ARTMAP_SPEC_LAY:
+            *weight = ARTMAP_LINK_RHOa_DRHO;
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_G2a_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_RECa_LAY:
+            *weight = ARTMAP_LINK_G2a_RECa;
+            break;
+         case ARTMAP_SPECa_LAY:
+            *weight = ARTMAP_LINK_G2a_CLa;
+            break;
+         } /*switch*/
+
+         break;
+
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_INPb_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_CMPb_LAY:
+         *weight = ARTMAP_LINK_INPb_CMPb;
+         break;
+      case ARTMAP_SPECb_LAY:
+         switch (trgt_unit->lun) {
+         case ARTMAP_G1b_UNIT:
+            *weight = ARTMAP_LINK_INPb_G1b;
+            break;
+         case ARTMAP_RIb_UNIT:
+            *weight = ARTMAP_LINK_INPb_RIb;
+            break;
+         case ARTMAP_G2b_UNIT:
+            *weight = ARTMAP_LINK_INPb_G2b;
+            break;
+         } /*switch*/
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_CMPb_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_SPECb_LAY:
+         *weight = ARTMAP_LINK_CMPb_RCb;
+         break;
+      } /*switch*/
+
+   case ARTMAP_RECb_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_DELb_LAY:
+         *weight = ARTMAP_LINK_RECb_DELb;
+         break;
+      case ARTMAP_SPECb_LAY:
+         *weight = ARTMAP_LINK_RECb_G1b;
+         break;
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_RECb_G;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_DELb_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_DELb_LAY:
+         *weight = ARTMAP_LINK_DELb_DELb;
+         break;
+      case ARTMAP_RSTb_LAY:
+         *weight = ARTMAP_LINK_DELb_RSTb;
+         break;
+      case ARTMAP_SPECb_LAY:
+         *weight = ARTMAP_LINK_DELb_CLb;
+         break;
+      case ARTMAP_MAP_LAY:
+         *weight = ARTMAP_LINK_DELb_MAP;
+         break;
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_DELb_D1;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_RSTb_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_RECb_LAY:
+         *weight = ARTMAP_LINK_RSTb_RECb;
+         break;
+      case ARTMAP_RSTb_LAY:
+         *weight = ARTMAP_LINK_RSTb_RSTb;
+         break;
+      case ARTMAP_SPECb_LAY:
+         *weight = ARTMAP_LINK_RSTb_NCb;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_SPECb_LAY:
+
+      switch (src_unit->lun) {
+
+      case ARTMAP_CLb_UNIT:
+
+         switch (trgt_unit->lun) {
+         case ARTMAP_CL_UNIT:
+            *weight = ARTMAP_LINK_CLb_CL;
+            break;
+         case ARTMAP_DRHO_UNIT:
+            *weight = ARTMAP_LINK_CLb_DRHO;
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_NCa_UNIT:
+
+         *weight = ARTMAP_LINK_NCb_NC;
+         break;
+
+      case ARTMAP_G1b_UNIT:
+
+         *weight = ARTMAP_LINK_G1b_CMPb;
+         break;
+
+      case ARTMAP_RIb_UNIT:
+
+         *weight = ARTMAP_LINK_RIb_RGb;
+         break;
+
+      case ARTMAP_RCb_UNIT:
+
+         *weight = ARTMAP_LINK_RCb_RGb;
+         break;
+
+      case ARTMAP_RGb_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_RECb_LAY:
+            *weight = ARTMAP_LINK_RGb_RECb;
+            break;
+         case ARTMAP_RSTb_LAY:
+            *weight = ARTMAP_LINK_RGb_RSTb;
+            break;
+         case ARTMAP_SPECb_LAY:
+            *weight = ARTMAP_LINK_RGb_CLb;
+            break;
+         } /*switch*/
+         break;
+
+      case ARTMAP_RHOb_UNIT:
+
+         switch (trgt_unit->lun) {
+         case ARTMAP_RIb_UNIT:
+            *weight = ARTMAP_LINK_RHOa_RIa;
+            break;
+         case ARTMAP_RHOb_UNIT:
+            *weight = ARTMAP_LINK_RHOa_RHOa;
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_G2b_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_RECb_LAY:
+            *weight = ARTMAP_LINK_G2b_RECb;
+            break;
+         case ARTMAP_SPECb_LAY:
+            *weight = ARTMAP_LINK_G2b_CLb;
+            break;
+         } /*switch*/
+
+         break;
+
+      } /*switch*/
+
+      break;
+
+
+   case ARTMAP_MAP_LAY:
+
+      switch (trgt_unit->lln) {
+      case ARTMAP_SPEC_LAY:
+         *weight = ARTMAP_LINK_MAP_RM;
+         break;
+      case ARTMAP_DELb_LAY:
+         *weight = ARTMAP_LINK_MAP_DELb;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ARTMAP_SPEC_LAY:
+
+      switch (src_unit->lun) {
+
+      case ARTMAP_D1_UNIT:
+
+         *weight = ARTMAP_LINK_D1_RB;
+         break;
+
+      case ARTMAP_G_UNIT:
+
+         *weight = ARTMAP_LINK_G_MAP;
+         break;
+
+      case ARTMAP_RB_UNIT:
+
+         *weight = ARTMAP_LINK_RB_RG;
+         break;
+
+      case ARTMAP_RM_UNIT:
+
+         *weight = ARTMAP_LINK_RM_RG;
+         break;
+
+      case ARTMAP_RG_UNIT:
+
+         switch (trgt_unit->lun) {
+         case ARTMAP_CL_UNIT:
+            *weight = ARTMAP_LINK_RG_CL;
+            break;
+         case ARTMAP_DRHO_UNIT:
+            *weight = ARTMAP_LINK_RG_DRHO;
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_RHO_UNIT:
+
+         switch (trgt_unit->lun) {
+         case ARTMAP_RB_UNIT:
+            *weight = ARTMAP_LINK_RHO_RB;
+            break;
+         case ARTMAP_RHO_UNIT:
+            *weight = ARTMAP_LINK_RHO_RHO;
+            break;
+         } /*switch*/
+
+         break;
+
+      case ARTMAP_QU_UNIT:
+
+         *weight = ARTMAP_LINK_QU_DRHO;
+         break;
+
+      case ARTMAP_DRHO_UNIT:
+
+         switch (trgt_unit->lln) {
+         case ARTMAP_SPECa_LAY:
+            *weight = ARTMAP_LINK_DRHO_RHOa;
+            break;
+         case ARTMAP_SPEC_LAY:
+            *weight = ARTMAP_LINK_DRHO_DRHO;
+            break;
+         } /* switch */
+
+         break;
+
+      } /*switch*/
+
+      break;
+
+   } /*switch*/
+
+} /* kram_set_fix_weight () */
+/*___________________________________________________________________________*/
diff -Naur snort-2.3.3/src/kernel_snns/kr_amap.h snort-2.3.3.new/src/kernel_snns/kr_amap.h
--- snort-2.3.3/src/kernel_snns/kr_amap.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_amap.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,94 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_amap.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ARTMAP-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:28 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_AMAP_DEFINED_
+#define  _KR_AMAP_DEFINED_
+
+
+
+
+extern int             ArtMap_NoOfInpUnits_a;
+extern int             ArtMap_NoOfInpUnits_b;
+extern int             ArtMap_NoOfRecUnits_a;
+extern int             ArtMap_NoOfRecUnits_b;
+
+extern struct Unit    *ArtMap_cl_unit;  /* Pointer to cl-unit */
+extern struct Unit    *ArtMap_nc_unit;  /* Pointer to nc-unit */
+
+
+
+
+/***************************************************************************/
+/* kram_init_i_act ()
+
+   Sets the initial activation values of the units
+*/
+ krui_err kram_init_i_act (
+
+                                 double rho_a,
+                                 double rho_b,
+                                 double rho
+
+                                );
+
+
+/***************************************************************************/
+/* kram_sort ()
+
+   Check for ARTMAP topology and create topo ptr array
+*/
+ krui_err  kram_sort (
+
+                            void
+
+                           );
+
+
+
+
+/***************************************************************************/
+/* kram_getClassNo ()
+
+   Returns the number of the actually activated class K, 1 <= K <= Mb
+*/
+ int  kram_getClassNo (
+
+                             void
+
+                            );
+
+
+
+/***************************************************************************/
+/* kram_AllMapUnitsActive ()
+
+   Returns TRUE, if all MAP-Field-Units are active, else, FALSE
+*/
+ bool  kram_AllMapUnitsActive (
+
+                                     void
+
+                                    );
+
+
+
+
+#endif 
+
+/* 94 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_amap.ph snort-2.3.3.new/src/kernel_snns/kr_amap.ph
--- snort-2.3.3/src/kernel_snns/kr_amap.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_amap.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,343 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_amap.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ARTMAP-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:29 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_AMAP_DEFINED_
+#define  _KR_AMAP_DEFINED_
+
+/* begin global definition section */
+
+
+
+ int             ArtMap_NoOfInpUnits_a;
+ int             ArtMap_NoOfInpUnits_b;
+ int             ArtMap_NoOfRecUnits_a;
+ int             ArtMap_NoOfRecUnits_b;
+
+ struct Unit    *ArtMap_cl_unit;  /* Pointer to cl-unit */
+ struct Unit    *ArtMap_nc_unit;  /* Pointer to nc-unit */
+
+
+
+
+/***************************************************************************/
+/* kram_init_i_act ()
+
+   Sets the initial activation values of the units
+*/
+ krui_err kram_init_i_act (
+
+                                 double rho_a,
+                                 double rho_b,
+                                 double rho
+
+                                );
+
+
+/***************************************************************************/
+/* kram_sort ()
+
+   Check for ARTMAP topology and create topo ptr array
+*/
+ krui_err  kram_sort (
+
+                            void
+
+                           );
+
+
+
+
+/***************************************************************************/
+/* kram_getClassNo ()
+
+   Returns the number of the actually activated class K, 1 <= K <= Mb
+*/
+ int  kram_getClassNo (
+
+                             void
+
+                            );
+
+
+
+/***************************************************************************/
+/* kram_AllMapUnitsActive ()
+
+   Returns TRUE, if all MAP-Field-Units are active, else, FALSE
+*/
+ bool  kram_AllMapUnitsActive (
+
+                                     void
+
+                                    );
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+static TopoPtrArray      ArtMap_map_layer = NULL;   /* Points to first pointer
+                                                       within map-layer
+                                                    */
+
+
+
+
+static krui_err  kram_get_InpUnits_a (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+static krui_err  kram_get_CmpUnits_a (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+static krui_err  kram_get_RecUnits_a (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_DelUnits_a (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_RstUnits_a (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_SpecUnits_a (
+
+                                       TopoPtrArray      *topo_ptr,
+                                       int               *no_of_units
+
+                                      );
+
+
+static krui_err  kram_get_InpUnits_b (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+static krui_err  kram_get_CmpUnits_b (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+static krui_err  kram_get_RecUnits_b (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_DelUnits_b (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_RstUnits_b (
+
+                                      TopoPtrArray      *topo_ptr,
+                                      int               *no_of_units
+
+                                     );
+
+
+static krui_err  kram_get_SpecUnits_b (
+
+                                       TopoPtrArray      *topo_ptr,
+                                       int               *no_of_units
+
+                                      );
+
+
+
+static krui_err  kram_get_MapUnits (
+
+                                    TopoPtrArray      *topo_ptr,
+                                    int               *no_of_units
+
+                                   );
+
+
+static krui_err  kram_get_SpecUnits (
+
+                                     TopoPtrArray      *topo_ptr,
+                                     int               *no_of_units
+
+                                    );
+
+
+static krui_err  kram_TopoPtrArray (
+
+                                    void
+
+                                   );
+
+
+static krui_err  kram_Sites (
+
+                             void
+
+                            );
+
+
+static krui_err  kram_LinksToInpUnits_a (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToCmpUnits_a (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToRecUnits_a (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToDelUnits_a (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToRstUnits_a (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToSpecUnits_a (
+
+                                          TopoPtrArray *topo_ptr
+
+                                         );
+
+
+static krui_err  kram_LinksToInpUnits_b (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToCmpUnits_b (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToRecUnits_b (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToDelUnits_b (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToRstUnits_b (
+
+                                         TopoPtrArray *topo_ptr
+
+                                        );
+
+
+static krui_err  kram_LinksToSpecUnits_b (
+
+                                          TopoPtrArray *topo_ptr
+
+                                         );
+
+
+static krui_err  kram_LinksToMapUnits (
+
+                                       TopoPtrArray *topo_ptr
+
+                                      );
+
+
+static krui_err  kram_LinksToSpecUnits (
+
+                                        TopoPtrArray *topo_ptr
+
+                                       );
+
+
+static krui_err  kram_init_fix_weights (
+
+                                        void
+
+                                       );
+
+
+static void  kram_set_fix_weight (
+
+                                  struct Unit *src_unit,
+                                  struct Unit *trgt_unit,
+                                  FlintType   *weight
+
+                                 );
+
+
+
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/kr_art1.c snort-2.3.3.new/src/kernel_snns/kr_art1.c
--- snort-2.3.3/src/kernel_snns/kr_art1.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art1.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,2339 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art1.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Functions for ART1 networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:35 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdlib.h>
+
+
+#ifndef NULL /* if NULL pointer is not defined include stdio.h */
+#include <stdio.h>
+#endif
+
+#include <string.h>
+
+#include "kr_const.h"
+#include "kr_mac.h"
+#include "kr_def.h"
+#include "kr_typ.h"
+#include "kr_funcs.h"
+#include "kernel.h"
+#include "glob_typ.h"
+#include "kr_art.h"     /*  Function prototypes for ART networks */
+#include "krart_df.h"   /*  Definitions for ART networks */
+#include "kr_art1.ph"
+
+
+
+/*#################################################
+
+GROUP: ART 1 kernel functions
+       by Kai-Uwe Herrmann
+
+#################################################*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* NOTE: Don't call this function unless net has been topologically sorted
+         with type ART1_TOPO_TYPE
+*/
+
+krui_err  kra1_init_i_act (double rho)
+{
+   int                    ret_code = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      switch (unit_ptr->lln) {
+
+      case ART1_SPEC_LAY:
+         switch (unit_ptr->lun) {
+         case ART1_G1_UNIT :
+            unit_ptr->i_act = 0.0;
+            break;
+         case ART1_RI_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ART1_RG_UNIT :
+            unit_ptr->i_act = 1.0;
+            break;
+         case ART1_RHO_UNIT :
+            unit_ptr->i_act = (FlintType) rho;
+            break;
+         default :
+            unit_ptr->i_act = 0.0;
+            break;
+         } /*switch*/
+         break;
+
+      default :
+         unit_ptr->i_act = 0.0;
+         break;
+      } /*switch*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+} /* kra1_init_i_act () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err  kra1_sort (void)
+{
+
+   int                  no_of_cmp_units = 0;
+   int                  no_of_del_units = 0;
+   int                  no_of_rst_units = 0;
+   int                  no_of_spec_units = 0;
+
+   TopoPtrArray         topo_ptr = topo_ptr_array;
+
+   int                  ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+
+
+   /* initialize ART1 sorting
+   */
+   krart_init_sorting ();
+
+
+   /* get no of input units and no of recognition units
+   */
+   NoOfInputUnits         = krart_get_NoOfInputUnits ();
+   Art1_NoOfRecUnits      = kra1_get_NoOfRecUnits ();
+
+
+   if (NoOfInputUnits == 0) {
+      ret_code = KRERR_NO_INPUT_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (Art1_NoOfRecUnits == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("recognition");
+   } /*if*/
+
+
+
+   /* insert a NULL pointer to topo ptr array for left limitation
+   */
+   *topo_ptr++ = NULL;
+
+
+   /* determine unit types and insert them into topo ptr array
+   */
+
+   /* determine input units
+   */
+   ret_code = kra1_get_InpUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine comparison units
+   */
+   ret_code = kra1_get_CmpUnits (&topo_ptr, &no_of_cmp_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_cmp_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("comparison");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine recognition units
+   */
+   ret_code = kra1_get_RecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine delay units
+   */
+   Art1_del_layer = topo_ptr;
+   ret_code = kra1_get_DelUnits (&topo_ptr, &no_of_del_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   if (no_of_del_units != Art1_NoOfRecUnits + 3) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("delay");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine local reset units
+   */
+   ret_code = kra1_get_RstUnits (&topo_ptr, &no_of_rst_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_rst_units != Art1_NoOfRecUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("reset");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+   ret_code = kra1_get_SpecUnits (&topo_ptr, &no_of_spec_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_spec_units != ART1_NO_OF_SPEC_UNITS) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("special");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* check if the logical type of really all units is determined
+   */
+   if (krart_check_undeterminedUnits ()) {
+      ret_code = topo_msg.error_code;
+      return (ret_code);
+   } /*if*/
+
+
+   /* Now check the topo ptr array
+   */
+   ret_code = kra1_TopoPtrArray ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check the sites
+   */
+
+   ret_code = kra1_Sites ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check link structure
+   */
+   topo_ptr = topo_ptr_array + 1;
+
+   /* Check links of input units
+   */
+   ret_code = kra1_LinksToInpUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* check links of comparison units
+   */
+   ret_code = kra1_LinksToCmpUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* check links of recognition units
+   */
+   ret_code = kra1_LinksToRecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* check links of delay units
+   */
+   ret_code = kra1_LinksToDelUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* check links of local reset units
+   */
+   ret_code = kra1_LinksToRstUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* check links of special function units
+   */
+   ret_code = kra1_LinksToSpecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   ret_code = kra1_init_fix_weights ();
+
+   return (ret_code);
+
+} /* kra1_sort () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+int   kra1_getClassNo (void)
+{
+    TopoPtrArray   topo_ptr = Art1_del_layer;
+    int            i;
+
+    /* if ART1 sorting wasn't performed then return negative value
+       to indicate mistake
+    */
+    if (topo_ptr == NULL) {
+       return (-1);
+    } /*if*/
+
+    /* look for winning unit */
+    for (i = 1; (i <= Art1_NoOfRecUnits) || ((*topo_ptr)->act >= 0.9);
+         i++, topo_ptr++
+        );
+
+    if ((i > Art1_NoOfRecUnits) && ((*topo_ptr)->act < 0.9)) {
+       return (-1);
+    } else {
+       return (topo_ptr - Art1_del_layer + 1);
+    } /*if*/
+
+} /* kra1_getClassNo () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static void   kra1_set_fix_weight (struct Unit *src_unit, struct Unit *trgt_unit, FlintType *weight)
+{
+
+   if ((src_unit == NULL) || (trgt_unit == NULL)) {
+      return;
+   } /*if*/
+
+   switch (src_unit->lln) {
+
+   case ART1_INP_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART1_CMP_LAY:
+         *weight = ART1_LINK_INP_CMP;
+         break;
+      case ART1_SPEC_LAY:
+         switch (trgt_unit->lun) {
+         case ART1_G1_UNIT:
+            *weight = ART1_LINK_INP_G1;
+            break;
+         case ART1_RI_UNIT:
+            *weight = ART1_LINK_INP_RI;
+            break;
+         case ART1_G2_UNIT:
+            *weight = ART1_LINK_INP_G2;
+            break;
+         } /* switch */
+         break;
+      } /*switch*/
+      break;
+
+   case ART1_CMP_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART1_SPEC_LAY:
+         *weight = ART1_LINK_CMP_RC;
+         break;
+      } /*switch*/
+      break;
+
+   case ART1_REC_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART1_DEL_LAY:
+         *weight = ART1_LINK_REC_DEL;
+         break;
+      case ART1_SPEC_LAY:
+         *weight = ART1_LINK_REC_G1;
+         break;
+      } /*switch*/
+      break;
+
+   case ART1_DEL_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART1_DEL_LAY:
+         *weight = ART1_LINK_DEL_DEL;
+         break;
+      case ART1_RST_LAY:
+         *weight = ART1_LINK_DEL_RST;
+         break;
+      case ART1_SPEC_LAY:
+         *weight = ART1_LINK_DEL_CL;
+         break;
+      } /*switch*/
+      break;
+
+   case ART1_RST_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART1_REC_LAY:
+         *weight = ART1_LINK_RST_REC;
+         break;
+      case ART1_RST_LAY:
+         *weight = ART1_LINK_RST_RST;
+         break;
+      case ART1_SPEC_LAY:
+         *weight = ART1_LINK_RST_NCL;
+         break;
+      } /*switch*/
+      break;
+
+   case ART1_SPEC_LAY:
+
+      switch (src_unit->lun) {
+      case ART1_G1_UNIT:
+         *weight = ART1_LINK_G1_CMP;
+         break;
+      case ART1_RI_UNIT:
+         *weight = ART1_LINK_RI_RG;
+         break;
+      case ART1_RC_UNIT:
+         *weight = ART1_LINK_RC_RG;
+         break;
+      case ART1_RG_UNIT:
+         switch (trgt_unit->lln) {
+         case ART1_REC_LAY:
+            *weight = ART1_LINK_RG_REC;
+            break;
+         case ART1_RST_LAY:
+            *weight = ART1_LINK_RG_RST;
+            break;
+         case ART1_SPEC_LAY:
+            *weight = ART1_LINK_RG_CL;
+            break;
+         } /*switch*/
+         break;
+      case ART1_RHO_UNIT:
+         if (trgt_unit->lln == ART1_SPEC_LAY) {
+            switch (trgt_unit->lun) {
+            case ART1_RI_UNIT:
+               *weight = ART1_LINK_RHO_RI;
+               break;
+            case ART1_RHO_UNIT:
+               *weight = ART1_LINK_RHO_RHO;
+               break;
+            } /*switch*/
+         } /*if*/
+         break;
+      case ART1_G2_UNIT:
+         switch (trgt_unit->lln) {
+         case ART1_REC_LAY:
+            *weight = ART1_LINK_G2_REC;
+            break;
+         case ART1_SPEC_LAY:
+            *weight = ART1_LINK_G2_CL;
+            break;
+         } /*switch*/
+      } /*switch*/
+      break;
+
+   } /* switch */
+
+
+} /* kra1_set_fix_weights () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* NOTE: Don't call this function unless net has been topologically sorted
+         with type ART1_TOPO_TYPE
+*/
+static krui_err   kra1_init_fix_weights (void)
+{
+
+   int                    ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+   register struct Link   *link_ptr;
+
+
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               kra1_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_LINKS*/
+
+         } else {
+
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+               kra1_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+} /* kra1_init_fix_weights () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static int  kra1_get_NoOfRecUnits (void)
+{
+   register struct Unit  *unit_ptr;
+   int                   count           = 0;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_SPECIAL_UNIT(unit_ptr)) {
+         count++;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (count);
+
+
+} /* kra1_get_NoOfRecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+
+/* topo_ptr points on first position, where an input unit has to placed in
+   the topo ptr array
+*/
+
+static krui_err kra1_get_InpUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit  *unit_ptr;
+
+   krui_err              ret_code = KRERR_NO_ERROR;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_INPUT_UNIT (unit_ptr)) {
+
+         if (!(CHECK_ACT_FUNC(unit_ptr, ART1_ACTF_INP))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC(unit_ptr, ART1_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         unit_ptr->lln = ART1_INP_LAY;
+         **topo_ptr = unit_ptr;
+         unit_ptr->flags |= UFLAG_REFRESH;
+         (*topo_ptr)++;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra1_get_InpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+
+static krui_err   kra1_get_CmpUnits (TopoPtrArray *topo_ptr, int *no_of_cmp_units)
+{
+   register struct Unit   *unit_ptr;
+   struct Unit            *unit_src_ptr;
+   register struct Link   *link_ptr;
+   struct Link            *link_src_ptr;
+
+   bool                   is_cmp_unit;
+   bool                   has_link_to_inp;
+   bool                   has_links_to_other_than_inp;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+
+   /* look for a recognition unit */
+
+   for (unit_ptr=unit_array+1; !IS_SPECIAL_UNIT(unit_ptr); unit_ptr++);
+
+
+   /* the recognition unit is not supposed to have sites
+   */
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+
+   /* unit_ptr points to a recognition unit.
+      We follow the incoming links of this unit. If the source unit
+      we got by doing this has the following properties, it is a
+      comparison unit:
+         - has no sites
+         - has link to input unit
+         - has link to other than input unit
+   */
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      unit_src_ptr = link_ptr->to;
+
+      if (UNIT_HAS_SITES (unit_src_ptr)) {
+         continue;
+      } /*if*/
+
+      is_cmp_unit                  = FALSE;
+      has_link_to_inp              = FALSE;
+      has_links_to_other_than_inp  = FALSE;
+
+      FOR_ALL_LINKS (unit_src_ptr, link_src_ptr) {
+
+         if (IS_INPUT_UNIT(link_src_ptr->to)) {
+            has_link_to_inp = TRUE;
+         } else {
+            has_links_to_other_than_inp = TRUE;
+         } /*if*/
+
+         if (has_link_to_inp && has_links_to_other_than_inp) {
+            is_cmp_unit = TRUE;
+            break;
+         } /*if*/
+
+      } /*FOR_ALL_LINKS*/
+
+
+      if (is_cmp_unit) {
+
+         if (!(CHECK_ACT_FUNC (unit_src_ptr, ART1_ACTF_CMP))) {
+            TOPO_MSG_ACT_FUNC (unit_src_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC (unit_src_ptr, ART1_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_src_ptr);
+         } /*if*/
+
+         if (! (UNIT_REFRESHED (unit_src_ptr))) {
+
+            unit_src_ptr->lln = ART1_CMP_LAY;
+            (*no_of_cmp_units)++;
+            **topo_ptr = unit_src_ptr;
+            unit_src_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+
+         } /*if*/
+
+      } /*if*/
+
+   }/*FOR_ALL_LINKS*/
+
+   return (ret_code);
+
+} /* kra1_get_CmpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kra1_get_RecUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit  *unit_ptr;
+
+   krui_err                   ret_code = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_SPECIAL_UNIT (unit_ptr)) {
+
+         if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_REC))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(UNIT_REFRESHED (unit_ptr))) {
+            unit_ptr->lln = ART1_REC_LAY;
+            **topo_ptr = unit_ptr;
+            unit_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra1_get_RecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+
+static krui_err   kra1_get_DelUnits (TopoPtrArray *topo_ptr, int *no_of_del_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr,
+                          *this_link = NULL;
+
+   int                    count;
+
+   bool                   checked_del_rec_units   = FALSE;
+   bool                   checked_first_del_unit  = FALSE;
+   bool                   checked_secnd_del_unit  = FALSE;
+   bool                   checked_third_del_unit  = FALSE;
+
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+
+   /* first we determine the delay units that correspond to a recognition
+      unit. These are units that have exactly one incoming link, coming
+      from a recognition unit.
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      count     = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+         count++;
+         this_link = link_ptr;
+
+      } /* FOR_ALL_LINKS */
+
+      if ((count == 1) && (this_link->to->lln == ART1_REC_LAY)) {
+
+         if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_DEL))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         unit_ptr->lln = ART1_DEL_LAY;
+         unit_ptr->lun = ART1_DEL_REC_UNIT;
+         (*no_of_del_units)++;
+         **topo_ptr = unit_ptr;
+         (*topo_ptr)++;
+         unit_ptr->flags |= UFLAG_REFRESH;
+
+      } /*if*/
+
+   } /* FOR_ALL_UNITS*/
+
+   checked_del_rec_units = TRUE;
+
+
+   /* Now we are looking for the first other delay unit which has got incoming
+      links from all delay units we determined above
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ((! (UNIT_REFRESHED (unit_ptr))) &&
+          (UNIT_HAS_DIRECT_INPUTS(unit_ptr))
+         )
+      {
+         count = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            if (link_ptr->to->lln == ART1_DEL_LAY) {
+               count++;
+               if (count > 1) {
+                  break;
+               } /*if*/
+            } else {
+               /* break FOR_ALL_LINKS */
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+         if (count > 1) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_D))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr);
+            } /*if*/
+
+
+            unit_ptr->lln = ART1_DEL_LAY;
+            unit_ptr->lun = ART1_D1_UNIT;
+            checked_first_del_unit = TRUE;
+            (*no_of_del_units)++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+            /* break FOR_ALL_UNITS, 'cause the unit we searched for, was found
+            */
+            break;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   /* Now we look for the d2 unit
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (! (UNIT_REFRESHED (unit_ptr))) {
+
+         count = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            count++;
+            this_link = link_ptr;
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count == 1) && (this_link->to->lln == ART1_DEL_LAY) &&
+             (this_link->to->lun == ART1_D1_UNIT)
+            )
+         {
+
+               unit_ptr->lln = ART1_DEL_LAY;
+               unit_ptr->lun = ART1_D2_UNIT;
+               checked_secnd_del_unit = TRUE;
+               (*no_of_del_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               break; /* terminate search for d2 unit */
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+
+   /* At last  we look for the d3 unit
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (! (UNIT_REFRESHED (unit_ptr))) {
+
+         count = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            count++;
+            this_link = link_ptr;
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count == 1) && (this_link->to->lln == ART1_DEL_LAY) &&
+             (this_link->to->lun == ART1_D2_UNIT)
+            )
+         {
+
+               unit_ptr->lln = ART1_DEL_LAY;
+               unit_ptr->lun = ART1_D3_UNIT;
+               checked_third_del_unit = TRUE;
+               (*no_of_del_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               **topo_ptr = unit_ptr;
+               (*topo_ptr)++;
+               break; /* terminate search for d3 unit */
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   if (!checked_first_del_unit) {
+      TOPO_MSG_UNIT_MISSING ("d1");
+   } /*if*/
+
+   if (!checked_secnd_del_unit) {
+      TOPO_MSG_UNIT_MISSING ("d2");
+   } /*if*/
+
+   if (!checked_third_del_unit) {
+      TOPO_MSG_UNIT_MISSING ("d3");
+   } /*if*/
+
+
+   return (ret_code);
+
+} /* kra1_get_DelUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+
+static krui_err   kra1_get_RstUnits (TopoPtrArray *topo_ptr, int *no_of_rst_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+   register struct Link   *link_ptr;
+
+   bool                   has_link_to_itself,
+                          has_link_to_del_rec_unit;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   /* determine rst units of which each one has sites, an incoming link
+      from itself , one of a delay unit that corresponds to a recognition
+      unit and one from the reset general unit (which wasn't determined yet)
+   */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ((! (UNIT_REFRESHED (unit_ptr))) && (UNIT_HAS_SITES (unit_ptr))) {
+
+         has_link_to_itself = FALSE;
+         has_link_to_del_rec_unit = FALSE;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            if (link_ptr->to == unit_ptr) {
+               has_link_to_itself = TRUE;
+            } else {
+               if ((link_ptr->to->lln == ART1_DEL_LAY) &&
+                   (link_ptr->to->lun == ART1_DEL_REC_UNIT)
+                  )
+               {
+                  has_link_to_del_rec_unit = TRUE;
+               } /*if*/
+            } /*if*/
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if (has_link_to_itself && has_link_to_del_rec_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_RST))) {
+                TOPO_MSG_ACT_FUNC (unit_ptr);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                 TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+            unit_ptr->lln = ART1_RST_LAY;
+            (*no_of_rst_units)++;
+            **topo_ptr = unit_ptr;
+            (*topo_ptr)++;
+            unit_ptr->flags |= UFLAG_REFRESH;
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+
+} /* kra1_get_RstUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_get_SpecUnits (TopoPtrArray *topo_ptr, int *no_of_spec_units)
+{
+   register struct Unit     *unit_ptr;
+   register struct Site     *site_ptr;
+   register struct Link     *link_ptr;
+
+   TopoPtrArray             topo_spec_ptr = *topo_ptr;
+
+   bool                     got_g1_unit    = FALSE;
+   bool                     got_ri_unit    = FALSE;
+   bool                     got_rc_unit    = FALSE;
+   bool                     got_rg_unit    = FALSE;
+   bool                     got_cl_unit    = FALSE;
+   bool                     got_ncl_unit   = FALSE;
+   bool                     got_rho_unit   = FALSE;
+   bool                     got_g2_unit    = FALSE;
+
+   bool                     links_to_rst_units,
+                            links_to_del_units,
+                            links_to_rec_units,
+                            links_to_cmp_units,
+                            links_to_rho_unit,
+                            links_to_inp_units;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (! (UNIT_REFRESHED (unit_ptr))) {
+
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+
+            /* This could be the g1 or the ri unit */
+
+            /* This is the Gain 1 unit if it has links to
+               a recognition unit
+            */
+            links_to_rec_units = FALSE;
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+               if (link_ptr->to->lln == ART1_REC_LAY) {
+                  links_to_rec_units = TRUE;
+                  break;
+               } /*if*/
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+            if (links_to_rec_units) {
+
+               if (!got_g1_unit) {
+
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_G1))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  unit_ptr->lun = ART1_G1_UNIT;
+                  unit_ptr->lln = ART1_SPEC_LAY;
+                  (*topo_ptr)++;
+                  (*no_of_spec_units)++;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  *(topo_spec_ptr + 2) = unit_ptr;
+                  got_g1_unit = TRUE;
+                  continue;
+
+               } /*if*/
+
+            } else {
+
+               /* This should be the ri unit */
+               if (!got_ri_unit) {
+
+                  if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_RI))) {
+                     TOPO_MSG_ACT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                      TOPO_MSG_OUT_FUNC (unit_ptr);
+                  } /*if*/
+
+                  unit_ptr->lun = ART1_RI_UNIT;
+                  unit_ptr->lln = ART1_SPEC_LAY;
+                  (*topo_ptr)++;
+                  (*no_of_spec_units)++;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  *(topo_spec_ptr + 3) = unit_ptr;
+                  got_ri_unit = TRUE;
+                  continue;
+
+               } /*if*/
+
+            } /*if*/
+
+         } else {
+
+            links_to_rst_units = FALSE;
+            links_to_del_units = FALSE;
+            links_to_cmp_units = FALSE;
+            links_to_rho_unit  = FALSE;
+            links_to_inp_units = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ART1_INP_LAY:
+                  links_to_inp_units = TRUE;
+                  break;
+               case ART1_CMP_LAY:
+                  links_to_cmp_units = TRUE;
+                  break;
+               case ART1_DEL_LAY:
+                  links_to_del_units = TRUE;
+                  break;
+               case ART1_RST_LAY:
+                  links_to_rst_units = TRUE;
+                  break;
+               default:
+                  if (unit_ptr == link_ptr->to) {
+                     links_to_rho_unit = TRUE;
+                  } /*if*/
+                  break;
+               } /* switch */
+
+            } /*FOR_ALL_LINKS*/
+
+            if ((links_to_inp_units) && (!got_g2_unit)) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_G2))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_G2_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *(topo_spec_ptr + 7) = unit_ptr;
+               got_g2_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (links_to_rho_unit && (!got_rho_unit)) {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_RHO))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_RHO_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *(topo_spec_ptr + 6) = unit_ptr;
+               got_rho_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (links_to_cmp_units && (!got_rc_unit)) {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_RC))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_RC_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *(topo_spec_ptr + 4) = unit_ptr;
+               got_rc_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (links_to_del_units && (!got_cl_unit)) {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_CL))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_CL_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *topo_spec_ptr = unit_ptr;
+               Art1_cl_unit = unit_ptr;
+               got_cl_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (links_to_rst_units && (!got_ncl_unit)) {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_NCL))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_NCL_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *(topo_spec_ptr+1) = unit_ptr;
+               Art1_nc_unit = unit_ptr;
+               got_ncl_unit = TRUE;
+               continue;
+            } /*if*/
+
+            if (!got_rg_unit) {
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART1_ACTF_RG))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART1_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               unit_ptr->lun = ART1_RG_UNIT;
+               unit_ptr->lln = ART1_SPEC_LAY;
+               (*topo_ptr)++;
+               (*no_of_spec_units)++;
+               unit_ptr->flags |= UFLAG_REFRESH;
+               *(topo_spec_ptr+5) = unit_ptr;
+               got_rg_unit = TRUE;
+               continue;
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   if (!got_cl_unit) {
+      TOPO_MSG_UNIT_MISSING ("cl");
+   } /*if*/
+
+   if (!got_ncl_unit) {
+      TOPO_MSG_UNIT_MISSING ("nc");
+   } /*if*/
+
+   if (!got_ri_unit) {
+      TOPO_MSG_UNIT_MISSING ("ri");
+   } /*if*/
+
+   if (!got_rc_unit) {
+      TOPO_MSG_UNIT_MISSING ("rc");
+   } /*if*/
+
+   if (!got_rg_unit) {
+      TOPO_MSG_UNIT_MISSING ("rg");
+   } /*if*/
+
+   if (!got_g1_unit) {
+      TOPO_MSG_UNIT_MISSING ("g1");
+   } /*if*/
+
+   if (!got_rho_unit) {
+      TOPO_MSG_UNIT_MISSING ("rho");
+   } /*if*/
+
+   if (!got_g2_unit) {
+      TOPO_MSG_UNIT_MISSING ("g2");
+   } /*if*/
+
+   return (ret_code);
+
+} /* kra1_get_SpecUnits () */
+/*___________________________________________________________________________*/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_TopoPtrArray (void)
+{
+   TopoPtrArray    topo_inp_cmp_sep,
+                   topo_cmp_rec_sep,
+                   topo_rec_del_sep,
+                   topo_del_rst_sep,
+                   topo_rst_spec_sep,
+                   topo_ptr_array_end;
+
+   int             ret_code = KRERR_NO_ERROR;
+
+
+   topo_inp_cmp_sep = topo_ptr_array + NoOfInputUnits + 1;
+   topo_cmp_rec_sep = topo_inp_cmp_sep + NoOfInputUnits + 1;
+   topo_rec_del_sep = topo_cmp_rec_sep + Art1_NoOfRecUnits + 1;
+   topo_del_rst_sep = topo_rec_del_sep + Art1_NoOfRecUnits + 4;
+   topo_rst_spec_sep = topo_del_rst_sep + Art1_NoOfRecUnits + 1;
+   topo_ptr_array_end = topo_rst_spec_sep + ART1_NO_OF_SPEC_UNITS + 1;
+
+   if ((*topo_ptr_array != NULL) ||
+       (*topo_inp_cmp_sep != NULL) ||
+       (*topo_cmp_rec_sep != NULL) ||
+       (*topo_rec_del_sep != NULL) ||
+       (*topo_del_rst_sep != NULL) ||
+       (*topo_rst_spec_sep != NULL) ||
+       (*topo_ptr_array_end != NULL) ||
+       (*(topo_ptr_array_end+1) != NULL)
+      )
+   {
+      ART1_RETURN_NET_ERROR (ret_code);
+   } /*if*/
+
+
+   return (ret_code);
+
+
+} /* kra1_TopoPtrArray */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_Sites (void)
+{
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+
+   TopoPtrArray           topo_rst_ptr,
+                          topo_g1_ptr,
+                          topo_ri_ptr;
+
+   bool                   got_site1,
+                          got_site2;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+
+
+   topo_rst_ptr = topo_ptr_array + 2*NoOfInputUnits + 2*Art1_NoOfRecUnits + 8;
+   topo_g1_ptr  = topo_rst_ptr + Art1_NoOfRecUnits + 3;
+   topo_ri_ptr  = topo_g1_ptr + 1;
+
+   /* check sites of local reset units
+   */
+   while ((unit_ptr = *topo_rst_ptr++) != NULL) {
+
+      got_site1 = FALSE;
+      got_site2 = FALSE;
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         FOR_ALL_SITES (unit_ptr, site_ptr) {
+
+            if ((CHECK_SITE_FUNC (site_ptr, ART1_SITEF_RST_SELF)) && (!got_site1)) {
+               got_site1 = TRUE;
+               continue;
+            } /*if*/
+
+            if ((CHECK_SITE_FUNC (site_ptr, ART1_SITEF_RST_SIGNAL)) && (!got_site2)) {
+               got_site2 = TRUE;
+               continue;
+            } /*if*/
+
+            TOPO_MSG_SITE_FUNC (unit_ptr);
+
+         } /*FOR_ALL_SITES*/
+
+
+         if (!got_site1 || !got_site2) {
+            TOPO_MSG_SITE_MISSING  (unit_ptr);
+         } /*if*/
+
+
+      } else {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } /*if*/
+
+   } /*while*/
+
+
+
+   /* Check sites of unit Gain 1 */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_g1_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_g1_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_g1_ptr, site_ptr) {
+
+      if ((CHECK_SITE_FUNC (site_ptr, ART1_SITEF_INP_G1)) && (!got_site1)) {
+         got_site1 = TRUE;
+         continue;
+      } /*if*/
+
+      if ((CHECK_SITE_FUNC (site_ptr, ART1_SITEF_REC_G1)) && (!got_site2)) {
+         got_site2 = TRUE;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_SITE_FUNC (*topo_g1_ptr);
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_g1_ptr);
+   } /*if*/
+
+
+   /* Check sites of unit RI */
+
+   if (UNIT_HAS_DIRECT_INPUTS (*topo_ri_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (*topo_ri_ptr);
+   } /*if*/
+
+   got_site1 = FALSE;
+   got_site2 = FALSE;
+
+   FOR_ALL_SITES (*topo_ri_ptr, site_ptr) {
+
+      if (CHECK_SITE_FUNC (site_ptr, ART1_SITEF_RI)) {
+         if (!got_site1) {
+            got_site1 = TRUE;
+         } else {
+            if (!got_site2) {
+               got_site2 = TRUE;
+            } else {
+               TOPO_MSG_SITE_FUNC (*topo_ri_ptr);
+            } /*if*/
+         } /*if*/
+      } /*if*/
+
+   } /*FOR_ALL_SITES*/
+
+   if (!got_site1 || !got_site2) {
+      TOPO_MSG_SITE_MISSING (*topo_ri_ptr);
+   } /*if*/
+
+   return (ret_code);
+
+} /* kra1_Sites () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToInpUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+         topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+         topo_msg.dest_error_unit = unit_ptr-unit_array;
+         topo_msg.src_error_unit = 0;
+         ret_code = topo_msg.error_code;
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra1_LinksToInpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToCmpUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_inp,
+                            count_spec,
+                            count_del;
+
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each comparison unit has a link to exactly one input unit which itself
+        is connected to only this comparison unit and no other.
+      - each comparison unit is linked to the gain 1 unit
+      - each comparison unit is linked to each delay unit that corresponds to
+        a recognition unit
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_inp = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ART1_DEL_LAY:
+               if (link_ptr->to->lun == ART1_DEL_REC_UNIT) {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               break;
+            case ART1_INP_LAY:
+               if ((UNIT_REFRESHED (link_ptr->to)) || (count_inp > 0)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_inp++;
+               break;
+            case ART1_SPEC_LAY:
+               if (link_ptr->to->lun != ART1_G1_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               count_spec++;
+               break;
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_inp != 1) || (count_spec != 1) ||
+             (count_del != Art1_NoOfRecUnits)
+            )
+         {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra1_LinksToCmpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToRecUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_cmp;
+   int                      count_rst;
+   int                      count_rg;
+   int                      count_g2;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each recognition unit is linked to all comparison units
+      - each recognition unit is linked to the reset general unit
+      - each recognition unit is linked to exactly one local reset unit which
+        itself is linked to only this recognition unit.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         count_cmp = 0;
+         count_rst = 0;
+         count_rg  = 0;
+         count_g2  = 0;
+
+         FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ART1_CMP_LAY:
+               count_cmp++;
+               break;
+            case ART1_RST_LAY:
+               if ((UNIT_REFRESHED (link_ptr->to)) || (count_rst > 0)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+               link_ptr->to->flags |= UFLAG_REFRESH;
+               count_rst++;
+               break;
+            case ART1_SPEC_LAY:
+               switch (link_ptr->to->lun) {
+               case ART1_RG_UNIT:
+                  count_rg++;
+                  break;
+               case ART1_G2_UNIT:
+                  count_g2++;
+                  break;
+               default:
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  break;
+               } /*switch*/
+               break;
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_LINKS*/
+
+         if ((count_rst != 1) || (count_rg != 1) || (count_g2 != 1) ||
+             (count_cmp != NoOfInputUnits)
+            )
+         {
+            TOPO_MSG_LINK_MISSING  (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra1_LinksToRecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToDelUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   int                      count_rec;
+   int                      count_del;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* There are different cases to distinguish
+      1. the delay unit is one that corresponds to a recogniton unit
+         then
+              - it has only one incoming link which comes from the corresponding
+                recognition unit
+
+      2. it is the first other delay unit then
+              - it has links to all delay units that correspond to a
+                recognition unit
+      3. it is the second other delay unit then
+              - it has exactly one link to the first other delay unit
+      4. it is the third other delay unit then
+              - it has exactly one link to the second other delay unit.
+   */
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_SITES (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+
+      } else {
+
+         switch (unit_ptr->lun) {
+
+         case ART1_DEL_REC_UNIT:
+
+            count_rec = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if (link_ptr->to->lln == ART1_REC_LAY) {
+
+                  if ((UNIT_REFRESHED (link_ptr->to)) || (count_rec > 0)) {
+                     TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+                  } else {
+                     link_ptr->to->flags |= UFLAG_REFRESH;
+                  } /*if*/
+                  count_rec++;
+
+               } else {
+
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_rec != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ART1_D1_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ART1_DEL_LAY) &&
+                   (link_ptr->to->lun == ART1_DEL_REC_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != Art1_NoOfRecUnits) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ART1_D2_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ART1_DEL_LAY) &&
+                   (link_ptr->to->lun == ART1_D1_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         case ART1_D3_UNIT:
+
+            count_del = 0;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((link_ptr->to->lln == ART1_DEL_LAY) &&
+                   (link_ptr->to->lun == ART1_D2_UNIT)
+                  )
+               {
+                  count_del++;
+               } else {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (count_del != 1) {
+               TOPO_MSG_LINK_MISSING (unit_ptr);
+            } /*if*/
+
+            break;
+
+         default :
+            ART1_RETURN_NET_ERROR (ret_code);
+         } /* switch */
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra1_LinksToDelUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToRstUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_spec;
+   int                      count_del;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* - each local reset unit is linked to via site 1
+      - each local reset unit is linked to the reset general unit via site 2
+      - each local reset unit is linked to exactly one delay unit that
+        corresponds to a recognition unit and which itself is linked
+        to only this local reset unit, via site 2.
+   */
+
+   krart_deleteTouchFlags();
+
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+         TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+
+      } else {
+
+         count_rst = 0;
+         count_spec = 0;
+         count_del = 0;
+
+         site_ptr1 = NULL;
+         site_ptr2 = NULL;
+
+         FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+            switch (link_ptr->to->lln) {
+            case ART1_RST_LAY:
+
+               count_rst++;
+
+               if (link_ptr->to != unit_ptr) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr1 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ART1_DEL_LAY:
+
+               if (UNIT_REFRESHED (link_ptr->to)) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               link_ptr->to->flags |= UFLAG_REFRESH;
+
+               count_del++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            case ART1_SPEC_LAY:
+
+               if (link_ptr->to->lun != ART1_RG_UNIT) {
+                  TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               count_spec++;
+
+               if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               site_ptr2 = site_ptr;
+
+               if (site_ptr1 == site_ptr2) {
+                  TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+               } /*if*/
+
+               break;
+
+            default :
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /* switch */
+
+         } /*FOR_ALL_SITES_AND_LINKS*/
+
+         if ((count_rst != 1) || (count_spec != 1) || (count_del != 1)) {
+            TOPO_MSG_LINK_MISSING (unit_ptr);
+         } /*if*/
+
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra1_LinksToRstUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra1_LinksToSpecUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit     *unit_ptr;
+   register struct Link     *link_ptr;
+
+   struct Site              *site_ptr,
+                            *site_ptr1,
+                            *site_ptr2;
+
+
+
+   int                      count_rst;
+   int                      count_del;
+   int                      count_inp;
+   int                      count_rec;
+   int                      count_cmp;
+   int                      count_ri;
+   int                      count_rc;
+   int                      count_rg;
+   int                      count_rho;
+   int                      count_g2;
+
+   krui_err                 ret_code = KRERR_NO_ERROR;
+
+
+   /* topo_ptr points to classified unit which has three links:
+      1. from third other delay unit
+      2. from reset general unit
+      3. from gain 2 unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_del = 0;
+   count_rg  = 0;
+   count_g2  = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+      case ART1_DEL_LAY:
+
+         count_del++;
+
+         if (link_ptr->to->lun != ART1_D3_UNIT) {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ART1_SPEC_LAY:
+
+         switch (link_ptr->to->lun) {
+         case ART1_RG_UNIT:
+            count_rg++;
+            break;
+         case ART1_G2_UNIT:
+            count_g2++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         break;
+      } /* switch */
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_del != 1) || (count_rg != 1) || (count_g2 != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to not classifiable unit which is linked to all
+      local reset units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rst = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ART1_RST_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_rst++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rst != Art1_NoOfRecUnits) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to Gain 1 unit which is linked to all input units
+      via site 1 and to all recognition units via site 2
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rec = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ART1_REC_LAY :
+
+         count_rec++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ART1_INP_LAY :
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default :
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_SITES_AND_LINKS*/
+
+   if ((count_inp != NoOfInputUnits) || (count_rec != Art1_NoOfRecUnits)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset I unit which is linked to all input units
+      via one site and to the RHO unit via the other site
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_DIRECT_INPUTS (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+   count_rho = 0;
+
+   site_ptr1 = NULL;
+   site_ptr2 = NULL;
+
+   FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+      switch (link_ptr->to->lln) {
+
+      case ART1_INP_LAY:
+
+         count_inp++;
+
+         if ((site_ptr1 != NULL) && (site_ptr1 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr1 = site_ptr;
+
+         if (site_ptr1 == site_ptr2) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      case ART1_SPEC_LAY:
+
+         if (link_ptr->to->lun != ART1_RHO_UNIT) {
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         count_rho++;
+
+         if ((site_ptr2 != NULL) && (site_ptr2 != site_ptr)) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         site_ptr2 = site_ptr;
+
+         if (site_ptr2 == site_ptr1) {
+            TOPO_MSG_LINK_TO_WRONG_SITE (link_ptr->to, unit_ptr);
+         } /*if*/
+
+         break;
+
+      default:
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+      } /*switch*/
+
+   } /*FOR_ALL_LINKS*/
+
+   if ((count_inp != NoOfInputUnits) || (count_rho != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to reset C unit which is linked to all comparison units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_cmp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ART1_CMP_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      count_cmp++;
+
+   } /*FOR_ALL_LINKS*/
+
+   if (count_cmp != NoOfInputUnits) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to reset general unit which is linked to
+      the reset I unit and the reset C unit
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_ri = 0;
+   count_rc = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+      if (link_ptr->to->lln != ART1_SPEC_LAY) {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      } /*if*/
+
+      if (link_ptr->to->lun == ART1_RI_UNIT) {
+         count_ri++;
+         continue;
+      } /*if*/
+
+      if (link_ptr->to->lun == ART1_RC_UNIT) {
+         count_rc++;
+         continue;
+      } /*if*/
+
+      TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+
+   } /*FOR_ALL_LINKS*/
+
+
+   if ((count_ri != 1) || (count_rc != 1)) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+
+   /* topo_ptr points to RHO unit which has an incoming link
+      from itself
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_rho = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+      if ((link_ptr->to->lln == ART1_SPEC_LAY) &&
+          (link_ptr->to->lun == ART1_RHO_UNIT)
+         )
+      {
+         count_rho++;
+      } else {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      }  /*if*/
+   } /*FOR_ALL_LINKS*/
+
+   if (count_rho != 1) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+
+   /* topo_ptr points to G2 unit which has incoming links
+      from all input units
+   */
+
+   unit_ptr = *(*topo_ptr)++;
+
+   if (UNIT_HAS_SITES (unit_ptr)) {
+      TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+   } /*if*/
+
+   count_inp = 0;
+
+   FOR_ALL_LINKS (unit_ptr, link_ptr) {
+      if (link_ptr->to->lln == ART1_INP_LAY) {
+         count_inp++;
+      } else {
+         TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+      }  /*if*/
+   } /*FOR_ALL_LINKS*/
+
+   if (count_inp != NoOfInputUnits) {
+      TOPO_MSG_LINK_MISSING (unit_ptr);
+   } /*if*/
+
+   return (ret_code);
+
+} /* kra1_LinksToSpecUnits () */
+/*___________________________________________________________________________*/
diff -Naur snort-2.3.3/src/kernel_snns/kr_art1.h snort-2.3.3.new/src/kernel_snns/kr_art1.h
--- snort-2.3.3/src/kernel_snns/kr_art1.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art1.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,75 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art1.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART1-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann 
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:34 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART1_DEFINED_
+#define  _KR_ART1_DEFINED_
+
+
+extern int             Art1_NoOfRecUnits;
+
+extern  struct Unit     *Art1_cl_unit; /* Pointer to ART1 cl-unit */
+extern  struct Unit     *Art1_nc_unit; /* Pointer to ART1 nc-unit */
+
+
+
+/***************************************************************************/
+/* kra1_sort ()
+
+   Set logical layer numbers and logical unit numbers in an ART1 network.
+   Also this function checks, whether the network is an ART1 network or not.
+   Returns an error code, when actual network is no ART1 architecture.
+*/
+extern krui_err  kra1_sort (
+
+                            void
+
+                           );
+
+/***************************************************************************/
+/* kra1_init_i_act ()
+
+   Sets the initial activation values of the units
+*/
+extern krui_err  kra1_init_i_act (
+
+                                  double rho
+
+                                 );
+
+
+/***************************************************************************/
+/* kra1_getClassNo ()
+
+   Returns the number of the actually activated class J, 1 <= J <= M
+*/
+extern int  kra1_getClassNo (
+
+                             void
+
+                            );
+
+
+
+
+
+ 
+#endif
+
+/* 74 lines generated by deleteprivatedefinitions.awk */
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_art1.ph snort-2.3.3.new/src/kernel_snns/kr_art1.ph
--- snort-2.3.3/src/kernel_snns/kr_art1.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art1.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,193 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art1.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART1-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann 
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:35 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART1_DEFINED_
+#define  _KR_ART1_DEFINED_
+
+/* begin global definition section */
+
+ int             Art1_NoOfRecUnits;
+
+ struct Unit     *Art1_cl_unit; /* Pointer to ART1 cl-unit */
+ struct Unit     *Art1_nc_unit; /* Pointer to ART1 nc-unit */
+
+
+
+/***************************************************************************/
+/* kra1_sort ()
+
+   Set logical layer numbers and logical unit numbers in an ART1 network.
+   Also this function checks, whether the network is an ART1 network or not.
+   Returns an error code, when actual network is no ART1 architecture.
+*/
+ krui_err  kra1_sort (
+
+                            void
+
+                           );
+
+/***************************************************************************/
+/* kra1_init_i_act ()
+
+   Sets the initial activation values of the units
+*/
+ krui_err  kra1_init_i_act (
+
+                                  double rho
+
+                                 );
+
+
+/***************************************************************************/
+/* kra1_getClassNo ()
+
+   Returns the number of the actually activated class J, 1 <= J <= M
+*/
+ int  kra1_getClassNo (
+
+                             void
+
+                            );
+
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+static TopoPtrArray      Art1_del_layer = NULL;   /* Points to first pointer
+                                                     within delay-layer
+                                                  */
+
+
+/**************** functions, local to this module ******************************/
+
+static int                kra1_get_NoOfRecUnits (
+
+                                                 void
+
+                                                );
+
+static krui_err           kra1_get_InpUnits (
+
+                                             TopoPtrArray *topo_ptr
+
+                                            );
+
+static krui_err           kra1_get_CmpUnits (
+
+                                             TopoPtrArray *topo_ptr,
+                                             int *no_of_cmp_units
+
+                                            );
+
+static krui_err           kra1_get_RecUnits (
+
+                                             TopoPtrArray *topo_ptr
+
+                                            );
+
+static krui_err           kra1_get_DelUnits (
+
+                                             TopoPtrArray *topo_ptr,
+                                             int *no_of_del_units
+
+                                            );
+
+static krui_err           kra1_get_RstUnits (
+
+                                             TopoPtrArray *topo_ptr,
+                                             int *no_of_rst_units
+
+                                            );
+
+static krui_err           kra1_get_SpecUnits (
+
+                                              TopoPtrArray *topo_ptr,
+                                              int *no_of_spec_units
+
+                                             );
+
+static krui_err           kra1_TopoPtrArray (
+
+                                             void
+
+                                            );
+
+static krui_err           kra1_Sites (
+
+                                      void
+
+                                     );
+
+static krui_err           kra1_LinksToInpUnits (
+
+                                                TopoPtrArray *topo_inp_ptr
+
+                                               );
+
+static krui_err           kra1_LinksToCmpUnits (
+
+                                                TopoPtrArray *topo_cmp_ptr
+
+                                               );
+
+static krui_err           kra1_LinksToRecUnits (
+
+                                                TopoPtrArray *topo_rec_ptr
+
+                                               );
+
+static krui_err           kra1_LinksToDelUnits (
+
+                                                TopoPtrArray *topo_del_ptr
+
+                                               );
+
+static krui_err           kra1_LinksToRstUnits (
+
+                                                TopoPtrArray *topo_rst_ptr
+
+                                               );
+
+static krui_err           kra1_LinksToSpecUnits (
+
+                                                 TopoPtrArray *topo_spec_ptr
+
+                                                );
+
+static void               kra1_set_fix_weight (
+
+                                               struct Unit *src_unit,
+                                               struct Unit *trgt_unit,
+                                               FlintType   *weight
+
+                                              );
+
+static krui_err           kra1_init_fix_weights (
+
+                                                 void
+
+                                                );
+
+
+/* end private definition section */
+
+ 
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_art2.c snort-2.3.3.new/src/kernel_snns/kr_art2.c
--- snort-2.3.3/src/kernel_snns/kr_art2.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art2.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,2248 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art2.c,v $
+  SHORTNAME      : kr_art2
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Functions for ART2 networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:36 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+/*#################################################
+
+GROUP: include files
+
+#################################################*/
+
+
+
+
+#include <stdlib.h>
+
+#ifndef NULL /* if NULL pointer is not defined include stdio.h */
+#include <stdio.h>
+#endif
+
+#include <string.h>
+
+#include <math.h>
+
+
+#include "kr_const.h"
+#include "kr_mac.h"
+#include "kr_def.h"
+#include "kr_typ.h"
+#include "kr_funcs.h"
+#include "kernel.h"
+#include "glob_typ.h"
+#include "kr_art.h"     /*  Function prototypes for ART networks */
+#include "krart_df.h"   /*  Definitions for ART networks */
+#include "kr_art2.ph"
+
+
+
+
+
+
+/*#################################################
+
+GROUP: declaration of module functions
+
+#################################################*/
+
+
+
+
+/*#################################################
+
+GROUP: IMPLEMENTATION SECTION of
+       ART 2 kernel functions visible to other
+       modules
+       by Kai-Uwe Herrmann
+
+#################################################*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err kra2_sort (void)
+{
+
+   TopoPtrArray        topo_ptr = topo_ptr_array;
+   int                 ret_code = KRERR_NO_ERROR;
+
+   int                 no_of_w_units = 0;
+   int                 no_of_x_units = 0;
+   int                 no_of_u_units = 0;
+   int                 no_of_v_units = 0;
+   int                 no_of_p_units = 0;
+   int                 no_of_q_units = 0;
+   int                 no_of_r_units = 0;
+   int                 no_of_rst_units = 0;
+
+   /* initialize ART2 sorting
+   */
+   krart_init_sorting ();
+
+
+   /* get no of input units and no of recognition units
+   */
+   NoOfInputUnits         = krart_get_NoOfInputUnits ();
+   Art2_NoOfRecUnits      = kra2_get_NoOfRecUnits ();
+
+   if (NoOfInputUnits == 0) {
+      ret_code = KRERR_NO_INPUT_UNITS;
+      return (ret_code);
+   } /*if*/
+
+   if (Art2_NoOfRecUnits == 0) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("recognition");
+   } /*if*/
+
+
+   /* insert a NULL pointer to topo ptr array for left limitation
+   */
+   *topo_ptr++ = NULL;
+
+
+   /* determine unit types and insert them into topo ptr array
+   */
+
+   topo_layer[0] = topo_ptr;
+
+
+   /* determine input units
+   */
+   topo_layer[0] = topo_ptr;
+   ret_code = kra2_get_InpUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+   /* determine w units
+   */
+   topo_layer[1] = topo_ptr;
+   ret_code = kra2_get_WUnits (&topo_ptr, &no_of_w_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_w_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("w");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine x units
+   */
+   topo_layer[2] = topo_ptr;
+   ret_code = kra2_get_XUnits (&topo_ptr, &no_of_x_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_x_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("x");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine u units
+   */
+   topo_layer[3] = topo_ptr;
+   ret_code = kra2_get_UUnits (&topo_ptr, &no_of_u_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_u_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("u");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine v units
+   */
+   topo_layer[4] = topo_ptr;
+   ret_code = kra2_get_VUnits (&topo_ptr, &no_of_v_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_v_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("v");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine p units
+   */
+   topo_layer[5] = topo_ptr;
+   ret_code = kra2_get_PUnits (&topo_ptr, &no_of_p_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_p_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("p");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine q units
+   */
+   topo_layer[6] = topo_ptr;
+   ret_code = kra2_get_QUnits (&topo_ptr, &no_of_q_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_q_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("q");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine r units
+   */
+   topo_layer[7] = topo_ptr;
+   ret_code = kra2_get_RUnits (&topo_ptr, &no_of_r_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_r_units != NoOfInputUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("r");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine rec units
+   */
+   topo_layer[8] = topo_ptr;
+   ret_code = kra2_get_RecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* determine rst units
+   */
+   topo_layer[9] = topo_ptr;
+   ret_code = kra2_get_RstUnits (&topo_ptr, &no_of_rst_units);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   if (no_of_rst_units != Art2_NoOfRecUnits) {
+      TOPO_MSG_NO_OF_UNITS_IN_LAYER ("reset");
+   } /*if*/
+
+   *topo_ptr++ = NULL;
+
+
+   /* check if the logical type of really all units is determined
+   */
+   if (krart_check_undeterminedUnits ()) {
+      ret_code = topo_msg.error_code;
+      return (ret_code);
+   } /*if*/
+
+
+   /* Now check the topo ptr array
+   */
+   ret_code = kra2_TopoPtrArray ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check link structure
+   */
+   topo_ptr = topo_ptr_array + 1;
+
+   /* Check links of input units
+   */
+   ret_code = kra2_LinksToInpUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of w units
+   */
+   ret_code = kra2_LinksToWUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of x units
+   */
+   ret_code = kra2_LinksToXUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of u units
+   */
+   ret_code = kra2_LinksToUUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of v units
+   */
+   ret_code = kra2_LinksToVUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of p units
+   */
+   ret_code = kra2_LinksToPUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of q units
+   */
+   ret_code = kra2_LinksToQUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of r units
+   */
+   ret_code = kra2_LinksToRUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of rec units
+   */
+   ret_code = kra2_LinksToRecUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+   /* Check links of rst units
+   */
+   ret_code = kra2_LinksToRstUnits (&topo_ptr);
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+
+/*--------------------------------------------------------------------*/
+#if 0
+/* this was the preliminary version of the sorting routine for testing*/
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_INP_LAY-1] = topo_ptr;
+
+                          Art2_NoOfRecUnits = 0;
+                          FOR_ALL_UNITS (unit_ptr) {
+                             if (IS_SPECIAL_UNIT (unit_ptr)) {
+                                Art2_NoOfRecUnits++;
+                             } /*if*/
+                          } /*FOR_ALL_UNITS*/
+
+
+                          unit_ptr = unit_array + 1;
+
+                          for (i=1; i<= NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_INP_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_W_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_W_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_X_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_X_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_U_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_U_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_V_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_V_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_P_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_P_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_Q_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_Q_LAY;
+                          } /*for*/
+
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_R_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=NoOfInputUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_R_LAY;
+                          } /*for*/
+
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_REC_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=Art2_NoOfRecUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_REC_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          topo_layer[ART2_RST_LAY-1] = topo_ptr;
+
+                          for (i=1; i<=Art2_NoOfRecUnits; i++, unit_ptr++) {
+                             *topo_ptr++ = unit_ptr;
+                             unit_ptr->lln = ART2_RST_LAY;
+                          } /*for*/
+
+                          *topo_ptr++ = NULL;
+                          *topo_ptr   = NULL;
+#endif /*#if 0*/
+/*-----------------------------------------------------------------*/
+
+   return (ret_code);
+
+} /* kra2_sort () */
+/*___________________________________________________________________________*/
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err kra2_init_propagate (void)
+{
+   int                    ret_code = KRERR_NO_ERROR;
+
+   ret_code = kra2_init_i_act ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   ret_code = kra2_init_fix_weights ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   ret_code = krart_reset_activations ();
+
+   if (ret_code != KRERR_NO_ERROR) {
+      return (ret_code);
+   } /*if*/
+
+   NoOfDelaySteps = 0;
+
+   return (ret_code);
+
+} /* kra2_init_propagate () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+krui_err  kra2_set_params (FlintType rho, FlintType a, FlintType b, FlintType c, FlintType d, FlintType theta)
+{
+   Param_rho   = rho;
+   Param_a     = a;
+   Param_b     = b;
+   Param_c     = c;
+   Param_d     = d;
+   Param_theta = theta;
+   return (KRERR_NO_ERROR);
+} /* kra2_set_theta () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_rho (void)
+{
+   return (Param_rho);
+} /* kra2_get_Param_rho () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_a (void)
+{
+   return (Param_a);
+} /* kra2_get_Param_a () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_b (void)
+{
+   return (Param_b);
+} /* kra2_get_Param_b () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_c (void)
+{
+   return (Param_c);
+} /* kra2_get_Param_c () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_d (void)
+{
+   return (Param_d);
+} /* kra2_get_Param_d () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_get_theta (void)
+{
+   return (Param_theta);
+} /* kra2_get_Param_theta () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  kra2_checkReset (void)
+{
+   FlintType NormR;
+
+   NormR = ART2_PARAM_e + kra2_L2_Norm (ART2_R_LAY);
+
+   if ((kra2_f1_stable()) && (kra2_topdn_phase()) && (kra2_get_rho() / NormR > 1)) {
+      GlobalReset  = TRUE;
+   } else {
+      GlobalReset  = FALSE;
+   } /*if*/
+
+} /* kra2_checkReset () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kra2_Reset (void)
+{
+   return (GlobalReset);
+} /* kra2_Reset () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  kra2_init_pattern (void)
+{
+  TopDownPhase = FALSE;
+  f1_stable    = FALSE;
+  GlobalReset  = FALSE;
+} /* kra2_init_phase () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kra2_topdn_phase (void)
+{
+  return (TopDownPhase);
+} /* kra2_topdn_phase () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void   kra2_compute_norms (void)
+{
+   NormInp = kra2_compute_l2_norm (ART2_INP_LAY);
+   NormW   = kra2_compute_l2_norm (ART2_W_LAY);
+   NormU   = kra2_compute_l2_norm (ART2_U_LAY);
+   NormV   = kra2_compute_l2_norm (ART2_V_LAY);
+   NormP   = kra2_compute_l2_norm (ART2_P_LAY);
+   NormR   = kra2_compute_l2_norm (ART2_R_LAY);
+} /* kra2_compute_norms () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+FlintType  kra2_L2_Norm (int Layer)
+{
+   switch (Layer) {
+   case ART2_INP_LAY:
+      return (NormInp);
+   case ART2_W_LAY:
+      return (NormW);
+   case ART2_U_LAY:
+      return (NormU);
+   case ART2_V_LAY:
+      return (NormV);
+   case ART2_P_LAY:
+      return (NormP);
+   case ART2_R_LAY:
+      return (NormR);
+   default :
+      return (0.0);
+   } /* switch */
+} /* kra2_L2_Norm () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kra2_classified (void)
+{
+
+   /* if the F1-Layer is actually stable, then it is necessary to continue
+      propagation for MIN_NO_OF_DELAY_STEPS cycles. Then the information
+      has been forwarded from recognition layer to r-units and it may be
+      decided about a reset.
+
+      if there occurs a reset during the delay propagation steps the no. of
+      executed delay propagation steps is reset to 0 and FALSE is returned.
+
+      if the F1-Layer becomes unstable during the delay propagation steps, the
+      no. of executed delay propagation steps is reset to 0, too and FALSE is
+      returned.
+   */
+
+   if (kra2_topdn_phase() && kra2_f1_stable()) {
+      if (NoOfDelaySteps >= MIN_NO_OF_DELAY_STEPS) {
+         if ( ! kra2_Reset()) {
+            return (TRUE);
+         } else {
+            NoOfDelaySteps = 0;
+            return (FALSE);
+         } /*if*/
+      } else {
+         NoOfDelaySteps++;
+         return (FALSE);
+      } /*if*/
+   } else {
+      NoOfDelaySteps = 0;
+      return (FALSE);
+   } /*if*/
+
+} /* kra2_classified () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kra2_not_classifiable (void)
+{
+   TopoPtrArray topo_ptr         = topo_layer[ART2_RST_LAY-1];
+
+
+   /* if there is one local reset unit that is inactive, then the
+      pattern may still be classifiable
+   */
+   while (*topo_ptr != NULL) {
+      if ((*topo_ptr)->Out.output < 0.1) {
+         return (FALSE);
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+
+   /* all local reset units are active -> pattern not classifiable */
+   return (TRUE);
+
+} /* kra2_classified () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  kra2_save_for_stability_check (void)
+{
+   register TopoPtrArray    topo_ptr ;
+
+   topo_ptr = topo_layer[ART2_W_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_X_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_U_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_V_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_P_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_Q_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_R_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      (*topo_ptr)->value_a = (*topo_ptr)->act;
+      topo_ptr++;
+   } /*while*/
+
+} /* kra2_save_for_stability_check () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  kra2_check_f1_stability (void)
+{
+   register TopoPtrArray    topo_ptr;
+
+   if (f1_stable && ( ! kra2_topdn_phase())) {
+      TopDownPhase = TRUE;
+   } /*if*/
+
+   if (kra2_Reset() && kra2_topdn_phase()) {
+      TopDownPhase = FALSE;
+      f1_stable    = FALSE;
+   } /*if*/
+
+
+   topo_ptr = topo_layer[ART2_W_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_X_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_U_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_V_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_P_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_Q_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   topo_ptr = topo_layer[ART2_R_LAY-1];
+
+   while (*topo_ptr != NULL) {
+      if ( fabs((*topo_ptr)->value_a-(*topo_ptr)->act) > F1_STABILITY_PARAM ) {
+         f1_stable = FALSE;
+         return;
+      } /*if*/
+      topo_ptr++;
+   } /*while*/
+
+   f1_stable = TRUE;
+
+   return;
+
+} /* kra2_check_f1_stability () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  kra2_f1_stable (void)
+{
+   return (f1_stable);
+} /* kra2_f1_stable () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+int  kra2_getClassNo (void)
+{
+    TopoPtrArray   topo_ptr = topo_layer[ART2_REC_LAY-1];
+    int            i;
+
+    /* if ART2 sorting wasn't performed then return negative value
+       to indicate mistake
+    */
+    if (topo_ptr == NULL) {
+       return (-1);
+    } /*if*/
+
+    /* look for winning unit */
+    for (i = 1;
+         (i <= Art2_NoOfRecUnits) || ((*topo_ptr)->Out.output == kra2_get_d());
+         i++, topo_ptr++
+        );
+
+    if ((i > Art2_NoOfRecUnits) && ((*topo_ptr)->Out.output < kra2_get_d())) {
+       return (-1);
+    } else {
+       return (topo_ptr - topo_layer[ART2_REC_LAY-1] + 1);
+    } /*if*/
+
+} /* kra2_getClassNo () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*#################################################
+
+GROUP: IMPLEMENTATION SECTION of
+       ART 2 kernel functions, local to this module
+       by Kai-Uwe Herrmann
+
+#################################################*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static void   kra2_set_fix_weight (struct Unit *src_unit, struct Unit *trgt_unit, FlintType *weight)
+{
+
+   if ((src_unit == NULL) || (trgt_unit == NULL)) {
+      return;
+   } /*if*/
+
+   switch (src_unit->lln) {
+
+   case ART2_INP_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_W_LAY:
+         *weight = ART2_LINK_INP_W;
+         break;
+      case ART2_R_LAY:
+         *weight = ART2_LINK_INP_R;
+         break;
+      } /*switch*/
+
+      break;
+
+   case ART2_W_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_X_LAY:
+         *weight = ART2_LINK_W_X;
+         break;
+      } /*switch*/
+      break;
+
+   case ART2_X_LAY:
+
+      *weight = ART2_LINK_X_V;
+      break;
+
+   case ART2_U_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_W_LAY:
+         *weight = ART2_LINK_U_W(kra2_get_a());
+         break;
+      case ART2_P_LAY:
+         *weight = ART2_LINK_U_P;
+         break;
+      default :
+         break;
+      } /* switch */
+      break;
+
+   case ART2_V_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_U_LAY:
+         *weight = ART2_LINK_V_U;
+         break;
+      default :
+         break;
+      } /* switch */
+      break;
+
+   case ART2_P_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_Q_LAY:
+         *weight = ART2_LINK_P_Q;
+         break;
+      case ART2_R_LAY:
+         *weight = ART2_LINK_P_R(kra2_get_c());
+         break;
+      default :
+         break;
+      } /* switch */
+      break;
+
+   case ART2_Q_LAY:
+
+      *weight = ART2_LINK_Q_V(kra2_get_b());
+      break;
+
+   case ART2_R_LAY:
+
+      /* doesn't have outgoing links because Norm of R is computed
+         within the function kra2_L2_Norm and not in a unit
+      */
+      break;
+
+   case ART2_REC_LAY:
+
+      if (trgt_unit->lln == ART2_RST_LAY) {
+         *weight = ART2_LINK_REC_RST;
+      } /*if*/
+      break;
+
+   case ART2_RST_LAY:
+
+      switch (trgt_unit->lln) {
+      case ART2_RST_LAY:
+         *weight = ART2_LINK_RST_RST;
+         break;
+      case ART2_REC_LAY:
+         *weight = ART2_LINK_RST_REC(kra2_get_d());
+         break;
+      default :
+         break;
+      } /* switch */
+      break;
+
+   } /* switch */
+
+
+} /* kra2_set_fix_weights () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static FlintType kra2_compute_l2_norm (int Layer)
+{
+   register TopoPtrArray    topo_ptr = topo_layer[Layer-1];
+   register FlintType       sum = 0.0;
+   register FlintType       val;
+
+   while (*topo_ptr != NULL) {
+      val = (*topo_ptr)->Out.output;
+      sum += val * val;
+      topo_ptr++;
+   } /*while*/
+   return ( sqrt((double) sum) );
+}
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static int kra2_get_NoOfRecUnits (void)
+{
+   register struct Unit  *unit_ptr;
+   int                   count           = 0;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_SPECIAL_UNIT(unit_ptr)) {
+         count++;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (count);
+
+
+} /* kra2_get_NoOfRecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_InpUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit  *unit_ptr;
+
+   krui_err              ret_code = KRERR_NO_ERROR;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_INPUT_UNIT (unit_ptr)) {
+
+         if (!(CHECK_ACT_FUNC(unit_ptr, ART2_ACTF_INP))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC(unit_ptr, ART2_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         unit_ptr->lln = ART2_INP_LAY;
+         **topo_ptr = unit_ptr;
+         unit_ptr->flags |= UFLAG_REFRESH;
+         (*topo_ptr)++;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_InpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kra2_get_WUnits (TopoPtrArray *topo_ptr, int *no_of_w_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Unit   *unit_ptr2;
+   register struct Link   *link_ptr;
+   register struct Link   *link_ptr2;
+
+   bool                   has_link_to_inp    = FALSE;
+   bool                   has_outgoing_links = FALSE;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+
+   /* look for w units */
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+
+         /* check if unit has direct inputs and link to inp unit */
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } else {
+
+            has_link_to_inp = FALSE;
+            has_outgoing_links = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+               if (link_ptr->to->lln == ART2_INP_LAY) {
+                  has_link_to_inp = TRUE;
+                  break;
+               } /*if*/
+            } /*FOR_ALL_UNITS*/
+
+            /* check if unit_ptr->  has outgoing links */
+
+            FOR_ALL_UNITS (unit_ptr2) {
+               if (UNIT_HAS_SITES (unit_ptr2)) {
+                  TOPO_MSG_UNEXPECTED_SITES (unit_ptr2);
+               } else {
+                  FOR_ALL_LINKS (unit_ptr2, link_ptr2) {
+                     if (link_ptr2->to == unit_ptr) {
+                        has_outgoing_links = TRUE;
+                        break;
+                     } /*if*/
+                  } /*FOR_ALL_LINKS*/
+               } /*if*/
+
+               if (has_outgoing_links) {
+                  break;
+               } /*if*/
+            } /*FOR_ALL_UNITS*/
+
+            /* if unit has link to input unit and has outgoing links it
+               is a w unit
+            */
+            if (has_link_to_inp && has_outgoing_links) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_W))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (! (UNIT_REFRESHED (unit_ptr))) {
+                  unit_ptr->lln = ART2_W_LAY;
+                  (*no_of_w_units)++;
+                  **topo_ptr = unit_ptr;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+               } /*if*/
+
+            }  /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_WUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_XUnits (TopoPtrArray *topo_ptr, int *no_of_x_units)
+{
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+
+   bool                   has_link_to_w;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+     if (UNIT_HAS_SITES (unit_ptr)) {
+        TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+     } else {
+
+        has_link_to_w = FALSE;
+
+        FOR_ALL_LINKS (unit_ptr, link_ptr) {
+           if (link_ptr->to->lln == ART2_W_LAY) {
+              has_link_to_w = TRUE;
+              break;
+           } /*if*/
+        } /*FOR_ALL_LINKS*/
+     } /*if*/
+
+     if (has_link_to_w) {
+
+        if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_X))) {
+           TOPO_MSG_ACT_FUNC (unit_ptr);
+        } /*if*/
+
+        if (! (UNIT_REFRESHED (unit_ptr))) {
+           unit_ptr->lln = ART2_X_LAY;
+           (*no_of_x_units)++;
+           **topo_ptr = unit_ptr;
+           unit_ptr->flags |= UFLAG_REFRESH;
+           (*topo_ptr)++;
+        } /*if*/
+
+     } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_XUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_UUnits (TopoPtrArray *topo_ptr, int *no_of_u_units)
+{
+   register struct Unit    *unit_ptr1;
+   register struct Unit    *unit_ptr2 = NULL;
+   register struct Link    *link_ptr;
+
+   bool                    is_u_unit;
+
+   krui_err                ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr1) {
+
+      if (unit_ptr1->lln == ART2_W_LAY) {
+
+         is_u_unit = FALSE;
+
+         FOR_ALL_LINKS (unit_ptr1, link_ptr) {
+
+            unit_ptr2=link_ptr->to;
+            if (unit_ptr2->lln != ART2_INP_LAY) {
+               is_u_unit = TRUE;
+               break;
+            } /*if*/
+
+         } /*FOR_ALL_LINKS*/
+
+
+         if (is_u_unit) {
+
+            if (!(CHECK_ACT_FUNC (unit_ptr2, ART2_ACTF_U))) {
+               TOPO_MSG_ACT_FUNC (unit_ptr2);
+            } /*if*/
+
+            if (!(CHECK_OUT_FUNC (unit_ptr2, ART2_OUTFUNC))) {
+               TOPO_MSG_OUT_FUNC (unit_ptr2);
+            } /*if*/
+
+            if (! (UNIT_REFRESHED (unit_ptr2))) {
+               unit_ptr2->lln = ART2_U_LAY;
+               (*no_of_u_units)++;
+               **topo_ptr = unit_ptr2;
+               unit_ptr2->flags |= UFLAG_REFRESH;
+               (*topo_ptr)++;
+            } /*if*/
+
+         }  /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_UUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_VUnits (TopoPtrArray *topo_ptr, int *no_of_v_units)
+{
+   register struct Unit  *unit_ptr;
+   register struct Link  *link_ptr;
+   bool                  has_link_to_x;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } else {
+            has_link_to_x = FALSE;
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+               if (link_ptr->to->lln == ART2_X_LAY) {
+                  has_link_to_x = TRUE;
+                  break;
+               } /*if*/
+            } /*FOR_ALL_LINKS*/
+         } /*if*/
+
+         if (has_link_to_x) {
+
+           if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_V))) {
+              TOPO_MSG_ACT_FUNC (unit_ptr);
+           } /*if*/
+
+           if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+              TOPO_MSG_OUT_FUNC (unit_ptr);
+           } /*if*/
+
+           if (! (UNIT_REFRESHED (unit_ptr))) {
+              unit_ptr->lln = ART2_V_LAY;
+              (*no_of_v_units)++;
+              **topo_ptr = unit_ptr;
+              unit_ptr->flags |= UFLAG_REFRESH;
+              (*topo_ptr)++;
+           } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_VUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_PUnits (TopoPtrArray *topo_ptr, int *no_of_p_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+
+   bool                   is_p_unit;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } else {
+
+            is_p_unit = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               if ((unit_ptr->lln != ART2_W_LAY) &&
+                   (link_ptr->to->lln == ART2_U_LAY)
+                  )
+               {
+                  is_p_unit = TRUE;
+                  break;
+               } /*if*/
+
+            } /*FOR_ALL_UNITS*/
+
+            if (is_p_unit) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_P))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (! (UNIT_REFRESHED (unit_ptr))) {
+                  unit_ptr->lln = ART2_P_LAY;
+                  (*no_of_p_units)++;
+                  **topo_ptr = unit_ptr;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+               } /*if*/
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_PUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kra2_get_QUnits (TopoPtrArray *topo_ptr, int *no_of_q_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+
+   bool                   has_link_to_p;
+   bool                   has_link_to_other;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } else {
+
+            has_link_to_p     = FALSE;
+            has_link_to_other = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ART2_P_LAY:
+                  has_link_to_p = TRUE;
+                  break;
+               default:
+                  has_link_to_other = TRUE;
+                  break;
+               } /*switch*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if ((has_link_to_p) && (! has_link_to_other)) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_Q))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (! (UNIT_REFRESHED (unit_ptr))) {
+                  unit_ptr->lln = ART2_Q_LAY;
+                  (*no_of_q_units)++;
+                  **topo_ptr = unit_ptr;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+               } /*if*/
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_QUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_RUnits (TopoPtrArray *topo_ptr, int *no_of_r_units)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+
+   bool                   has_link_to_p;
+   bool                   has_link_to_inp;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+
+         if (UNIT_HAS_SITES (unit_ptr)) {
+            TOPO_MSG_UNEXPECTED_SITES (unit_ptr);
+         } else {
+
+            has_link_to_inp = FALSE;
+            has_link_to_p   = FALSE;
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               switch (link_ptr->to->lln) {
+               case ART2_INP_LAY:
+                  has_link_to_inp = TRUE;
+                  break;
+               case ART2_P_LAY:
+                  has_link_to_p = TRUE;
+                  break;
+               } /*switch*/
+
+            } /*FOR_ALL_LINKS*/
+
+            if (has_link_to_inp && has_link_to_p) {
+
+               if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_R))) {
+                  TOPO_MSG_ACT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+                  TOPO_MSG_OUT_FUNC (unit_ptr);
+               } /*if*/
+
+               if (! (UNIT_REFRESHED (unit_ptr))) {
+                  unit_ptr->lln = ART2_R_LAY;
+                  (*no_of_r_units)++;
+                  **topo_ptr = unit_ptr;
+                  unit_ptr->flags |= UFLAG_REFRESH;
+                  (*topo_ptr)++;
+               } /*if*/
+
+            } /*if*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_RUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_RecUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit  *unit_ptr;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if ((unit_ptr->lln == 0) && (IS_SPECIAL_UNIT (unit_ptr))) {
+
+         if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_REC))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (! (UNIT_REFRESHED (unit_ptr))) {
+            unit_ptr->lln = ART2_REC_LAY;
+            **topo_ptr = unit_ptr;
+            unit_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_RecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_get_RstUnits (TopoPtrArray *topo_ptr, int *no_of_rst_units)
+{
+   register struct Unit   *unit_ptr;
+
+   krui_err               ret_code   = KRERR_NO_ERROR;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0)  {
+
+         if (!(CHECK_ACT_FUNC (unit_ptr, ART2_ACTF_RST))) {
+            TOPO_MSG_ACT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (!(CHECK_OUT_FUNC (unit_ptr, ART2_OUTFUNC))) {
+            TOPO_MSG_OUT_FUNC (unit_ptr);
+         } /*if*/
+
+         if (! (UNIT_REFRESHED (unit_ptr))) {
+            unit_ptr->lln = ART2_RST_LAY;
+            (*no_of_rst_units)++;
+            **topo_ptr = unit_ptr;
+            unit_ptr->flags |= UFLAG_REFRESH;
+            (*topo_ptr)++;
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_get_RstUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err  kra2_TopoPtrArray (void)
+{
+   TopoPtrArray    topo_inp_w_sep,
+                   topo_w_x_sep,
+                   topo_x_u_sep,
+                   topo_u_v_sep,
+                   topo_v_p_sep,
+                   topo_p_q_sep,
+                   topo_q_r_sep,
+                   topo_r_rec_sep,
+                   topo_rec_rst_sep,
+                   topo_ptr_array_end;
+
+   krui_err        ret_code = KRERR_NO_ERROR;
+
+   topo_inp_w_sep   = topo_ptr_array + NoOfInputUnits + 1;
+   topo_w_x_sep     = topo_inp_w_sep + NoOfInputUnits + 1;
+   topo_x_u_sep     = topo_w_x_sep   + NoOfInputUnits + 1;
+   topo_u_v_sep     = topo_x_u_sep   + NoOfInputUnits + 1;
+   topo_v_p_sep     = topo_u_v_sep   + NoOfInputUnits + 1;
+   topo_p_q_sep     = topo_v_p_sep   + NoOfInputUnits + 1;
+   topo_q_r_sep     = topo_p_q_sep   + NoOfInputUnits + 1;
+   topo_r_rec_sep   = topo_q_r_sep   + NoOfInputUnits + 1;
+   topo_rec_rst_sep = topo_r_rec_sep + Art2_NoOfRecUnits + 1;
+   topo_ptr_array_end = topo_rec_rst_sep + Art2_NoOfRecUnits + 1;
+
+   if ((*topo_inp_w_sep   != NULL) ||
+       (*topo_w_x_sep     != NULL) ||
+       (*topo_x_u_sep     != NULL) ||
+       (*topo_u_v_sep     != NULL) ||
+       (*topo_v_p_sep     != NULL) ||
+       (*topo_p_q_sep     != NULL) ||
+       (*topo_q_r_sep     != NULL) ||
+       (*topo_r_rec_sep   != NULL) ||
+       (*topo_rec_rst_sep != NULL) ||
+       (*topo_ptr_array_end  != NULL)
+      )
+   {
+      ART2_RETURN_NET_ERROR (ret_code);
+   } /*if*/
+
+   return (ret_code);
+
+} /* kra2_TopoPtrArray () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err   kra2_LinksToInpUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+         topo_msg.error_code = KRERR_I_UNITS_CONNECT;
+         topo_msg.dest_error_unit = unit_ptr-unit_array;
+         topo_msg.src_error_unit = 0;
+         ret_code = topo_msg.error_code;
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToInpUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToWUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_inp, count_u;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_inp = 0;
+      count_u   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_INP_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_inp > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_inp++;
+            break;
+         case ART2_U_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_u > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_u++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_inp != 1) || (count_u != 1)) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToWUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToXUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_w;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_w   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_W_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_w > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_w++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if (count_w != 1) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToXUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToUUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_v;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_v   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_V_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_v > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_v++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if (count_v != 1) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToUUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToVUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_x, count_q;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_x   = 0;
+      count_q   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_X_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_x > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_x++;
+            break;
+         case ART2_Q_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_q > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_q++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_x != 1) || (count_q != 1)) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToVUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToPUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_u, count_rec;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_u   = 0;
+      count_rec = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_U_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_u > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_u++;
+            break;
+         case ART2_REC_LAY:
+            count_rec++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_u != 1) || (count_rec != Art2_NoOfRecUnits)) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToPUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToQUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_p;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_p   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_P_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_p > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_p++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if (count_p != 1) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToQUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToRUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_inp, count_p;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_inp = 0;
+      count_p   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_INP_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_inp > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_inp++;
+            break;
+         case ART2_P_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_p > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_p++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_inp != 1) || (count_p != 1)) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToRUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToRecUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_p, count_rst;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_p   = 0;
+      count_rst = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_P_LAY:
+            count_p++;
+            break;
+         case ART2_RST_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_rst > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_rst++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if ((count_p != NoOfInputUnits) || (count_rst != 1)) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToRecUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_LinksToRstUnits (TopoPtrArray *topo_ptr)
+{
+   register struct Unit   *unit_ptr;
+   register struct Link   *link_ptr;
+   int                    count_rec;
+   krui_err               ret_code = KRERR_NO_ERROR;
+
+   krart_deleteTouchFlags();
+
+   while ((unit_ptr = *(*topo_ptr)++) != NULL) {
+
+      count_rec   = 0;
+
+      FOR_ALL_LINKS (unit_ptr, link_ptr) {
+         switch (link_ptr->to->lln) {
+         case ART2_REC_LAY:
+            if ((UNIT_REFRESHED (link_ptr->to)) || (count_rec > 0)) {
+               TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            } /*if*/
+            link_ptr->to->flags |= UFLAG_REFRESH;
+            count_rec++;
+            break;
+         default:
+            TOPO_MSG_UNEXPECTED_LINK (link_ptr->to, unit_ptr);
+            break;
+         } /*switch*/
+      } /*FOR_ALL_LINKS*/
+
+      if (count_rec != 1) {
+         TOPO_MSG_LINK_MISSING (unit_ptr);
+      } /*if*/
+
+   } /*while*/
+
+   return (ret_code);
+
+} /* kra2_LinksToRstUnits () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_init_i_act (void)
+{
+   int                    ret_code = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+
+
+   /* set initial activation values to 0.0 and
+      copy actual activation values of input units into value_a field to
+      remember it
+   */
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+         unit_ptr->i_act = 0.0;
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* kra2_init_i_act () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+static krui_err kra2_init_fix_weights (void)
+{
+   int                    ret_code  = KRERR_NO_ERROR;
+
+   register struct Unit   *unit_ptr;
+   register struct Site   *site_ptr;
+   register struct Link   *link_ptr;
+
+
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (UNIT_HAS_INPUTS (unit_ptr)) {
+
+         if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)) {
+
+            FOR_ALL_LINKS (unit_ptr, link_ptr) {
+
+               kra2_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_LINKS*/
+
+         } else {
+
+            FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr) {
+
+               kra2_set_fix_weight (link_ptr->to, unit_ptr, &(link_ptr->weight));
+
+            } /*FOR_ALL_SITES_AND_LINKS*/
+
+         } /*if*/
+
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+
+   return (ret_code);
+
+
+} /* kra2_init_fix_weights () */
+/*___________________________________________________________________________*/
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_art2.h snort-2.3.3.new/src/kernel_snns/kr_art2.h
--- snort-2.3.3/src/kernel_snns/kr_art2.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art2.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,275 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art2.h,v $
+  SHORTNAME      : kr_art2 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART2-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:37 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART2_DEFINED_
+#define  _KR_ART2_DEFINED_
+
+
+/************* Global variables
+*************/
+extern int              Art2_NoOfRecUnits;
+extern  struct Unit     *Art2_cl_unit;
+extern  struct Unit     *Art2_nc_unit;
+
+/**************** Function Prototypes
+****************/
+
+/***************************************************************************/
+/* kra2_init_propagate ()
+
+   initializes net for propagation.
+*/
+extern  krui_err  kra2_init_propagate (
+                                      void
+                                     );
+
+
+/***************************************************************************/
+/* kra2_sort ()
+
+   Set logical layer numbers and logical unit numbers in an ART2 network.
+   Also this function checks, whether the network is an ART2 network or not.
+   Returns an error code, when actual network is no ART2 architecture.
+*/
+extern  krui_err  kra2_sort (
+                            void
+                           );
+
+
+
+/***************************************************************************/
+/* kra2_set_params ()
+
+   Sets the value of Parameters rho, a, b, c, d, theta, which are stored locally
+   in this Module.
+*/
+extern  krui_err kra2_set_params (
+                                FlintType rho,
+                                FlintType param_a,
+                                FlintType param_b,
+                                FlintType param_c,
+                                FlintType param_d,
+                                FlintType theta
+                               );
+
+
+/***************************************************************************/
+/* kra2_get_rho ()
+
+   returns the actual value of Parameter rho.
+*/
+extern  FlintType kra2_get_rho (
+                               void
+                              );
+
+/***************************************************************************/
+/* kra2_get_a ()
+
+   returns the actual value of Parameter a.
+*/
+ FlintType kra2_get_a (
+                             void
+                            );
+
+/***************************************************************************/
+/* kra2_get_b ()
+
+   returns the actual value of Parameter b.
+*/
+extern  FlintType kra2_get_b (
+                             void
+                            );
+
+/***************************************************************************/
+/* kra2_get_c ()
+
+   returns the actual value of Parameter c.
+*/
+extern  FlintType kra2_get_c (
+                             void
+                            );
+
+
+/***************************************************************************/
+/* kra2_get_d ()
+
+   returns the actual value of Parameter d.
+*/
+extern  FlintType kra2_get_d (
+                             void
+                            );
+
+
+/***************************************************************************/
+/* kra2_get_theta ()
+
+   returns the actual value of Parameter theta.
+*/
+extern  FlintType kra2_get_theta (
+                                 void
+                                );
+
+
+/***************************************************************************/
+/* kra2_checkReset ()
+
+   checks if global reset has to be sent into network
+*/
+extern  void kra2_checkReset (
+                             void
+                            );
+
+
+
+
+/***************************************************************************/
+/* kra2_Reset ()
+
+   returns TRUE if global reset is actually active, else FALSE
+*/
+extern  bool kra2_Reset (
+                        void
+                       );
+
+
+
+
+/***************************************************************************/
+/* kra2_init_pattern ()
+
+   sets current phase to bottom up
+*/
+extern  void kra2_init_pattern (
+                               void
+                              );
+
+
+
+/***************************************************************************/
+/* kra2_top_dn_phase ()
+
+   sets current phase to bottom up
+*/
+extern  bool kra2_topdn_phase (
+                             void
+                            );
+
+
+
+/***************************************************************************/
+/* kra2_compute_norms ()
+
+   computes the L2 vector norms of inp, w, u, v, p, r
+*/
+
+extern  void kra2_compute_norms (
+                                void
+                               );
+
+
+
+
+
+
+/***************************************************************************/
+/* kra2_L2_Norm ()
+
+   returns the L2-Norm of a vector which is determined by the number
+   of the Layer in the topo_ptr_array.
+*/
+
+extern  FlintType kra2_L2_Norm (
+                               int VectorNr
+                              );
+
+
+
+/***************************************************************************/
+/* kra2_classified ()
+
+   returns TRUE if net has classified input pattern
+*/
+extern  bool kra2_classified (
+                             void
+                            );
+
+
+
+/***************************************************************************/
+/* kra2_not_classifiable ()
+
+   returns TRUE if net is not able to classify input pattern
+*/
+extern  bool kra2_not_classifiable (
+                                   void
+                                  );
+
+
+
+/***************************************************************************/
+/* kra2_save_for_stability_check ()
+
+   saves informaion of relevant unit in F1-Layer for stability check
+*/
+extern  void kra2_save_for_stability_check (
+                                           void
+                                          );
+
+
+
+/***************************************************************************/
+/* kra2_check_f1_stability ()
+
+   checks, if F1-Layer is stable.
+*/
+extern  void kra2_check_f1_stability (
+                                     void
+                                    );
+
+
+
+
+
+/***************************************************************************/
+/* kra2_f1_stable ()
+
+   returns TRUE if F1-Layer is stable
+*/
+extern  bool kra2_f1_stable (
+                            void
+                           );
+
+
+
+
+/***************************************************************************/
+/* kra2_getClassNo ()
+
+   Returns the number of the actually activated class J, 1 <= J <= M
+*/
+extern  int  kra2_getClassNo (void
+                            );
+
+
+
+
+#endif 
+
+
+/* 275 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_art2.ph snort-2.3.3.new/src/kernel_snns/kr_art2.ph
--- snort-2.3.3/src/kernel_snns/kr_art2.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art2.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,518 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art2.ph,v $
+  SHORTNAME      : kr_art2 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART2-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:38 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART2_DEFINED_
+#define  _KR_ART2_DEFINED_
+
+/* begin global definition section */
+
+/************* Global variables
+*************/
+ int              Art2_NoOfRecUnits;
+ struct Unit     *Art2_cl_unit;
+ struct Unit     *Art2_nc_unit;
+
+/**************** Function Prototypes
+****************/
+
+/***************************************************************************/
+/* kra2_init_propagate ()
+
+   initializes net for propagation.
+*/
+ krui_err  kra2_init_propagate (
+                                      void
+                                     );
+
+
+/***************************************************************************/
+/* kra2_sort ()
+
+   Set logical layer numbers and logical unit numbers in an ART2 network.
+   Also this function checks, whether the network is an ART2 network or not.
+   Returns an error code, when actual network is no ART2 architecture.
+*/
+ krui_err  kra2_sort (
+                            void
+                           );
+
+
+
+/***************************************************************************/
+/* kra2_set_params ()
+
+   Sets the value of Parameters rho, a, b, c, d, theta, which are stored locally
+   in this Module.
+*/
+ krui_err kra2_set_params (
+                                FlintType rho,
+                                FlintType param_a,
+                                FlintType param_b,
+                                FlintType param_c,
+                                FlintType param_d,
+                                FlintType theta
+                               );
+
+
+/***************************************************************************/
+/* kra2_get_rho ()
+
+   returns the actual value of Parameter rho.
+*/
+ FlintType kra2_get_rho (
+                               void
+                              );
+
+/***************************************************************************/
+/* kra2_get_a ()
+
+   returns the actual value of Parameter a.
+*/
+ FlintType kra2_get_a (
+                             void
+                            );
+
+/***************************************************************************/
+/* kra2_get_b ()
+
+   returns the actual value of Parameter b.
+*/
+ FlintType kra2_get_b (
+                             void
+                            );
+
+/***************************************************************************/
+/* kra2_get_c ()
+
+   returns the actual value of Parameter c.
+*/
+ FlintType kra2_get_c (
+                             void
+                            );
+
+
+/***************************************************************************/
+/* kra2_get_d ()
+
+   returns the actual value of Parameter d.
+*/
+ FlintType kra2_get_d (
+                             void
+                            );
+
+
+/***************************************************************************/
+/* kra2_get_theta ()
+
+   returns the actual value of Parameter theta.
+*/
+ FlintType kra2_get_theta (
+                                 void
+                                );
+
+
+/***************************************************************************/
+/* kra2_checkReset ()
+
+   checks if global reset has to be sent into network
+*/
+ void kra2_checkReset (
+                             void
+                            );
+
+
+
+
+/***************************************************************************/
+/* kra2_Reset ()
+
+   returns TRUE if global reset is actually active, else FALSE
+*/
+ bool kra2_Reset (
+                        void
+                       );
+
+
+
+
+/***************************************************************************/
+/* kra2_init_pattern ()
+
+   sets current phase to bottom up
+*/
+ void kra2_init_pattern (
+                               void
+                              );
+
+
+
+/***************************************************************************/
+/* kra2_top_dn_phase ()
+
+   sets current phase to bottom up
+*/
+ bool kra2_topdn_phase (
+                             void
+                            );
+
+
+
+/***************************************************************************/
+/* kra2_compute_norms ()
+
+   computes the L2 vector norms of inp, w, u, v, p, r
+*/
+
+ void kra2_compute_norms (
+                                void
+                               );
+
+
+
+
+
+
+/***************************************************************************/
+/* kra2_L2_Norm ()
+
+   returns the L2-Norm of a vector which is determined by the number
+   of the Layer in the topo_ptr_array.
+*/
+
+ FlintType kra2_L2_Norm (
+                               int VectorNr
+                              );
+
+
+
+/***************************************************************************/
+/* kra2_classified ()
+
+   returns TRUE if net has classified input pattern
+*/
+ bool kra2_classified (
+                             void
+                            );
+
+
+
+/***************************************************************************/
+/* kra2_not_classifiable ()
+
+   returns TRUE if net is not able to classify input pattern
+*/
+ bool kra2_not_classifiable (
+                                   void
+                                  );
+
+
+
+/***************************************************************************/
+/* kra2_save_for_stability_check ()
+
+   saves informaion of relevant unit in F1-Layer for stability check
+*/
+ void kra2_save_for_stability_check (
+                                           void
+                                          );
+
+
+
+/***************************************************************************/
+/* kra2_check_f1_stability ()
+
+   checks, if F1-Layer is stable.
+*/
+ void kra2_check_f1_stability (
+                                     void
+                                    );
+
+
+
+
+
+/***************************************************************************/
+/* kra2_f1_stable ()
+
+   returns TRUE if F1-Layer is stable
+*/
+ bool kra2_f1_stable (
+                            void
+                           );
+
+
+
+
+/***************************************************************************/
+/* kra2_getClassNo ()
+
+   Returns the number of the actually activated class J, 1 <= J <= M
+*/
+ int  kra2_getClassNo (void
+                            );
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+
+/*#################################################
+
+GROUP: local defines
+
+#################################################*/
+
+
+
+#define MIN_NO_OF_DELAY_STEPS   5                /* when checking if pattern has been
+                                                    classified F1 layer has to be stable
+                                                    over MIN_NO_OF_DELAY_STEPS cycles
+                                                 */
+
+#define F1_STABILITY_PARAM      0.0001           /* if difference of activation in all
+                                                    u units between two prop cycles are
+                                                    less or equal to F1_STABILITY_PARAM
+                                                    then F1 is stable
+                                                 */
+
+
+/*#################################################
+
+GROUP: global variables, local to this module
+
+#################################################*/
+
+/* Global variable for parameter values */
+
+static FlintType      Param_rho   = 0.8;
+static FlintType      Param_a     = 0.0;
+static FlintType      Param_b     = 0.0;
+static FlintType      Param_c     = 0.0;
+static FlintType      Param_d     = 0.0;
+static FlintType      Param_theta = 0.5;
+
+/* Global variables for vector norms */
+
+static FlintType      NormInp     = 0.0;
+static FlintType      NormW       = 0.0;
+static FlintType      NormU       = 0.0;
+static FlintType      NormV       = 0.0;
+static FlintType      NormP       = 0.0;
+static FlintType      NormR       = 0.0;
+
+
+static TopoPtrArray   topo_layer[10];      /* contains pointers to first pointer
+                                              to inp unit, first pointer
+                                              to w unit, x unit ... in the topo
+                                              pointer array
+                                           */
+
+static int            NoOfDelaySteps = 0;
+
+static bool           GlobalReset     = FALSE;
+static bool           TopDownPhase;
+static bool           f1_stable = FALSE;   /* becomes TRUE if F1-Layer is stable
+                                              (see kra2_check_f1_stability)
+                                           */
+
+/* functions that are local to this module
+*/
+
+static void   kra2_set_fix_weight (
+
+                                   struct Unit   *src_unit,
+                                   struct Unit   *trgt_unit,
+                                   FlintType     *weight
+
+                                  );
+
+
+static FlintType  kra2_compute_l2_norm (
+
+                                        int Layer
+
+                                       );
+
+static int  kra2_get_NoOfRecUnits (
+
+                                   void
+
+                                  );
+
+
+static krui_err  kra2_get_InpUnits (
+
+                                    TopoPtrArray  *topo_ptr
+
+                                   );
+
+
+static krui_err  kra2_get_WUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_w_units
+
+                                 );
+
+
+static krui_err  kra2_get_XUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_x_units
+
+                                 );
+
+
+static krui_err  kra2_get_UUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_u_units
+
+                                 );
+
+
+static krui_err  kra2_get_VUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_v_units
+
+                                 );
+
+
+static krui_err  kra2_get_PUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_p_units
+
+                                 );
+
+
+static krui_err  kra2_get_QUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_q_units
+
+                                 );
+
+
+static krui_err  kra2_get_RUnits (
+
+                                  TopoPtrArray *topo_ptr,
+                                  int          *no_of_r_units
+
+                                 );
+
+
+static krui_err  kra2_get_RecUnits (
+
+                                    TopoPtrArray  *topo_ptr
+
+                                   );
+
+
+static krui_err  kra2_get_RstUnits (
+
+                                    TopoPtrArray  *topo_ptr,
+                                    int          *no_of_rst_units
+
+                                   );
+
+
+static krui_err  kra2_TopoPtrArray (
+
+                                    void
+
+                                   );
+
+
+static krui_err  kra2_LinksToInpUnits (
+
+                                       TopoPtrArray *topo_ptr
+
+                                      );
+
+
+static krui_err  kra2_LinksToWUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToXUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToUUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToVUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToPUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToQUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToRUnits (
+
+                                     TopoPtrArray *topo_ptr
+
+                                    );
+
+
+static krui_err  kra2_LinksToRecUnits (
+
+                                       TopoPtrArray *topo_ptr
+
+                                      );
+
+
+static krui_err  kra2_LinksToRstUnits (
+                                       TopoPtrArray *topo_ptr
+                                      );
+
+static krui_err kra2_init_i_act (void);
+static krui_err kra2_init_fix_weights (void);
+
+/* end private definition section */
+
+#endif 
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_art.c snort-2.3.3.new/src/kernel_snns/kr_art.c
--- snort-2.3.3/src/kernel_snns/kr_art.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,335 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Functions for ART networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:34 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+
+#ifndef NULL /* if NULL pointer is not defined include stdio.h */
+#include <stdio.h>
+#endif
+
+#include "krart_df.h"   /*  Definitions for ART networks */
+
+#include "kr_const.h"
+#include "kr_mac.h"
+#include "kr_def.h"
+#include "kr_typ.h"
+#include "kr_funcs.h"
+#include "kernel.h"
+#include "glob_typ.h"
+#include "kr_art.ph"
+
+/* declaration of module functions
+*/
+
+/**************** functions, visible to other modules **************************/
+
+/*#################################################
+
+GROUP: ART kernel functions
+       by Kai-Uwe Herrmann
+
+#################################################*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* initialization of activations of all input units according to their i_act
+   value. this initialization is necessary each time a new pattern is
+   presented to the network.
+*/
+
+krui_err krart_reset_activations (void)
+{
+   krui_err        ret_code = KRERR_NO_ERROR;
+
+   struct Unit     *unit_ptr;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (! IS_INPUT_UNIT (unit_ptr)) {
+         unit_ptr->act = unit_ptr->i_act;
+      } /*if*/
+
+      /* The output is set for input units, too
+      */
+      unit_ptr->Out.output = unit_ptr->act;
+
+   } /*FOR_ALL_UNITS*/
+
+   return (ret_code);
+
+} /* krart_reset_activations () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* synchronous propagation (1 cycle) i.e. each unit puts its output onto
+   its outgoing links and calculates its new activation.
+*/
+void  krart_prop_synch (void)
+{
+  struct Unit    *unit_ptr;
+
+  /* calculate new activations of non input units
+  */
+
+  FOR_ALL_UNITS (unit_ptr) {
+
+     if (!IS_INPUT_UNIT(unit_ptr)) {
+        unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+     } /*if*/
+
+  } /*FOR_ALL_UNITS*/
+
+  /* set new output values
+  */
+
+  FOR_ALL_UNITS (unit_ptr) {
+
+     if (unit_ptr->out_func == OUT_IDENTITY) {
+        unit_ptr->Out.output = unit_ptr->act;
+     } else {
+        unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+     } /*if*/
+
+  } /*FOR_ALL_UNITS*/
+
+} /* krart_prop_synch */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+/* get the winner of the last propagation cycle. returns a pointer to
+   the winning recognition unit.
+*/
+struct Unit  *krart_get_winner (TopoPtrArray wta_layer, FlintType winner_output)
+                            /* points to first pointer to recognition unit
+                            */
+                                /* output value of the winning unit */
+
+{
+   TopoPtrArray   topo_ptr;
+
+   struct Unit    *unit_ptr,
+                  *winner_ptr = NULL;  /* points to the unit with the maximal
+                                          activation
+                                       */
+
+   FlintType      max_out  = 0.0;      /* contains the maximal activation
+                                       */
+
+
+   topo_ptr = wta_layer;
+
+   while ((unit_ptr = *topo_ptr++) != NULL) {
+
+      if (unit_ptr->Out.output > max_out) {
+         max_out    = unit_ptr->Out.output;
+         winner_ptr = unit_ptr;
+         continue;
+      } /*if*/
+
+      /* The foollowing statements assure, that a winner is returned, if
+         no Reset signal is sent from Reset general unit. So we will
+         find a winner, even if the winner unit's activation is 0.0
+         This is neccessary to assure, that all recognition units are
+         tested for to get a 'not classifiable' signal when all and really
+         all local reset units are turned on.
+      */
+      if ((winner_ptr == NULL) && (unit_ptr->Out.output >= max_out)) {
+         max_out    = unit_ptr->Out.output;
+         winner_ptr = unit_ptr;
+      } /*if*/
+
+   } /*while*/
+
+
+
+   /* set activation and output of winner unit to 1.0, the one of the
+      other recognition units to 0.0
+   */
+
+   topo_ptr = wta_layer;
+
+   while ((unit_ptr = *topo_ptr++) != NULL) {
+
+      if (unit_ptr != winner_ptr) {
+         unit_ptr->Out.output = 0.0;
+      } else {
+         unit_ptr->Out.output = winner_output;
+      } /*if*/
+
+   } /*while*/
+
+
+   return (winner_ptr);
+
+} /* krart_get__winner () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  krart_deleteTouchFlags (void)
+{
+   register struct Unit *unit_ptr;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      /* delete touch flags
+      */
+      unit_ptr->flags &= ~UFLAG_REFRESH;
+
+   } /*FOR_ALL_UNITS*/
+
+} /* krart_deleteTouchFlags () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  krart_init_sorting (void)
+{
+   register struct Unit *unit_ptr;
+
+
+   krart_deleteTouchFlags ();
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      /* init lln and lun
+      */
+      unit_ptr->lln = unit_ptr->lun = 0;
+
+   } /*FOR_ALL_UNITS*/
+
+} /* krart_init_sorting () */
+/*___________________________________________________________________________*/
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+int  krart_get_NoOfInputUnits (void)
+{
+   register struct Unit  *unit_ptr;
+   int                   count           = 0;
+
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (IS_INPUT_UNIT(unit_ptr)) {
+         count++;
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (count);
+
+
+} /* krart_get_NoOfInputUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool   krart_check_undeterminedUnits (void)
+{
+   register struct Unit   *unit_ptr;
+
+   FOR_ALL_UNITS (unit_ptr) {
+
+      if (unit_ptr->lln == 0) {
+         TOPO_MSG_UNDETERMINED_UNIT (unit_ptr);
+         return (TRUE);
+      } /*if*/
+
+   } /*FOR_ALL_UNITS*/
+
+   return (FALSE);
+
+} /* krart_check_undeterminedUnits () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+void  krart_save_inp_pat (TopoPtrArray topo_inp_ptr)
+{
+  TopoPtrArray   topo_ptr = topo_inp_ptr;
+
+  while (*topo_ptr != NULL) {
+     if (IS_INPUT_UNIT (*topo_ptr)) {
+        (*topo_ptr)->value_a = (*topo_ptr)->act;
+     } /*if*/
+     topo_ptr++;
+  } /*while*/
+  return;
+} /* krart_save_inp_pat () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
+bool  krart_inp_pat_changed (TopoPtrArray topo_inp_ptr)
+{
+
+   TopoPtrArray    topo_ptr = topo_inp_ptr;
+
+   while (*topo_ptr != NULL) {
+      if ((IS_INPUT_UNIT(*topo_ptr)) && ((*topo_ptr)->value_a != (*topo_ptr)->act)) {
+         return (TRUE);
+      } /*if*/
+      topo_ptr++;
+   } /*FOR_ALL_UNITS*/
+
+   return (FALSE);
+} /* krart_inp_pat_changed () */
+/*___________________________________________________________________________*/
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/krart_df.h snort-2.3.3.new/src/kernel_snns/krart_df.h
--- snort-2.3.3/src/kernel_snns/krart_df.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/krart_df.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,589 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/krart_df.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel definitions for ART-Networks 
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:19 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef __KR_ART_DEF
+#define __KR_ART_DEF
+
+
+/* Logical Layers for ART1 networks
+*/
+#define ART1_INP_LAY 1     /* The ART1 Input layer */
+#define ART1_CMP_LAY 2     /* The ART1 Comparison layer */
+#define ART1_REC_LAY 3     /* The ART1 Recognition layer */
+#define ART1_DEL_LAY 4     /* The ART1 Delay layer */
+#define ART1_RST_LAY 5     /* The ART1 Reset layer */
+#define ART1_SPEC_LAY 6    /* The ART1 Special unit layer */
+
+
+/* Logical Layers for ART2 networks
+*/
+#define ART2_INP_LAY    1   /* The ART2 Input Layer */
+#define ART2_W_LAY      2   /* The ART2 W Units (belonging to F1) */
+#define ART2_X_LAY      3   /* The ART2 X Units (belonging to F1) */
+#define ART2_U_LAY      4   /* The ART2 U Units (belonging to F1) */
+#define ART2_V_LAY      5   /* The ART2 V Units (belonging to F1) */
+#define ART2_P_LAY      6   /* The ART2 P Units (belonging to F1) */
+#define ART2_Q_LAY      7   /* The ART2 Q Units (belonging to F1) */
+#define ART2_R_LAY      8   /* The ART2 R Units (belonging to F1) */
+#define ART2_REC_LAY    9   /* The ART2 Recognition Layer */
+#define ART2_RST_LAY   10   /* The ART2 Reset Layer */
+
+/* Logical Layers for ARTMAP networks
+*/
+#define ARTMAP_INPa_LAY    1       /* the artmap-arta input layer */
+#define ARTMAP_CMPa_LAY    2       /* the artmap-arta comparison layer */
+#define ARTMAP_RECa_LAY    3       /* the artmap-arta recognition layer */
+#define ARTMAP_DELa_LAY    4       /* the artmap-arta delay layer */
+#define ARTMAP_RSTa_LAY    5       /* the artmap-arta local reset layer */
+#define ARTMAP_SPECa_LAY   6       /* the artmap-arta special unit layer */
+#define ARTMAP_INPb_LAY    7       /* the artmap-artb input layer */
+#define ARTMAP_CMPb_LAY    8       /* the artmap-artb comparison layer */
+#define ARTMAP_RECb_LAY    9       /* the artmap-artb recognition layer */
+#define ARTMAP_DELb_LAY   10       /* the artmap-artb delay layer */
+#define ARTMAP_RSTb_LAY   11       /* the artmap-artb local reset layer */
+#define ARTMAP_SPECb_LAY  12       /* the artmap-artb special unit layer */
+#define ARTMAP_MAP_LAY    13       /* the artmap map layer */
+#define ARTMAP_SPEC_LAY   14       /* the artmap special unit layer */
+
+/* Logical unit numbers for ART1 networks
+*/
+
+  /* special units */
+#define ART1_NO_OF_SPEC_UNITS   8
+
+#define ART1_CL_UNIT    1
+#define ART1_NCL_UNIT   2
+#define ART1_G1_UNIT    3
+#define ART1_RI_UNIT    4
+#define ART1_RC_UNIT    5
+#define ART1_RG_UNIT    6
+#define ART1_RHO_UNIT   7
+#define ART1_G2_UNIT    8
+
+  /* delay type units */
+#define ART1_DEL_REC_UNIT         1
+#define ART1_D1_UNIT              2
+#define ART1_D2_UNIT              3
+#define ART1_D3_UNIT              4
+
+
+/* Logical unit numbers for ARTMAP networks
+*/
+
+  /* special units */
+#define ARTMAP_NO_OF_SPECa_UNITS   8
+
+#define ARTMAP_CLa_UNIT   1
+#define ARTMAP_NCa_UNIT   2
+#define ARTMAP_G1a_UNIT   3
+#define ARTMAP_RIa_UNIT   4
+#define ARTMAP_RCa_UNIT   5
+#define ARTMAP_RGa_UNIT   6
+#define ARTMAP_RHOa_UNIT  7
+#define ARTMAP_G2a_UNIT   8
+
+
+#define ARTMAP_NO_OF_SPECb_UNITS   8
+
+#define ARTMAP_CLb_UNIT   1
+#define ARTMAP_NCb_UNIT   2
+#define ARTMAP_G1b_UNIT   3
+#define ARTMAP_RIb_UNIT   4
+#define ARTMAP_RCb_UNIT   5
+#define ARTMAP_RGb_UNIT   6
+#define ARTMAP_RHOb_UNIT  7
+#define ARTMAP_G2b_UNIT   8
+
+
+#define ARTMAP_NO_OF_SPEC_UNITS   10
+
+#define ARTMAP_D1_UNIT    1
+#define ARTMAP_CL_UNIT    2
+#define ARTMAP_NC_UNIT    3
+#define ARTMAP_G_UNIT     4
+#define ARTMAP_RB_UNIT    5
+#define ARTMAP_RM_UNIT    6
+#define ARTMAP_RG_UNIT    7
+#define ARTMAP_RHO_UNIT   8
+#define ARTMAP_QU_UNIT    9
+#define ARTMAP_DRHO_UNIT 10
+
+  /* delay type units */
+#define ARTMAP_DELa_REC_UNIT   1
+#define ARTMAP_D1a_UNIT        2
+#define ARTMAP_D2a_UNIT        3
+#define ARTMAP_D3a_UNIT        4
+
+#define ARTMAP_DELb_REC_UNIT   1
+#define ARTMAP_D1b_UNIT        2
+#define ARTMAP_D2b_UNIT        3
+#define ARTMAP_D3b_UNIT        4
+
+
+
+
+/* Link initialization values for the links of an ART1 network.
+   The last two elements of the name indicate the logical source layer
+   and the logical target layer
+*/
+
+  /* fix links for ART1 */
+#define ART1_LINK_INP_CMP   1.0
+#define ART1_LINK_INP_G1    1.0
+#define ART1_LINK_INP_RI    1.0
+#define ART1_LINK_INP_G2    1.0
+#define ART1_LINK_CMP_RC    1.0
+#define ART1_LINK_REC_G1    1.0
+#define ART1_LINK_REC_DEL   2.0
+#define ART1_LINK_DEL_DEL   1.0
+#define ART1_LINK_DEL_RST   1.0
+#define ART1_LINK_DEL_CL    1.0
+#define ART1_LINK_RST_REC   -2.0
+#define ART1_LINK_RST_RST   1.0
+#define ART1_LINK_RST_NCL   1.0
+#define ART1_LINK_G1_CMP    1.0
+#define ART1_LINK_RI_RG     -1.0
+#define ART1_LINK_RC_RG     1.0
+#define ART1_LINK_RG_RST    1.0
+#define ART1_LINK_RG_REC    -2.0
+#define ART1_LINK_RG_CL     -1.0
+#define ART1_LINK_RHO_RI    1.0
+#define ART1_LINK_RHO_RHO   1.0
+#define ART1_LINK_G2_REC    -2.0
+#define ART1_LINK_G2_CL     1.0
+
+
+/* trainable links for ART1 */
+  /* the initial values of the bottom up link weights should be
+             0 < weight < (1 / (beta + |I|))
+             where beta is a value > 0.0 and should not be too big,
+                   I is the number of ones in the binary input vector.
+                   gamma has to be choosen > 1.0.
+  */
+#define ART1_LINK_CMP_REC(beta,gamma)    (1.0 / ((beta) + (gamma) * NoOfInputUnits))
+#define ART1_LINK_DEL_CMP                1.0
+
+  /* Formulas to adjust the link weights in an ART1 network
+  */
+#define ART1_ADJUST_LINK_DEL_CMP(unit)                      (unit->act)
+#define ART1_ADJUST_LINK_CMP_REC(unit, beta, norm) \
+                                       ((unit->act)/((beta) + (norm)))
+
+
+
+
+/* fix links for ART2 */
+#define ART2_LINK_INP_W               1.0
+#define ART2_LINK_U_W(a)              a
+#define ART2_LINK_W_X                 1.0
+#define ART2_LINK_V_U                 1.0
+#define ART2_LINK_X_V                 1.0
+#define ART2_LINK_Q_V(b)              b
+#define ART2_LINK_U_P                 1.0
+#define ART2_LINK_P_Q                 1.0
+#define ART2_LINK_P_R(c)              c
+#define ART2_LINK_INP_R               1.0
+
+#define ART2_LINK_RST_REC(d)         -(1/(1-(d)))-10
+#define ART2_LINK_REC_RST             1.0
+#define ART2_LINK_RST_RST             1.0
+
+
+
+/* trainable links for ART2 */
+#define ART2_LINK_P_REC(param_d,gamma) (1.0/(gamma*(1-param_d)*sqrt((double) NoOfInputUnits)))
+#define ART2_LINK_REC_P                0.0
+
+  /* Formulas to adjust the link weights in an ART2 network
+  */
+#define ART2_ADJUST_LINK_REC_P(unit_u, d)       (unit_u->act / (1-d))
+#define ART2_ADJUST_LINK_P_REC(unit_u, d)       (unit_u->act / (1-d))
+
+
+
+
+
+/* fix links for ARTMAP */
+#define ARTMAP_LINK_INPa_CMPa   1.0
+#define ARTMAP_LINK_INPa_G1a    1.0
+#define ARTMAP_LINK_INPa_RIa    1.0
+#define ARTMAP_LINK_INPa_G2a    1.0
+#define ARTMAP_LINK_CMPa_RCa    1.0
+#define ARTMAP_LINK_RECa_G1a    1.0
+#define ARTMAP_LINK_RECa_DELa   2.0
+#define ARTMAP_LINK_DELa_DELa   1.0
+#define ARTMAP_LINK_DELa_RSTa   1.0
+#define ARTMAP_LINK_DELa_CLa    1.0
+#define ARTMAP_LINK_RSTa_RECa  -2.0
+#define ARTMAP_LINK_RSTa_RSTa   1.0
+#define ARTMAP_LINK_RSTa_NCa    1.0
+#define ARTMAP_LINK_G1a_CMPa    1.0
+#define ARTMAP_LINK_RIa_RGa    -1.0
+#define ARTMAP_LINK_RCa_RGa     1.0
+#define ARTMAP_LINK_RGa_RSTa    1.0
+#define ARTMAP_LINK_RGa_RECa   -2.0
+#define ARTMAP_LINK_RGa_CLa    -1.0
+#define ARTMAP_LINK_RGa_DRHO   -1.0
+#define ARTMAP_LINK_RHOa_RIa    1.0
+#define ARTMAP_LINK_RHOa_RHOa   1.0
+#define ARTMAP_LINK_G2a_RECa   -2.0
+#define ARTMAP_LINK_G2a_CLa     1.0
+
+#define ARTMAP_LINK_INPb_CMPb   1.0
+#define ARTMAP_LINK_INPb_G1b    1.0
+#define ARTMAP_LINK_INPb_RIb    1.0
+#define ARTMAP_LINK_INPb_G2b    1.0
+#define ARTMAP_LINK_CMPb_RCb    1.0
+#define ARTMAP_LINK_RECb_G1b    1.0
+#define ARTMAP_LINK_RECb_DELb   2.0
+#define ARTMAP_LINK_DELb_DELb   1.0
+#define ARTMAP_LINK_MAP_DELb    1.0
+#define ARTMAP_LINK_DELb_RSTb   1.0
+#define ARTMAP_LINK_DELb_CLb    1.0
+#define ARTMAP_LINK_RSTb_RECb  -2.0
+#define ARTMAP_LINK_RSTb_RSTb   1.0
+#define ARTMAP_LINK_RSTb_NCb    1.0
+#define ARTMAP_LINK_G1b_CMPb    1.0
+#define ARTMAP_LINK_RIb_RGb    -1.0
+#define ARTMAP_LINK_RCb_RGb     1.0
+#define ARTMAP_LINK_RGb_RSTb    1.0
+#define ARTMAP_LINK_RGb_RECb   -2.0
+#define ARTMAP_LINK_RGb_CLb    -1.0
+#define ARTMAP_LINK_RHOb_RIb    1.0
+#define ARTMAP_LINK_RHOb_RHOb   1.0
+#define ARTMAP_LINK_G2b_RECb   -2.0
+#define ARTMAP_LINK_G2b_CLb     1.0
+
+#define ARTMAP_LINK_DELb_MAP    1.0
+#define ARTMAP_LINK_G_MAP       1.0
+#define ARTMAP_LINK_DELb_D1     1.0
+#define ARTMAP_LINK_CLa_CL      1.0
+#define ARTMAP_LINK_CLb_CL      1.0
+#define ARTMAP_LINK_RG_CL      -2.0
+#define ARTMAP_LINK_NCa_NC      1.0
+#define ARTMAP_LINK_NCb_NC      1.0
+#define ARTMAP_LINK_RECa_G      1.0
+#define ARTMAP_LINK_RECb_G      1.0
+#define ARTMAP_LINK_D1_RB       1.0
+#define ARTMAP_LINK_RHO_RB      1.0
+#define ARTMAP_LINK_MAP_RM      1.0
+#define ARTMAP_LINK_RB_RG      -1.0
+#define ARTMAP_LINK_RM_RG       1.0
+#define ARTMAP_LINK_RHO_RHO     1.0
+#define ARTMAP_LINK_INPa_QU     1.0
+#define ARTMAP_LINK_RHO_RB      1.0
+#define ARTMAP_LINK_INPa_QU     1.0
+#define ARTMAP_LINK_CMPa_QU     1.0
+#define ARTMAP_LINK_RHOa_DRHO  -1.0
+#define ARTMAP_LINK_CLb_DRHO    1.0
+#define ARTMAP_LINK_RG_DRHO     1.0
+#define ARTMAP_LINK_QU_DRHO     1.0
+#define ARTMAP_LINK_DRHO_DRHO  -1.0
+#define ARTMAP_LINK_DRHO_RHOa   1.0
+
+
+/* trainable links for ARTMAP */
+  /* the initial values of the bottom up link weights should be
+             0 < weight < (1 / (beta + |I|))
+             where beta is a value > 0.0 and should not be too big,
+                   I is the number of ones in the binary input vector.
+                   gamma has to be choosen > 1.0.
+  */
+#define ARTMAP_LINK_CMPa_RECa(beta,gamma)    (1.0 / ((beta) + (gamma) * ArtMap_NoOfInpUnits_a))
+#define ARTMAP_LINK_DELa_CMPa                1.0
+#define ARTMAP_LINK_CMPb_RECb(beta,gamma)    (1.0 / ((beta) + (gamma) * ArtMap_NoOfInpUnits_b))
+#define ARTMAP_LINK_DELb_CMPb                1.0
+#define ARTMAP_LINK_DELa_MAP                 1.0
+
+/* Links of ARTMAP networks are adjusted using the ART1 formulas */
+
+
+/******************** Output and Activation function names ******************/
+
+/* Definition of the Outputfunctions for ART1 */
+#define ART1_OUTFUNC    "Out_Identity"
+
+/* Definition of the Outputfunctions for ART2 */
+#define ART2_OUTFUNC    "Out_Identity"
+
+/* Definition of the Outputfunctions for ARTMAP */
+#define ARTMAP_OUTFUNC    "Out_Identity"
+
+
+/* Definition of the Activationfunctions for ART1 */
+#define ART1_ACTF_INP            "Act_Identity"
+#define ART1_ACTF_CMP            "Act_at_least_2"
+#define ART1_ACTF_REC            "Act_Identity"
+#define ART1_ACTF_DEL            "Act_at_least_2"
+#define ART1_ACTF_D              "Act_at_least_1"
+#define ART1_ACTF_RST            "Act_at_least_1"
+#define ART1_ACTF_G1             "Act_at_least_2"
+#define ART1_ACTF_RI             "Act_Product"
+#define ART1_ACTF_RC             "Act_Identity"
+#define ART1_ACTF_RG             "Act_less_than_0"
+#define ART1_ACTF_CL             "Act_at_least_1"
+#define ART1_ACTF_NCL            "Act_ART1_NC"
+#define ART1_ACTF_RHO            "Act_Identity"
+#define ART1_ACTF_G2             "Act_at_most_0"
+
+/* Definition of the Activationfunctions for ART2 */
+
+/* F0-Layer*/
+#define ART2_ACTF_INP            "Act_Identity"
+
+/* F1-Layer */
+#define ART2_ACTF_W              "Act_ART2_Identity"
+#define ART2_ACTF_X              "Act_ART2_NormW"
+#define ART2_ACTF_U              "Act_ART2_NormV"
+#define ART2_ACTF_V              "Act_ART2_Identity"
+#define ART2_ACTF_P              "Act_ART2_Identity"
+#define ART2_ACTF_Q              "Act_ART2_NormP"
+#define ART2_ACTF_R              "Act_ART2_NormIP"
+
+/* F2-Layer */
+#define ART2_ACTF_REC            "Act_ART2_Rec"
+#define ART2_ACTF_RST            "Act_ART2_Rst"
+
+
+/* Definition of the Activationfunctions for ARTMAP */
+#define ARTMAP_ACTF_INPa            "Act_Identity"
+#define ARTMAP_ACTF_CMPa            "Act_at_least_2"
+#define ARTMAP_ACTF_RECa            "Act_Identity"
+#define ARTMAP_ACTF_DELa            "Act_at_least_2"
+#define ARTMAP_ACTF_Da              "Act_at_least_1"
+#define ARTMAP_ACTF_RSTa            "Act_at_least_1"
+#define ARTMAP_ACTF_G1a             "Act_at_least_2"
+#define ARTMAP_ACTF_RIa             "Act_Product"
+#define ARTMAP_ACTF_RCa             "Act_Identity"
+#define ARTMAP_ACTF_RGa             "Act_less_than_0"
+#define ARTMAP_ACTF_CLa             "Act_at_least_1"
+#define ARTMAP_ACTF_NCa             "Act_ARTMAP_NCa"
+#define ARTMAP_ACTF_RHOa            "Act_Identity"
+#define ARTMAP_ACTF_G2a             "Act_at_most_0"
+
+#define ARTMAP_ACTF_INPb            "Act_Identity"
+#define ARTMAP_ACTF_CMPb            "Act_at_least_2"
+#define ARTMAP_ACTF_RECb            "Act_Identity"
+#define ARTMAP_ACTF_DELb            "Act_at_least_2"
+#define ARTMAP_ACTF_Db              "Act_at_least_1"
+#define ARTMAP_ACTF_RSTb            "Act_at_least_1"
+#define ARTMAP_ACTF_G1b             "Act_at_least_2"
+#define ARTMAP_ACTF_RIb             "Act_Product"
+#define ARTMAP_ACTF_RCb             "Act_Identity"
+#define ARTMAP_ACTF_RGb             "Act_less_than_0"
+#define ARTMAP_ACTF_CLb             "Act_at_least_1"
+#define ARTMAP_ACTF_NCb             "Act_ARTMAP_NCb"
+#define ARTMAP_ACTF_RHOb            "Act_Identity"
+#define ARTMAP_ACTF_G2b             "Act_at_most_0"
+
+#define ARTMAP_ACTF_MAP             "Act_at_least_2"
+#define ARTMAP_ACTF_D1              "Act_Identity"
+#define ARTMAP_ACTF_CL              "Act_at_least_2"
+#define ARTMAP_ACTF_NC              "Act_at_least_1"
+#define ARTMAP_ACTF_G               "Act_exactly_1"
+#define ARTMAP_ACTF_RB              "Act_Product"
+#define ARTMAP_ACTF_RM              "Act_Identity"
+#define ARTMAP_ACTF_RG              "Act_less_than_0"
+#define ARTMAP_ACTF_RHO             "Act_Identity"
+#define ARTMAP_ACTF_QU              "Act_Product"
+#define ARTMAP_ACTF_DRHO            "Act_ARTMAP_DRho"
+
+
+
+
+/* Definition of the Sitefunctions for ART1 */
+#define ART1_SITEF_RST_SELF      "Site_WeightedSum"
+#define ART1_SITEF_RST_SIGNAL    "Site_at_least_2"
+#define ART1_SITEF_REC_G1        "Site_at_most_0"
+#define ART1_SITEF_INP_G1        "Site_at_least_1"
+#define ART1_SITEF_RI            "Site_WeightedSum"
+
+
+/* Definition of the Sitefunctions for ART2 */
+#define ART2_SITEF_RST_SELF      "Site_WeightedSum"
+#define ART2_SITEF_RST_SIGNAL    "Site_at_least_2"
+
+
+/* Definition of the Sitefunctions for ARTMAP */
+#define ARTMAP_SITEF_RSTa_SELF       "Site_WeightedSum"
+#define ARTMAP_SITEF_RSTa_SIGNAL     "Site_at_least_2"
+#define ARTMAP_SITEF_RECa_G1a        "Site_at_most_0"
+#define ARTMAP_SITEF_INPa_G1a        "Site_at_least_1"
+#define ARTMAP_SITEF_RIa             "Site_WeightedSum"
+
+#define ARTMAP_SITEF_RSTb_SELF       "Site_WeightedSum"
+#define ARTMAP_SITEF_RSTb_SIGNAL     "Site_at_least_2"
+#define ARTMAP_SITEF_RECb_G1b        "Site_at_most_0"
+#define ARTMAP_SITEF_INPb_G1b        "Site_at_least_1"
+#define ARTMAP_SITEF_RIb             "Site_WeightedSum"
+
+#define ARTMAP_SITEF_ARTa_G          "Site_at_least_1"
+#define ARTMAP_SITEF_ARTb_G          "Site_at_least_1"
+#define ARTMAP_SITEF_RB              "Site_WeightedSum"
+#define ARTMAP_SITEF_INPa_QU         "Site_Reciprocal"
+#define ARTMAP_SITEF_CMPa_QU         "Site_WeightedSum"
+
+
+
+/* Global fix parameters */
+
+/* for ART 2 */
+#define ART2_PARAM_e                 0.00001
+
+
+
+
+/************************** other macros ************************************/
+
+/*  Don't call this macro unless kra1_sort() has been run
+*/
+#define ART1_CLASSIFIED       (Art1_cl_unit->Out.output >= 0.9)
+
+/*  Don't call this macro unless kra1_sort() has been run
+*/
+#define ART1_NOT_CLASSIFIABLE (Art1_nc_unit->Out.output >= 0.9)
+
+
+/*  Don't call this macro unless kra2_sort() has been run
+*/
+#define ART2_CLASSIFIED       kra2_classified()
+
+/*  Don't call this macro unless kra2_sort() has been run
+*/
+#define ART2_NOT_CLASSIFIABLE kra2_not_classifiable()
+
+
+
+/* Don't call this macro unless kram_sort() has been run
+*/
+#define ARTMAP_CLASSIFIED     (ArtMap_cl_unit->Out.output >= 0.9)
+
+/* Don't call this macro unless kram_sort() has been run
+*/
+#define ARTMAP_NOT_CLASSIFIABLE  (ArtMap_nc_unit->Out.output >= 0.9)
+
+
+/* Check if Sitefuncname is OK
+*/
+#define CHECK_SITE_FUNC(site_ptr, sitef_name)  \
+                 (strcmp (krf_getFuncName ((FunctionPtr) site_ptr->site_table->site_func), \
+                          sitef_name) \
+                 ) == 0
+
+/* Check if Actfuncname is OK
+*/
+#define CHECK_ACT_FUNC(unit_ptr, actf_name) \
+                 (strcmp (krf_getFuncName ((FunctionPtr) unit_ptr->act_func), \
+                          actf_name) \
+                 ) == 0
+
+/* Check if Outfuncname is OK
+*/
+#define CHECK_OUT_FUNC(unit_ptr, outf_name) \
+                 (strcmp (krf_getFuncName ((FunctionPtr) unit_ptr->out_func), \
+                           outf_name) \
+                 ) == 0
+
+
+/* Set topo_msg for unexpexted link
+*/
+
+#define TOPO_MSG_NO_OF_UNITS_IN_LAYER(layer_name) \
+                  topo_msg.error_code = KRERR_NO_OF_UNITS_IN_LAYER; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = 0; \
+                  strcpy (topo_msg.name, layer_name); \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_UNIT_MISSING(unit_name) \
+                  topo_msg.error_code = KRERR_UNIT_MISSING; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = 0; \
+                  strcpy (topo_msg.name, unit_name); \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_UNDETERMINED_UNIT(unit_ptr) \
+                  topo_msg.error_code = KRERR_UNDETERMINED_UNIT; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array
+
+#define TOPO_MSG_ACT_FUNC(unit_ptr) \
+                  topo_msg.error_code = KRERR_ACT_FUNC; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_OUT_FUNC(unit_ptr) \
+                  topo_msg.error_code = KRERR_OUT_FUNC; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_SITE_FUNC(unit_ptr) \
+                  topo_msg.error_code = KRERR_SITE_FUNC; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_UNEXPECTED_SITES(unit_ptr) \
+                  topo_msg.error_code = KRERR_UNEXPECTED_SITES; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_SITE_MISSING(unit_ptr) \
+                  topo_msg.error_code = KRERR_SITE_MISSING; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_UNEXPECTED_DIRECT_INPUTS(unit_ptr) \
+                  topo_msg.error_code = KRERR_UNEXPECTED_DIRECT_INPUTS; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = (unit_ptr)-unit_array; \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_UNEXPECTED_LINK(src_unit_ptr, dest_unit_ptr) \
+                  topo_msg.error_code = KRERR_UNEXPECTED_LINK; \
+                  topo_msg.src_error_unit = ((src_unit_ptr)-unit_array); \
+                  topo_msg.dest_error_unit = ((dest_unit_ptr)-unit_array); \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_LINK_MISSING(dest_unit_ptr) \
+                  topo_msg.error_code = KRERR_LINK_MISSING; \
+                  topo_msg.src_error_unit = 0; \
+                  topo_msg.dest_error_unit = ((dest_unit_ptr)-unit_array); \
+                  return (topo_msg.error_code)
+
+#define TOPO_MSG_LINK_TO_WRONG_SITE(src_unit_ptr, dest_unit_ptr) \
+                  topo_msg.error_code = KRERR_LINK_TO_WRONG_SITE; \
+                  topo_msg.src_error_unit = ((src_unit_ptr)-unit_array); \
+                  topo_msg.dest_error_unit = ((dest_unit_ptr)-unit_array); \
+                  return (topo_msg.error_code)
+
+
+#define ART1_RETURN_NET_ERROR(ret_code)  return ((ret_code = KRERR_TOPOLOGY))
+
+#define ART2_RETURN_NET_ERROR(ret_code)  return ((ret_code = KRERR_TOPOLOGY))
+
+#define ARTMAP_RETURN_NET_ERROR(ret_code) return ((ret_code = KRERR_TOPOLOGY))
+
+
+
+#endif  /* ifndef __KR_ART_DEF */
diff -Naur snort-2.3.3/src/kernel_snns/kr_art.h snort-2.3.3.new/src/kernel_snns/kr_art.h
--- snort-2.3.3/src/kernel_snns/kr_art.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,104 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art.h,v $
+  SHORTNAME      : kr_art.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:31 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART_DEFINED_
+#define  _KR_ART_DEFINED_
+
+
+/***************************************************************************/
+/* krart_prop_synch ()
+
+   synchronous propagation (1 cycle) i.e. each unit puts its output onto
+   its outgoing links and calculates its new activation.
+*/
+extern  void  krart_prop_synch (void);
+
+/***************************************************************************/
+/* krart_get_winner ()
+
+   get the winner of the last propagation cycle. returns a pointer to
+   the winning recognition unit.
+*/
+extern  struct Unit  *krart_get_winner (TopoPtrArray wta_layer,FlintType winner_output);
+
+/***************************************************************************/
+/* krart_reset_activations
+
+   reset activation values of all non input units to their i_act value.
+*/
+extern  krui_err   krart_reset_activations (void);
+
+
+/***************************************************************************/
+/* krart_deleteTouchFlags
+
+   delete touch-flags of all units in unit-array
+*/
+extern  void               krart_deleteTouchFlags (void);
+
+/***************************************************************************/
+/* krart_init_sorting
+
+   initialize unit-array in order to prepare it for sorting routine
+*/
+extern  void               krart_init_sorting (void);
+
+/***************************************************************************/
+/* krart_get_NoOfInputUnits
+
+   returns no of input units of the network
+*/
+extern  int                krart_get_NoOfInputUnits (void);
+
+/***************************************************************************/
+/* krart_check_undeterminedUnits
+
+   checks network for undetermined units. if there are any, returns true
+   else false.
+*/
+extern  bool               krart_check_undeterminedUnits (void);
+
+/***************************************************************************/
+/* krart_save_inp_pat()
+
+   copies activation values of input units to value_a field of unit-struct.
+*/
+extern  void krart_save_inp_pat (TopoPtrArray topo_inp_ptr);
+
+
+
+
+/***************************************************************************/
+/* krart_inp_pat_changed ()
+
+   returns TRUE, if one or more activation values of input units
+   differ from value_a i.e. their value changed.
+*/
+extern  bool krart_inp_pat_changed (TopoPtrArray topo_inp_ptr);
+
+
+
+
+#endif 
+
+
+
+
+
+/* 104 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_art.ph snort-2.3.3.new/src/kernel_snns/kr_art.ph
--- snort-2.3.3/src/kernel_snns/kr_art.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_art.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,107 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_art.ph,v $
+  SHORTNAME      : kr_art.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel Function Prototypes for ART-Networks
+  NOTES          :
+
+  AUTHOR         : Kai-Uwe Herrmann
+  DATE           : 17.05.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:32 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_ART_DEFINED_
+#define  _KR_ART_DEFINED_
+
+/* begin global definition section */
+
+/***************************************************************************/
+/* krart_prop_synch ()
+
+   synchronous propagation (1 cycle) i.e. each unit puts its output onto
+   its outgoing links and calculates its new activation.
+*/
+ void  krart_prop_synch (void);
+
+/***************************************************************************/
+/* krart_get_winner ()
+
+   get the winner of the last propagation cycle. returns a pointer to
+   the winning recognition unit.
+*/
+ struct Unit  *krart_get_winner (TopoPtrArray wta_layer,FlintType winner_output);
+
+/***************************************************************************/
+/* krart_reset_activations
+
+   reset activation values of all non input units to their i_act value.
+*/
+ krui_err   krart_reset_activations (void);
+
+
+/***************************************************************************/
+/* krart_deleteTouchFlags
+
+   delete touch-flags of all units in unit-array
+*/
+ void               krart_deleteTouchFlags (void);
+
+/***************************************************************************/
+/* krart_init_sorting
+
+   initialize unit-array in order to prepare it for sorting routine
+*/
+ void               krart_init_sorting (void);
+
+/***************************************************************************/
+/* krart_get_NoOfInputUnits
+
+   returns no of input units of the network
+*/
+ int                krart_get_NoOfInputUnits (void);
+
+/***************************************************************************/
+/* krart_check_undeterminedUnits
+
+   checks network for undetermined units. if there are any, returns true
+   else false.
+*/
+ bool               krart_check_undeterminedUnits (void);
+
+/***************************************************************************/
+/* krart_save_inp_pat()
+
+   copies activation values of input units to value_a field of unit-struct.
+*/
+ void krart_save_inp_pat (TopoPtrArray topo_inp_ptr);
+
+
+
+
+/***************************************************************************/
+/* krart_inp_pat_changed ()
+
+   returns TRUE, if one or more activation values of input units
+   differ from value_a i.e. their value changed.
+*/
+ bool krart_inp_pat_changed (TopoPtrArray topo_inp_ptr);
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_const.h snort-2.3.3.new/src/kernel_snns/kr_const.h
--- snort-2.3.3/src/kernel_snns/kr_const.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_const.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,189 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_const.h,v $
+  SHORTNAME      : const.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Constants
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.03.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:39 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef KR_CONSTANTS
+
+#define KR_CONSTANTS
+
+/*  flag modifier:
+
+		   |------------------------------ Direct Link Flag
+		   |  |--------------------------- Site Flag
+		   |  |  |------------------------ |
+		   |  |  |  |--------------------- | Topologic Type Flags
+		   |  |  |  |  |------------------ |
+		   |  |  |  |  |  |--------------- |
+		   |  |  |  |  |  |  |------------ Refresh Flag
+		   |  |  |  |  |  |  |	|--------- Enable Flag
+		   |  |  |  |  |  |  |	|  |------ In-Use Flag
+		   |  |  |  |  |  |  |	|  |  |--- Allocation Flag
+
+15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+-----------------------------------------------
+                                           0  0  : Unit is free and may be allocated
+                                           0  1  : Unit is now allocated, but not ready to use
+					   1  0  : Unit is allocated and ready to use
+					   1  1  : Unit is allocated and ready to use
+
+                                        0 -----  : Unit is freezed
+                                        1 -----  : Unit is active (will be updated during next cycle)
+
+                                     0 --------  : Unit is not updated now
+                                     1 --------  : Unit is currently updated
+
+			 0  0  0  0 -----------  : Unknown topologic type
+			 0  0  0  1 -----------  : Input type
+			 0  0  1  0 -----------  : Output type
+			 0  0  1  1 -----------  : Dual type (input and output)
+			 0  1  0  0 -----------  : Hidden type
+			 1  0  0  0 -----------  : Special type (no weight adjustment of input links)
+
+		   0  0 -----------------------  : Unit has no inputs (no links and no Sites)
+		   0  1 -----------------------  : Unit has at least one site (and no direct wired inputs)
+		   1  0 -----------------------  : Unit has direct input links (and no sites)
+		   1  1 -----------------------  : -- NOT USED --
+
+*/
+
+#define  UFLAG_FREE	 0x0000
+#define  UFLAG_NOT_FREE  0x0001
+#define  UFLAG_IN_USE	 0x0002
+
+#define  UFLAG_INITIALIZED   0x0007
+#define  UFLAG_ENABLED	 0x0004
+
+#define  UFLAG_REFRESH	 0x0008
+
+#define  UFLAG_TTYP_PAT  0x00f0
+#define  UFLAG_TTYP_UNKN 0x0000
+#define  UFLAG_TTYP_IN	 0x0010
+#define  UFLAG_TTYP_OUT  0x0020
+#define  UFLAG_TTYP_DUAL 0x0030
+#define  UFLAG_TTYP_HIDD 0x0040
+#define  UFLAG_TTYP_SPEC 0x0080
+#define  UFLAG_TTYP_SPEC_I 0x0090
+#define  UFLAG_TTYP_SPEC_O 0x00a0
+#define  UFLAG_TTYP_SPEC_H 0x00c0
+#define  UFLAG_TTYP_SPEC_D 0x00b0
+#define  UFLAG_TTYP_SPEC_X 0x00FE   /* only used to identfy toggle */
+#define  UFLAG_TTYP_N_SPEC_X 0x00FF /* only used to identfy toggle */
+
+#define  UFLAG_INPUT_PAT 0x0300
+#define  UFLAG_NO_INP	 0x0000
+#define  UFLAG_SITES	 0x0100
+#define  UFLAG_DLINKS	 0x0200
+
+
+/*  The unit output identity function is the NULL pointer
+*/
+#define     OUT_IDENTITY    NULL
+
+
+
+/* ***********************************************************
+
+          Constants for selectors
+
+*********************************************************** */
+/*  modes for unit counting
+*/
+#define  UNIT_DELETE  1
+#define  UNIT_ADD     2
+
+/*  topologic sorting modes
+*/
+
+#define  NOT_SORTED	  0
+#define  TOPOLOGICAL	  1
+#define  TOPOLOGICAL_FF   2
+#define  TOPOLOGIC_TYPE   3
+#define  PERMUTATION	  4
+#define  ART1_TOPO_TYPE   5
+#define  ART2_TOPO_TYPE   6
+#define  ARTMAP_TOPO_TYPE 7
+#define  TOPOLOGICAL_CC  8
+#define  TOPOLOGICAL_RCC 9
+#define  TOPOLOGICAL_BCC 10
+#define  TOPOLOGIC_LOGICAL 11
+#define  TOPOLOGICAL_JE  12
+
+/*  unit component selectors
+*/
+#define  SEL_UNIT_ACT  1
+#define  SEL_UNIT_OUT  2
+#define  SEL_UNIT_IACT  3
+#define  SEL_UNIT_BIAS  4
+#define  SEL_UNIT_ALL   5
+#define  SEL_UNIT_VALA 6
+
+/*  link searching selectors
+*/
+#define  FIRST	  1
+#define  NEXT	  2
+#define  CURRENT  3
+#define  NAME	  4
+
+/*  function searching in function table
+*/
+#define  GET_NO_OF_FUNCS  1
+#define  GET_FUNC_INFO    2
+#define  SEARCH_FUNC      3
+#define  GET_FUNC_NAME    4
+#define  GET_DEFAULT_FUNC 5
+
+/*  link delete selectors
+*/
+#define  INPUTS   0
+#define  OUTPUTS  1
+
+/*  pattern function selectors
+*/
+#define  PATTERN_SET  1
+#define  PATTERN_GET  2
+#define  PATTERN_DELETE  3
+#define  PATTERN_MODIFY  4
+#define  PATTERN_SHOW	 5
+#define  PATTERN_NEW  6
+#define  PATTERN_DELETE_ALL  7
+#define  PATTERN_SHUFFLE_ON  8
+#define  PATTERN_SHUFFLE_OFF 9
+#define  PATTERN_VECTOR_NEW  10
+#define  PATTERN_ARRAY_ALLOC 11
+#define  PATTERN_SET_NUMBER  12
+#define  PATTERN_GET_NUMBER  13
+#define  PATTERN_SUB_SHUFFLE_ON 14
+#define  PATTERN_SUB_SHUFFLE_OFF 15
+#define  GET_SHUFFLE_FLAG 16
+#define  GET_SUB_SHUFFLE_FLAG 17
+#define  SUBPATTERN_GET_NUMBER 18
+
+/*#################################################
+
+GROUP: Parallel kernel constants
+
+#################################################*/
+
+
+#endif
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_def.h snort-2.3.3.new/src/kernel_snns/kr_def.h
--- snort-2.3.3/src/kernel_snns/kr_def.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_def.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,96 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_def.h,v $
+  SHORTNAME      : def.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Defaults
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.03.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:40 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef KR_DEFAULTS
+
+#define KR_DEFAULTS
+
+#ifndef NULL
+#include <stdio.h>	/*  include "stdio.h" if the NULL-pointer isn't
+			    defined  */
+#endif
+
+
+/*  default constants for block memory allocation in # of components
+*/
+#ifdef __BORLANDC__
+
+#define  UNIT_BLOCK     100
+#define  LINK_BLOCK     500
+#define  SITE_BLOCK     20
+#define  NTABLE_BLOCK   50
+#define  STABLE_BLOCK   20
+#define  PATTERN_BLOCK  50
+
+#else
+#ifdef  __ENZO__
+
+/* A population of networks doesn't allow to use this much memory ... */
+
+#define  UNIT_BLOCK     300
+#define  LINK_BLOCK     1000
+#define  SITE_BLOCK     20
+#define  NTABLE_BLOCK   50
+#define  STABLE_BLOCK   20
+#define  PATTERN_BLOCK  200
+
+#else
+
+#define  UNIT_BLOCK     1000
+#define  LINK_BLOCK     5000
+#define  SITE_BLOCK     200
+#define  NTABLE_BLOCK   500
+#define  STABLE_BLOCK   200
+#define  PATTERN_BLOCK  200
+
+#endif /*__ENZO__*/
+#endif /*__BORLANDC__*/
+
+/*  Unit/Site Default Initialisations
+*/
+
+#define     DEF_OUT         0
+#define     DEF_I_ACT       0
+#define     DEF_BIAS        0
+
+#define     DEF_SUBNET_NO   0
+#define     DEF_LAYER_NO    1
+#define     DEF_POS_X       0
+#define     DEF_POS_Y       0
+
+#define     DEF_POS_Z       0
+
+
+#define     DEF_STYPE       UFLAG_TTYP_HIDD
+
+
+/*#################################################
+
+GROUP: File I/O Constants
+
+#################################################*/
+
+/*  max. line length for the kernel input/output files
+*/
+#define  MAX_LIN_LEN    250
+#define  BEST_LINE_LEN  132
+
+
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_funcs.c snort-2.3.3.new/src/kernel_snns/kr_funcs.c
--- snort-2.3.3/src/kernel_snns/kr_funcs.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_funcs.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,514 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_funcs.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Management routines for user functions 
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 12.02.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:37 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <string.h>
+
+#include "kr_typ.h"         /*  Kernel types and constants  */
+#include "kr_const.h"       /*  Kernel constants  */
+#include "kr_def.h"	    /*	Default values	*/
+#include "kr_funcs.ph"       /*  Function prototypes  */
+#include "kernel.h"
+#include "func_tbl.h"
+#include "glob_typ.h"
+
+
+/*#################################################
+
+GROUP: MasPar functions
+
+#################################################*/
+
+#ifdef MASPAR_KERNEL
+#ifndef MASPAR_KERNEL_EMULATION
+
+extern  krmp_getMasParFuncInfo();
+
+#endif
+#endif
+
+
+/*#################################################
+
+GROUP: Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krf_getInternalFuncInfo 
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krf_getInternalFuncInfo(int mode, struct FuncInfoDescriptor *func_descr)
+{
+  struct FuncTable  *ftbl_ptr;
+  unsigned short  func_type;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  switch (mode)  {
+    case  GET_NO_OF_FUNCS:
+      func_descr->number = NoOfKernelFuncs;
+      break;
+
+    case  GET_FUNC_INFO:  /*  return all info about given function  */
+      if ((func_descr->number < 0) || (func_descr->number >= NoOfKernelFuncs))  {
+        KernelErrorCode = KRERR_PARAMETERS;
+        return( KernelErrorCode );
+      }
+
+      ftbl_ptr = kernel_func_table + func_descr->number;
+
+      strcpy( func_descr->func_name, ftbl_ptr->func_name );
+      func_descr->func_type = ftbl_ptr->func_type & ~DEFAULT_FUNC;
+      func_descr->no_of_input_parameters = ftbl_ptr->no_of_input_parameters;
+      func_descr->no_of_output_parameters = ftbl_ptr->no_of_output_parameters;
+      func_descr->function = ftbl_ptr->function;
+#ifdef PARAGON_KERNEL
+      func_descr->parallelized = ftbl_ptr->parallelized;
+#endif
+      break;
+
+    case  SEARCH_FUNC:  /*  search for the given function and return the
+                            info about the function  */
+
+      for (ftbl_ptr = kernel_func_table;
+           ftbl_ptr < kernel_func_table + NoOfKernelFuncs;
+           ftbl_ptr++)  {
+        func_type = func_descr->func_type;
+        if (((func_type & FUNC_TYPE_MASK) == (ftbl_ptr->func_type & FUNC_TYPE_MASK)) &&
+            (strcmp( func_descr->func_name, ftbl_ptr->func_name ) == 0))  {
+          func_descr->no_of_input_parameters = ftbl_ptr->no_of_input_parameters;
+          func_descr->no_of_output_parameters = ftbl_ptr->no_of_output_parameters;
+          func_descr->function = ftbl_ptr->function;
+#ifdef PARAGON_KERNEL
+	  func_descr->parallelized = ftbl_ptr->parallelized;
+#endif
+          return( KRERR_NO_ERROR );
+        }
+      }
+
+      func_descr->function = NULL;
+#ifdef PARAGON_KERNEL
+      func_descr->parallelized = ftbl_ptr->parallelized;
+#endif
+
+      switch (func_descr->func_type)  {
+        case  OUT_FUNC:
+          KernelErrorCode = KRERR_OUTFUNC;
+          break;
+        case  ACT_FUNC:
+          KernelErrorCode = KRERR_ACTFUNC;
+          break;
+        case  SITE_FUNC:
+          KernelErrorCode = KRERR_SITEFUNC;
+          break;
+        case  LEARN_FUNC:
+          KernelErrorCode = KRERR_LEARNING_FUNC;
+          break;
+        case  UPDATE_FUNC:
+          KernelErrorCode = KRERR_UPDATE_FUNC;
+          break;
+        case  INIT_FUNC:
+          KernelErrorCode = KRERR_INIT_FUNC;
+          break;
+        case  ACT_DERIV_FUNC:
+        case  ACT_2_DERIV_FUNC:
+          KernelErrorCode = KRERR_DERIV_FUNC;
+          break;
+	case REMAP_FUNC:
+	  KernelErrorCode = KRERR_REMAP_FUNC;
+          break;
+
+        default:
+          KernelErrorCode = KRERR_PARAMETERS;
+      }
+
+      break;
+
+    case  GET_FUNC_NAME:   /*  search for the given function pointer and
+                               returns the name of the function  */
+
+      for (ftbl_ptr = kernel_func_table;
+           ftbl_ptr < kernel_func_table + NoOfKernelFuncs;
+           ftbl_ptr++)
+        if (func_descr->function == ftbl_ptr->function)  {
+          strcpy( func_descr->func_name, ftbl_ptr->func_name );
+          func_descr->func_type = ftbl_ptr->func_type & ~DEFAULT_FUNC;
+          func_descr->no_of_input_parameters = ftbl_ptr->no_of_input_parameters;
+          func_descr->no_of_output_parameters = ftbl_ptr->no_of_output_parameters;
+#ifdef PARAGON_KERNEL
+	  func_descr->parallelized = ftbl_ptr->parallelized;
+#endif
+
+          return( KRERR_NO_ERROR );
+        }
+
+      func_descr->func_type = 0;
+      break;
+
+    case  GET_DEFAULT_FUNC:   /*  search for the given function type and
+                                  returns the default function of this type  */
+
+      func_type = (func_descr->func_type | DEFAULT_FUNC) & ~FF_LEARN_FUNC;
+      for (ftbl_ptr = kernel_func_table;
+           ftbl_ptr < kernel_func_table + NoOfKernelFuncs;
+           ftbl_ptr++)  {
+        if (func_type == (ftbl_ptr->func_type & ~FF_LEARN_FUNC))  {
+          func_descr->no_of_input_parameters = ftbl_ptr->no_of_input_parameters;
+          func_descr->no_of_output_parameters = ftbl_ptr->no_of_output_parameters;
+          func_descr->function = ftbl_ptr->function;
+          strcpy( func_descr->func_name, ftbl_ptr->func_name );
+          func_descr->number = ftbl_ptr - kernel_func_table;
+          return( KRERR_NO_ERROR );
+        }
+      }
+
+      func_descr->number = 0;
+      KernelErrorCode = KRERR_MISSING_DEFAULT_FUNC;
+      break;
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+  }
+
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krf_getFuncInfo
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+
+krui_err  krf_getFuncInfo(int mode, struct FuncInfoDescriptor *func_descr)
+{
+  switch (specialNetworkType)  {
+    case NET_TYPE_GENERAL:
+      (void) krf_getInternalFuncInfo( mode, func_descr );
+      break;
+
+#ifdef MASPAR_KERNEL
+
+    case NET_TYPE_FF1:
+
+#ifndef MASPAR_KERNEL_EMULATION
+      
+  
+      KernelErrorCode = callRequest( krmp_getMasParFuncInfo,
+                                     sizeof (int) +
+                                     sizeof (struct FuncInfoDescriptor *),
+                                     mode, func_descr );
+#else
+      (void) krf_getInternalFuncInfo( mode, func_descr );
+#endif
+
+      break;
+#endif
+
+    default:
+      KernelErrorCode = KRERR_PARAMETERS;
+  }
+
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : krf_getNoOfFuncs
+
+  PURPOSE  : Returns the number of functions in the function table
+  NOTES    :
+
+  RETURNS  : Returns the number of functions in the function table
+  UPDATE   : 
+******************************************************************************/
+int  krf_getNoOfFuncs(void)
+{
+  struct FuncInfoDescriptor  functionDescr;
+
+
+  KernelErrorCode = krf_getFuncInfo( GET_NO_OF_FUNCS, &functionDescr );
+  return( functionDescr.number );
+}
+
+/*****************************************************************************
+  FUNCTION : krf_funcSearch
+
+  PURPOSE  : seaches for the given function (name and type) and returns a pointer to
+             this function. krf_funcSearch(...)
+  NOTES    :
+
+  RETURNS  : TRUE if the given function was found, FALSE otherwise.
+  UPDATE   : 
+******************************************************************************/
+bool  krf_funcSearch(char *func_name, int func_type, FunctionPtr *func_ptr)
+{
+  struct FuncInfoDescriptor  functionDescr;
+
+  functionDescr.func_type = func_type;
+  strcpy( functionDescr.func_name, func_name );
+
+  KernelErrorCode = krf_getFuncInfo( SEARCH_FUNC, &functionDescr );
+
+  if (KernelErrorCode != KRERR_NO_ERROR)  return( FALSE );
+  *func_ptr = functionDescr.function;
+  return( TRUE );
+}
+/*****************************************************************************
+  FUNCTION : krf_getFuncName
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : Returns the name of the given function
+  UPDATE   : 
+******************************************************************************/
+char  *krf_getFuncName(FunctionPtr func_ptr)
+{
+  static struct FuncInfoDescriptor  functionDescr;
+
+  functionDescr.function = func_ptr;
+
+  KernelErrorCode = krf_getFuncInfo( GET_FUNC_NAME, &functionDescr );
+
+  if (functionDescr.func_type == 0)  return( NULL );
+
+  return( functionDescr.func_name );
+}
+
+
+/*#################################################
+
+GROUP: Functions for managing current and
+       default network functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krf_getCurrentNetworkFunc
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns the name of the current network function
+  UPDATE   : 
+******************************************************************************/
+char  *krf_getCurrentNetworkFunc(int type)
+{
+  int  sel;
+  static struct FuncInfoDescriptor  func_descr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (specialNetworkType == NET_TYPE_GENERAL)  sel = 0;
+  else  sel = NO_OF_FUNC_TYPES;
+
+  switch (type)  {
+    case  UPDATE_FUNC:
+      break;
+    case  LEARN_FUNC:
+      sel += 1;
+      break;
+    case  INIT_FUNC:
+      sel += 2;
+      break;
+    case  OUT_FUNC:
+      sel += 3;
+      break;
+    case  ACT_FUNC:
+      sel += 4;
+      break;
+    case  SITE_FUNC:
+      sel += 5;
+      break;
+    case  UPDATE_FUNC | BENCH_FUNC:
+      sel += 6;
+      break;
+    case  LEARN_FUNC | BENCH_FUNC:
+      sel += 7;
+      break;
+    case  LEARN_FUNC | FF_LEARN_FUNC:
+      sel += 8;
+      break;
+    case  PRUNING_FUNC:
+      sel += 9;
+      break;
+    case  TEST_FUNC:  
+      sel += 10;
+      break;
+   default:
+     KernelErrorCode = KRERR_PARAMETERS;
+     return( NULL );
+  }
+
+  if (netFuncInit[sel])  return( &CurrNetworkFunc[sel][0] );
+
+  func_descr.func_type = type;
+  if (krf_getFuncInfo( GET_DEFAULT_FUNC, &func_descr ) == KRERR_NO_ERROR)
+    return( func_descr.func_name );
+
+  return( NULL );
+}
+
+/*****************************************************************************
+  FUNCTION : krf_storeCurrentNetworkFunc
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krf_storeCurrentNetworkFunc(char *function_name, int type)
+{
+  int  sel;
+
+  if (specialNetworkType == NET_TYPE_GENERAL)  sel = 0;
+  else  sel = 3;
+
+
+  switch (type)  {
+    case  UPDATE_FUNC:
+      break;
+    case  LEARN_FUNC:
+      sel += 1;
+      break;
+    case  INIT_FUNC:
+      sel += 2;
+      break;
+    case  OUT_FUNC:
+      sel += 3;
+      break;
+    case  ACT_FUNC:
+      sel += 4;
+      break;
+    case  SITE_FUNC:
+      sel += 5;
+      break;
+    case  UPDATE_FUNC | BENCH_FUNC:
+      sel += 6;
+      break;
+    case  LEARN_FUNC | BENCH_FUNC:
+      sel += 7;
+      break;
+    case  LEARN_FUNC | FF_LEARN_FUNC:
+      sel += 8;
+      break;
+    case  PRUNING_FUNC:
+      sel += 9;
+      break;
+    case  TEST_FUNC: 
+      sel += 10;
+      break;
+   default:
+     KernelErrorCode = KRERR_PARAMETERS;
+     return;
+    }
+
+  netFuncInit[sel] = TRUE;
+  strcpy( &CurrNetworkFunc[sel][0], function_name );
+  return;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krf_setCurrentNetworkFunc
+
+  PURPOSE  : sets the current network function.
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+krui_err  krf_setCurrentNetworkFunc(char *function_name, int type)
+{
+  FunctionPtr func_ptr;
+  bool	func_has_changed;
+  char  *current_func;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (!krf_funcSearch( function_name, type, &func_ptr ))
+    return( KernelErrorCode );
+  if ((current_func = krf_getCurrentNetworkFunc( type )) == NULL)
+    return( KernelErrorCode );
+
+  func_has_changed = strcmp( function_name, current_func ) != 0;
+
+  switch (type)  {
+    case  UPDATE_FUNC:
+      if (func_has_changed)
+	{  /*  update function has changed, initialize the network  */
+        NetInitialize = TRUE;
+        krf_storeCurrentNetworkFunc( function_name, type );
+      }
+
+      return( KernelErrorCode );
+
+    case  LEARN_FUNC:
+      if (func_has_changed)
+	{  /*  Learning function has changed  */
+	LearnFuncHasChanged = TRUE;
+        krf_storeCurrentNetworkFunc( function_name, type );
+        krf_storeCurrentNetworkFunc( function_name, TEST_FUNC ); 
+      }
+
+      return( KernelErrorCode );
+
+    case PRUNING_FUNC:
+      if (func_has_changed)
+        krf_storeCurrentNetworkFunc (function_name, type);
+      break;
+
+    case (FF_LEARN_FUNC | LEARN_FUNC):
+      if (func_has_changed)
+        krf_storeCurrentNetworkFunc (function_name, type);
+        krf_storeCurrentNetworkFunc( function_name, TEST_FUNC );
+      break;
+
+    case  INIT_FUNC:
+    case  OUT_FUNC:
+    case  ACT_FUNC:
+    case  SITE_FUNC:
+      krf_storeCurrentNetworkFunc( function_name, type );
+      break;
+
+   default:
+      KernelErrorCode = KRERR_PARAMETERS;
+      return( KernelErrorCode );
+  }
+
+  return( KernelErrorCode );
+}
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_funcs.h snort-2.3.3.new/src/kernel_snns/kr_funcs.h
--- snort-2.3.3/src/kernel_snns/kr_funcs.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_funcs.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,56 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_funcs.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Routines for User-Function Management
+		               (Function Prototypes)
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 12.02.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:43 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_FUNCS_DEFINED_
+#define  _KR_FUNCS_DEFINED_
+
+
+extern krui_err  krf_getFuncInfo( int  mode, struct FuncInfoDescriptor  *func_descr );
+
+/*  Returns the number of functions in the function table
+*/
+extern int krf_getNoOfFuncs( void );
+
+/*  seaches for the given function (name and type) and returns a pointer to
+    this function. krf_funcSearch(...) returns TRUE if the given function was
+    found, FALSE otherwise.
+*/
+extern bool krf_funcSearch( char *func_name, int  func_type, FunctionPtr  *func_ptr );
+
+/*  Returns the name of the given function
+*/
+extern char *krf_getFuncName( FunctionPtr func_ptr );
+
+/*  returns the name of the current network function
+*/
+extern char  *krf_getCurrentNetworkFunc( int  type );
+
+/*  sets the current network function.
+*/
+extern krui_err  krf_setCurrentNetworkFunc( char  *function_name, int  type );
+
+
+
+
+#endif 
+
+
+
+/* 56 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_funcs.ph snort-2.3.3.new/src/kernel_snns/kr_funcs.ph
--- snort-2.3.3/src/kernel_snns/kr_funcs.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_funcs.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,78 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_funcs.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Routines for User-Function Management
+		               (Function Prototypes)
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 12.02.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:43 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_FUNCS_DEFINED_
+#define  _KR_FUNCS_DEFINED_
+
+/* begin global definition section */
+
+krui_err  krf_getFuncInfo( int  mode, struct FuncInfoDescriptor  *func_descr );
+
+/*  Returns the number of functions in the function table
+*/
+int krf_getNoOfFuncs( void );
+
+/*  seaches for the given function (name and type) and returns a pointer to
+    this function. krf_funcSearch(...) returns TRUE if the given function was
+    found, FALSE otherwise.
+*/
+bool krf_funcSearch( char *func_name, int  func_type, FunctionPtr  *func_ptr );
+
+/*  Returns the name of the given function
+*/
+char *krf_getFuncName( FunctionPtr func_ptr );
+
+/*  returns the name of the current network function
+*/
+char  *krf_getCurrentNetworkFunc( int  type );
+
+/*  sets the current network function.
+*/
+krui_err  krf_setCurrentNetworkFunc( char  *function_name, int  type );
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/*#################################################
+
+GROUP: Local Vars
+
+#################################################*/
+
+
+#define  NO_OF_FUNC_TYPES  11
+#define  NO_OF_KERNELS  2
+static char  CurrNetworkFunc[NO_OF_FUNC_TYPES * NO_OF_KERNELS][FUNCTION_NAME_MAX_LEN];
+
+static bool  netFuncInit[NO_OF_FUNC_TYPES * NO_OF_KERNELS] = { 
+                         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
+                         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE  };
+
+static krui_err  krf_getInternalFuncInfo(int mode, struct FuncInfoDescriptor *func_descr);
+static void  krf_storeCurrentNetworkFunc(char *function_name, int type);
+
+
+/* end private definition section */
+
+#endif 
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_inversion.c snort-2.3.3.new/src/kernel_snns/kr_inversion.c
--- snort-2.3.3/src/kernel_snns/kr_inversion.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_inversion.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,279 @@
+/**********************************************************************
+  FILE           : %W%
+
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Implement Kindermann/Linden-inversion-method
+
+  NOTES          : The functions implemented here closely resemble the
+                   the functions propagateNetForward and propagateNetBackward2 
+		   in the file learn_f.c.
+  FUNCTIONS      : -- kr_initInversion
+                      Purpose : initialize net for inversion algorithm
+	               Calls   : int kr_topoCheck();
+		                 int kr_IOCheck();
+		            	  int kr_topoSort();
+ 
+                   -- kr_inv_forwardPass
+ 	              Purpose : topological forward propagation
+	              Calls   : nothing
+ 
+	           -- kr_inv_backwardPass
+                      Purpose : Backward error propagation (topological) 
+	              Calls   : nothing
+ 
+  AUTHOR         : Guenter Mamier
+  DATE           : 04.02.92
+
+  CHANGED BY     : Sven Doering, Michael Vogt
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:56 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+**********************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"	
+#include "kr_const.h"
+#include "kernel.h"
+#include "kr_def.h"	
+#include "kr_mac.h"	
+#include "kr_inversion.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_initInversion
+
+  PURPOSE  : initialize net for inversion algorithm
+  NOTES    :
+  UPDATE   : 06.02.92
+******************************************************************************/
+int kr_initInversion(void)
+{
+    int ret_code = KRERR_NO_ERROR;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF &&
+			TopoSortID != TOPOLOGIC_LOGICAL)){
+       /*  Net has been modified or topologic array isn't initialized */
+       /*  check the topology of the network  */
+      ret_code = kr_topoCheck();
+    if (ret_code < KRERR_NO_ERROR)  
+       return( ret_code );  /*  an error has occured  */
+    if (ret_code < 2)  
+       return( KRERR_NET_DEPTH );  /*  the network has less then 2 layers  */
+
+
+    /*  count the no. of I/O units and check the patterns  */
+    ret_code = kr_IOCheck();
+    if(ret_code < KRERR_NO_ERROR)  
+       return( ret_code );
+
+    /*  sort units by topology and by topologic type  */
+
+    ret_code = kr_topoSort( TOPOLOGICAL_FF );
+  }
+  return(ret_code);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_inv_forwardPass
+
+  PURPOSE  : topological forward propagation
+  NOTES    :
+  UPDATE   : 29.01.92
+******************************************************************************/
+void  kr_inv_forwardPass(struct UnitList *inputs)
+{
+
+   register struct Unit   *unit_ptr;
+   register TopoPtrArray  topo_ptr;    /* points to a topological sorted    */
+				       /* unit stucture (input units first) */
+   struct UnitList        *IUnit;      /* working list of input units       */
+
+
+   /* initialize the topological pointer */
+
+   topo_ptr = topo_ptr_array;
+
+
+   /*  calculate the activation and output value of the input units */ 
+
+   IUnit = inputs;
+   while((unit_ptr = *++topo_ptr) != NULL){
+
+     /*  clear error values  */
+     unit_ptr->Aux.flint_no = 0.0;
+
+     if(unit_ptr->out_func == OUT_IDENTITY)
+        unit_ptr->Out.output = unit_ptr->act = IUnit->act;
+     else  /* no identity output function: calculate unit's output also  */
+       unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act = IUnit->act);
+     IUnit = IUnit->next;
+   }
+
+
+   /*  popagate hidden units  */
+ 
+   while((unit_ptr = *++topo_ptr) != NULL){
+
+     /*  clear error values  */
+     unit_ptr->Aux.flint_no = 0.0;
+
+     /*  calculate the activation value of the unit: 
+	 call the activation function if needed  */
+     unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+     if(unit_ptr->out_func == OUT_IDENTITY)
+       unit_ptr->Out.output = unit_ptr->act;
+     else
+       /*  no identity output function: calculate unit's output also  */
+       unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+   }
+ 
+ 
+   /*  popagate output units  */
+ 
+   while((unit_ptr = *++topo_ptr) != NULL){
+
+     /*  clear error values  */
+     unit_ptr->Aux.flint_no = 0.0;
+
+     /*  calculate the activation value of the unit: 
+	 call the activation function if needed  */
+     unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+     if(unit_ptr->out_func == OUT_IDENTITY)
+       unit_ptr->Out.output = unit_ptr->act;
+     else      /*  no identity output function: calculate unit's output also  */
+       unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+   }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_inv_backwardPass
+
+  PURPOSE  : Backward error propagation (topological) 
+  NOTES    :
+  UPDATE   : 04.02.92
+*****************************************************************************/
+double kr_inv_backwardPass(float learn, float delta_max, int *err_units, 
+			   float ratio, struct UnitList *inputs, 
+			   struct UnitList *outputs)
+{
+   register struct Link   *link_ptr;
+   register struct Site   *site_ptr;
+   register struct Unit   *unit_ptr;
+   register float         error,  sum_error,  eta,  devit;
+   register TopoPtrArray  topo_ptr;
+   struct UnitList        *IUnit, *OUnit;
+
+
+   sum_error = 0.0;    /*  reset network error  */
+   *err_units = 0;     /*  reset error units */
+   eta = learn;        /*  store learn_parameter in CPU register  */
+
+
+   /* add 3 to no_of_topo_units because topologic array contains 4 NULL 
+      pointers  */
+
+   topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+
+   /*  calculate output units only  */
+
+   OUnit = outputs;
+   while(OUnit->next != NULL)OUnit = OUnit->next;
+   while((unit_ptr = *--topo_ptr) != NULL){
+
+
+     /*  calc. devitation */
+     devit = OUnit->i_act - unit_ptr->Out.output;
+     OUnit->act = unit_ptr->Out.output;
+     OUnit = OUnit->prev;
+     if ( (devit > -delta_max) && (devit < delta_max) ){
+       continue;
+     }else{
+       *err_units += 1;
+     }
+
+     /*  sum up the error of the network  */
+     sum_error += devit * devit;  
+
+     /*	calc. error for output units	 */
+     error = devit * (unit_ptr->act_deriv_func) ( unit_ptr );
+     /*     error = devit;*/
+
+     /* Calculate sum of errors of predecessor units  */
+     if(UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+       FOR_ALL_LINKS( unit_ptr, link_ptr )
+         link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+     }else{        /*	the unit has sites  */
+       FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+         link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+     }
+   }
+
+
+   /*  calculate hidden units only  */
+
+   while((unit_ptr = *--topo_ptr) != NULL){
+
+     /*	calc. the error of the (hidden) unit  */
+     error = (unit_ptr->act_deriv_func) ( unit_ptr ) * unit_ptr->Aux.flint_no;
+     error = unit_ptr->Aux.flint_no;
+
+     /* Calculate sum of errors of predecessor units  */
+     if(UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+       FOR_ALL_LINKS( unit_ptr, link_ptr )
+	  link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+     }else{       /*  the unit has sites  */
+       FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+  	  link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+     }
+     unit_ptr->act = unit_ptr->i_act;
+   }
+
+
+   /*  calculate input units only  */
+
+   IUnit = inputs;
+   while(IUnit->next != NULL)IUnit = IUnit->next;
+   while((unit_ptr = *--topo_ptr) != NULL){
+
+     /*	calc. the error of the (input) unit  */
+     error = (unit_ptr->act_deriv_func) ( unit_ptr ) * unit_ptr->Aux.flint_no;
+     error = unit_ptr->Aux.flint_no;
+
+     /* Calculate the new activation for the input units */
+     IUnit->im_act += eta * error + ratio*(IUnit->i_act - (float)unit_ptr->act);
+     unit_ptr->act = 1.0 / (1.0 + exp((double)(-IUnit->im_act)));
+     IUnit->act = unit_ptr->act;
+     IUnit = IUnit->prev;
+   }
+
+
+   /*  return the error of the network */
+
+   sum_error *= 0.5;
+   return( sum_error ); 
+
+
+}
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_inversion.h snort-2.3.3.new/src/kernel_snns/kr_inversion.h
--- snort-2.3.3/src/kernel_snns/kr_inversion.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_inversion.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,33 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_inversion.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 29.02.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:45 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_INVERSION_DEFINED_
+#define  _KR_INVERSION_DEFINED_
+
+
+
+/* required functions that are declared here */
+
+extern int    kr_initInversion(void);
+extern void   kr_inv_forwardPass(struct UnitList *inputs);
+extern double kr_inv_backwardPass(float learn, float delta_max, int *err_units,
+				  float ratio, struct UnitList *inputs,
+				  struct UnitList *outputs);
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/kr_inversion.ph snort-2.3.3.new/src/kernel_snns/kr_inversion.ph
--- snort-2.3.3/src/kernel_snns/kr_inversion.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_inversion.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,47 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_inversion.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 29.02.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:46 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_INVERSION_DEFINED_
+#define  _KR_INVERSION_DEFINED_
+
+/* begin global definition section */
+
+
+/* required functions that are declared here */
+
+int    kr_initInversion(void);
+void   kr_inv_forwardPass(struct UnitList *inputs);
+double kr_inv_backwardPass(float learn, float delta_max, int *err_units, 
+			   float ratio, struct UnitList *inputs,
+			   struct UnitList *outputs);
+
+/* end global definition section */
+
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_io.c snort-2.3.3.new/src/kernel_snns/kr_io.c
--- snort-2.3.3/src/kernel_snns/kr_io.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_io.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,3216 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_io.c,v $
+  SHORTNAME      : kr_io.c
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel User Interface File I/O
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 28.05.90
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.18 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:39 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include <ctype.h>
+#include <memory.h>
+#include <stdarg.h>
+#include <stdio.h>
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants  */
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"	 /*  Default Values  */
+
+#include "kr_ui.h"	 /*  Interface Functions  */
+#include "kernel.h"      /*  Function Prototypes */
+#include "kr_mac.h"	 /*  Kernel Macros  */
+#include "version.h"	 /*  Version and Patchlevel  */
+#include "dlvq_learn.h"
+#include "kr_io.ph"	 /*  Function Prototypes */
+#include "kr_newpattern.h" /*pattern handling functions */
+#include "cc_glob.h"      /* for NetLearnAlgorithm to decide, if we must
+                            save in TACOMA-mode */
+#include "cc_mac.h"
+
+#ifdef ultrix
+#define retchk( ret_code )  if ((ret_code) == EOF)  return( KRERR_IO )
+#define RETCHKGTO( ret_code )  if ((ret_code) == EOF)  goto ende
+#else
+#define retchk( ret_code )  if ((ret_code) < 0)  return( KRERR_IO )
+#define RETCHKGTO( ret_code )  if ((ret_code) < 0)  goto ende
+#endif
+
+/*****************************************************************************
+  FUNCTION : mstrcat 
+
+  PURPOSE  : 
+  NOTES    : mstrcat is called
+             mstrcat( dest, src1, src2, ... , (char *) 0 )
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void  mstrcat(char *va_alist,...)
+
+{
+  va_list  args;
+  char	  *dest, *src;
+
+
+  va_start( args, va_alist );
+  if ((dest = va_alist) == (char *) 0)  return;
+
+  while ((src = va_arg( args, char * )) != (char *) 0)
+    strcat( dest, src );
+
+  va_end( args );
+}
+
+/*****************************************************************************
+  FUNCTION : mstrcpy 
+
+  PURPOSE  : 
+  NOTES    : mstrcpy is called
+             mstrcpy ( dest, src1, src2, ... , (char *) 0 )
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void  mstrcpy(char *va_alist,...)
+{
+  va_list  args;
+  char	  *dest, *src;
+
+
+  va_start( args, va_alist );
+  if ((dest = va_alist) == (char *) 0)  return;
+  if ((src  = va_arg( args, char * )) == (char *) 0)  return;
+  while( *src != EOS )
+    *dest++ = *src++;
+
+  while ((src = va_arg( args, char * )) != (char *) 0)
+    {
+    while( *src != EOS )
+      *dest++ = *src++;
+  }
+
+  va_end( args );
+
+  *dest = EOS;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_getIOVersion
+
+  PURPOSE  : returns the current file I/O version number
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static char  *krio_getIOVersion(void)
+{
+  static char	io_version[128];
+
+  strcpy( io_version, NETFILE_VERSION );
+
+  strcat( io_version, KERNEL3D_NETFILE_VERSION );
+
+
+  return( io_version );
+}
+
+
+/*#################################################
+
+GROUP: Kernel File Output Functions
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : krio_writeHeader
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static krui_err  krio_writeHeader(char *version, char *net_name)
+{
+  long  clock;
+  int   err;
+  int   no_of_sites,
+        no_of_STable_entries,
+        no_of_FTable_entries;
+  char *learn_func;
+
+
+  krui_getNetInfo( &no_of_sites, &NoOfLinks, &no_of_STable_entries,
+		   &no_of_FTable_entries );
+  units_have_sites = no_of_sites > 0;
+
+  clock = 1;
+  (void) time( (time_t *) &clock);
+
+  err = fprintf( file_out, "%s %s\n%s %s\n%s : ",
+                title[0], version, title[1], 
+		ctime( (time_t *) &clock), title[2] );
+  retchk( err );
+
+  if (net_name == NULL)
+    err = fprintf( file_out, "UNTITLED\n" );
+  else
+    err = fprintf( file_out, "%s\n", net_name );
+
+  retchk( err );
+  err = fprintf( file_out, "%s :\n%s : %i\n%s : %i\n%s : %i\n%s : %i\n",
+                title[14],
+                title[3], NoOfUnits,
+                title[4], NoOfLinks,
+                title[5], no_of_FTable_entries,
+                title[6], no_of_STable_entries );
+
+  retchk( err );
+
+  learn_func = krui_getLearnFunc();
+
+  err = fprintf( file_out, "\n\n%s : %s\n",
+                title[7], learn_func );
+  retchk( err );
+  err = fprintf( file_out, "%s   : %s\n",
+                title[16], krui_getUpdateFunc() );
+  retchk( err );
+
+  if (strcmp (learn_func, "PruningFeedForward") == 0)
+  {
+  err = fprintf( file_out, "%s   : %s\n",
+                title[19], krui_getPrunFunc() );
+  retchk( err );
+  err = fprintf( file_out, "%s   : %s\n",
+                title[20], krui_getFFLearnFunc() );
+  retchk( err );
+  }
+
+  return( KRERR_NO_ERROR );
+}
+/*****************************************************************************
+  FUNCTION : krio_cutTrailingZeros
+
+  PURPOSE  : cut all trailing '0'  
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void krio_cutTrailingZeros(char *string)
+{
+    int j;
+
+
+    if (*string == EOS)  return;
+    for (j = strlen( string ) - 1; ((string[j] == '0') && (j > 0)); j--) {}
+
+    if (string[j] == '.')
+      string[j] = EOS;
+    else
+      string[j + 1] = EOS;
+}
+
+/*****************************************************************************
+  FUNCTION : krio_repchar 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+****************************************************************************/
+static char  *krio_repchar(char c, int N)
+{
+  int   i;
+  static char  str[180];
+
+  if ( (N - 1) >= sizeof (str))   N = sizeof (str) - 1;
+
+  for (i = 0; i < N; i++)
+    str[ i ] = c;
+
+  str[N] = 0;
+  return( str );
+}
+
+/*****************************************************************************
+  FUNCTION : krio_stringLimits 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+
+static void  krio_stringLimits(void)
+{
+  char  *symbol, *name;
+  int   sym_type,
+        unit_no,
+	len, i1, i2, i3, i4, i5,
+	subnet_no, layer_no;
+  FlintType  act, bias;
+  int	st;
+  char	*def_act_func,	*def_out_func;
+
+  struct  PosType   pos;
+  bool	  neg1, neg2, neg3;
+
+
+  unit_name_len = site_name_len = type_name_len = 0;
+  out_func_len = act_func_len = site_func_len = 0;
+  def_out_func_len = def_act_func_len = 0;
+
+  /*  get default subnet and layer numbers  */
+  krui_getUnitDefaults( &act, &bias, &st, &subnet_no, &layer_no,
+			&def_act_func, &def_out_func );
+
+  if ( krui_getFirstSymbolTableEntry( &symbol, &sym_type) )  {
+    do  {
+      len = strlen( symbol );
+
+      switch (sym_type)  {
+        case  UNIT_SYM:
+            unit_name_len = Max( unit_name_len, len );
+            break;
+        case  SITE_SYM:
+            site_name_len = Max( site_name_len, len );
+            break;
+        case  FTYPE_UNIT_SYM:
+            type_name_len = Max( type_name_len, len );
+      }
+    }
+    while ( krui_getNextSymbolTableEntry( &symbol, &sym_type ) );
+  }
+
+  unit_no = krui_getFirstUnit();
+  do  {
+    symbol = krui_getUnitOutFuncName( unit_no );
+    if (strcmp( symbol, def_out_func ) != 0)
+      out_func_len = Max( out_func_len, strlen( symbol ));
+
+    symbol = krui_getUnitActFuncName( unit_no );
+    if (strcmp( symbol, def_act_func ) != 0)
+      act_func_len = Max( act_func_len, strlen( symbol ));
+  }
+  while ((unit_no = krui_getNextUnit() ) != 0);
+
+
+  def_out_func_len = strlen( def_out_func );
+  def_act_func_len = strlen( def_act_func );
+
+  if (krui_getFirstSiteTableEntry( &name, &symbol ))  {  
+    do
+      site_func_len = Max( site_func_len, strlen( symbol ));
+    while (krui_getNextSiteTableEntry( &name, &symbol ));
+  }
+
+  unit_no = krui_getFirstUnit();
+
+  neg1 = neg2 = neg3 = is_subnet_info =
+  is_layer_info = FALSE;
+  i1 = i2 = i3 = 0;
+
+  do  {
+    krui_getUnitPosition( unit_no, &pos );
+    i1 = Max( i1, abs( pos.x ) );
+    i1 = Max( i1, abs( pos.y ) );
+    if (pos.x < 0) neg1 = TRUE;
+    if (pos.y < 0) neg1 = TRUE;
+
+    i5 = krui_getUnitSubnetNo( unit_no );
+    if (i5 < 0) neg2 = TRUE;
+    i2 = Max( i2, abs( i5 ) );
+    if (i2 != subnet_no)  is_subnet_info = TRUE;
+
+    i4 = (int) krui_getUnitLayerNo( unit_no );
+    if (i4 < 0) neg2 = TRUE;
+    i3 = Max( i3, abs( i4 ) );
+    if (i3 != layer_no) is_layer_info = TRUE;
+  }
+  while ( (unit_no = krui_getNextUnit() ) > 0);
+
+  pos_no_len = 1;
+  while ( (i1 /= 10) != 0)
+    ++pos_no_len;
+  if (neg1)  pos_no_len++;
+
+  subnet_no_len = 1;
+  while ( (i2 /= 10) != 0)
+    ++subnet_no_len;
+  if (neg2)  subnet_no_len++;
+
+  layer_no_len = 1;
+  while ( (i3 /= 10) != 0)
+    ++layer_no_len;
+  if (neg3)  layer_no_len++;
+
+  len = NoOfUnits;
+  unit_no_len = 1;
+  while ( (len /= 10) != 0)
+    ++unit_no_len;
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_fmtShapeing
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_fmtShapeing(int choose_me)
+{
+  static char   *formats[] = {
+                /*  0   */   "site name",
+                /*  1   */   "sites",
+                /*  2   */   "unitName",
+                /*  3   */   "typeName",
+                /*  4   */   "name",
+                /*  5   */   "site function",
+                /*  6   */   "act func",
+                /*  7   */   "out func",
+                /*  8   */   "no.",
+                /*  9   */   "target",
+                /*  10  */   "act",
+                /*  11  */   "bias",
+                /*  12  */   "position",
+                /*  13  */   "site",
+                /*  14  */   " source:weight",
+                /*  15  */   "subnet",
+                /*  16  */   "layer",
+                /*  17  */   " unitNo."
+                             };
+
+  char  fmt [ MAX_LIN_LEN ],
+        aux [ MAX_LIN_LEN ];
+
+  int	len, len1, act_len, out_len;
+
+
+  switch( choose_me )
+    {
+    case  SITE_DEF:
+        if (site_name_len + site_func_len + 5 > MAX_LIN_LEN)
+          return( KRERR_SAVE_LINE_LEN );
+        len = Max( site_name_len, strlen( formats[ 0 ] ) );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, " %-", aux, "s | %s\n", (char *) 0 );
+
+	mstrcpy( fmt, " %-", aux, "s | ", (char *) 0 );
+	sprintf( fmt_hdr1, fmt, formats[ 0 ] );
+	mstrcat( fmt_hdr1, formats[ 5 ], "\n", (char *) 0 );
+
+	mstrcpy( fmt_hdr2 ,krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+	len = Max( site_func_len, strlen( formats[ 6 ] ));
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "\n", (char *) 0 );
+
+        break;
+
+    case  TYPE_DEF:
+	if (act_func_len == 0)	act_len = def_act_func_len;
+	else  act_len = act_func_len;
+	if (out_func_len == 0)	out_len = def_out_func_len;
+	else  out_len = out_func_len;
+
+	len = act_len + out_len + site_name_len + type_name_len + 11;
+	if (len > MAX_LIN_LEN)	return( KRERR_SAVE_LINE_LEN );
+
+	len = Max( type_name_len, strlen( formats[ 4 ] ));
+	len1 = len + 2;
+	sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, "%-", aux, "s |", (char *) 0 );
+	sprintf( fmt_hdr1, fmt_shape1, formats[ 4 ] );
+	mstrcpy( fmt_hdr2, krio_repchar( '-', len + 1 ), "|", (char *) 0 );
+
+
+	len = Max( act_len, strlen( formats[ 6 ] ) );
+        len1 = len1 + len + 3;
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+        strcat( fmt_shape1, fmt );
+        sprintf( aux, fmt, formats[ 6 ] );
+	strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+	len = Max( out_len, strlen( formats[ 7 ] ) );
+        len1 = len1 + len + 3;
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+	strcat( fmt_shape1, fmt );
+
+        sprintf( aux, fmt, formats[ 7 ] );
+	mstrcat( fmt_hdr1, aux, formats[1], "\n", (char *) 0 );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+	mstrcpy( fmt_blank, ",\n", krio_repchar( ' ', len1 ), (char *) 0 );
+
+        len = Max( site_name_len, strlen( formats[ 1 ] ) );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "\n", (char *) 0 );
+
+        break;
+
+    case  DEFAULT_DEF:
+        len = Max( 8, strlen( formats[ 10 ] ) );
+        len1 = len + 2;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        strcpy( fmt_shape1, "%8.5f |" );
+
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, "%-", aux, "s |", (char *) 0 );
+	sprintf( fmt_hdr1, fmt, formats[ 10 ] );
+
+	mstrcpy( fmt_hdr2, krio_repchar( '-', len + 1 ), "|", (char *) 0 );
+
+        len = Max( 8, strlen( formats[ 11 ] ) );
+        len1 = len1 + len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        strcat( fmt_shape1, " %8.5f |" );
+
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+        sprintf( aux, fmt, formats[ 11 ] );
+	strcat( fmt_hdr1, aux );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+        len1 = len1 + 5;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        strcat( fmt_shape1, " %s  |" );
+        strcat( fmt_hdr1, " st |" );
+	strcat( fmt_hdr2, "----|" );
+
+        len = Max( subnet_no_len, strlen( formats[ 15 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcat( fmt_shape1, " %", aux, "d |", (char *) 0 );
+
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+        sprintf( aux, fmt, formats[ 15 ] );
+	strcat( fmt_hdr1, aux );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+        len = Max( layer_no_len, strlen( formats[ 16 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcat( fmt_shape1, " %", aux, "d |", (char *) 0 );
+
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+        sprintf( aux, fmt, formats[ 16 ] );
+	strcat( fmt_hdr1, aux );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+	len = Max( def_act_func_len, strlen( formats[ 6 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s | ", (char *) 0 );
+        strcat( fmt_shape1, fmt );
+        sprintf( aux, fmt, formats[ 6 ] );
+	mstrcat( fmt_hdr1, aux, formats[7], "\n", (char *) 0 );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+	len = Max( def_out_func_len, strlen( formats[ 7 ] ) );
+	len1 += len + 1;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcat( fmt_shape1, "%-", aux, "s \n", (char *) 0 );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 1 ), "\n", (char *) 0 );
+
+        break;
+
+    case  UNIT_DEF:
+        len = Max( unit_no_len, strlen( formats[ 8 ] ) );
+	len1 = len + 2;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+
+	sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, "%", aux, "d |", (char *) 0 );
+
+	mstrcpy( fmt, "%", aux, "s |", (char *) 0 );
+	sprintf( fmt_hdr1, fmt, formats[ 8 ] );
+
+	mstrcpy( fmt_hdr2, krio_repchar( '-', len + 1 ), "|", (char *) 0);
+
+
+        len = Max( type_name_len, strlen( formats[ 3 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+
+	sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+	strcat( fmt_shape1, fmt );
+
+	sprintf( aux, fmt, formats[ 3 ] );
+        strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+        len = Max( unit_name_len, strlen( formats[ 2 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+
+	sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+	strcat( fmt_shape1, fmt );
+
+	sprintf( aux, fmt, formats[ 2 ] );
+	strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+        len = Max( 8, strlen( formats[ 10 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+
+        strcat( fmt_shape1, " %8.5f |" );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+
+        sprintf( aux, fmt, formats[ 10 ] );
+        strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+        len = Max( 8, strlen( formats[ 11 ] ) );
+        len1 = len1 + len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        strcat( fmt_shape1, " %8.5f |" );
+        sprintf( aux, "%d", len );
+
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+
+        sprintf( aux, fmt, formats[ 11 ] );
+        strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+	len1 += 5;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+	strcat( fmt_shape1, " %s  |" );
+	strcat( fmt_hdr1, " st |" );
+	strcat( fmt_hdr2, "----|" );
+
+
+        len = Max( pos_no_len * 3 + 2, strlen( formats[ 12 ] ) );
+
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", pos_no_len );
+	mstrcpy( fmt, " %", aux, "d,", (char *) 0 );
+        strcat( fmt_shape1, fmt );
+
+        sprintf( aux, "%d", pos_no_len );
+	mstrcpy( fmt, "%", aux, "d", (char *) 0 );
+
+
+        strcat( fmt_shape1, fmt );
+        sprintf( aux, "%d", pos_no_len );
+	mstrcpy( fmt, ",%", aux, "d", (char *) 0 );
+
+
+        if ((pos_no_len * 3 + 2) < len)
+          strcat( fmt, krio_repchar( ' ', len - (pos_no_len * 3 + 2)) );
+
+
+        strcat( fmt, " |" );
+        strcat( fmt_shape1, fmt );
+
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+
+        sprintf( aux, fmt, formats[ 12 ] );
+        strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+        len = Max( act_func_len, strlen( formats[ 6 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+	strcpy( fmt_shape2, fmt_shape1 );
+	strcat( fmt_shape2, "||" );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+	strcat( fmt_shape1, fmt );
+
+        sprintf( aux, fmt, formats[ 6 ] );
+        strcat( fmt_hdr1, aux );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+
+
+        len = Max( out_func_len, strlen( formats[ 7 ] ) );
+	len1 += len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, " %-", aux, "s | ", (char *) 0 );
+	strcat( fmt_shape1, fmt );
+
+        sprintf( aux, fmt, formats[ 7 ] );
+	mstrcat( fmt_hdr1, aux, formats[1], "\n", (char *) 0 );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+	mstrcpy( fmt_blank, ",\n", krio_repchar( ' ', len1 ), (char *) 0 );
+
+
+        len = Max( site_name_len, strlen( formats[ 1 ] ) );
+	len1 += len + 2;
+	if (len1 + len > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "\n", (char *) 0 );
+
+        break;
+
+    case  CONNECT_DEF:
+        sprintf( aux, "%d", unit_no_len );
+	mstrcpy( fmt_shape3, " %", aux, "d:%8.5f", (char *) 0 );
+        mstrcpy( fmt_shape4, " %", aux, "d:%8.5f (%8.5f,%8.5f) ", (char *) 0 );
+        len = Max( unit_no_len, strlen( formats[ 9 ] ) );
+        len1 = len + 2;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, "%", aux, "d |", (char *) 0 );
+
+	mstrcpy( fmt, "%", aux, "s |", (char *) 0 );
+	sprintf( fmt_hdr1, fmt, formats[ 9 ] );
+	mstrcpy( fmt_hdr2, krio_repchar( '-', len + 1 ), "|", (char *) 0 );
+        strcpy( fmt_shape2, krio_repchar( ' ', len1 ) );
+
+        len = Max( site_name_len, strlen( formats[ 13 ] ) );
+        len1 = len1 + len + 3;
+	if (len1 > MAX_LIN_LEN)  return( KRERR_SAVE_LINE_LEN );
+        sprintf( aux, "%d", len );
+
+
+	mstrcpy( fmt, " %-", aux, "s |", (char *) 0 );
+        strcat( fmt_shape1, fmt );
+        strcat( fmt_shape2, fmt );
+        sprintf( aux, fmt, formats[ 13 ] );
+	mstrcat( fmt_hdr1, aux, formats[14], "\n", (char *) 0 );
+
+	mstrcat( fmt_hdr2, krio_repchar( '-', len + 2 ), "|", (char *) 0 );
+	mstrcpy( fmt_blank, "\n", krio_repchar( ' ', len1 ), (char *) 0 );
+
+	if ((len1 + unit_no_len + 14) > MAX_LIN_LEN)  
+	    return( KRERR_SAVE_LINE_LEN );
+        max_connects_per_line = (BEST_LINE_LEN - len1) / (unit_no_len + 11);
+	mstrcat( fmt_hdr2,
+		 krio_repchar( '-', 
+			      (unit_no_len + 11) * max_connects_per_line ),
+		"\n", (char *) 0 );
+
+        break;
+
+      case  SUBNET_DEF:
+        len = Max( subnet_no_len, strlen( formats[ 15 ] ) );
+	len1 = len + 1;
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, "\n%", aux, "d |", (char *) 0 );
+
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt, "%", aux, "s |", (char *) 0 );
+        sprintf( fmt_hdr1, fmt, formats[ 15 ] );
+        strcat( fmt_hdr1, formats[17] );
+	mstrcpy( fmt_hdr2, "\n", krio_repchar( '-', len1 ), "|", (char *) 0 );
+	mstrcpy( fmt_blank, "\n", krio_repchar( ' ', len1 + 1 ), (char *) 0 );
+
+        sprintf( aux, "%d", unit_no_len );
+	mstrcat( fmt_shape1, " %", aux, "d", (char *) 0 );
+	mstrcpy( fmt_shape2, " %", aux, "d", (char *) 0 );
+
+        max_subnets_per_line = (BEST_LINE_LEN - len1 - 1) / (unit_no_len + 2);
+        strcat( fmt_hdr2, krio_repchar( '-', (unit_no_len + 2) 
+				             * max_subnets_per_line ) );
+
+        break;
+
+      case  LAYER_DEF:
+        len = Max( layer_no_len, strlen( formats[ 16 ] ) );
+	len1 = len + 1;
+        sprintf( aux, "%d", len );
+	mstrcpy( fmt_shape1, "\n%", aux, "d |", (char *) 0 );
+
+	mstrcpy( fmt, "%", aux, "s |", (char *) 0 );
+        sprintf( fmt_hdr1, fmt, formats[ 16 ] );
+        strcat( fmt_hdr1, formats[17] );
+
+	mstrcpy( fmt_hdr2, "\n", krio_repchar( '-', len1 ), "|", (char *) 0 );
+	mstrcpy( fmt_blank, "\n", krio_repchar( ' ', len1 + 1 ), (char *) 0 );
+
+        sprintf( aux, "%d", unit_no_len );
+	mstrcat( fmt_shape1, " %", aux, "d", (char *) 0 );
+	mstrcpy( fmt_shape2, " %", aux, "d", (char *) 0 );
+
+        max_layers_per_line = (BEST_LINE_LEN - len1 - 1) / (unit_no_len + 2);
+        strcat( fmt_hdr2, krio_repchar( '-', (unit_no_len + 2) 
+				             * max_layers_per_line ) );
+
+        break;
+  }
+
+  return( 0 );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeSiteDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeSiteDefinitions(void)
+{
+  int   err;
+  char  *site_name,
+        *site_func;
+
+
+  if ( !krui_getFirstSiteTableEntry( &site_name, &site_func ) )
+    return( 0 );
+
+  err = krio_fmtShapeing( SITE_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[8] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  do
+    {
+    err = fprintf( file_out, fmt_shape1,
+                   site_name, site_func );
+    retchk( err );
+  }
+  while (krui_getNextSiteTableEntry( &site_name, &site_func ) );
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+  return( 0 );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeTypeDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeTypeDefinitions(void)
+{
+  int   err;
+  bool  second;
+
+
+  if ( !krui_setFirstFTypeEntry() )
+    return( 0 );
+
+  err = krio_fmtShapeing( TYPE_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[9] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  do  {
+    err = fprintf( file_out, fmt_shape1,
+                   krui_getFTypeName(),
+                   krui_getFTypeActFuncName(), krui_getFTypeOutFuncName() );
+    retchk( err );
+
+    if ( krui_setFirstFTypeSite() )  {
+      second = FALSE;
+      do  {
+        if (second)  {
+	  err = fprintf( file_out, fmt_blank );
+          retchk( err );
+	}
+
+	err = fprintf( file_out, " %-s", krui_getFTypeSiteName() );
+        retchk( err );
+        second = TRUE;
+      }
+      while ( krui_setNextFTypeSite() );
+    }
+
+    err = fprintf( file_out, "\n" );
+    retchk( err );
+  }
+  while (krui_setNextFTypeEntry() );
+
+  err = fprintf( file_out, fmt_hdr2 );
+  if (err <= 0)  return( err );
+
+  return( 0 );
+}
+
+/*****************************************************************************
+  FUNCTION : getTType 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static char  *getTType(int st)
+{
+  static char   *ttype[] = { "-", "i", "o", "d", "h", "s" ,
+                             "si", "so", "sh", "sd"}; 
+
+  switch ( st )  {
+    case  INPUT:
+      return( ttype[1] );
+    case  OUTPUT:
+      return( ttype[2] );
+    case  DUAL:
+      return( ttype[3] );
+    case  HIDDEN:
+      return( ttype[4] );
+    case  SPECIAL:
+      return( ttype[5] );
+    case  SPECIAL_I:      
+      return( ttype[6] ); 
+    case  SPECIAL_O:      
+      return( ttype[7] ); 
+    case  SPECIAL_H:      
+      return( ttype[8] ); 
+    case  SPECIAL_D:      
+      return( ttype[9] ); 
+    default:
+      return( ttype[0] );
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeDefaultDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeDefaultDefinitions(void)
+{
+  int   err;
+  FlintType  act, bias;
+  int   st, subnet_no, layer_no;
+  char  *act_func,  *out_func;
+
+
+  err = krio_fmtShapeing( DEFAULT_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[13] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  krui_getUnitDefaults( &act, &bias, &st, &subnet_no, &layer_no,
+                        &act_func, &out_func );
+
+  if ((act_func != NULL) && (out_func != NULL))  {
+    err = fprintf( file_out, fmt_shape1, act, bias, getTType( st ),
+                   subnet_no, layer_no, act_func, out_func );
+  }
+  else  {
+    err = fprintf( file_out, fmt_shape1, act, bias, getTType( st ),
+                   subnet_no, layer_no, " ", " " );
+  }
+
+  retchk( err );
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeUnitDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeUnitDefinitions(void)
+{
+  static char   *blank = "\0";
+
+  struct  PosType   pos;
+
+  char  *u_type,
+        *u_name,
+        *act_func,
+        *act_func_def,
+        *out_func_def,
+        *out_func;
+
+  bool  no_Ftype, second,
+        writeUnitActFuncName, writeUnitOutFuncName;
+  int   err,
+        unit_no,
+        u_no,
+        st_def, subnet_no, layer_no;
+
+  FlintType  act_def, bias_def;
+
+
+
+  if (NoOfUnits <= 0)  return( KRERR_NO_ERROR );
+
+  err = krio_fmtShapeing( UNIT_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[10] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  krui_getUnitDefaults( &act_def, &bias_def, &st_def, &subnet_no, &layer_no,
+                        &act_func_def, &out_func_def );
+
+  unit_no = krui_getFirstUnit();
+  u_no = 1;
+
+  do  {
+    krui_getUnitPosition( unit_no, &pos );
+
+    if ( (u_name = krui_getUnitName( unit_no )) == NULL)
+      u_name = blank;
+
+    if ( (u_type = krui_getUnitFTypeName( unit_no )) == NULL)
+      {  /*  no ftype  */
+      no_Ftype = TRUE;
+
+      act_func = krui_getUnitActFuncName( unit_no );
+      out_func = krui_getUnitOutFuncName( unit_no );
+
+      writeUnitActFuncName = strcmp( act_func, act_func_def) != 0;
+      writeUnitOutFuncName = strcmp( out_func, out_func_def) != 0;
+
+      if (!writeUnitActFuncName && !writeUnitOutFuncName)  {
+
+    err = fprintf( file_out, fmt_shape2,
+		   u_no, blank, u_name,
+                   krui_getUnitActivation( unit_no ),
+                   krui_getUnitBias( unit_no ),
+                   getTType( krui_getUnitTType( unit_no ) ),
+		   pos.x, pos.y, pos.z );
+
+	}
+      else  {
+	if (!writeUnitActFuncName)  act_func = blank;
+	if (!writeUnitOutFuncName)  out_func = blank;
+
+
+    err = fprintf( file_out, fmt_shape1,
+		   u_no, blank, u_name,
+                   krui_getUnitActivation( unit_no ),
+                   krui_getUnitBias( unit_no ),
+                   getTType( krui_getUnitTType( unit_no ) ),
+                   pos.x, pos.y, pos.z, act_func, out_func );
+
+      }
+    }
+    else  {
+
+    err = fprintf( file_out, fmt_shape2,
+                   u_no, u_type, u_name,
+                   krui_getUnitActivation( unit_no ),
+                   krui_getUnitBias( unit_no ),
+                   getTType( krui_getUnitTType( unit_no ) ),
+		   pos.x, pos.y, pos.z );
+
+
+      no_Ftype = FALSE;
+    }
+
+
+    retchk( err );
+
+    if ( no_Ftype )  {
+      if ( krui_setFirstSite() )  {
+        second = FALSE;
+        do  {
+          if (second)  {
+	    err = fprintf( file_out, fmt_blank );
+	    retchk( err );
+	  }
+
+	  err = fprintf( file_out, " %-s", krui_getSiteName() );
+          retchk( err );
+          second = TRUE;
+	}
+        while ( krui_setNextSite() );
+      }
+    }
+
+    err = fprintf( file_out, "\n" );
+    retchk( err );
+    u_no++;
+  }
+  while ( (unit_no = krui_getNextUnit() ) > 0);
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeTimeDelayDefs
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static krui_err    krio_writeTimeDelayDefs(void)
+{
+
+  struct Unit  *unit_ptr;
+
+  int   err,
+        unit_no,
+        u_no,
+        lln,
+        lun,
+        toff,
+        soff,
+        conn_type;
+
+  if (NoOfUnits <= 0)
+    return( 0 );
+
+
+  if ((strcmp (krui_getLearnFunc(), "TimeDelayBackprop") == 0) || 
+      (strcmp (krui_getLearnFunc(), "TDBP_McClelland") == 0)) {
+  
+     err = fprintf( file_out, "\n\n%s :\n\n", title[18] ); 
+     retchk( err );
+     err = fprintf (file_out, "%s\n", headers[8]);
+     retchk (err);
+     err = fprintf (file_out, "-----|-----|-----|------|------|-------\n");
+     retchk (err);
+
+     unit_no = krui_getFirstUnit ();
+     u_no = 1;
+
+     do {
+
+       unit_ptr = kr_getUnitPtr (unit_no);
+
+       lln = unit_ptr->lln;
+       lun = unit_ptr->lun;
+       toff = unit_ptr->TD.target_offset;
+       soff = unit_ptr->TD.source_offset;
+       conn_type = unit_ptr->TD.td_connect_typ;
+    
+       err = fprintf (file_out, "%4d |%4d |%4d |%5d |%5d |%6d\n", 
+		      u_no, lln, lun, toff, soff, conn_type);
+       retchk (err);
+    
+       unit_no = krui_getNextUnit ();
+       u_no++;
+
+     } while (unit_no != 0);
+
+     err = fprintf(file_out, "-----|-----|-----|------|------|-------\n");
+     retchk (err);
+
+   }
+  
+  return (KRERR_NO_ERROR);
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeSourcesAndWeights  
+
+  PURPOSE  : write link weights
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static krui_err  krio_writeSourcesAndWeights(void)
+{
+  bool  second;
+  int   i, err,
+        source_unit,
+        tacoma_mode;
+
+  FlintType     weight;
+  float val_a,val_b,val_c;
+  
+
+  tacoma_mode = (!strcmp(krui_getUnitActFuncName(GET_UNIT_NO(unitPtr)),"Act_TACOMA"));
+   i = 0;
+  source_unit = krui_getFirstPredUnitAndData( &weight, &val_a, &val_b, &val_c );
+  second = FALSE;
+
+  do  {
+    if (second)  {
+      err = fprintf( file_out, "," );
+      retchk( err );
+    }
+
+    if (++i > max_connects_per_line)  {
+      i = 1;
+      err = fprintf( file_out, fmt_blank );
+      retchk( err );
+    }
+    if ((tacoma_mode)&&((val_a != 0.0)&&(val_b != 0.0)))
+      err = fprintf( file_out, fmt_shape4, source_unit, weight, val_b, val_a);
+    else
+      err = fprintf( file_out, fmt_shape3, source_unit, weight );
+    retchk( err );
+
+    second = TRUE;
+  }
+  while ( (source_unit = krui_getNextPredUnitAndData( &weight, &val_a, &val_b, &val_c )) > 0);
+
+  err = fprintf( file_out, "\n" );
+  retchk( err );
+
+  return( KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : krio_writeConnectionDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeConnectionDefs(void)
+{
+  bool  second;
+  int   target_unit, unit_no,
+        err;
+
+
+  FlintType  weight;
+
+
+  if (NoOfLinks == 0)  return( 0 );
+
+  err = krio_fmtShapeing( CONNECT_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[11] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  unit_no = krui_getFirstUnit();
+  target_unit = 1;
+
+  do  {
+    switch (krui_getUnitInputType( unit_no ))  {
+      case  DIRECT_LINKS:
+	err = fprintf( file_out, fmt_shape1, target_unit, " ");
+        retchk( err );
+	err = krio_writeSourcesAndWeights();
+        retchk( err );
+
+        break;
+
+      case  SITES:
+        krui_setFirstSite();
+        second = FALSE;
+
+        do  {
+          if (krui_getFirstPredUnit( &weight ) > 0)  {
+            if (second)  {
+	      err = fprintf( file_out, fmt_shape2, krui_getSiteName() );
+              retchk( err );
+	    }
+            else  {
+	      err = fprintf( file_out, fmt_shape1, target_unit, 
+			    krui_getSiteName() );
+              retchk( err );
+	    }
+
+	    err = krio_writeSourcesAndWeights();
+            retchk( err );
+
+            second = TRUE;
+	  }
+	}
+        while ( krui_setNextSite() );
+
+        break;
+    }
+
+    target_unit++;
+  }
+  while ( (unit_no = krui_getNextUnit()) > 0 );
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_writeSubnetDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static krui_err  krio_writeSubnetDefs(void)
+{
+  struct Unit   *unit_ptr,
+                *unit_ptr2;
+  int	i,  k, elem_no, err, dummy2, def_subnet_no;
+  short  subnet_no;
+  FlintType  dummy1;
+  char	*dummy3;
+
+
+  if (!is_subnet_info)  return( 0 );
+
+  err = krio_fmtShapeing( SUBNET_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[12] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  /*  get default subnet number  */
+  krui_getUnitDefaults( &dummy1, &dummy1, &dummy2, &def_subnet_no, &dummy2,
+			&dummy3, &dummy3 );
+
+  /*  clear refresh flags  */
+  FOR_ALL_UNITS( unit_ptr )
+    unit_ptr->flags &= ~UFLAG_REFRESH;
+
+  for (i = MinUnitNo, unit_ptr = unit_array + MinUnitNo; 
+       i <= MaxUnitNo; 
+       i++, unit_ptr++)
+      if (!UNIT_REFRESHED( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {				/*  unit is in use and 'fresh' */
+	  subnet_no = unit_ptr->subnet_no;
+	  if (subnet_no == def_subnet_no)
+	      continue;
+
+	  err = fprintf( file_out, fmt_shape1, subnet_no, i);
+	  retchk( err );
+	  elem_no = 0;
+
+	  for (k = i + 1, unit_ptr2 = unit_ptr + 1;
+	       k <= MaxUnitNo;
+	       k++, unit_ptr2++ )
+	  {
+	      if (!UNIT_REFRESHED( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+	      {			/*  unit is in use and 'fresh' */
+		  if (unit_ptr2->subnet_no == subnet_no)  {
+		      unit_ptr2->flags |= UFLAG_REFRESH;
+
+		      err = fprintf( file_out, "," );
+		      retchk( err );
+
+		      if ( (++elem_no % max_subnets_per_line) == 0)  {
+			  err = fprintf( file_out, fmt_blank );
+			  retchk( err );
+		      }
+
+		      err = fprintf( file_out, fmt_shape2,  k);
+		      retchk( err );
+		  }
+	      }
+	  }
+      }
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+  err = fprintf( file_out, "\n" );
+  retchk( err );
+
+  return( KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : krio_writeLayerDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static krui_err  krio_writeLayerDefs(void)
+{
+  struct Unit   *unit_ptr,
+                *unit_ptr2;
+
+  int	i,  k, elem_no, err, dummy2, def_layer_no;
+  short  layer_no;
+  FlintType  dummy1;
+  char	    *dummy3;
+
+
+  if (!is_layer_info)  return( KRERR_NO_ERROR );
+
+  err = krio_fmtShapeing( LAYER_DEF );
+  retchk( err );
+
+  err = fprintf( file_out, "\n\n%s :\n\n", title[15] );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr1 );
+  retchk( err );
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+
+  /*  get default layer number	*/
+  krui_getUnitDefaults( &dummy1, &dummy1, &dummy2, &dummy2, &def_layer_no,
+			&dummy3, &dummy3 );
+
+  /*  clear refresh flags  */
+  FOR_ALL_UNITS( unit_ptr )
+    unit_ptr->flags &= ~UFLAG_REFRESH;
+
+  for (i = MinUnitNo, unit_ptr = unit_array + MinUnitNo; 
+       i <= MaxUnitNo; 
+       i++, unit_ptr++)
+      if (!UNIT_REFRESHED( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+      {				/*  unit is in use and 'fresh' */
+	  layer_no = (int) unit_ptr->layer_no;
+	  if (layer_no == def_layer_no)
+	      continue;
+
+	  err = fprintf( file_out, fmt_shape1, layer_no, i);
+	  retchk( err );
+	  elem_no = 0;
+
+	  for (k = i + 1, unit_ptr2 = unit_ptr + 1;
+	       k <= MaxUnitNo;
+	       k++, unit_ptr2++ )  {
+	      if (!UNIT_REFRESHED( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+	      {			/*  unit is in use and 'fresh' */
+		  if ((int) unit_ptr2->layer_no == layer_no)  {
+		      unit_ptr2->flags |= UFLAG_REFRESH;
+
+		      err = fprintf( file_out, "," );
+		      retchk( err );
+
+		      if ( (++elem_no % max_layers_per_line) == 0)  {
+			  err = fprintf( file_out, fmt_blank );
+			  retchk( err );
+		      }
+
+		      err = fprintf( file_out, fmt_shape2, k);
+		      retchk( err );
+		  }
+	      }
+	  }
+      }
+
+  err = fprintf( file_out, fmt_hdr2 );
+  retchk( err );
+  err = fprintf( file_out, "\n" );
+  retchk( err );
+
+  return( KRERR_NO_ERROR );
+}
+
+
+
+
+static krui_err  writeXYTransTable(void)
+{
+  int err;
+  int z_index;
+
+
+  if (transTableSize > 0)  {
+    err = fprintf( file_out, "\n\n%s :\n\n", title[17]);
+    retchk( err );
+    err = fprintf( file_out, " delta x | delta y |    z    \n");
+    retchk( err );
+    err = fprintf( file_out, "---------|---------|---------\n");
+    retchk( err );
+    for (z_index = 0; z_index < transTableSize; z_index++)  {
+	err = fprintf( file_out, "%8d |", transTable[z_index].x);
+	retchk( err );
+	err = fprintf( file_out, "%8d |", transTable[z_index].y);
+	retchk( err );
+	err = fprintf( file_out, "%8d \n", transTable[z_index].z);
+	retchk( err );
+    }
+
+    err = fprintf( file_out, "---------|---------|---------\n");
+    retchk( err );
+    err = fprintf( file_out, "\n" );
+    retchk( err );
+  }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_saveNet  
+
+  PURPOSE  : write complete network to disk
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+krui_err  krio_saveNet(char *filename, char *netname)
+{
+  int  err;
+
+  if (NoOfUnits == 0)  return( KRERR_NO_UNITS );  /*  no units defined	*/
+
+  if ((file_out = fopen( filename, "w" )) == NULL)  {
+    err = KRERR_IO;  /*  file open error  */
+    goto  ende;
+  }
+
+  kr_forceUnitGC();  /*  do unit garbage-collection  */
+
+  /*  write file header  */
+  err = krio_writeHeader( krio_getIOVersion(), netname );
+
+  /*  calc. maximum string length of all identifiers  */
+  krio_stringLimits();
+  if (err < 0)	goto ende;
+
+  err = krio_writeSiteDefinitions();
+  if (err < 0)	goto ende;
+
+  err = krio_writeTypeDefinitions();
+  if (err < 0)	goto ende;
+
+  err = krio_writeDefaultDefinitions();
+  if (err < 0)	goto ende;
+
+  err = krio_writeUnitDefinitions();
+  if (err < 0)	goto ende;
+/*
+  err = krio_writeTopologicDef();
+  if (err < 0)	goto ende;
+*/
+  err = krio_writeConnectionDefs();
+  if (err < 0)	goto ende;
+
+  err = krio_writeSubnetDefs();
+  if (err < 0)	goto ende;
+  err = krio_writeLayerDefs();
+  if (err < 0)	goto ende;
+  err = krio_writeTimeDelayDefs ();
+  if (err < 0)	goto ende;
+
+  err = writeXYTransTable();
+  if (err < 0)	goto ende;
+
+  err = fclose( file_out );
+
+ende:
+
+  KernelErrorCode = err;
+
+  return( KernelErrorCode );
+}
+
+
+
+/*#################################################
+
+GROUP: Kernel I/O Input Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : skipComments 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  skipComments(void)
+{
+  register int   c;
+
+  while (TRUE)  {
+    do  {
+      c = getc( file_in );
+      if (c == '\n')  lineno++;
+    }
+    while ( isspace( c ) );
+
+    if (c != '#')  break;
+
+    do
+      c = getc( file_in );
+    while (c != EOF && c != '\n');
+
+    if (c == '\n')  lineno++;
+  }
+
+  if (c == EOF)  return( FALSE );
+
+  ungetc( c, file_in );
+  return( TRUE );
+}
+/*****************************************************************************
+  FUNCTION : skipSpace 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+
+static bool  skipSpace(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == EOF)  {
+    KernelErrorCode = KRERR_EOF;
+    return( FALSE );
+  }
+
+  ungetc( c, file_in );
+  return( TRUE );
+}
+
+/*****************************************************************************
+  FUNCTION : comma  
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  comma(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == EOF)  {  KernelErrorCode = KRERR_EOF;  return( FALSE ); }
+  if (c != ',')  {
+    ungetc( c, file_in );
+    return( FALSE );
+  }
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  ungetc( c, file_in );
+  return( TRUE );
+}
+
+
+/*****************************************************************************
+  FUNCTION :  get_nl
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  get_nl(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  {
+      lineno++;
+      return( TRUE );
+    }
+  }
+  while ( isspace( c ) );
+
+  if (c == EOF)  KernelErrorCode = KRERR_EOF;
+  else  ungetc( c, file_in );
+
+  return( FALSE );
+}
+
+/*****************************************************************************
+  FUNCTION : get_pipe 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  get_pipe(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == '|')  return( TRUE );
+
+  if (c == EOF)  KernelErrorCode = KRERR_EOF;
+  else  ungetc( c, file_in );
+
+  return( FALSE );
+}
+/*****************************************************************************
+  FUNCTION : skip_pipe  
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  skip_pipe(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == '|')  return( TRUE );
+
+  if (c == EOF)  KernelErrorCode = KRERR_EOF;
+  else  {
+    ungetc( c, file_in );
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+  }
+
+  return( FALSE );
+}
+
+/*****************************************************************************
+  FUNCTION : get_alpha   
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+
+static bool  get_alpha(void)
+{
+  register int  c;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == EOF)  KernelErrorCode = KRERR_EOF;
+  else  {
+    ungetc( c, file_in );
+    if (isalpha( c ))  return( TRUE );
+  }
+
+  return( FALSE );
+}
+/*****************************************************************************
+  FUNCTION : getSymbol 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  getSymbol(char *symbol)
+{
+  register int  c;
+  register char  *s_ptr;
+
+  do  {
+    c = getc( file_in );
+    if (c == '\n')  lineno++;
+  }
+  while ( isspace( c ) );
+
+  if (c == EOF)  {
+    KernelErrorCode = KRERR_EOF;
+    return( FALSE );
+  }
+  else  {
+    s_ptr = symbol;
+    while (isgraph( c ))  {
+      if ((c == ',') || (c == '|'))  break;
+      *s_ptr++ = c;
+      c = getc( file_in );
+    }
+
+    ungetc( c, file_in );
+    *s_ptr = EOS;
+    if (s_ptr == symbol)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return( FALSE );
+    }
+    return( TRUE );
+  }
+}
+/*****************************************************************************
+  FUNCTION : getSection 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static char  *getSection(char *line, int *title_no)
+{
+  int   i;
+  char  *s1_ptr, *s2_ptr;
+
+
+  if ( !skipComments() )
+    {  /* EOF  */
+    *title_no = -2;
+    return( NULL );
+  }
+
+  if (fgets( line, LIN_MAX, file_in ) == NULL)
+    {  /*  I/O error  */
+    *title_no = -3;
+    return( NULL );
+  }
+
+  for (i = 0; i < NoOfTitles; i++)  {
+    s1_ptr = line;
+    s2_ptr = title[ i ];
+    while (*s2_ptr != EOS)
+      {  /* compare strings, don't examine white space  */
+      if (*s1_ptr == ' ') s1_ptr++;
+      if (*s2_ptr == ' ') s2_ptr++;
+      if (*s1_ptr++ != *s2_ptr++)  break;
+
+      if (*s2_ptr == EOS)
+	{   /*	strings are equal   */
+	*title_no = i;
+	return( s1_ptr );
+      }
+    }
+  }
+
+
+  *title_no = -1;  /*  title not found  */
+  return( NULL );
+}
+
+/*****************************************************************************
+  FUNCTION : matchHead
+
+  PURPOSE  : read /dev/null
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  matchHead(int N)
+{
+  register int  c;
+  int   i;
+
+
+  c = getc( file_in );
+  if (c != '-')  {
+    ungetc( c, file_in );
+    return( FALSE );
+  }
+
+  for (i = 0; i < N; i++)  {
+    c = getc( file_in );
+    if (c != '-')
+      return( FALSE );
+
+    do
+      c = getc( file_in );
+    while ( c == '-' );
+
+    if (c != '|')  {  KernelErrorCode = KRERR_FILE_SYNTAX;  return( FALSE );  }
+  }
+
+  c = getc( file_in );
+  if (c != '-')  {  KernelErrorCode = KRERR_FILE_SYNTAX;  return( FALSE );  }
+
+  do
+    c = getc( file_in );
+  while ( c == '-' );
+
+  if (c == EOF)  {  KernelErrorCode = KRERR_EOF;  return( FALSE ); }
+  ungetc( c, file_in );
+
+  if ( !get_nl() )  return( FALSE );
+
+  return( TRUE );
+}
+
+/*****************************************************************************
+  FUNCTION : matchHead2 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static bool  matchHead2(int N)
+{
+  if (!skipSpace())  return( FALSE );
+
+  return( matchHead(N) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : my_strstr 
+
+  PURPOSE  : Find the first occurrence of find in s.
+             (slow version)
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static char  *my_strstr(char *s, char *find)
+{
+  register char c, sc;
+  register size_t len;
+
+  if ((c = *find++) != 0)  {
+    len = strlen(find);
+    do  {
+      do  {
+	if ((sc = *s++) == 0)	return (NULL);
+      }
+      while (sc != c);
+    }
+    while (strncmp(s, find, len) != 0);
+    s--;
+  }
+
+  return ((char *) s);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krio_readHeader 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readHeader(char *netfile_version, char *net_name, 
+			     char *learn_func, char *update_func,
+			     char *pruning_func, char *ff_learn_func,
+			     int *no_of_units, int *no_of_connect, 
+			     int *no_of_unitTypes, int *no_of_siteTypes)
+{
+  char  *cursor;
+  int   ret_code,  i, no_of_scan_params,
+        title_no;
+
+
+  ret_code = 1;
+
+  /*  get file version  */
+  cursor = getSection( fmt_shape1, &title_no );
+  if ((cursor == NULL) || (title_no != 0))  {
+    /*  "SNNS network definition file" not found  */
+    KernelErrorCode = KRERR_FILE_FORMAT;
+    return;
+  }
+  if (sscanf( cursor, "%s", netfile_version ) != 1)  {
+    /*  version string not found */
+    KernelErrorCode = KRERR_FILE_FORMAT;
+    return;
+  }
+
+  /*  determine version number of the network file  */
+  if (my_strstr( netfile_version, KERNEL3D_NETFILE_VERSION ) != NULL)
+    NetfileVersion = 1;
+  else
+    NetfileVersion = 0;
+
+  if (my_strstr( netfile_version, NETFILE_VERSION ) != NULL ||
+      my_strstr( netfile_version, NETFILE_VERSION2 ) != NULL)
+    /*  current netfile version  */
+    no_of_scan_params = 9;
+  else
+    no_of_scan_params = 8;
+
+  for (i = 0; i < no_of_scan_params; i++)  {
+    if ( (cursor = getSection( fmt_shape1, &title_no )) == NULL)  return;
+
+    switch (title_no)  {
+      case  -3:  /*  Physical I/O error  */
+        KernelErrorCode = KRERR_IO;
+        return;
+      case  -2:  /*  unexpected EOF  */ 
+        KernelErrorCode = KRERR_EOF;
+        return;
+      case  -1:  /*  not found  */ 
+        KernelErrorCode = KRERR_FILE_FORMAT;  /*  Incompatible file format  */
+        return;
+      case  1:  /*  "generated at"  */
+        break;
+      case  2:  /*  network name"  */
+        ret_code = sscanf( cursor, " :%s", net_name );
+        if ((ret_code != 1) && (ret_code != 0))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        if (ret_code == 0) {
+          *net_name = EOS;
+          ret_code = 1;
+        }
+        break;
+      case  3:  /*  "no. of units"  */
+        ret_code = sscanf( cursor, " :%d", no_of_units );
+        break; 
+      case  4:  /*  "no. of connections"  */
+        ret_code = sscanf( cursor, " :%d", no_of_connect );
+        break;
+      case  5:  /*  "no. of unit types"  */
+        ret_code = sscanf( cursor, " :%d", no_of_unitTypes );
+        break;
+      case  6:  /*  "no. of site types"  */
+        ret_code = sscanf( cursor, " :%d", no_of_siteTypes );
+        break;
+      case  7:  /*  "learning function"  */
+        ret_code = sscanf( cursor, " :%s\n", learn_func );
+        if ((ret_code != 1) && (ret_code != 0))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        if (ret_code == 0)  {
+          *learn_func = '\0';
+          ret_code = 1;
+        }
+	if (strcmp (learn_func, "PruningFeedForward") == 0)
+	    /* pruning functions need two more lines */
+	    no_of_scan_params += 2;
+        break;
+      case 14:  /*  "source files"  */
+        break;
+      case  16:  /*  "update function"  */
+        ret_code = sscanf( cursor, " :%s\n", update_func );
+        if ((ret_code != 1) && (ret_code != 0))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+
+        if (ret_code == 0)  {
+          *update_func = '\0';
+          ret_code = 1;
+        }
+        break;
+      case 19:  /* pruning function */
+        ret_code = sscanf( cursor, " :%s\n", pruning_func );
+        if ((ret_code != 1) && (ret_code != 0))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+
+        if (ret_code == 0)  {
+          *pruning_func = '\0';
+          ret_code = 1;
+        }
+        break;
+      case 20:  /* feed forward learning function */
+        ret_code = sscanf( cursor, " :%s\n", ff_learn_func );
+        if ((ret_code != 1) && (ret_code != 0))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+
+        if (ret_code == 0)  {
+          *ff_learn_func = '\0';
+          ret_code = 1;
+        }
+        break;
+      default:
+        KernelErrorCode = KRERR_FILE_FORMAT;  /*  Incompatible file format  */
+        return;
+     }
+
+   switch (ret_code)  {
+     case 1:    /*  one argument matched  */
+       break;
+     case EOF:  /*  unexpected EOF  */
+       KernelErrorCode = KRERR_EOF;
+       return;
+     default:   /*  Syntax error at line  */
+       KernelErrorCode = KRERR_FILE_SYNTAX;
+       return;
+     }
+
+   lineno++;
+   }
+
+}
+
+/*****************************************************************************
+  FUNCTION : str_to_Ttype 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static int  str_to_Ttype(char *str)
+{
+  if (strcmp (str, "i" ) == 0) return (INPUT    ) ;
+  if (strcmp (str, "o" ) == 0) return (OUTPUT   ) ;
+  if (strcmp (str, "h" ) == 0) return (HIDDEN   ) ;
+  if (strcmp (str, "d" ) == 0) return (DUAL     ) ;
+  if (strcmp (str, "s" ) == 0) return (SPECIAL  ) ;
+  if (strcmp (str, "si") == 0) return (SPECIAL_I) ;
+  if (strcmp (str, "so") == 0) return (SPECIAL_O) ;
+  if (strcmp (str, "sh") == 0) return (SPECIAL_H) ;
+  if (strcmp (str, "sd") == 0) return (SPECIAL_D) ;
+  return( 0 );
+}
+
+/*****************************************************************************
+  FUNCTION : krio_readSiteDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readSiteDefinitions(void)
+{
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[0] ) != 0) ||
+      !matchHead2( 1 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  NoOfSiteTypes = 0;
+  while (TRUE)  {
+    if (matchHead2( 1 )) return;
+    if (!skipComments())  return;
+
+    if (!getSymbol( fmt_shape1 ))  return;
+
+    /*  skip "|" character  */
+    if (!skip_pipe())  return;
+
+    if (!getSymbol( fmt_shape2 ))  return;
+
+    if (krui_createSiteTableEntry( fmt_shape1, fmt_shape2 ) != KRERR_NO_ERROR)
+      return;
+
+    NoOfSiteTypes++;
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : krio_readTypeDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readTypeDefinitions(void)
+{
+  int  no_of_sites;
+  SymbolType  *site_names = NULL;
+  char  * *site_name_ptrs;
+
+
+  NoOfUnitTypes = 0;
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[1] ) != 0) ||
+      !matchHead2( 3 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  if (NoOfSiteTypes > 0)  {
+    site_names = (SymbolType *) 
+	calloc( (unsigned int) NoOfSiteTypes, sizeof (SymbolType) );
+    site_name_ptrs = (char * *) 
+	calloc( (unsigned int) NoOfSiteTypes, sizeof (site_name_ptrs) );
+    if (site_names == NULL || site_name_ptrs == NULL)  {
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return;
+    }
+  }
+
+  while (TRUE)  {
+    if ( matchHead2( 3 ) )  break;
+    if ( !skipComments() )  break;
+
+    /*  read unit type name, activation and output function  */
+    if (fscanf( file_in, "%s | %s | %s",
+                fmt_shape1, fmt_shape2,  fmt_shape3 ) != 3)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    /*  skip "|" character  */
+    if (!skip_pipe())  return;
+
+    NoOfUnitTypes++;
+
+    if (get_nl())  {
+      /*  no sites  */
+      if (krui_createFTypeEntry( fmt_shape1, fmt_shape2,  fmt_shape3,
+                                 0, site_name_ptrs ) != KRERR_NO_ERROR)
+	  return;
+      continue;
+    }
+
+    no_of_sites = 0;
+    while (TRUE)  {
+      if (!getSymbol( site_names[ no_of_sites ] ))  return;
+
+      site_name_ptrs[ no_of_sites ] = site_names[ no_of_sites ];
+      no_of_sites++;
+      if ( !comma() )  break;
+      if (no_of_sites > NoOfSiteTypes)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+    }
+
+    if (krui_createFTypeEntry( fmt_shape1, fmt_shape2,  fmt_shape3,
+                               no_of_sites, site_name_ptrs ) != KRERR_NO_ERROR)
+      return;
+  }
+
+  if (site_names != NULL)  {
+    free( (char *) site_names );
+    free( (char *) site_name_ptrs );
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krio_readDefaultDefinitions
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readDefaultDefinitions(void)
+{
+  FlintType  act, bias;
+  int  st, subnet_no, layer_no;
+
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[2] ) != 0) ||
+      !matchHead2( 6 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  if (fscanf( file_in, "%f | %f | %s | %d | %d | %s | %s",
+              &act, &bias, fmt_shape1, &subnet_no, &layer_no,
+              fmt_shape2, fmt_shape3 ) != 7)  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  if ( (st = str_to_Ttype( fmt_shape1 )) == 0)  {
+    KernelErrorCode = KRERR_TTYPE;
+    return;
+  }
+
+  if (krui_setUnitDefaults( act, bias, st, subnet_no, layer_no,
+                            fmt_shape2, fmt_shape3 )  != KRERR_NO_ERROR)
+    return;
+
+  if ( !matchHead2( 6 ) )  KernelErrorCode = KRERR_FILE_SYNTAX;
+}
+
+/*****************************************************************************
+  FUNCTION : krio_readUnitDefinitions 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readUnitDefinitions(void)
+{
+  struct PosType  pos;
+  FlintType  fp;
+  int   unit_no, def_unit_no, st, x, y, z;
+  bool  is_ftype_unit;
+
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[3] ) != 0) ||
+      !matchHead2( 9 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  def_unit_no = 0;
+  while (TRUE)  {
+    if ( matchHead2( 9 ) )  return;
+    if ( !skipComments() )  return;
+
+    /*  read unit no.  */
+    if (fscanf( file_in, "%d", &unit_no ) != 1)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+    if (unit_no != ++def_unit_no)  {
+      KernelErrorCode = KRERR_UNIT_NO;
+      return;
+    }
+
+    /*  skip "|" character  */
+    if (!skip_pipe())  return;
+
+    /*  read unit type name, if exist  */
+    if (!get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read unit type name  */
+      if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      
+      krui_createFTypeUnit( fmt_shape1 );
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  skip next "|" character  */
+      if (!skip_pipe())  return;
+
+      is_ftype_unit = TRUE;
+    }
+    else  {
+      if (krui_createDefaultUnit() != unit_no)  {
+        KernelErrorCode = KRERR_MALLOC1;
+        return;
+      }
+      is_ftype_unit = FALSE;
+    }
+
+    /*  read unit name, if exist  */
+    if (!get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read unit name  */
+      if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+
+      if (krui_setUnitName(def_unit_no, fmt_shape1) != KRERR_NO_ERROR) return;
+      /*  skip next "|" character  */
+      if (!skip_pipe())  return;
+    }
+
+    /*  read unit's activation value, if exist  */
+    if (!get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read unit activation value  */
+      if (fscanf( file_in, "%f", &fp ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      krui_setUnitInitialActivation( def_unit_no, fp );
+      krui_setUnitActivation( def_unit_no, fp );
+      /*  skip next "|" character  */
+      if (!skip_pipe())  return;
+    }
+
+    /*  read unit's bias value, if exist  */
+    if (!get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read unit bias value  */
+      if (fscanf( file_in, "%f", &fp ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      krui_setUnitBias( def_unit_no, fp );
+      /*  skip next "|" character  */
+      if (!skip_pipe())  return;
+    }
+
+    /*  read unit's topologic type, if exist  */
+    if (!get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read unit's topologic type  */
+      if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      if ( (st = str_to_Ttype( fmt_shape1 )) == 0)  {
+        KernelErrorCode = KRERR_TTYPE;
+        return;
+      }
+
+      if (krui_setUnitTType( def_unit_no, st ) != KRERR_NO_ERROR)  return;
+      /*  skip next "|" character  */
+      if (!skip_pipe())  return;
+    }
+
+    /*  read unit position  */
+    switch (NetfileVersion)  {
+      case 0:
+        if (fscanf( file_in, "%d , %d", &x, &y ) != 2)  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        pos.x = (short) x;
+        pos.y = (short) y;
+
+        pos.z = (short) 0;
+
+        krui_setUnitPosition( def_unit_no, &pos );
+
+        break;
+
+      case 1:
+        if (fscanf( file_in, "%d , %d, %d", &x, &y, &z ) != 3)  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        pos.x = (short) x;
+        pos.y = (short) y;
+
+        pos.z = (short) z;
+
+        krui_setUnitPosition( def_unit_no, &pos );
+
+        break;
+    }
+
+    /*  skip "|" character  */
+    if (!skip_pipe())  return;
+
+    if (is_ftype_unit)  {
+      /*  skip 2 "|" characters  */
+     if (!skip_pipe())  return;
+     if (!skip_pipe())  return;
+    }
+    else  {
+      /*  read unit's activation function, if exist  */
+      if (!get_pipe())  {
+        if (KernelErrorCode != KRERR_NO_ERROR)  return;
+        /*  read unit's activation function  */
+        if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        if (krui_setUnitActFunc( def_unit_no, fmt_shape1 ) != KRERR_NO_ERROR)
+          return;
+        /*  skip next "|" character  */
+        if (!skip_pipe())  return;
+      }
+
+      /*  read unit's output function, if exist  */
+      if (!get_pipe())  {
+        if (KernelErrorCode != KRERR_NO_ERROR)  return;
+        /*  read unit's output function  */
+        if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        if (krui_setUnitOutFunc( def_unit_no, fmt_shape1 ) != KRERR_NO_ERROR)
+          return;
+        /*  skip next "|" character  */
+        if (!skip_pipe())  return;
+      }
+    }
+
+    if (get_alpha())  {
+      /*  a site name was detected  */
+      if (krui_setCurrentUnit( def_unit_no ) != KRERR_NO_ERROR)  return;
+
+      /*  get site names  */
+      while (TRUE)  {
+        if (!getSymbol( fmt_shape1 ))  {
+          KernelErrorCode = KRERR_FILE_SYNTAX;
+          return;
+        }
+        if (krui_addSite( fmt_shape1 ) != KRERR_NO_ERROR)  return;
+
+        if ( !comma() )  break;
+      }
+    }
+  }
+}
+/*****************************************************************************
+  FUNCTION : krio_readConnectionDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readConnectionDefs(void)
+{
+  FlintType  weight;
+  int   unit_no, src_unit_no;
+  bool  new_unit, unit_has_sites;
+  float tacoma_xi,tacoma_ri;
+  int fscanRet;
+  struct Link* LinkDummy;
+
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[4] ) != 0) ||
+     (!matchHead2( 2 )) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  new_unit = TRUE;
+  unit_has_sites = FALSE;
+
+  while (TRUE)  {
+    if ( matchHead2( 2 ) )  return;
+    if ( !skipComments() )  return;
+
+    if (new_unit)  {
+      if (fscanf( file_in, "%d", &unit_no ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+
+      if (krui_setCurrentUnit( unit_no ) != KRERR_NO_ERROR)  return;
+
+      /*  skip "|" character  */
+      if (!skip_pipe())  return;
+    }
+
+    /*  test for occurence of the "|" character, if exist the unit
+        has no sites  */
+    if (unit_has_sites || !get_pipe())  {
+      if (KernelErrorCode != KRERR_NO_ERROR)  return;
+      /*  read site name  */
+      if (fscanf( file_in, "%s", fmt_shape1 ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+
+      if (krui_setSite( fmt_shape1 ) != KRERR_NO_ERROR)  return;
+      unit_has_sites = TRUE;
+
+      /* following two lines were taken off between v1.3 and v1.5 of
+         this file. the result was that when reading artmap nets, there
+         occured a syntax error
+      */
+      /* skip "|" character */
+      if (!skip_pipe()) return;
+
+    }
+    else
+      unit_has_sites = FALSE;
+
+    while (TRUE)  {
+      /*  read link weights  */
+      fscanRet = fscanf( file_in, "%d:%f (%f,%f) ", &src_unit_no, &weight, 
+                 &tacoma_xi, &tacoma_ri );
+      if (fscanRet==2) 
+         tacoma_xi=tacoma_ri=0.0;
+      if ((fscanRet!=2)&&(fscanRet!=4)){
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      LinkDummy=krui_createLinkWithAdditionalParameters
+                      ( src_unit_no, weight,tacoma_ri,tacoma_xi,0.0);
+      if (KernelErrorCode!=KRERR_NO_ERROR) return;
+      if ( !comma() )  break;
+    }
+
+    if (unit_has_sites)  {
+      if (get_alpha())  {
+        /*  a new site name was found  */
+        new_unit = FALSE;
+      }
+      else  {
+        if (KernelErrorCode != KRERR_NO_ERROR)  return;
+        /*  a digit was read -> a new unit number was found  */
+        new_unit = TRUE;
+        unit_has_sites = FALSE;
+      }
+    }
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : krio_readSubnetDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readSubnetDefs(void)
+{
+  int   unit_no, subnet_no;
+
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[5] ) != 0) ||
+      !matchHead2( 1 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  while (TRUE)  {
+    if (matchHead2( 1 )) return;
+    if ( !skipComments() )  return;
+    if (fscanf( file_in, "%d", &subnet_no ) != 1)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    if ( !get_pipe() )  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    while (TRUE)  {
+      if (fscanf( file_in, "%d", &unit_no ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      if (kr_getUnitPtr( unit_no ) == NULL)  return;
+
+      krui_setUnitSubnetNo( unit_no, subnet_no );
+
+      if ( !comma() )  break;
+    }
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : krio_readLayerDefs 
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  krio_readLayerDefs(void)
+{
+  int   unit_no, layer_no;
+
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[6] ) != 0) ||
+      !matchHead2( 1 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  while (TRUE)  {
+    if (matchHead2( 1 )) return;
+    if ( !skipComments() )  return;
+    if (fscanf( file_in, "%d", &layer_no ) != 1)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    if ( !get_pipe() )  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    while (TRUE)  {
+      if (fscanf( file_in, "%d", &unit_no ) != 1)  {
+        KernelErrorCode = KRERR_FILE_SYNTAX;
+        return;
+      }
+      if (kr_getUnitPtr( unit_no ) == NULL)  return;
+
+      krui_setUnitLayerNo( unit_no, (unsigned short) layer_no );
+
+      if ( !comma() )  break;
+    }
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : readXYTransTable 
+
+  PURPOSE  : read the XY-Tranlation Table from input file 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+static void  readXYTransTable(void)
+{
+  int x, y, z, c;
+
+
+  kr_xyTransTable( OP_TRANSTABLE_CLEAR, &x, &y, 0 );
+
+  if ( !skipComments() )  return;
+  if ((fscanf( file_in, headers[7] ) != 0) ||
+      !matchHead2( 2 ) )  {
+    KernelErrorCode = KRERR_FILE_SYNTAX;
+    return;
+  }
+
+  while (TRUE)  {
+    if (matchHead( 2 )) return;
+    if ( !skipComments() )  return;
+
+    if (fscanf( file_in, "%d | %d | %d", &x, &y, &z ) != 3)  {
+      KernelErrorCode = KRERR_FILE_SYNTAX;
+      return;
+    }
+
+    /* skip remaining spaces */
+    do{
+	c = getc( file_in );
+	if (c == '\n')  lineno++;
+    }while(c == ' ');
+
+    kr_xyTransTable( OP_TRANSTABLE_SET, &x, &y, z );
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_readTimeDelayDefs
+
+  PURPOSE  : 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void krio_readTimeDelayDefs(void)
+{
+   int u_no,
+       lln, 
+       lun,
+       toff,
+       soff,
+       conn_type,
+       ret;
+
+   struct Unit *unit_ptr;
+ 
+  if ( !skipComments() )  return;
+  if (fscanf( file_in, headers[8] ) != 0)
+    {  KernelErrorCode = KRERR_FILE_SYNTAX;  return;  }
+  if ( !matchHead2( 5 ) )
+    {  KernelErrorCode = KRERR_FILE_SYNTAX;  return;  }
+  
+  while (TRUE)
+    {
+    if (matchHead2( 5 )) return;
+    if ( !skipComments() )  return;
+
+    ret = fscanf (file_in, "%4d |%4d |%4d |%5d |%5d |%6d", 
+		  &u_no, &lln, &lun, &toff, &soff, &conn_type);
+    if (ret != 6)  {  KernelErrorCode = KRERR_FILE_SYNTAX;  return;  }
+
+    unit_ptr = kr_getUnitPtr (u_no);
+
+    unit_ptr->lln = lln;
+    unit_ptr->lun = lun;
+    unit_ptr->TD.target_offset = toff;
+    unit_ptr->TD.source_offset = soff;
+    unit_ptr->TD.td_connect_typ = conn_type;
+    unit_ptr++;
+    }
+}   
+
+
+
+/*****************************************************************************
+  FUNCTION : krio_loadNet  
+
+  PURPOSE  : load network from disk
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+krui_err  krio_loadNet(char *filename, char **netname, char **netfile_version)
+{
+  static char  netname_str[81],
+               netfile_version_str[81],
+               learn_func[81],
+               update_func[81],
+               pruning_func[81],
+               ff_learn_func[81];
+
+  int  no_units, no_connect, no_unitT,
+       no_siteT, title_no, status;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  lineno = status = 0;
+
+  file_in = fopen( filename, "r" );
+  if (file_in == NULL)  {
+    KernelErrorCode = KRERR_FILE_OPEN;  /*  Can't open file  */
+    goto ende;
+  }
+
+  lineno = 1;
+  if (NoOfUnits > 0)  krui_deleteNet();
+
+  krio_readHeader( netfile_version_str, netname_str, learn_func, update_func,
+                   pruning_func, ff_learn_func, &no_units, &no_connect, &no_unitT,
+		   &no_siteT );
+  if (KernelErrorCode)  goto ende;
+
+  if(*learn_func != '\0')  {
+    (void) krui_setLearnFunc( learn_func );
+    if (KernelErrorCode)  goto ende;
+  }
+  if(*update_func != '\0')  {
+    (void)  krui_setUpdateFunc( update_func );
+    if (KernelErrorCode)  goto ende;
+  }
+  if(*pruning_func != '\0')  {
+    (void) krui_setPrunFunc( pruning_func );
+    if (KernelErrorCode)  goto ende;
+  }
+  if(*ff_learn_func != '\0')  {
+    (void)  krui_setFFLearnFunc( ff_learn_func );
+    if (KernelErrorCode)  goto ende;
+  }
+
+  *netname = netname_str;
+  *netfile_version = netfile_version_str;
+
+  while ( getSection( fmt_shape1, &title_no ) != NULL )  {
+    if (title_no >= 0)  lineno++;  /* increment line number */
+
+    switch (title_no)  {
+      case  -3:  /*  Physical I/O error  */
+        KernelErrorCode = KRERR_IO;
+        return( KernelErrorCode );
+      case  -2:  /*   EOF  */
+        if (status < 2)  KernelErrorCode = KRERR_EOF;  /*  unexpected EOF  */
+        return( KernelErrorCode );
+      case  -1:  /*  not found  */
+        KernelErrorCode = KRERR_FILE_SYNTAX;  /*  Syntax error at line  */
+        break;
+      case  8:  /*  "site definition section"  */
+	krio_readSiteDefinitions();
+        break;
+      case  9:  /*  "type definition section"  */
+	krio_readTypeDefinitions();
+        break;
+      case  10:  /*  "unit definition section"  */
+	(void) krui_allocateUnits( no_units );
+	if (KernelErrorCode)  goto ende;
+
+        krio_readUnitDefinitions();
+        status++;
+        break;
+      case  11:  /*  "connection definition section"  */
+	krio_readConnectionDefs();
+        status++;
+        break;
+      case  12:  /*  "subnet definition section"  */
+	krio_readSubnetDefs();
+        break;
+      case  13:  /*  "unit default section"  */
+	krio_readDefaultDefinitions();
+        break;
+      case  15:  /*  "layer definition section"  */
+	krio_readLayerDefs();
+        break;
+
+      case  17:  /*  "3D translation section"  */
+	readXYTransTable();
+        break;
+
+      case  18:  /*  "time delay section"  */
+        krio_readTimeDelayDefs ();
+	break;
+      default:
+        KernelErrorCode = KRERR_FILE_FORMAT;  /*  Incompatible file format  */
+        break;
+    }
+
+    if (KernelErrorCode)  break;
+  }
+
+  if (KernelErrorCode == KRERR_NO_ERROR)  lineno = 0;
+
+ende:
+  if (file_in != NULL)
+    fclose( file_in );
+
+  return( KernelErrorCode );
+}
+
+/*#################################################
+
+GROUP: Functions for Pattern Management
+
+This group has been moved to kr_newpattern.c
+
+#################################################*/
+
+/*#################################################
+
+GROUP: Functions for Result Management
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krio_saveResult 
+
+  PURPOSE  : write result to disk 
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : now the actual update function is used instead of 
+             Topological_Order (M. Vogt, 20.02.93, necessary for TD networks)
+******************************************************************************/
+krui_err krio_saveResult(char *filename, bool create, int startpattern, 
+			 int endpattern, bool includeinput, bool includeoutput,
+			 float *Update_param_array, int NoOfUpdateParam)
+{
+  char	work_str[ LIN_MAX ];
+  struct Unit	*unit_ptr;
+  long	clock;
+  int  ret,  i, j;
+  Patterns  in_pat, out_pat, save_in_pat;
+  krui_err	temp_error;
+  int start, end, i_size, o_size, in_pat_size;
+  int pat,sub;
+
+  lineno = 1;
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if (krui_getNoOfPatterns() == 0)
+  {
+    KernelErrorCode = KRERR_NO_PATTERNS;
+    return( KernelErrorCode );
+  }
+
+  if (endpattern < startpattern || endpattern > krui_getNoOfPatterns())
+  {
+    return(KernelErrorCode = KRERR_PATTERN_NO);
+  }
+
+  /* calculate absolute numbers of first and last subpattern */
+  KernelErrorCode = kr_initSubPatternOrder(startpattern-1,endpattern-1);
+  if (KernelErrorCode != KRERR_NO_ERROR)
+      return( KernelErrorCode );
+
+  start = kr_AbsPosOfFirstSubPat(startpattern-1);
+  end   = kr_AbsPosOfFirstSubPat(endpattern-1);
+  end  += kr_NoOfSubPatPairs(endpattern-1)-1;
+
+  if (create)
+    file_out = fopen(filename, "w");
+  else
+    file_out = fopen(filename, "a");
+  if (file_out == NULL)
+  { /*  Can't open file  */
+    KernelErrorCode = KRERR_FILE_OPEN;
+    return( KernelErrorCode );
+  }
+
+  KernelErrorCode = KRERR_IO;
+
+  /*  write header and version number  */
+  ret = fprintf( file_out, resHeader[0], krio_getIOVersion() );
+  RETCHKGTO( ret );
+  lineno++;
+
+  /*  write date  */
+  clock = 1;
+  (void) time( (time_t *) &clock);
+
+  strcpy( work_str, resHeader[1] );
+  strcat( work_str, " %s\n" );
+  ret = fprintf( file_out, work_str, ctime( (time_t *) &clock) );
+  RETCHKGTO( ret );
+  lineno++;
+
+  /*  write no. of patterns, input units, output units  */
+  strcpy( work_str, resHeader[2] );
+  strcat( work_str, resHeader[3] );
+  strcat( work_str, resHeader[4] );
+  ret = fprintf( file_out, work_str, end - start + 1, 
+		krui_getNoOfInputUnits() + krui_getNoOfSpecialInputUnits(),
+		krui_getNoOfOutputUnits() + krui_getNoOfSpecialOutputUnits() );
+  RETCHKGTO( ret );
+  lineno += 3;
+
+  /* write numbers of used patterns */
+  strcpy( work_str, resHeader[5] );
+  strcat( work_str, resHeader[6] );
+  ret = fprintf( file_out, work_str, startpattern, endpattern);
+  RETCHKGTO( ret );
+  lineno += 2;
+
+  /* write additional format information */
+  if (includeinput)
+  {
+    ret = fprintf(file_out, resHeader[7]);
+    RETCHKGTO( ret );
+    lineno += 1;
+  }
+  if (includeoutput)
+  {
+    ret = fprintf(file_out, resHeader[8]);
+    RETCHKGTO( ret );
+    lineno += 1;
+  }
+
+  /* process network update for all subpattern */
+  for(i=start; i<=end;i++){
+    kr_getSubPatternByNo(&pat,&sub,i);
+    in_pat = kr_getSubPatData(pat,sub,INPUT,&i_size);
+    out_pat = kr_getSubPatData(pat,sub,OUTPUT,&o_size);
+
+    if (in_pat == (Patterns) NULL || out_pat == (Patterns) NULL)
+	goto ende;
+
+    if (o_size == 0 && includeoutput)
+    {
+	KernelErrorCode = KRERR_NP_NO_OUTPUT_PATTERN;
+	goto ende;
+    }
+
+    ret = fprintf( file_out, "#%d.%d\n", pat+1, sub+1 );
+    RETCHKGTO( ret );
+
+    if (includeinput)
+    {
+	save_in_pat = in_pat;
+	for (j = 1; j <= i_size; j++)
+        {
+            sprintf( work_str, "%.5f", *in_pat );
+            krio_cutTrailingZeros( work_str );
+
+            if (j < i_size)
+                if (j % 10 == 0)  
+		    strcat( work_str, "\n" );
+                else
+		    strcat( work_str, " " );
+   
+	    ret = fputs( work_str, file_out );
+	    RETCHKGTO( ret );  
+
+	    lineno++;
+	    in_pat++;
+    	}
+	fputs( "\n", file_out );
+	in_pat = save_in_pat;
+    }
+
+    if (includeoutput)
+    {
+    	for (j = 1; j <= o_size; j++)
+      	{
+      	    sprintf( work_str, "%.5f", *out_pat );
+      	    krio_cutTrailingZeros( work_str );
+
+      	    if (j < o_size)
+        	if (j % 10 == 0)  
+		    strcat( work_str, "\n" );
+        	else  
+		    strcat( work_str, " " );
+
+	    ret = fputs( work_str, file_out );
+	    RETCHKGTO( ret );  
+
+	    lineno++;
+      	    out_pat++;
+    	}
+	fputs( "\n", file_out );
+    }
+
+    /* activate input layer */
+    in_pat_size = i_size;
+    FOR_ALL_UNITS( unit_ptr )
+	if ( IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+	    if (in_pat_size--)
+		unit_ptr->act = *in_pat++;
+
+    /* propagate network */
+    if ((temp_error = krui_updateNet(Update_param_array, 
+				     NoOfUpdateParam)) != KRERR_NO_ERROR)
+    {
+	KernelErrorCode = temp_error;
+	goto ende;
+    }
+
+    /* write network output */
+    j = 1;
+    FOR_ALL_UNITS( unit_ptr )
+        if UNIT_IN_USE( unit_ptr )
+        {
+            if IS_OUTPUT_UNIT( unit_ptr )
+            {
+		sprintf( work_str, "%.5f", unit_ptr->Out.output );
+      	    	krio_cutTrailingZeros( work_str );
+		if (j % 10 == 0)  
+		    strcat( work_str, "\n" );
+		else  
+		    strcat( work_str, " " );
+		j++;
+	    	ret = fputs( work_str, file_out );
+	    	RETCHKGTO( ret );  
+
+	    	lineno++;
+            }
+        }
+    fputs( "\n", file_out );
+  }
+
+
+ende:
+  if (KernelErrorCode == KRERR_NO_ERROR)
+      lineno = 0;
+  if (fclose(file_out) != 0 && KernelErrorCode == KRERR_NO_ERROR)
+    KernelErrorCode = KRERR_IO;
+
+  return KernelErrorCode;
+}
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_io.h snort-2.3.3.new/src/kernel_snns/kr_io.h
--- snort-2.3.3/src/kernel_snns/kr_io.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_io.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,64 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_io.h,v $
+  SHORTNAME      : kr_io.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel User Interface File I/O Function Prototypes 
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 28.05.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:48 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _KR_IO_DEFINED_
+#define  _KR_IO_DEFINED_
+
+
+/*  write complete network to disk
+*/
+extern krui_err  krio_saveNet( char  *filename, char  *netname );
+
+/*  load network form disk
+*/
+extern krui_err krio_loadNet( char  *filename, char  **netname, char  **netfile_version );
+
+/*  loading pattern file from disk
+*/
+extern krui_err krio_loadPatterns( char  *filename );
+
+/*  write patterns to disk
+*/
+extern krui_err krio_savePatterns( char  *filename );
+
+extern krui_err  krio_saveResult( char *filename,
+                           bool create,
+                           int  startpattern,
+                           int  endpattern,
+                           bool includeinput,
+                           bool includeoutput,
+			   float *Update_param_array, 
+			   int NoOfUpdateParam);
+
+
+/*  Function for the 3D-Kernel	*/
+/*  Return the base address of the XY-Translation Table
+*/
+extern struct TransTable  *krio_getXYTransTablePtr( void );
+
+
+extern void krio_readTimeDelayDefs(void);
+
+
+
+#endif 
+
+
+
+/* 61 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_io.ph snort-2.3.3.new/src/kernel_snns/kr_io.ph
--- snort-2.3.3/src/kernel_snns/kr_io.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_io.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,237 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_io.ph,v $
+  SHORTNAME      : kr_io.ph
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel User Interface File I/O Function Prototypes 
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 28.05.90
+ 
+  CHANGED BY     : Sven Doering, Michael Vogt
+  RCS VERSION    : $Revision: 2.11 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:49 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _KR_IO_DEFINED_
+#define  _KR_IO_DEFINED_
+
+/* begin global definition section */
+
+/*  write complete network to disk
+*/
+krui_err  krio_saveNet( char  *filename, char  *netname );
+
+/*  load network form disk
+*/
+krui_err krio_loadNet( char  *filename, char  **netname, char  **netfile_version );
+
+/*  loading pattern file from disk
+*/
+krui_err krio_loadPatterns( char  *filename );
+
+/*  write patterns to disk
+*/
+krui_err krio_savePatterns( char  *filename );
+
+krui_err  krio_saveResult( char *filename,
+                           bool create,
+                           int  startpattern,
+                           int  endpattern,
+                           bool includeinput,
+                           bool includeoutput,
+			   float *Update_param_array, 
+			   int NoOfUpdateParam);
+
+
+
+extern struct TransTable  *transTable;
+extern int transTableSize;
+
+
+
+void krio_readTimeDelayDefs(void);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/*#################################################
+
+GROUP: Local Defines
+
+#################################################*/
+
+#define LIN_MAX      (MAX_LIN_LEN + 1)
+
+#define SITE_DEF     1
+#define TYPE_DEF     2
+#define DEFAULT_DEF  3
+#define UNIT_DEF     4
+#define CONNECT_DEF  5
+#define SUBNET_DEF   6
+#define LAYER_DEF    7
+
+
+#define EOS	'\0'	/*  End Of String  */
+
+
+/*#################################################
+
+GROUP: Local Var's
+
+#################################################*/
+
+typedef char   SymbolType[LIN_MAX];
+
+static FILE  *file_in;
+static FILE  *file_out;
+
+static bool  is_subnet_info,
+	     is_layer_info,
+	     units_have_sites;
+
+static int   site_name_len,
+	     unit_name_len,
+	     type_name_len,
+	     site_func_len,
+	     act_func_len,
+	     out_func_len,
+	     def_act_func_len,
+	     def_out_func_len,
+             unit_no_len,
+             max_connects_per_line,
+             max_subnets_per_line,
+             max_layers_per_line,
+             pos_no_len,
+             subnet_no_len,
+             layer_no_len,
+             NoOfLinks,
+             NoOfSiteTypes,
+             NoOfUnitTypes,
+             NetfileVersion;
+
+
+static char  fmt_shape1 [ LIN_MAX ],
+	     fmt_shape2 [ LIN_MAX ],
+	     fmt_shape3 [ LIN_MAX ],
+	     fmt_shape4 [ LIN_MAX ],
+	     fmt_hdr1	[ LIN_MAX ],
+	     fmt_hdr2	[ LIN_MAX ],
+	     fmt_blank	[ LIN_MAX ];
+
+
+static char  *title[] = {
+    "SNNS network definition file",
+    "generated at",
+    "network name",
+    "no. of units",
+    "no. of connections",
+    "no. of unit types",
+    "no. of site types",
+    "learning function",
+    "site definition section",
+    "type definition section",
+    "unit definition section",
+    "connection definition section",
+    "subnet definition section",
+    "unit default section",
+    "source files",
+    "layer definition section",
+    "update function",
+    "3D translation section",
+    "time delay section",
+    "pruning function",
+    "subordinate learning function"
+/*
+    "topologic definition section",
+    "feedforward network"
+*/
+    };	 /*  20  */
+
+static int  NoOfTitles = (sizeof title) / (sizeof title[0]);
+
+static char *resHeader[] = {
+    "SNNS result file %s\n",
+    "generated at",
+    "No. of patterns     : %d\n",
+    "No. of input units  : %d\n",
+    "No. of output units : %d\n",
+    "startpattern        : %d\n",
+    "endpattern          : %d\n",
+    "input patterns included\n",
+    "teaching output included\n"
+    };
+
+static char  *headers[] = {
+    " site name | site function",
+    " name | act func | out func | sites",
+    " act | bias | st | subnet | layer | act func | out func",
+    " no. | typeName | unitName | act | bias | st | position | act func | out func | sites",
+    " target | site | source:weight",
+    " subnet | unitNo.",
+    " layer | unitNo.",
+    " delta x | delta y | z",
+    " no. | LLN | LUN | Toff | Soff | Ctype"
+    };
+
+
+
+/*
+static void  mstrcat(int __builtin_va_alist);
+static void  mstrcpy(int __builtin_va_alist);
+*/
+static void  mstrcat(char *va_alist,...);
+static void  mstrcpy(char *va_alist,...);
+static char  *krio_getIOVersion(void);
+static krui_err  krio_writeHeader(char *version, char *net_name);
+static void krio_cutTrailingZeros(char *string);
+static char  *krio_repchar(char c, int N);
+static void  krio_stringLimits(void);
+static krui_err  krio_fmtShapeing(int choose_me);
+static krui_err  krio_writeSiteDefinitions(void);
+static krui_err  krio_writeTypeDefinitions(void);
+static char  *getTType(int st);
+static krui_err  krio_writeDefaultDefinitions(void);
+static krui_err  krio_writeUnitDefinitions(void);
+static krui_err  krio_writeSourcesAndWeights(void);
+static krui_err  krio_writeConnectionDefs(void);
+static krui_err  krio_writeSubnetDefs(void);
+static krui_err  krio_writeLayerDefs(void);
+static krui_err  writeXYTransTable(void);
+static bool  skipComments(void);
+static bool  skipSpace(void);
+static bool  comma(void);
+static bool  get_nl(void);
+static bool  get_pipe(void);
+static bool  skip_pipe(void);
+static bool  get_alpha(void);
+static bool  getSymbol(char *symbol);
+static char  *getSection(char *line, int *title_no);
+static bool  matchHead2(int N);
+static char  *my_strstr(char *s, char *find);
+static void  krio_readHeader(char *netfile_version, char *net_name,
+			     char *learn_func, char *update_func, char
+			     *pruning_func, char *ff_learn_func, int
+			     *no_of_units, int *no_of_connect, int
+			     *no_of_unitTypes, int *no_of_siteTypes);
+static int  str_to_Ttype(char *str);
+static void  krio_readSiteDefinitions(void);
+static void  krio_readTypeDefinitions(void);
+static void  krio_readDefaultDefinitions(void);
+static void  krio_readUnitDefinitions(void);
+static void  krio_readConnectionDefs(void);
+static void  krio_readSubnetDefs(void);
+static void  krio_readLayerDefs(void);
+static void  readXYTransTable(void);
+
+
+/* end private definition section */
+
+#endif 
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_JordElm.c snort-2.3.3.new/src/kernel_snns/kr_JordElm.c
--- snort-2.3.3/src/kernel_snns/kr_JordElm.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_JordElm.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,496 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_JordElm.c,v $
+  SHORTNAME      : kr_JordElm.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Topological sorting for Jordan and Elman networks 
+  NOTES          :
+
+  AUTHOR         : Tobias Soyez
+  DATE           : 09.11.1993
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:32 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+******************************************************************************/
+#include <config.h>
+
+
+#include "kr_typ.h"	
+#include "kr_const.h"	 
+#include "kr_def.h"	 
+#include "kr_mac.h"
+#include "kernel.h"
+#include "kr_JordElm.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_recTouchContextUnits
+
+  PURPOSE  : touches only context units recursively
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void kr_recTouchContextUnits (struct Unit *unit_ptr)
+
+{
+  struct Site   *site_ptr ;
+  struct Link   *link_ptr ;
+  bool           unit_has_incoming_links ;
+
+  if (unit_ptr->flags & UFLAG_REFRESH) return ;
+
+  if ((IS_HIDDEN_UNIT (unit_ptr)) && (IS_SPECIAL_UNIT (unit_ptr)))
+  {
+    /* -----------  touch only context units ------------- */
+
+    unit_ptr->flags |= UFLAG_REFRESH ;             /* set the 'touch' flag  */
+
+    unit_has_incoming_links = FALSE ;
+
+    switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+    {
+      case  UFLAG_DLINKS:                          /* unit has direct links  */
+        FOR_ALL_LINKS (unit_ptr, link_ptr)
+	{ 
+          kr_recTouchContextUnits (link_ptr->to) ; 
+          unit_has_incoming_links = TRUE ;
+        }
+        break ;
+
+      case  UFLAG_SITES:	                         /*  unit has sites  */
+        FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+	{
+	  kr_recTouchContextUnits (link_ptr->to) ; 
+          unit_has_incoming_links = TRUE ;
+        }
+        break ;
+    }
+  }
+
+  if ((! unit_has_incoming_links) && (! IS_INPUT_UNIT (unit_ptr)))
+  {
+    /* unit has no incoming links -> dead unit -> delete touch flag */
+
+    unit_ptr->flags &= ~UFLAG_REFRESH ;
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_recTopoCheckJE
+
+  PURPOSE  : recursive topology check, called by kr_topoCheckJE
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  kr_recTopoCheckJE (struct Unit *unit_ptr, int depth)
+
+{
+  struct Site   *site_ptr ;
+  struct Link   *link_ptr ;
+  bool           unit_has_incoming_links ;
+
+
+
+  if ((IS_HIDDEN_UNIT (unit_ptr)) && (IS_SPECIAL_UNIT (unit_ptr))) 
+  {
+    /* --------  touch context units recursively  -------- */
+ 
+    kr_recTouchContextUnits (unit_ptr) ;
+    return ;
+  }
+
+  if (unit_ptr->flags & UFLAG_REFRESH)
+  {  
+    if (unit_ptr->lln == 0)
+    {  
+      /*  logical layer no. isn't set => Cycle found  */
+      topo_msg.no_of_cycles++ ;
+      
+      if (topo_msg.error_code == KRERR_NO_ERROR)
+      { 
+        topo_msg.src_error_unit = unit_ptr - unit_array ;
+        topo_msg.error_code     = KRERR_CYCLES ;
+      }
+    }
+    return ;
+  }
+
+ 
+  /* -----  unit is not a context unit and has not been touched yet  ------ */
+  /* -----  continue recursive depth search                          ------ */
+
+  unit_ptr->flags |= UFLAG_REFRESH ;             /* set the 'touch' flag  */
+
+  unit_has_incoming_links = FALSE ;
+
+  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+  {
+    case  UFLAG_DLINKS:                          /* unit has direct links  */
+      FOR_ALL_LINKS (unit_ptr, link_ptr)
+      {
+	kr_recTopoCheckJE (link_ptr->to, depth + 1) ; 
+        unit_has_incoming_links = TRUE ;
+      }
+      break ;
+
+    case  UFLAG_SITES:	                         /*  unit has sites  */
+      FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+      {
+	kr_recTopoCheckJE (link_ptr->to, depth + 1) ; 
+        unit_has_incoming_links = TRUE ;
+      }
+      break ;
+  }
+
+  /*  remember the depth (for cycle detection and statistics)  */
+  unit_ptr->lln = depth ;
+
+  /*  store highest layer no.  */
+  if (depth > topo_msg.no_of_layers) topo_msg.no_of_layers = depth ;
+
+
+  if ((! unit_has_incoming_links) && (! IS_INPUT_UNIT (unit_ptr)))
+  {
+    /* unit has no incoming links -> dead unit -> delete touch flag */
+
+    unit_ptr->flags &= ~UFLAG_REFRESH ;
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoCheckJE
+
+  PURPOSE  : Checks the topology of partial recurrent networks 
+             (i.e. JORDAN or ELMAN networks) :
+	     only recurrent links to context units are allowed
+  NOTES    : 
+
+  RETURNS  : kernel error code
+  UPDATE   : 
+******************************************************************************/
+
+krui_err kr_topoCheckJE (void)
+
+{
+  struct Unit  *unit_ptr ;
+  bool          o_units  ;
+
+
+  topo_msg.no_of_cycles     = 
+  topo_msg.no_of_dead_units =
+  topo_msg.dest_error_unit  = 
+  topo_msg.src_error_unit   =
+  topo_msg.no_of_layers     = 0 ;
+  topo_msg.error_code       = KernelErrorCode = KRERR_NO_ERROR ;
+
+
+  if (NoOfUnits == 0)
+  {
+    /*  no units defined  */
+    KernelErrorCode = KRERR_NO_UNITS ;
+    return (KernelErrorCode) ;
+  }
+
+
+  /* -------------------  reset units 'touch' flags  ----------------------- */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (UNIT_IN_USE (unit_ptr))
+    {
+      unit_ptr->flags &= ~UFLAG_REFRESH ;
+      unit_ptr->lln = 0 ;
+    }
+
+
+  /* ----------  begin depth search at the first output unit  -------------- */
+
+  o_units = FALSE ;
+  FOR_ALL_UNITS (unit_ptr)
+    if (IS_OUTPUT_UNIT (unit_ptr) && UNIT_IN_USE (unit_ptr))
+    {
+      o_units = TRUE ;
+      kr_recTopoCheckJE (unit_ptr, 1) ;
+      if (topo_msg.error_code != KRERR_NO_ERROR)
+      {  /*  stop if an error occured  */
+        KernelErrorCode = topo_msg.error_code ;
+        return (KernelErrorCode) ;
+      }
+    }
+      
+  if (!o_units)
+  {  /*  no output units */
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS ;
+    return (KernelErrorCode) ;
+  }
+
+
+  /* ----------  search for dead units i.e. units without inputs  ---------- */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (!(unit_ptr->flags & UFLAG_REFRESH) && UNIT_IN_USE (unit_ptr))
+    {
+      topo_msg.error_code = KRERR_DEAD_UNITS ;
+      topo_msg.no_of_dead_units++ ;
+      if (topo_msg.src_error_unit == 0)
+        topo_msg.src_error_unit = unit_ptr - unit_array ;
+    }
+
+  if (topo_msg.no_of_dead_units != 0)
+    KernelErrorCode = KRERR_DEAD_UNITS ;
+
+  return (topo_msg.error_code) ;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_recTopoSortJE
+
+  PURPOSE  : stores only hidden (NOT special hidden !) units in the topologic 
+             array
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+
+static void  kr_recTopoSortJE (struct Unit *unit_ptr, int depth)
+
+{
+  struct Site   *site_ptr ;
+  struct Link   *link_ptr ;
+
+
+  /* ---------------------  ignore context units  ------------------------- */
+
+  if ((IS_HIDDEN_UNIT (unit_ptr)) && (IS_SPECIAL_UNIT (unit_ptr)))
+  {
+    unit_ptr->flags |= UFLAG_REFRESH ;    /* set the 'touch' flag */
+    return ;
+  } 
+
+
+  if (unit_ptr->flags & UFLAG_REFRESH)
+  {  
+    /* the 'touch' flag is set: don't continue search */
+    topo_msg.src_error_unit = unit_ptr - unit_array ;  /* store unit number */
+
+    if IS_OUTPUT_UNIT (unit_ptr)
+    {  
+      /*  this output unit has a output connection to another unit  */
+      if (topo_msg.error_code == KRERR_NO_ERROR)
+        topo_msg.error_code = KRERR_O_UNITS_CONNECT ;
+    }
+    else
+      if (unit_ptr->lln == 0)
+      {  
+        /*  logical layer no. isn't set => Cycle found  */
+          topo_msg.no_of_cycles++ ;
+        if (topo_msg.error_code == KRERR_NO_ERROR)
+          topo_msg.error_code = KRERR_CYCLES ;
+      }
+
+    return ;
+  }
+  else
+    unit_ptr->flags |= UFLAG_REFRESH ; /* set the 'touch' flag */
+
+
+  /* -------------------------  continue search  -------------------------- */
+
+  switch (unit_ptr->flags & UFLAG_INPUT_PAT)
+  {
+    case  UFLAG_DLINKS:   
+      FOR_ALL_LINKS (unit_ptr, link_ptr)
+	kr_recTopoSortJE (link_ptr->to, depth + 1) ; 
+      break ;
+
+    case  UFLAG_SITES:	
+      FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+	kr_recTopoSortJE (link_ptr->to, depth + 1) ; 
+      break ;
+  }
+
+  /*  remember the depth (for cycle detection and statistics)  */
+  unit_ptr->lln = depth ; 
+
+
+  /* ------------------------  store hidden units  ------------------------ */
+
+  if IS_HIDDEN_UNIT( unit_ptr )
+  {
+    *topo_ptr++ = unit_ptr ; 
+    no_of_topo_units++ ;
+  }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : kr_topoSortJE
+
+  PURPOSE  : sorts units of a partial recurrent network by their topologic 
+             type input, hidden, output, context and stores the pointers to 
+             this units in the topologic array
+  NOTES    : ###########  V E R Y    I M P O R T A N T   N O T E  ############
+             no_of_topo_units contains only the number of input, hidden and
+             output units 
+
+             no_of_topo_units DOES NOT contain the no. of context units !!!
+
+             all special hidden units (io-type = SPECIAL_H) are assumed to
+             be context units 
+
+             !! before calling this function:                  !!
+             !! check the network topology with kr_topoCheckJE !!
+
+  RETURNS  : error code 
+  UPDATE   : 
+******************************************************************************/
+
+krui_err kr_topoSortJE (void)
+
+{ 
+  register struct Unit	 *unit_ptr ;
+
+
+  KernelErrorCode  = KRERR_NO_ERROR ;  /* reset return code                  */
+  topo_ptr         = topo_ptr_array ;  /* initialize global pointer          */
+  NoOfInputUnits   = 0 ;
+  NoOfOutputUnits  = 0 ;
+  no_of_topo_units = 0 ;
+  *topo_ptr++      = NULL ;            /* limit left side of the topological */
+                                       /* array with NULL pointer            */
+
+
+  /* ------------------  reset 'touch' flags of all units  ----------------- */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (UNIT_IN_USE (unit_ptr))
+    {
+      unit_ptr->flags &= ~UFLAG_REFRESH ;
+      unit_ptr->lln = 0 ;
+    }
+
+
+  /* -----------  store all input units in the topologic array  ------------ */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (IS_INPUT_UNIT (unit_ptr) && UNIT_IN_USE (unit_ptr))
+    {
+      if UNIT_HAS_INPUTS (unit_ptr)
+      { 
+        /* links to input units are not allowed */ 
+        topo_msg.dest_error_unit = unit_ptr - unit_array ;  
+	KernelErrorCode          = KRERR_I_UNITS_CONNECT ; 
+        return (KernelErrorCode) ;
+      }
+
+      NoOfInputUnits++   ;	
+      no_of_topo_units++ ;	
+      *topo_ptr++ = unit_ptr ;  
+    }
+
+  *topo_ptr++ = NULL ;  /* limit input units in the topological array with   */
+                        /* NULL pointer                                      */
+
+  if (NoOfInputUnits == 0)
+  {  
+    KernelErrorCode = KRERR_NO_INPUT_UNITS ;
+    return( KernelErrorCode ) ;
+  }
+
+
+  /* -----------  store all hidden units in the topologic array  ----------- */
+  /* sorts hidden units by their topological order using recursive depth     */
+  /* search starting at the first output unit                                */
+
+  FOR_ALL_UNITS( unit_ptr )
+    if (IS_OUTPUT_UNIT (unit_ptr) && UNIT_IN_USE (unit_ptr))
+    {
+      kr_recTopoSortJE (unit_ptr, 1) ;  
+      if (topo_msg.error_code != KRERR_NO_ERROR)
+      {  
+        KernelErrorCode = topo_msg.error_code ;
+        return (KernelErrorCode) ;
+      }
+    }
+
+  *topo_ptr++ = NULL ;  /* limit hidden units in the topological array with  */
+                        /* NULL pointer                                      */
+
+
+  /* -----------  store all output units in the topologic array  ----------- */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (IS_OUTPUT_UNIT (unit_ptr) && UNIT_IN_USE (unit_ptr))
+    {
+      NoOfOutputUnits++  ;	
+      no_of_topo_units++ ;
+      *topo_ptr++ = unit_ptr ;
+    }
+
+  if (NoOfOutputUnits == 0)
+  { 
+    KernelErrorCode = KRERR_NO_OUTPUT_UNITS ;
+    return (KernelErrorCode) ;
+  }
+
+  *topo_ptr++ = NULL ;  /* limit output units in the topological array with  */
+                        /* NULL pointer                                      */
+
+
+  /* ----------  store all context units in the topologic array  ----------- */
+  /*       !!!  no_of_topo_units MUST NOT BE INCREMENTED ANY MORE  !!!       */
+  
+  FOR_ALL_UNITS (unit_ptr)
+    if (IS_HIDDEN_UNIT (unit_ptr) && IS_SPECIAL_UNIT (unit_ptr) &&
+        UNIT_IN_USE (unit_ptr))
+    {
+      *topo_ptr++ = unit_ptr ;
+    }
+
+  *topo_ptr++ = NULL ;  /* limit context units in the topological array with */
+                        /* NULL pointer                                      */
+
+
+  /* ---------  search for dead units i.e. units without inputs  ----------- */
+
+  FOR_ALL_UNITS (unit_ptr)
+    if (!(unit_ptr->flags & UFLAG_REFRESH) && UNIT_IN_USE (unit_ptr))
+    {
+      topo_msg.no_of_dead_units++ ;
+      if (topo_msg.src_error_unit == 0)
+        topo_msg.src_error_unit = unit_ptr - unit_array ; 
+    }
+
+  if (topo_msg.no_of_dead_units != 0) KernelErrorCode = KRERR_DEAD_UNITS ;
+
+
+  return( KernelErrorCode ) ;
+}
+
+
+
+/*****************************************************************************
+                        E N D     O F     F I L E
+******************************************************************************/
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_JordElm.h snort-2.3.3.new/src/kernel_snns/kr_JordElm.h
--- snort-2.3.3/src/kernel_snns/kr_JordElm.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_JordElm.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,44 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_JordElm.h,v $
+  SHORTNAME      : kr_JordElm.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : header file for corresponding '.c' file
+  NOTES          :
+
+  AUTHOR         : Tobias Soyez
+  DATE           : 09.11.1993
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:25 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+
+#ifndef _KR_JORDANELMAN_DEFINED_
+#define _KR_JORDANELMAN_DEFINED_
+
+
+extern krui_err kr_topoCheckJE (void) ;
+extern krui_err kr_topoSortJE  (void) ;
+ 
+
+#endif
+
+
+/*****************************************************************************
+                        E N D     O F     F I L E
+******************************************************************************/
+
+
+
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_JordElm.ph snort-2.3.3.new/src/kernel_snns/kr_JordElm.ph
--- snort-2.3.3/src/kernel_snns/kr_JordElm.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_JordElm.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,50 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_JordElm.ph,v $
+  SHORTNAME      : kr_JordElm.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : private header file for corresponding '.c' file
+  NOTES          :
+
+  AUTHOR         : Tobias Soyez
+  DATE           : 09.11.1993
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:26 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+
+#ifndef _KR_JORDANELMAN_DEFINED_
+#define _KR_JORDANELMAN_DEFINED_
+
+
+krui_err kr_topoCheckJE (void) ;
+krui_err kr_topoSortJE  (void) ;
+
+
+static void  kr_recTopoCheckJE (struct Unit *unit_ptr, int depth) ;
+static void  kr_recTopoSortJE  (struct Unit *unit_ptr, int depth) ;
+
+static TopoPtrArray  topo_ptr ;
+
+
+#endif
+
+
+/*****************************************************************************
+                        E N D     O F     F I L E
+******************************************************************************/
+
+
+
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_mac.h snort-2.3.3.new/src/kernel_snns/kr_mac.h
--- snort-2.3.3/src/kernel_snns/kr_mac.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_mac.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,116 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_mac.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Macros
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 09.12.91
+
+  CHANGED BY     : Michael Vogt
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:50 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+/*  Macro Definitions  */
+#ifndef numeric
+#define numeric(c)	       (c >= '0' && c <= '9')
+#endif
+#ifndef Max
+#define Max(a,b)	       (a<b ? b : a)
+#endif
+#ifndef Min
+#define Min(a,b)	       (a>b ? b : a)
+#endif
+#ifndef abs
+#define abs(x)		       (x>=0 ? x : -(x))
+#endif
+
+
+/*  Macros for stepping thru the unit array and the site/link lists
+*/
+#define FOR_ALL_UNITS( unit_ptr ) \
+for ((unit_ptr) = (unit_array != NULL ? \
+		   unit_array + MinUnitNo : unit_array + MaxUnitNo + 1); \
+     (unit_ptr) <= unit_array + MaxUnitNo; (unit_ptr)++)
+
+#define FOR_ALL_SITES( unit_ptr, site_ptr ) \
+for ((site_ptr) = (unit_ptr)->sites; (site_ptr) != NULL; \
+     (site_ptr) = (site_ptr)->next)
+
+#define FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ) \
+for ((site_ptr) = (unit_ptr)->sites; (site_ptr) != NULL; \
+     (site_ptr) = (site_ptr)->next) \
+  for ((link_ptr) = (site_ptr)->links; (link_ptr) != NULL; \
+       (link_ptr) = (link_ptr)->next)
+
+#define FOR_ALL_LINKS( unit_ptr, link_ptr ) \
+for ((link_ptr) = (struct Link *) (unit_ptr)->sites; (link_ptr) != NULL; \
+     (link_ptr) = (link_ptr)->next)
+
+#define FOR_ALL_LINKS_AT_SITE( site_ptr, link_ptr ) \
+for ((link_ptr) = (site_ptr)->links; (link_ptr) != NULL; \
+     (link_ptr) = (link_ptr)->next)
+
+
+
+/*  Some useful macros to determine the input type of a given unit
+*/
+#define UNIT_HAS_SITES( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_SITES)
+
+#define UNIT_HAS_DIRECT_INPUTS( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_DLINKS)
+
+#define UNIT_HAS_INPUTS( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_INPUT_PAT)
+
+#define IS_INPUT_UNIT( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_TTYP_IN)
+
+#define IS_OUTPUT_UNIT( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_TTYP_OUT)
+
+#define IS_HIDDEN_UNIT( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_TTYP_HIDD)
+
+#define IS_DUAL_UNIT( unit_ptr ) \
+(((unit_ptr)->flags & UFLAG_TTYP_DUAL) == UFLAG_TTYP_DUAL)
+
+#define IS_SPECIAL_UNIT( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_TTYP_SPEC)
+
+#define IS_SPECIAL_I_UNIT( unit_ptr ) \
+(((unit_ptr)->flags & UFLAG_TTYP_SPEC_I) == UFLAG_TTYP_SPEC_I)
+  
+#define IS_SPECIAL_H_UNIT( unit_ptr ) \
+(((unit_ptr)->flags & UFLAG_TTYP_SPEC_H) == UFLAG_TTYP_SPEC_H)
+ 
+#define IS_SPECIAL_O_UNIT( unit_ptr ) \
+(((unit_ptr)->flags & UFLAG_TTYP_SPEC_O) == UFLAG_TTYP_SPEC_O)
+
+#define IS_SPECIAL_D_UNIT( unit_ptr ) \
+(((unit_ptr)->flags & UFLAG_TTYP_SPEC_D) == UFLAG_TTYP_SPEC_D)
+
+
+
+/*  Macro to determine if a given unit is in use or not
+*/
+#define UNIT_IN_USE( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_IN_USE)
+
+#define UNIT_REFRESHED( unit_ptr ) \
+((unit_ptr)->flags & UFLAG_REFRESH)
+
+
+/*  Some macros for determine the current kernel type
+*/
+#define  KERNEL_STANDARD  (specialNetworkType == NET_TYPE_GENERAL)
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_mem.c snort-2.3.3.new/src/kernel_snns/kr_mem.c
--- snort-2.3.3/src/kernel_snns/kr_mem.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_mem.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,2096 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_mem.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel Memory Manager 
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 21.2.90
+ 
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.17 $
+  LAST CHANGE    : $Date: 1998/05/15 13:12:08 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#else
+#include <math.h>
+#endif
+
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants  */
+#include "kernel.h"
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"	 /*  Default Values  */
+
+#include "kr_mem.ph"	 /*  Function prototypes  */
+#include "kr_mac.h"	 /*  Kernel Macros  */
+
+/*  ULTRIX-32 Operating System	*/
+#if defined (ultrix) || defined (__BORLANDC__) 
+#include "strdup.h"	/*  include strdup function because strdup is
+			    missing in ULTRIX-32  */
+#endif
+
+
+/*****************************************************************************
+  FUNCTION : krm_allocLinks
+
+  PURPOSE  : allocate another link array (with size N entries)
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  int     krm_allocLinks(int N)
+{
+  LinkArray     tmp_ptr;
+
+
+  tmp_ptr = (LinkArray) calloc((unsigned int)( N + 1), LINK_SIZE );
+  if (tmp_ptr == NULL)  return( 1 );
+
+  if (link_array == NULL)
+    {
+    tmp_ptr->next = NULL;           /*  free link/block sentinel
+                                    */
+    free_link_ptr = tmp_ptr;
+    }
+  else
+    {
+    tmp_ptr->next = link_block_list;
+    }
+
+  link_block_list = tmp_ptr;    /* free link block sentinel */
+  NoOfAllocLinks += N;
+  link_array = tmp_ptr;         /* link_array points to the first link entry */
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getLink
+
+  PURPOSE  : get one link structure
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct Link  *krm_getLink(void)
+{
+  struct Link   *tmp_ptr;
+
+
+  if ((NoOfLinks == NoOfAllocLinks) || (link_array == NULL))
+    if (krm_allocLinks( LINK_BLOCK ) != 0)
+      {  /*  memory allocation failed  */
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( NULL );
+    }
+
+  NoOfLinks++;
+
+  if (free_link_ptr->next != NULL)
+    {
+    tmp_ptr = free_link_ptr;
+    free_link_ptr = free_link_ptr->next;
+  }
+  else
+    {
+    tmp_ptr = ++link_array;
+  }
+
+  return( tmp_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseLink
+
+  PURPOSE  : release one link structure
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseLink(struct Link *link_ptr)
+{
+  --NoOfLinks;
+
+  link_ptr->next = free_link_ptr;
+  free_link_ptr  = link_ptr;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseAllLinks
+
+  PURPOSE  : release the link and all following links
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseAllLinks(struct Link *first_link_ptr)
+{
+  struct Link  *curr,
+               *next,
+               *free;
+
+
+  free = free_link_ptr;
+  curr = first_link_ptr;
+
+  while (curr != NULL)  {
+    --NoOfLinks;
+
+    next = curr->next;
+    curr->next = free;
+
+    free = curr;
+    curr = next;
+  }
+
+  free_link_ptr = free;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseLinkArrays
+
+  PURPOSE  : free all link array
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void  krm_releaseLinkArrays(void)
+{
+  register struct Link  *tmp_ptr1, *tmp_ptr2;
+
+
+  NoOfLinks = NoOfAllocLinks = 0;
+
+  if (link_array != NULL)  {
+    tmp_ptr2 = link_block_list;
+    while (tmp_ptr2 != NULL)  {
+      tmp_ptr1 = tmp_ptr2->next;
+      free( (char *) tmp_ptr2 );
+      tmp_ptr2 = tmp_ptr1;
+    }
+
+    free_link_ptr = link_array = NULL;
+  }
+}
+
+
+
+/*#################################################
+
+GROUP: Site Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_allocSites
+
+  PURPOSE  : allocate another site array (with size N entries)
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  int     krm_allocSites(int N)
+{
+  SiteArray     tmp_ptr;
+
+
+  tmp_ptr = (SiteArray) calloc((unsigned int)(N + 1), SITE_SIZE );
+  if (tmp_ptr == NULL)  return( 1 );
+
+  if (site_array == NULL)  {
+    tmp_ptr->next = NULL;           /*  free site/block sentinel   */
+    free_site_ptr = tmp_ptr;
+  }
+  else  {
+    tmp_ptr->next = site_block_list;
+  }
+
+  site_block_list = tmp_ptr;    /*  free site block sentinel  */
+  NoOfAllocSites += N;
+  site_array = tmp_ptr;         /*  site_array points to the sentinel */
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getSite
+
+  PURPOSE  : get one unit-site structure
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct Site    *krm_getSite(void)
+{
+  struct Site   *tmp_ptr;
+
+
+  if ((site_array == NULL) || (NoOfSites == NoOfAllocSites))
+    if (krm_allocSites( SITE_BLOCK ) != 0)  {
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( NULL );
+    }
+
+  NoOfSites++;
+  NoOfNetSites++;
+
+  if (free_site_ptr->next != NULL)  {
+    tmp_ptr = free_site_ptr;
+    free_site_ptr = free_site_ptr->next;
+  }
+  else  {
+    tmp_ptr = ++site_array;
+  }
+
+  return( tmp_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getFtypeSite
+
+  PURPOSE  : get one site structure for functionality use only
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static struct Site  *krm_getFtypeSite(void)
+{
+  struct Site  *tmp_ptr;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if ((site_array == NULL) || (NoOfSites == NoOfAllocSites))
+    if (krm_allocSites( SITE_BLOCK ) != 0)  {
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( NULL );
+    }
+
+  NoOfSites++;
+
+  if (free_site_ptr->next != NULL)  {
+    tmp_ptr = free_site_ptr;
+    free_site_ptr = free_site_ptr->next;
+  }
+  else  {
+    tmp_ptr = ++site_array;
+  }
+
+  return( tmp_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseSite
+
+  PURPOSE  : release one unit-site structure
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseSite(struct Site *site_ptr)
+{
+  --NoOfSites;
+  --NoOfNetSites;
+
+  site_ptr->next = free_site_ptr;
+  free_site_ptr  = site_ptr;
+}
+
+
+/*****************************************************************************
+  FUNCTION :krm_releaseFtypeSite
+
+  PURPOSE  : 
+  NOTES    : Future Use: 
+             release one Ftype-site structure
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+/*
+static void    krm_releaseFtypeSite(struct Site *site_ptr )
+{
+  --NoOfSites;
+
+  site_ptr->next = free_site_ptr;
+  free_site_ptr  = site_ptr;
+}
+*/
+
+/*****************************************************************************
+  FUNCTION : krm_releaseAllSites
+
+  PURPOSE  : release the unit-site and all following sites (at this unit)
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseAllSites(struct Site *first_site_ptr)
+{
+  struct Site  *curr,
+               *next,
+               *free;
+
+
+  free = free_site_ptr;
+  curr = first_site_ptr;
+
+  while (curr != NULL)  {
+    --NoOfSites;
+    --NoOfNetSites;
+
+    next = curr->next;
+    curr->next = free;
+
+    free = curr;
+    curr = next;
+  }
+
+  free_site_ptr = free;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseAllFtypeSites
+
+  PURPOSE  : release the Ftype-site and all following sites
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void    krm_releaseAllFtypeSites(struct Site *first_site_ptr)
+{
+  struct Site  *curr,
+               *next,
+               *free;
+
+
+  free = free_site_ptr;
+  curr = first_site_ptr;
+
+  while (curr != NULL)  {
+    --NoOfSites;
+
+    next = curr->next;
+    curr->next = free;
+
+    free = curr;
+    curr = next;
+  }
+
+  free_site_ptr = free;
+}
+
+/*****************************************************************************
+  FUNCTION :  krm_releaseSiteArrays
+
+  PURPOSE  : free all site arrays
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  void    krm_releaseSiteArrays(void)
+{
+  struct Site      *tmp_ptr;
+
+
+  NoOfSites      = 0;
+  NoOfNetSites   = 0;
+  NoOfAllocSites = 0;
+
+  if (site_array != NULL)  {
+    while (site_block_list != NULL)  {
+      tmp_ptr =  site_block_list->next;
+      free( (char *) site_block_list );
+      site_block_list = tmp_ptr;
+    }
+
+    free_site_ptr = NULL;
+    site_array    = NULL;
+  }
+}
+
+
+
+/*#################################################
+
+GROUP: Unit Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_unitArrayGC
+
+  PURPOSE  : garbage collection of unit array 
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void  krm_unitArrayGC(void)
+{
+  register struct Link   *link_ptr;
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+  register struct Unit   *new_unit_ptr;
+  struct Unit   *dest_unit_ptr;
+
+
+  /*  find first unused unit stucture  */
+  dest_unit_ptr = NULL;
+  FOR_ALL_UNITS( unit_ptr )
+    if (!UNIT_IN_USE( unit_ptr ))
+      {  /*  unit isn't in use  */
+      dest_unit_ptr = unit_ptr;  /*  store the first unused unit stucture  */
+      break;
+    }
+
+  if (dest_unit_ptr != NULL)  
+    {  /*  do garbage collection  */
+    NetModified = TRUE;
+
+    /*  store continous unit pointers in each unit struct  */
+    new_unit_ptr = unit_array;
+    FOR_ALL_UNITS( unit_ptr )
+      if UNIT_IN_USE( unit_ptr )
+        /*  unit is in use  */
+        unit_ptr->Aux.ptr = (char *) ++new_unit_ptr;
+
+    /*  adjust the link pointers  */
+    FOR_ALL_UNITS( unit_ptr )
+      if UNIT_IN_USE( unit_ptr )  {
+	if UNIT_HAS_SITES( unit_ptr )
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+              link_ptr->to = (struct Unit *) link_ptr->to->Aux.ptr;
+        else
+	  if UNIT_HAS_DIRECT_INPUTS( unit_ptr )
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+              link_ptr->to = (struct Unit *) link_ptr->to->Aux.ptr;
+      }
+
+
+    /*  compress unit array  */
+    for (unit_ptr = dest_unit_ptr+1; unit_ptr<=unit_array+MaxUnitNo; unit_ptr++)
+      if UNIT_IN_USE( unit_ptr )
+        memcpy( (char *) dest_unit_ptr++, (char *) unit_ptr, UNIT_SIZE );
+
+    MinUnitNo = 1;
+    MaxUnitNo = NoOfUnits;
+    FreeUnitIndex = 0;
+  }
+
+  /*  reduce size of unit array, if needed  */
+  if ((NoOfAllocUnits - NoOfUnits) >= (2 * UNIT_BLOCK))  {
+    unit_ptr = (UnitArray) realloc( (char *) unit_array, (unsigned)
+                                   ((NoOfAllocUnits + 1 - UNIT_BLOCK) * 
+				    UNIT_SIZE) );
+    if (unit_ptr != NULL)  {
+      unit_array = unit_ptr;
+      NoOfAllocUnits -= UNIT_BLOCK;
+    }
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_relocateLinkPtrs
+
+  PURPOSE  : relocate the link pointers. (If the address of the unit array was modified
+             because the memory was reallocated, the link pointers must be relocated)
+
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  void    krm_relocateLinkPtrs(int offset)
+{
+  register struct Link   *link_ptr;
+  register struct Site   *site_ptr;
+  register struct Unit   *unit_ptr;
+
+
+  FOR_ALL_UNITS( unit_ptr )
+    if UNIT_IN_USE( unit_ptr )  {
+      if UNIT_HAS_SITES( unit_ptr )
+	FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	  link_ptr->to = (struct Unit *) ((char *) link_ptr->to + offset);
+      else
+	if UNIT_HAS_DIRECT_INPUTS( unit_ptr )
+	  FOR_ALL_LINKS( unit_ptr, link_ptr )
+            link_ptr->to = (struct Unit *) ((char *) link_ptr->to + offset);
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_allocUnits
+
+  PURPOSE  : allocate the unit array
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  krm_allocUnits(int N)
+{
+  UnitArray  tmp_ptr;
+  int  offset;
+
+  if ((NoOfAllocUnits - NoOfUnits) < N)
+    {  /*  alloc units	*/
+    N = (N / UNIT_BLOCK + 1) * UNIT_BLOCK;
+  }
+
+  if (unit_array == NULL)  {
+    tmp_ptr = (UnitArray) calloc((unsigned int)( NoOfAllocUnits + N + 1 ), 
+				 UNIT_SIZE );
+    if (tmp_ptr == NULL)
+      {  /*  mem alloc failed	 */
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( KernelErrorCode );
+    }
+    FreeUnitIndex = 0;
+    tmp_ptr[0].Out.nextFreeUnit = 0;   /*  sentinel of free unit list
+                                       */
+  }
+  else  {
+    tmp_ptr = (UnitArray) realloc( (char *) unit_array, (unsigned)
+                                   ((NoOfAllocUnits + N + 1 ) * UNIT_SIZE) );
+    if (tmp_ptr == NULL)
+      {  /*  mem alloc failed	 */
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( KernelErrorCode );
+    }
+    offset = (char *) tmp_ptr - (char *) unit_array;
+    if (offset != 0)  krm_relocateLinkPtrs( offset );
+  }
+
+  NoOfAllocUnits += N;
+  unit_array = tmp_ptr;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : krm_getUnit
+
+  PURPOSE  : get one unit structure
+  NOTES    :
+
+  RETURNS  : the number of the current unit structure. This number is negative 
+             if a new block had to be allocated, to signal the calling program 
+             that it has to update its unit pointers.
+  UPDATE   : 
+******************************************************************************/
+int  krm_getUnit(void)
+{
+  register int   unit_no;
+  int ret_fact = 1;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  if ((unit_array == NULL) || (NoOfUnits == NoOfAllocUnits)){
+    if (krm_allocUnits( UNIT_BLOCK ) != 0)
+      {  /*  Insufficient memory  */
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( 0 );
+    }
+    ret_fact = -1;
+  }
+  NoOfUnits++;
+
+  if (FreeUnitIndex != 0)
+    {  /*  reuse unit  */
+    unit_no = FreeUnitIndex;
+    FreeUnitIndex = unit_array[unit_no].Out.nextFreeUnit;
+  }
+  else
+    unit_no = NoOfUnits;
+
+  /*  this unit is ready to use  */
+  unit_array[unit_no].flags = UFLAG_IN_USE;
+  unit_array[unit_no].sites = NULL;
+
+  if (NoOfUnits == 1)
+    MinUnitNo = MaxUnitNo = unit_no;
+  else  {
+    /*	store the highest allocated unit number  */
+    if (unit_no > MaxUnitNo)  MaxUnitNo = unit_no;
+    /*	store the lowest allocated unit number	*/
+    if (unit_no < MinUnitNo)  MinUnitNo = unit_no;
+  }
+
+  return( unit_no * ret_fact);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseUnit
+
+  PURPOSE  : release unit
+
+  NOTES    : NEW VERSION in SNNS V3.0
+             Now the garbage collection is performed on every deletion of 
+             a unit.
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseUnit(int UnitNo)
+{
+  if (unit_array[UnitNo].flags != UFLAG_FREE) {  /*  don't release twice
+                                                 */
+    --NoOfUnits;
+
+    unit_array[UnitNo].flags = UFLAG_FREE;
+
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseUnitArrays
+
+  PURPOSE  : free the unit array
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static	void	krm_releaseUnitArrays(void)
+{
+  NoOfAllocUnits = FreeUnitIndex =
+  NoOfUnits = NoOfInputUnits = NoOfOutputUnits =
+  NoOfHiddenUnits = MaxUnitNo = 0;
+
+  if (unit_array != NULL)  {
+    free( (char *) unit_array );
+    unit_array = NULL;
+  }
+}
+
+
+
+/*#################################################
+
+GROUP: General Purpose Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_getMemoryManagerInfo
+
+  PURPOSE  : get information about memory usage
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_getMemoryManagerInfo(int *array_size, int info_array[])
+{
+  info_array[ 0 ] = NoOfNetSites;
+
+#ifdef MASPAR_KERNEL
+  if (specialNetworkType == NET_TYPE_FF1)
+    info_array[ 1 ] = descrFFnet.no_of_weights;
+  else
+    info_array[ 1 ] = NoOfLinks;
+#else
+  info_array[ 1 ] = NoOfLinks;
+#endif
+
+  info_array[ 2 ] = NoOfSTableEntries;
+  info_array[ 3 ] = NoOfFTableEntries;
+
+  info_array[ 4 ] = NoOfAllocUnits;
+  info_array[ 5 ] = NoOfAllocSites;
+  info_array[ 6 ] = NoOfAllocLinks;
+  info_array[ 7 ] = NoOfAllocNTableEntries;
+  info_array[ 8 ] = NoOfAllocSTableEntries;
+  info_array[ 9 ] = NoOfFTableEntries;
+
+  *array_size = 10;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_allocUnitTopoArray
+
+  PURPOSE  : allocate the array for topological sorting of the units in the 
+             network
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  krm_allocUnitTopoArray(int N)
+{
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (topo_ptr_array != NULL)
+    {  /*  reallocate array for topologic sorting  */
+    topo_ptr_array = (TopoPtrArray) realloc( (char *) topo_ptr_array,
+					     (unsigned) (N * TOPO_PTR_SIZE) );
+  }
+  else
+    {  /*  allocate new array for topologic sorting  */
+    topo_ptr_array = (TopoPtrArray) calloc((unsigned int) N, TOPO_PTR_SIZE);
+  }
+
+  if (topo_ptr_array == NULL)  KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+
+  return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseUnitTopoArray
+
+  PURPOSE  : release the topolocic array
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void  krm_releaseUnitTopoArray(void)
+{
+  if (topo_ptr_array != NULL)  {
+    free( (char *) topo_ptr_array );
+    topo_ptr_array = NULL;
+  }
+}
+
+
+
+/*#################################################
+
+GROUP: NameTable Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_allocNTableArray
+
+  PURPOSE  : allocate one name-table block
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  int     krm_allocNTableArray(void)
+{
+  NTableArray     tmp_ptr;
+
+
+  tmp_ptr = (NTableArray) calloc( NTABLE_BLOCK + 1, NTABLE_SIZE );
+  if (tmp_ptr == NULL)  return( 1 );
+
+  if (NTable_array == NULL)  {
+    tmp_ptr->Entry.next = NULL;     /*  free name-table block sentinel  */
+    free_NTable_entry = tmp_ptr;    /*  free name-table entry sentinel  */
+  }
+  else  {
+    tmp_ptr->Entry.next = NTable_block_list;    /*  append new name-table block
+                                                    to block list   */
+  }
+
+  NTable_block_list = tmp_ptr;      /* update block list ptr */
+  NoOfAllocNTableEntries += NTABLE_BLOCK;
+  NTable_array = tmp_ptr + 1;       /* NTable_array points to the first entry */
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getNTableEntry
+
+  PURPOSE  : get one name-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static struct NameTable  *krm_getNTableEntry(void)
+{
+  struct NameTable  *tmp_ptr;
+
+
+  if ((NTable_array == NULL) || (NoOfNTableEntries == NoOfAllocNTableEntries))
+    if (krm_allocNTableArray() != 0)  {
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( NULL );
+    }
+
+  NoOfNTableEntries++;
+
+  if (free_NTable_entry->Entry.next != NULL)
+    {   /*  a previous released name-table entry is availabe    */
+    tmp_ptr = free_NTable_entry;
+    free_NTable_entry = free_NTable_entry->Entry.next;
+  }
+  else  {
+    tmp_ptr = NTable_array++;
+  }
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  tmp_ptr->ref_count = 1;
+  return( tmp_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_NTableReleaseEntry
+
+  PURPOSE  : release one name-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_NTableReleaseEntry(struct NameTable *NTable_ptr)
+{
+  --NoOfNTableEntries;
+
+  free( NTable_ptr->Entry.symbol );
+  NTable_ptr->sym_type = UNUSED_SYM;
+  NTable_ptr->Entry.next = free_NTable_entry;
+  free_NTable_entry = NTable_ptr;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseNTableArrays
+
+  PURPOSE  : release all name-table blocks
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static void  krm_releaseNTableArrays(void)
+{
+  struct NameTable     *tmp_ptr;
+
+
+  NoOfNTableEntries      = 0;
+  NoOfAllocNTableEntries = 0;
+
+  if (NTable_array != NULL)  {
+    for (tmp_ptr = NTable_array - 1; tmp_ptr > NTable_block_list; --tmp_ptr)  {
+      if (tmp_ptr->sym_type != UNUSED_SYM)
+        free( tmp_ptr->Entry.symbol );    /*  free symbols */
+    }
+
+    tmp_ptr = NTable_block_list->Entry.next;
+    free( (char *) NTable_block_list );
+    NTable_block_list = tmp_ptr;
+
+    while (NTable_block_list != NULL)  {
+      for (tmp_ptr = NTable_block_list + NTABLE_BLOCK;
+           tmp_ptr > NTable_block_list; --tmp_ptr)  {
+        if (tmp_ptr->sym_type != UNUSED_SYM)
+          free( tmp_ptr->Entry.symbol );   /*  free symbols */
+      }
+
+      tmp_ptr =  NTable_block_list->Entry.next;
+      free( (char *) NTable_block_list );
+      NTable_block_list = tmp_ptr;
+    }
+
+    free_NTable_entry = NULL;
+    NTable_array      = NULL;
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_NTableSymbolSearch
+
+  PURPOSE  : Searches for a given symbol and symbol-type in the name table.
+  NOTES    :
+
+  RETURNS  : Returns symbol ptr if symbol was found, NULL otherwise.
+  UPDATE   : 
+******************************************************************************/
+struct  NameTable   *krm_NTableSymbolSearch(char *symbol, int sym_type)
+{
+  int   symbol_type;
+  struct  NameTable   *n_ptr,
+                      *block_list;
+
+
+  if (NTable_array == NULL)  return( NULL );
+
+  block_list = NTable_block_list;
+  for (n_ptr = NTable_array - 1; n_ptr > block_list; n_ptr--)  {
+    symbol_type = (int) n_ptr->sym_type;
+    if ( (symbol_type != UNUSED_SYM) &&
+         (symbol_type == sym_type) &&
+         (strcmp( n_ptr->Entry.symbol, symbol ) == 0) )
+      return( n_ptr );    /*  symbol was found    */
+  }
+
+  for (block_list = block_list->Entry.next;
+       block_list != NULL;
+       block_list = block_list->Entry.next)  {
+    for (n_ptr = block_list + NTABLE_BLOCK; n_ptr > block_list; n_ptr--)  {
+      symbol_type = (int) n_ptr->sym_type;
+      if ( (symbol_type != UNUSED_SYM) &&
+           (symbol_type == sym_type) &&
+           (strcmp( n_ptr->Entry.symbol, symbol ) == 0) )
+        return( n_ptr );    /*  symbol was found    */
+    }
+  }
+
+  return( NULL );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_NTableCreateEntry
+
+  PURPOSE  : Creates a new symbol in the name-table
+  NOTES    :
+
+  RETURNS  : Returns name-table ptr or NULL if memory alloc has failed.
+  UPDATE   : 
+******************************************************************************/
+struct NameTable  *krm_NTableCreateEntry(char *symbol_name, int symbol_type)
+{
+  char   *str_ptr;
+  struct  NameTable     *n_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+
+  if ( (n_ptr = krm_getNTableEntry() ) == NULL)
+    return( NULL );     /*  memory alloc failed */
+
+  if ((str_ptr = (char *) strdup( symbol_name ) ) == NULL)
+    {  /*  memory alloc failed */
+    KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+    return( NULL );
+  }
+
+  n_ptr->Entry.symbol = str_ptr;
+  n_ptr->sym_type = (unsigned short) symbol_type;
+
+  return( n_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_NTableInsertSymbol
+
+  PURPOSE  : Inserts a symbol in the name-table. This function duplicates 
+             symbol ptrs if the symbol was found in the name-table.
+  NOTES    :
+
+  RETURNS  : Returns symbol ptr or NULL if memory alloc has failed
+  UPDATE   : 
+******************************************************************************/
+char  *krm_NTableInsertSymbol(char *symbol_name, int symbol_type)
+{
+  struct NameTable  *n_ptr;
+
+
+  if ( (n_ptr = krm_NTableSymbolSearch( symbol_name, symbol_type ) ) != NULL)
+    {   /*  symbol is already in the name table  */
+    if ((n_ptr->ref_count) < ((unsigned short) MAXSHORT)) {
+        n_ptr->ref_count++;
+    }
+    return( n_ptr->Entry.symbol );
+  }
+
+  n_ptr = krm_NTableCreateEntry( symbol_name, symbol_type );
+  return( n_ptr->Entry.symbol );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_NTableReleaseSymbol
+
+  PURPOSE  : release name-table entry if there is no other reference to this 
+             symbol
+  NOTES    :
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+void  krm_NTableReleaseSymbol(char *symbol_name, int symbol_type)
+{
+  struct NameTable  *n_ptr;
+
+
+  if (symbol_name == NULL)  return;
+  if ( (n_ptr = krm_NTableSymbolSearch( symbol_name, symbol_type ) ) != NULL)
+    {   /*  symbol is in the name table  */
+    if ((n_ptr->ref_count) < ((unsigned short) MAXSHORT))
+      {   /*    No. of references to this symbol don't exceed the max. reference
+                count. This means it is possible to delete the symbol if the
+                reference count is zero.
+          */
+      if (--(n_ptr->ref_count) == 0)
+        krm_NTableReleaseEntry( n_ptr );
+    }
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getNTableFirstEntry
+
+  PURPOSE  : get the first name-table entry
+  NOTES    :
+
+  RETURNS  : the nametable 
+  UPDATE   : 
+******************************************************************************/
+struct NameTable       *krm_getNTableFirstEntry(void)
+{
+  if (NTable_array == NULL)  return( NULL );
+
+  curr_NTable_block = NTable_block_list;
+  curr_NTable_entry = NTable_array - 1;
+  return( curr_NTable_entry );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getNTableNextEntry
+
+  PURPOSE  : get the next name-table entry
+  NOTES    :
+
+  RETURNS  : the nametable 
+  UPDATE   : 
+******************************************************************************/
+struct NameTable       *krm_getNTableNextEntry(void)
+{
+  if ((NTable_array == NULL) || (curr_NTable_block == NULL))
+    return( NULL );
+
+  if (--curr_NTable_entry == curr_NTable_block)  {
+    if ( (curr_NTable_block = curr_NTable_block->Entry.next) == NULL)
+      return( NULL );
+
+    curr_NTable_entry = curr_NTable_block + NTABLE_BLOCK;
+  }
+
+  return( curr_NTable_entry );
+}
+
+
+
+
+
+/*#################################################
+
+GROUP: SiteTable Functions
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_allocSTableArray
+
+  PURPOSE  : allocate another site-table block
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static int  krm_allocSTableArray(void)
+{
+  STableArray     tmp_ptr;
+
+
+  tmp_ptr = (STableArray) calloc( STABLE_BLOCK + 1, STABLE_SIZE );
+  if (tmp_ptr == NULL)  return( 1 );
+
+  if (STable_array == NULL)  {
+    tmp_ptr->Entry.next = NULL;     /*  free site-table block sentinel  */
+    free_STable_entry = tmp_ptr;    /*  free site-table entry sentinel  */
+  }
+  else  {
+    tmp_ptr->Entry.next = STable_block_list;    /*  append new site-table block
+                                                    to block list   */
+  }
+
+  STable_block_list = tmp_ptr;      /*  update block list ptr  */
+  NoOfAllocSTableEntries += STABLE_BLOCK;
+  STable_array = tmp_ptr + 1;       /* STable_array points to the first entry */
+  return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_allocSTableArray
+
+  PURPOSE  : get one site-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  struct SiteTable    *krm_getSTableEntry(void)
+{
+  struct SiteTable  *tmp_ptr;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  if ((STable_array == NULL) || (NoOfSTableEntries == NoOfAllocSTableEntries))
+    if (krm_allocSTableArray() != 0)  {
+      KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+      return( NULL );
+    }
+
+  NoOfSTableEntries++;
+
+  if (free_STable_entry->Entry.next != NULL)
+    {   /*  a previous released site-table entry is availabe    */
+    tmp_ptr = free_STable_entry;
+    free_STable_entry = free_STable_entry->Entry.next;
+  }
+  else  {
+    tmp_ptr = STable_array++;
+  }
+
+  return( tmp_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseSTableEntry
+
+  PURPOSE  : release site table block
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  void    krm_releaseSTableEntry(struct SiteTable *STable_ptr)
+{
+  --NoOfSTableEntries;
+
+  STable_ptr->site_func  = NULL;
+  STable_ptr->Entry.next = free_STable_entry;
+  free_STable_entry = STable_ptr;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseSTableArrays
+
+  PURPOSE  : release all site-table blocks
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+static  void    krm_releaseSTableArrays(void)
+{
+  struct SiteTable     *tmp_ptr;
+
+
+  NoOfSTableEntries      = 0;
+  NoOfAllocSTableEntries = 0;
+
+  if (STable_array != NULL)  {
+    while (STable_block_list != NULL)  {
+      tmp_ptr =  STable_block_list->Entry.next;
+      free( (char *) STable_block_list );
+      STable_block_list = tmp_ptr;
+    }
+
+    free_STable_entry = NULL;
+    STable_array      = NULL;
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_STableCreateEntry
+
+  PURPOSE  : create new site-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct SiteTable *krm_STableCreateEntry(char *site_symbol, 
+					SiteFuncPtr site_func)
+{
+  struct  NameTable     *n_ptr;
+  struct  SiteTable     *s_ptr;
+
+
+  if ( (s_ptr = krm_getSTableEntry() ) == NULL)
+    return( NULL );     /*  memory alloc failed */
+
+  if ((n_ptr = krm_NTableCreateEntry( site_symbol, SITE_SYM ) ) == NULL)  {
+    krm_releaseSTableEntry( s_ptr );
+    return( NULL );     /*  memory alloc failed */
+  }
+
+  s_ptr->Entry.site_name = n_ptr;
+  s_ptr->site_func       = site_func;
+
+  return( s_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_STableChangeEntry
+
+  PURPOSE  : change the properties of the given site-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct  SiteTable   *krm_STableChangeEntry(struct SiteTable *stbl_ptr, 
+					   char *new_site_name, 
+					   SiteFuncPtr new_site_func)
+{
+  struct  NameTable     *n_ptr;
+
+
+  if ((n_ptr = krm_NTableCreateEntry( new_site_name, SITE_SYM ) ) == NULL)
+    return( NULL );     /*  memory alloc failed */
+
+  krm_NTableReleaseEntry( stbl_ptr->Entry.site_name );
+
+  stbl_ptr->Entry.site_name = n_ptr;
+  stbl_ptr->site_func       = new_site_func;
+
+  return( stbl_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_STableRemoveEntry
+
+  PURPOSE  : release a previosly defined site-table entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_STableRemoveEntry(struct SiteTable *STable_ptr)
+{
+  krm_NTableReleaseEntry( STable_ptr->Entry.site_name );
+  krm_releaseSTableEntry( STable_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_STableSymbolSearch
+
+  PURPOSE  : searches for a symbol in the site-table
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct SiteTable    *krm_STableSymbolSearch(char *site_symbol)
+{
+  struct  NameTable   *n_ptr;
+  struct  SiteTable   *s_ptr,
+                      *block_list;
+
+
+  if (STable_array == NULL)
+    return( NULL );     /*  there are no site-table entries */
+
+  if ( (n_ptr = krm_NTableSymbolSearch( site_symbol , SITE_SYM ) ) == NULL)
+    return( NULL );     /*  symbol dosn't exist */
+
+
+  block_list = STable_block_list;
+  for (s_ptr = STable_array - 1; s_ptr > block_list; s_ptr--)
+    if ( (s_ptr->site_func != NULL) &&
+         (s_ptr->Entry.site_name == n_ptr ) )
+      return( s_ptr );
+
+  for (block_list = block_list->Entry.next;
+       block_list != NULL;
+       block_list = block_list->Entry.next)  {
+    for (s_ptr = block_list + STABLE_BLOCK; s_ptr > block_list; s_ptr--)
+      if ( (s_ptr->site_func != NULL) &&
+           (s_ptr->Entry.site_name == n_ptr ) )
+        return( s_ptr );
+  }
+
+  return( NULL );  /*  the site symbol is in the name table, but not in 
+		       the site table: Error */
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getSTableNextRawEntry
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns a pointer to the next (used or unused) site-table entry
+  UPDATE   : 
+******************************************************************************/
+static struct SiteTable       *krm_getSTableNextRawEntry(void)
+{
+  if ((STable_array == NULL) || (curr_STable_block == NULL))
+    return( NULL );
+
+  if (--curr_STable_entry == curr_STable_block)
+    {  /*  get new site-table block  */
+    if ( (curr_STable_block = curr_STable_block->Entry.next) == NULL)  {
+      curr_STable_block = NULL;
+      curr_STable_entry = NULL;
+
+      return( NULL );
+    }
+
+    /* next site-table block  */
+    curr_STable_entry = curr_STable_block + STABLE_BLOCK; 
+  }
+
+  return( curr_STable_entry );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getSTableNextEntry
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns a pointer to the next used site-table entry
+  UPDATE   : 
+******************************************************************************/
+struct SiteTable       *krm_getSTableNextEntry(void)
+{
+  struct  SiteTable   *stbl_ptr;
+
+
+  if ((stbl_ptr = krm_getSTableNextRawEntry()) == NULL)
+    return( NULL );
+
+  while ( stbl_ptr->site_func == NULL)	/*  return only used site-table entries  */
+    if ((stbl_ptr = krm_getSTableNextRawEntry()) == NULL)
+      return( NULL );
+        
+  return( stbl_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getSTableFirstEntry
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns a pointer to the first used site-table entry
+  UPDATE   : 
+******************************************************************************/
+struct SiteTable       *krm_getSTableFirstEntry(void)
+{
+  struct  SiteTable   *stbl_ptr;
+  
+
+  if (STable_array == NULL)  return( NULL );
+
+  curr_STable_block = STable_block_list;
+  curr_STable_entry = STable_array - 1;
+  stbl_ptr = curr_STable_entry;
+
+  if (stbl_ptr->site_func == NULL)  /*	return only used site-table entries  */
+    if ((stbl_ptr = krm_getSTableNextEntry()) == NULL)
+      return( NULL );
+
+  return( stbl_ptr );
+}
+
+
+
+
+
+/*#################################################
+
+GROUP: Ftype entry functions
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : krm_getFtypeEntry
+
+  PURPOSE  : allocate a new Ftype entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct FtypeUnitStruct  *krm_getFtypeEntry(void)
+{
+  struct FtypeUnitStruct  *Ftype_entry;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  if ((Ftype_entry = 
+           (struct FtypeUnitStruct *) malloc( FTYPE_UNIT_SIZE ) ) == NULL)
+    {  /*  memory alloc failed */
+    KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+    return( NULL );
+  }
+
+  if (Ftype_list_root != NULL)  {
+    Ftype_list_root->prev = Ftype_entry;
+    Ftype_entry->next = Ftype_list_root;
+  }
+  else
+    Ftype_entry->next = NULL;
+
+  Ftype_list_root   = Ftype_entry;
+  Ftype_entry->prev = NULL;
+
+  Ftype_entry->sites = NULL;
+  Ftype_entry->Ftype_symbol = NULL;
+
+  ++NoOfFTableEntries;
+
+  return( Ftype_entry );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseFtypeEntry
+
+  PURPOSE  : free a previosly defined Ftype entry
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseFtypeEntry(struct FtypeUnitStruct *Ftype_entry)
+{
+  struct  FtypeUnitStruct   *next_entry,
+                            *prev_entry;
+
+
+  /*  release sites first */
+  if ( Ftype_entry->sites != NULL)
+    krm_releaseAllSites( Ftype_entry->sites );
+
+  /*  release Ftype symbol name */
+  if ( Ftype_entry->Ftype_symbol != NULL )
+    krm_NTableReleaseEntry( Ftype_entry->Ftype_symbol );
+
+  next_entry = Ftype_entry->next;
+  prev_entry = Ftype_entry->prev;
+
+  if (prev_entry != NULL)
+    prev_entry->next = next_entry;
+  else
+    Ftype_list_root = next_entry;
+
+  if (next_entry != NULL)
+    next_entry->prev = prev_entry;
+
+  /*  release unit entry  */
+  free( (char *) Ftype_entry );       /*  release Ftype entry   */
+
+  --NoOfFTableEntries;
+}
+
+/*****************************************************************************
+  FUNCTION : krm_FtypeCreateEntry
+
+  PURPOSE  : create and define a Ftype entry
+  NOTES    :
+
+  RETURNS  : the ftype
+  UPDATE   : 
+******************************************************************************/
+struct FtypeUnitStruct  *krm_FtypeCreateEntry(char *Ftype_symbol, OutFuncPtr out_func, ActFuncPtr act_func, ActDerivFuncPtr act_deriv_func, ActDerivFuncPtr act_2_deriv_func)
+{
+  struct  FtypeUnitStruct   *Ftype_entry;
+  struct  NameTable         *n_ptr;
+
+
+  if ( (Ftype_entry = krm_getFtypeEntry() ) == NULL)
+    return( NULL );     /*  memory alloc failed */
+
+  if((n_ptr = krm_NTableCreateEntry( Ftype_symbol, FTYPE_UNIT_SYM ) ) == NULL) {
+    krm_releaseFtypeEntry( Ftype_entry );
+    return( NULL );     /*  memory alloc failed */
+  }
+
+  Ftype_entry->Ftype_symbol = n_ptr;
+  Ftype_entry->out_func = out_func;
+  Ftype_entry->act_func = act_func;
+  Ftype_entry->act_deriv_func = act_deriv_func;
+  Ftype_entry->act_2_deriv_func = act_2_deriv_func;
+  Ftype_entry->sites = NULL;
+
+  return( Ftype_entry );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_FtypeAddSite
+
+  PURPOSE  : add a site to a previosly defined Ftype entry
+  NOTES    :
+
+  RETURNS  : the site
+  UPDATE   : 
+******************************************************************************/
+struct Site  *krm_FtypeAddSite(struct FtypeUnitStruct *Ftype_entry, 
+			       struct SiteTable *STable_entry)
+{
+  struct  Site   *site_ptr;
+
+
+  if ( (site_ptr = krm_getFtypeSite() ) == NULL)
+    return( NULL );     /*  memory alloc failed */
+
+  site_ptr->next = Ftype_entry->sites;
+  Ftype_entry->sites = site_ptr;
+
+  site_ptr->site_table = STable_entry;
+
+  return( site_ptr );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getFtypeFirstEntry
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns a pointer to first Ftype entry
+  UPDATE   : 
+******************************************************************************/
+struct FtypeUnitStruct  *krm_getFtypeFirstEntry(void)
+{
+  curr_Ftype_entry = Ftype_list_root;
+  return( Ftype_list_root );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getFtypeNextEntry
+
+  PURPOSE  : 
+  NOTES    :
+
+  RETURNS  : returns a pointer to next Ftype entry
+  UPDATE   : 
+******************************************************************************/
+struct FtypeUnitStruct  *krm_getFtypeNextEntry(void)
+{
+  if (curr_Ftype_entry != NULL)  {
+    if (curr_Ftype_entry->next != NULL)
+      curr_Ftype_entry = curr_Ftype_entry->next;
+    else
+      return( NULL );
+  }
+
+  return( curr_Ftype_entry );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_getFtypeNextEntry
+
+  PURPOSE  : searches for a Ftype entry with the given name
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+struct  FtypeUnitStruct  *krm_FtypeSymbolSearch(char *Ftype_symbol)
+{
+  struct  FtypeUnitStruct   *ftype_entry;
+
+
+  if (Ftype_symbol == NULL)  return( NULL);
+
+  ftype_entry = Ftype_list_root;
+  while (ftype_entry != NULL)  {
+    if (strcmp( Ftype_symbol, (ftype_entry->Ftype_symbol)->Entry.symbol ) == 0)
+      return( ftype_entry );
+
+    ftype_entry = ftype_entry->next;
+  }
+
+  return( NULL );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krm_releaseFtypeList
+
+  PURPOSE  : releases all Ftype entries
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseFtypeList(void)
+{
+  struct  FtypeUnitStruct   *Ftype_entry,
+                            *ft_ptr;
+
+
+  Ftype_entry = Ftype_list_root;
+
+  while( Ftype_entry != NULL )  {
+    /*  release sites first */
+    if ( Ftype_entry->sites != NULL)
+      krm_releaseAllFtypeSites( Ftype_entry->sites );
+
+    /*  release Ftype symbol name */
+    if ( Ftype_entry->Ftype_symbol != NULL )
+      krm_NTableReleaseEntry( Ftype_entry->Ftype_symbol );
+
+    ft_ptr = Ftype_entry;
+    Ftype_entry = Ftype_entry->next;
+    /*  release unit entry  */
+    free( (char *) ft_ptr );       /*  release Ftype entry   */
+  }
+
+  Ftype_list_root = NULL;
+  NoOfFTableEntries = 0;
+}
+
+
+
+#ifdef MASPAR_KERNEL
+#ifdef MASPAR_KERNEL_EMULATION
+
+/*#################################################
+
+GROUP: Functions for the MasPar kernel
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION : krm_releaseWeightArrays
+
+  PURPOSE  : release weight arrays from memory
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void  krm_releaseWeightArrays(void)
+{
+  int  dest_layer, src_layer;
+  FlintType  *weight_array;
+
+  /*  get weight array pointers  */
+  for (dest_layer = 1; dest_layer < descrFFnet.no_of_layers; dest_layer++)
+    for (src_layer = 0; src_layer < dest_layer; src_layer++)  {
+      weight_array = 
+	  descrFFnet.layers[dest_layer].inputs[src_layer].weight_array;
+      if (weight_array != NULL)  {
+        free( (char *) weight_array );
+	descrFFnet.layers[ dest_layer ].inputs[src_layer].weight_array = NULL;
+	descrFFnet.layers[ dest_layer ].inputs[src_layer].no_of_inputs = 0;
+      }
+    }
+
+  NoOfWeights = 0;
+  specialNetworkType == NET_TYPE_GENERAL;
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krm_createWeightArrays
+
+  PURPOSE  :  creates arrays containing connection weights for feedforward 
+              networks
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  krm_createWeightArrays(void)
+{
+  int  dest_layer, src_layer, no_of_inputs;
+  FlintType  *weight_array;
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  NoOfWeights = 0;
+
+  /*  allocate weight arrays  */
+  for (dest_layer = 1; dest_layer < descrFFnet.no_of_layers; dest_layer++)
+    for (src_layer = 0; src_layer < dest_layer; src_layer++)  {
+	no_of_inputs = 
+	    descrFFnet.layers[ dest_layer ].inputs[src_layer].no_of_inputs;
+      if (no_of_inputs > 0)
+        {  /*  there are <no_of_inputs> connections between layer <src_layer>
+               and layer <dest_layer>.  */
+	weight_array = (FlintType *) calloc( no_of_inputs, sizeof (FlintType) );
+        if (weight_array == NULL)
+          {  /*  insufficient memory  */
+          KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+          krm_releaseWeightArrays();
+          return( KernelErrorCode );
+        }
+
+	descrFFnet.layers[dest_layer].inputs[src_layer].weight_array = 
+	    weight_array;
+      }
+    }
+
+  NoOfWeights = descrFFnet.no_of_weights;
+  return( KernelErrorCode );
+}
+
+#endif
+#endif
+
+
+
+/*#################################################
+
+GROUP: Memory cleanup
+
+#################################################*/
+/*****************************************************************************
+  FUNCTION :  krm_releaseMem
+
+  PURPOSE  :  frees all memory used for the internal representation of the 
+              network
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+void    krm_releaseMem(void)
+{
+#ifdef MASPAR_KERNEL
+#ifdef MASPAR_KERNEL_EMULATION
+
+  if (specialNetworkType == NET_TYPE_FF1)
+    krm_releaseWeightArrays();
+
+#endif
+#endif
+
+  specialNetworkType = NET_TYPE_GENERAL;
+  krm_releaseFtypeList();
+  krm_releaseSTableArrays();
+  krm_releaseNTableArrays();
+  krm_releaseLinkArrays();
+  krm_releaseSiteArrays();
+  krm_releaseUnitArrays();
+  krm_releaseUnitTopoArray();
+
+
+  if (transTable != NULL)  {
+    free( (void *) transTable );
+    transTable = NULL;
+    transTableSize = 0;
+  }
+
+
+}
+
+
+/*  ---------------------  End of Memory Management Functions  -------------  */
+
+/*  ---------------------    Begin Enzo Interface Functions   -------------  */
+#ifdef __ENZO__
+/*****************************************************************************
+  FUNCTION : krm_getNet
+
+  PURPOSE  : Receiving a network from the Enzo network manager modul
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void krm_getNet( memNet *n )
+{                              /* the patterns stay untouched! */
+    char *afunc, *ofunc;
+    
+    strcpy(n->update_func, krui_getUpdateFunc());
+    strcpy(n->learn_func,  krui_getLearnFunc());
+    strcpy(n->init_func,   krui_getInitialisationFunc());
+    
+    kr_getUnitDefaults( &n->u_act, &n->u_bias, &n->u_ttflags,
+		        &n->u_subnet_no, &n->u_layer_no,
+			&afunc, &ofunc                         );
+
+    strcpy( n->u_act_func, afunc );
+    strcpy( n->u_out_func, ofunc );
+
+    n->NoOfLinks   = NoOfLinks;
+    n->NoOfAllocLinks  = NoOfAllocLinks;
+    n->link_array  = link_array;
+    n->link_block_list   = link_block_list;
+    n->free_link_ptr   = free_link_ptr;
+    
+    n->NoOfSites   = NoOfSites;
+    n->NoOfNetSites  = NoOfNetSites;
+    n->NoOfAllocSites  = NoOfAllocSites;
+    n->site_array  = site_array;
+    n->site_block_list   = site_block_list;
+    n->free_site_ptr   = free_site_ptr;
+    n->site_array  = site_array;
+
+
+    n->NoOfAllocUnits  = NoOfAllocUnits;
+    n->FreeUnitIndex   = FreeUnitIndex;
+    n->NoOfUnits   = NoOfUnits;
+    n->NoOfInputUnits  = NoOfInputUnits;
+    n->NoOfOutputUnits   = NoOfOutputUnits;
+    n->NoOfHiddenUnits   = NoOfHiddenUnits;
+    n->MaxUnitNo   = MaxUnitNo;
+    n->MinUnitNo   = MinUnitNo;
+    n->unit_array  = unit_array;
+
+    n->topo_ptr_array  = topo_ptr_array;
+    
+    n->NoOfNTableEntries   = NoOfNTableEntries;
+    n->NoOfAllocNTableEntries  = NoOfAllocNTableEntries;
+    n->NTable_array  = NTable_array;
+    n->NTable_block_list   = NTable_block_list;
+    n->free_NTable_entry   = free_NTable_entry;
+    n->NTable_array  = NTable_array;
+    
+    n->NoOfSTableEntries   = NoOfSTableEntries;
+    n->NoOfAllocSTableEntries  = NoOfAllocSTableEntries;
+    n->STable_array  = STable_array;
+    n->STable_block_list   = STable_block_list;
+    n->free_STable_entry   = free_STable_entry;
+    n->STable_array  = STable_array;
+    
+    n->Ftype_list_root   = Ftype_list_root;
+    n->NoOfFTableEntries   = NoOfFTableEntries;
+
+
+
+    n->curr_Ftype_entry = curr_Ftype_entry;
+    n->curr_STable_entry = curr_STable_entry;
+    n->curr_STable_block = curr_STable_block;
+    n->curr_NTable_entry = curr_NTable_entry;
+    n->curr_NTable_block = curr_NTable_block;
+    n->NetModified =  NetModified;
+    n->NetInitialize = NetInitialize;
+    n->LearnFuncHasChanged = LearnFuncHasChanged;
+    n->unitPtr =  unitPtr;
+    n->sitePtr = sitePtr;
+    n->prevSitePtr = prevSitePtr;
+    n->linkPtr = linkPtr;
+    n->prevLinkPtr = prevLinkPtr;
+    n->unitNo = unitNo;
+    n->specialNetworkType = specialNetworkType;
+    n->TopoSortID = TopoSortID;
+    n->no_of_topo_units = no_of_topo_units;
+    
+    /* treat this just as the net would have been deleted */
+
+    NoOfLinks   = 0;
+    NoOfAllocLinks  = 0;
+    link_array  = NULL;
+    link_block_list   = NULL;
+    free_link_ptr   = NULL;
+    
+    NoOfSites   = 0;
+    NoOfNetSites  = 0;
+    NoOfAllocSites  = 0;
+    site_array  = NULL;
+    site_block_list   = NULL;
+    free_site_ptr   = NULL;
+    
+    NoOfAllocUnits  = 0;
+    FreeUnitIndex   = 0;
+    NoOfUnits   = 0;
+    NoOfInputUnits  = 0;
+    NoOfOutputUnits   = 0;
+    NoOfHiddenUnits   = 0;
+    MaxUnitNo   = 0;
+    unit_array  = NULL;
+
+    topo_ptr_array  = NULL; 
+    
+    NoOfNTableEntries   = 0;
+    NoOfAllocNTableEntries  = 0;
+    NTable_array  = NULL;
+    NTable_block_list   = NULL;
+    free_NTable_entry   = NULL;
+    NTable_array  = NULL;
+    
+    NoOfSTableEntries   = 0;
+    NoOfAllocSTableEntries  = 0;
+    STable_array  = NULL;
+    STable_block_list   = NULL;
+    free_STable_entry   = NULL;
+    
+    Ftype_list_root   = NULL;
+    NoOfFTableEntries   = 0;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krm_putNet
+
+  PURPOSE  : Putting a network back under the control of the Enzo network 
+             manager modul
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void krm_putNet( memNet *n )
+{
+    
+    krm_releaseFtypeList();
+    krm_releaseSTableArrays();
+    krm_releaseNTableArrays();
+    krm_releaseLinkArrays();
+    krm_releaseSiteArrays();
+    krm_releaseUnitArrays();
+
+    
+    krui_setUpdateFunc( n->update_func );
+    krui_setLearnFunc( n->learn_func );
+    krui_setInitialisationFunc( n->init_func );
+
+    kr_setUnitDefaults( n->u_act, n->u_bias, n->u_ttflags,
+		        n->u_subnet_no, n->u_layer_no,
+		        n->u_act_func, n->u_out_func       );
+
+    NoOfLinks   = n->NoOfLinks;
+    NoOfAllocLinks  = n->NoOfAllocLinks;
+    link_array  = n->link_array;
+    link_block_list   = n->link_block_list;
+    free_link_ptr   = n->free_link_ptr;
+    
+    NoOfSites   = n->NoOfSites;
+    NoOfNetSites  = n->NoOfNetSites;
+    NoOfAllocSites  = n->NoOfAllocSites;
+    site_array  = n->site_array;
+    site_block_list   = n->site_block_list;
+    free_site_ptr   = n->free_site_ptr;
+    site_array  = n->site_array;
+
+    NoOfAllocUnits  = n->NoOfAllocUnits;
+    FreeUnitIndex   = n->FreeUnitIndex;
+    NoOfUnits   = n->NoOfUnits;
+    NoOfInputUnits  = n->NoOfInputUnits;
+    NoOfOutputUnits   = n->NoOfOutputUnits;
+    NoOfHiddenUnits   = n->NoOfHiddenUnits;
+    MinUnitNo   = n->MinUnitNo;
+    MaxUnitNo   = n->MaxUnitNo;
+    unit_array  = n->unit_array;
+    
+    topo_ptr_array  = n->topo_ptr_array;
+    
+    NoOfNTableEntries   = n->NoOfNTableEntries;
+    NoOfAllocNTableEntries  = n->NoOfAllocNTableEntries;
+    NTable_array  = n->NTable_array;
+    NTable_block_list   = n->NTable_block_list;
+    free_NTable_entry   = n->free_NTable_entry;
+    NTable_array  = n->NTable_array;
+    
+    NoOfSTableEntries   = n->NoOfSTableEntries;
+    NoOfAllocSTableEntries  = n->NoOfAllocSTableEntries;
+    STable_array  = n->STable_array;
+    STable_block_list   = n->STable_block_list;
+    free_STable_entry   = n->free_STable_entry;
+    STable_array  = n->STable_array;
+    
+    Ftype_list_root   = n->Ftype_list_root;
+    NoOfFTableEntries   = n->NoOfFTableEntries;
+
+    curr_Ftype_entry = n->curr_Ftype_entry;
+    curr_STable_entry = n->curr_STable_entry;
+    curr_STable_block = n->curr_STable_block;
+    curr_NTable_entry = n->curr_NTable_entry;
+    curr_NTable_block = n->curr_NTable_block;
+    NetModified =  n->NetModified;
+    NetInitialize = n->NetInitialize;
+    LearnFuncHasChanged = n->LearnFuncHasChanged;
+    unitPtr =  n->unitPtr;
+    sitePtr = n->sitePtr;
+    prevSitePtr = n->prevSitePtr;
+    linkPtr = n->linkPtr;
+    prevLinkPtr = n->prevLinkPtr;
+    unitNo = n->unitNo;
+    specialNetworkType = n->specialNetworkType;
+    TopoSortID = n->TopoSortID;
+    no_of_topo_units = n->no_of_topo_units;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krm_getPattern
+
+  PURPOSE  : Receiving a pattern set from the Enzo  manager modul
+
+  RETURNS  : 
+  NOTES    : This is just a dummy function
+
+  UPDATE   : 
+******************************************************************************/
+void krm_getPattern( memPat *p )
+{
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krm_putPattern
+
+  PURPOSE  : Receiving a pattern set back under the control of the Enzo 
+             manager modul
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+void krm_putPattern( memPat *p )
+{
+    static int in[MAX_NO_OF_VAR_I_DIM],out[MAX_NO_OF_VAR_I_DIM];
+
+    krui_setCurrPatSet( p->number );
+    in[0] = 1; /*krui_getNoOfInputUnits();*/
+    in[1] = 1;
+    out[0] = 1; /*krui_getNoOfOutputUnits();*/
+    out[1] = 1;
+    krui_DefTrainSubPat(in, out, in, out,NULL);
+}
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_mem.h snort-2.3.3.new/src/kernel_snns/kr_mem.h
--- snort-2.3.3/src/kernel_snns/kr_mem.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_mem.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,181 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_mem.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Memory Manager Function Prototypes
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 21.2.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.11 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:53 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef  _KR_MEM_DEFINED_
+#define _KR_MEM_DEFINED_
+
+
+
+/*  get one link structure */
+extern struct Link *krm_getLink( void );
+
+/*  release one link structure */
+extern void krm_releaseLink( struct Link * link_ptr);
+
+/*  release the link and all following links */
+extern void krm_releaseAllLinks( struct Link *first_link_ptr );
+
+/*  get one unit-site structure */
+extern struct Site *krm_getSite( void );
+
+/*  release one unit-site structure */
+extern void krm_releaseSite( struct Site *site_ptr );
+
+/*  release the unit-site and all following sites (at this unit) */
+extern void krm_releaseAllSites( struct Site *first_site_ptr );
+
+/*  garbage collection of unit array   */
+extern void  krm_unitArrayGC( void );
+
+/*  allocate the unit array */
+extern krui_err krm_allocUnits( int  N );
+
+/*  get one unit structure */
+extern int krm_getUnit( void );
+
+/*  release unit */
+extern void krm_releaseUnit( int  UnitNo );
+
+/*  get information about memory usage */
+extern void krm_getMemoryManagerInfo( int  *array_size, int info_array[] );
+
+/*  allocate the array for topological sorting of the units in the network */
+extern krui_err  krm_allocUnitTopoArray( int  N );
+
+/*  release the topolocic array */
+extern void  krm_releaseUnitTopoArray( void );
+
+/*  release one name-table entry */
+extern void krm_NTableReleaseEntry( struct NameTable  *NTable_ptr );
+
+/*  Searches for a given symbol and symbol-type in the name table.
+    Returns symbol ptr if symbol was found, NULL otherwise. */
+extern struct NameTable *krm_NTableSymbolSearch( char  *symbol, int  sym_type );
+
+/*  Creates a new symbol in the name-table.   Returns name-table ptr or NULL if
+    memory alloc has failed.  */
+extern struct NameTable *krm_NTableCreateEntry(char  *symbol_name, 
+					       int  symbol_type );
+
+/*  Inserts a symbol in the name-table. This function duplicates symbol ptrs
+    if the symbol was found in the name-table.  Returns symbol ptr or NULL if
+    memory alloc has failed. */
+extern char *krm_NTableInsertSymbol( char  *symbol_name, int  symbol_type );
+
+/*  release name-table entry if there is no other reference to this symbol */
+extern void krm_NTableReleaseSymbol( char  *symbol_name, int  symbol_type );
+
+/*  get the first name-table entry */
+extern struct NameTable *krm_getNTableFirstEntry( void );
+
+/*  get the next name-table entry */
+extern struct NameTable *krm_getNTableNextEntry( void );
+
+/*  create new site-table entry */
+extern struct SiteTable *krm_STableCreateEntry(char  *site_symbol, 
+					       SiteFuncPtr  site_func );
+
+/*  change the properties of the given site-table entry */
+extern struct SiteTable *krm_STableChangeEntry(struct  SiteTable  *stbl_ptr, 
+					       char  *new_site_name,
+                                         SiteFuncPtr  new_site_func );
+
+/*  release a previosly defined site-table entry */
+extern void krm_STableRemoveEntry( struct SiteTable  *STable_ptr );
+
+/*  searches for a symbol in the site-table */
+extern struct SiteTable *krm_STableSymbolSearch( char  *site_symbol );
+
+/*  returns a pointer to the first used site-table entry */
+extern struct SiteTable *krm_getSTableFirstEntry( void );
+
+/*  returns a pointer to the next used site-table entry */
+extern struct SiteTable *krm_getSTableNextEntry( void );
+
+/*  allocate a new Ftype entry */
+extern struct FtypeUnitStruct *krm_getFtypeEntry( void );
+
+/*  free a previosly defined Ftype entry */
+extern void krm_releaseFtypeEntry( struct FtypeUnitStruct  *Ftype_entry );
+
+/*  create and define a Ftype entry
+*/
+extern struct FtypeUnitStruct *krm_FtypeCreateEntry( char *Ftype_symbol, OutFuncPtr out_func, 
+                                              ActFuncPtr act_func, ActDerivFuncPtr act_deriv_func, ActDerivFuncPtr act_2_deriv_func );
+
+/*  add a site to a previosly defined Ftype entry */
+extern struct Site *krm_FtypeAddSite(struct FtypeUnitStruct  *Ftype_entry, 
+				     struct SiteTable  *STable_entry );
+
+/*  returns a pointer to first Ftype entry */
+extern struct FtypeUnitStruct *krm_getFtypeFirstEntry( void );
+
+/*  returns a pointer to next Ftype entry */
+extern struct FtypeUnitStruct *krm_getFtypeNextEntry( void );
+
+/*  searches for a Ftype entry with the given name */
+extern struct FtypeUnitStruct *krm_FtypeSymbolSearch( char  *Ftype_symbol );
+
+/*  releases all Ftype entries */
+extern void krm_releaseFtypeList( void );
+
+/*  free all link arrays */
+extern void  krm_releaseLinkArrays( void );
+
+
+/*  Functions for the MasPar kernel  */
+#ifdef MASPAR_KERNEL
+#ifdef MASPAR_KERNEL_EMULATION
+
+/*  release weight arrays from memory */
+extern void  krm_releaseWeightArrays( void );
+
+/*  creates arrays containing connection weights for feedforward networks */
+extern krui_err  krm_createWeightArrays( void );
+
+#endif
+#endif
+
+/*  frees all memory used for the internal representation of the network */
+extern void krm_releaseMem( void );
+
+/* Functions for the Enzo interface */
+#ifdef __ENZO__
+#include "enzo_mem_typ.h"
+
+extern void krm_getNet( memNet *n );
+extern void krm_putNet( memNet *n );
+extern void krm_getPattern( memPat *p );
+extern void krm_putPattern( memPat *p );
+#endif
+
+
+
+
+
+/*#################################################
+
+GROUP: Global Var's (as declared by the Memory Manager)
+
+#################################################*/
+
+extern int  NoOfAllocPatternPairs;  /*  no. of allocated pattern pairs  */
+
+#endif 
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_mem.ph snort-2.3.3.new/src/kernel_snns/kr_mem.ph
--- snort-2.3.3/src/kernel_snns/kr_mem.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_mem.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,267 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_mem.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel Memory Manager Function Prototypes
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 21.2.90
+ 
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.14 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:53 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef  _KR_MEM_DEFINED_
+#define _KR_MEM_DEFINED_
+
+/* begin global definition section */
+
+
+/*  get one link structure */
+struct Link *krm_getLink( void );
+
+/*  release one link structure */
+void krm_releaseLink( struct Link * link_ptr);
+
+/*  release the link and all following links */
+void krm_releaseAllLinks( struct Link *first_link_ptr );
+
+/*  get one unit-site structure */
+struct Site *krm_getSite( void );
+
+/*  release one unit-site structure */
+void krm_releaseSite( struct Site *site_ptr );
+
+/*  release the unit-site and all following sites (at this unit) */
+void krm_releaseAllSites( struct Site *first_site_ptr );
+
+/*  garbage collection of unit array */
+void  krm_unitArrayGC( void );
+
+/*  allocate the unit array */
+krui_err krm_allocUnits( int  N );
+
+/*  get one unit structure */
+int krm_getUnit( void );
+
+/*  release unit */
+void krm_releaseUnit( int  UnitNo );
+
+/*  get information about memory usage */
+void krm_getMemoryManagerInfo( int  *array_size, int info_array[] );
+
+/*  allocate the array for topological sorting of the units in the network */
+krui_err  krm_allocUnitTopoArray( int  N );
+
+/*  release the topolocic array */
+void  krm_releaseUnitTopoArray( void );
+
+/*  release one name-table entry */
+void krm_NTableReleaseEntry( struct NameTable  *NTable_ptr );
+
+/*  Searches for a given symbol and symbol-type in the name table.
+    Returns symbol ptr if symbol was found, NULL otherwise. */
+struct NameTable *krm_NTableSymbolSearch( char  *symbol, int  sym_type );
+
+/*  Creates a new symbol in the name-table.   Returns name-table ptr or NULL if
+    memory alloc has failed. */
+struct NameTable *krm_NTableCreateEntry( char  *symbol_name, int  symbol_type );
+
+/*  Inserts a symbol in the name-table. This function duplicates symbol ptrs
+    if the symbol was found in the name-table.  Returns symbol ptr or NULL if
+    memory alloc has failed. */
+char *krm_NTableInsertSymbol( char  *symbol_name, int  symbol_type );
+
+/*  release name-table entry if there is no other reference to this symbol */
+void krm_NTableReleaseSymbol( char  *symbol_name, int  symbol_type );
+
+/*  get the first name-table entry */
+struct NameTable *krm_getNTableFirstEntry( void );
+
+/*  get the next name-table entry */
+struct NameTable *krm_getNTableNextEntry( void );
+
+/*  create new site-table entry */
+struct SiteTable *krm_STableCreateEntry( char  *site_symbol, SiteFuncPtr  site_func );
+
+/*  change the properties of the given site-table entry */
+struct SiteTable *krm_STableChangeEntry(struct  SiteTable  *stbl_ptr, 
+					char  *new_site_name,
+                                         SiteFuncPtr  new_site_func );
+
+/*  release a previosly defined site-table entry */
+void krm_STableRemoveEntry( struct SiteTable  *STable_ptr );
+
+/*  searches for a symbol in the site-table */
+struct SiteTable *krm_STableSymbolSearch( char  *site_symbol );
+
+/*  returns a pointer to the first used site-table entry */
+struct SiteTable *krm_getSTableFirstEntry( void );
+
+/*  returns a pointer to the next used site-table entry */
+struct SiteTable *krm_getSTableNextEntry( void );
+
+/*  allocate a new Ftype entry */
+struct FtypeUnitStruct *krm_getFtypeEntry( void );
+
+/*  free a previosly defined Ftype entry */
+void krm_releaseFtypeEntry( struct FtypeUnitStruct  *Ftype_entry );
+
+/*  create and define a Ftype entry
+*/
+struct FtypeUnitStruct *krm_FtypeCreateEntry( char *Ftype_symbol, OutFuncPtr out_func, 
+                                              ActFuncPtr act_func, ActDerivFuncPtr act_deriv_func, ActDerivFuncPtr act_2_deriv_func );
+
+/*  add a site to a previosly defined Ftype entry */
+struct Site *krm_FtypeAddSite(struct FtypeUnitStruct  *Ftype_entry, 
+			      struct SiteTable  *STable_entry );
+
+/*  returns a pointer to first Ftype entry */
+struct FtypeUnitStruct *krm_getFtypeFirstEntry( void );
+
+/*  returns a pointer to next Ftype entry */
+struct FtypeUnitStruct *krm_getFtypeNextEntry( void );
+
+/*  searches for a Ftype entry with the given name */
+struct FtypeUnitStruct *krm_FtypeSymbolSearch( char  *Ftype_symbol );
+
+/*  releases all Ftype entries */
+void krm_releaseFtypeList( void );
+
+/*  free all link arrays */
+void  krm_releaseLinkArrays( void );
+
+
+/*  Functions for the MasPar kernel  */
+#ifdef MASPAR_KERNEL
+#ifdef MASPAR_KERNEL_EMULATION
+
+/*  release weight arrays from memory */
+void  krm_releaseWeightArrays( void );
+
+/*  creates arrays containing connection weights for feedforward networks */
+krui_err  krm_createWeightArrays( void );
+
+#endif
+#endif
+
+/*  frees all memory used for the internal representation of the network */
+void krm_releaseMem( void );
+
+/* Functions for the Enzo interface */
+#ifdef __ENZO__
+#include "enzo_mem_typ.h"
+
+void krm_getNet( memNet *n );
+void krm_putNet( memNet *n );
+void krm_getPattern( memPat *p );
+void krm_putPattern( memPat *p );
+#endif
+
+
+extern struct TransTable  *transTable;
+extern int transTableSize;
+
+
+
+
+/*#################################################
+
+GROUP: Global Var's (as declared by the Memory Manager)
+
+#################################################*/
+
+int  NoOfAllocPatternPairs = 0;  /*  no. of allocated pattern pairs  */
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+
+/*#################################################
+
+GROUP: Local Var's
+
+#################################################*/
+
+static int  FreeUnitIndex  = 0, /* no. of the next free unit in the unit array*/
+	    NoOfAllocUnits = 0,  /*  no. of allocated units  */
+	    NoOfSites	   = 0, /* no. of used sites in the network and Ftype 
+				   sites (including sites for functionality 
+				   type use only) */
+	    NoOfNetSites   = 0, /* no. of used sites in the network (only unit 
+				   sites)  */
+	    NoOfAllocSites = 0,  /*  no. of allocated sites  */
+	    NoOfLinks	   = 0,  /*  no. of links used for the network	*/
+	    NoOfAllocLinks = 0,  /*  no. of allocated links  */
+	    NoOfNTableEntries	    = 0, /*no. of name table entries  */
+	    NoOfAllocNTableEntries  = 0, /*no. of allocated name table entries*/
+	    NoOfSTableEntries	    = 0, /*no. of site table entries  */
+	    NoOfAllocSTableEntries  = 0, /*no. of allocated site table entries*/
+	    NoOfFTableEntries	    = 0; /*no. of functionality types  */
+
+static SiteArray    
+            site_array        = NULL,  /*  pointer to first site array  */
+		       free_site_ptr	 = NULL,  /*  pointer to first free site  */
+		       site_block_list	 = NULL;  /*  pointer to first free site block */
+
+static LinkArray       
+            link_array        = NULL,  /*  pointer to first link array  */
+		       free_link_ptr	 = NULL,  /*  pointer to first free link  */
+		       link_block_list	 = NULL;  /*  pointer to first free link block */
+
+
+static NTableArray  
+            NTable_array      = NULL,  /* pointer to name table  */
+	    free_NTable_entry = NULL,  /* ptr to first free name table entry  */
+	    NTable_block_list = NULL,  /* ptr to first free name table block  */
+		       curr_NTable_entry = NULL,  /*  pointer to current name table entry  */
+		       curr_NTable_block = NULL;  /*  pointer to current name table block  */
+
+
+static STableArray  
+            STable_array      = NULL,  /* pointer to site table  */
+            free_STable_entry = NULL,  /* ptr to first free site table entry  */
+	    STable_block_list = NULL,  /* ptr to first free site table block  */
+		       curr_STable_entry = NULL,  /*  pointer to current name site entry  */
+		       curr_STable_block = NULL;  /*  pointer to current name site block  */
+
+
+static struct FtypeUnitStruct  
+            *Ftype_list_root  = NULL,  /*  pointer to root of the Ftype list  */
+			       *curr_Ftype_entry = NULL;  /*  pointer to current Ftype entry  */
+
+
+static  int     krm_allocLinks(int N);
+static  int     krm_allocSites(int N);
+static struct Site  *krm_getFtypeSite(void);
+
+/* Future Use: release one Ftype-site structure */
+/*static void    krm_releaseFtypeSite(struct Site *site_ptr ); */
+
+static void    krm_releaseAllFtypeSites(struct Site *first_site_ptr);
+static  void    krm_releaseSiteArrays(void);
+static  void    krm_relocateLinkPtrs(int offset);
+static	void	krm_releaseUnitArrays(void);
+static  int     krm_allocNTableArray(void);
+static struct NameTable  *krm_getNTableEntry(void);
+static void  krm_releaseNTableArrays(void);
+static int  krm_allocSTableArray(void);
+static int  krm_allocSTableArray(void);
+static  struct SiteTable    *krm_getSTableEntry(void);
+static  void    krm_releaseSTableEntry(struct SiteTable *STable_ptr);
+static  void    krm_releaseSTableArrays(void);
+static struct SiteTable       *krm_getSTableNextRawEntry(void);
+
+
+/* end private definition section */
+
+#endif 
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_newpattern.c snort-2.3.3.new/src/kernel_snns/kr_newpattern.c
--- snort-2.3.3/src/kernel_snns/kr_newpattern.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_newpattern.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,4594 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_newpattern.c,v $
+  SHORTNAME      : newpattern
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : handling of new pattern files;
+  NOTES          :
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.28 $
+  LAST CHANGE    : $Date: 1998/05/20 09:36:18 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef NeXT
+#ifdef HAVE_SYS_FILE_H
+#include <sys/file.h>
+#endif
+#else
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#endif
+#include <string.h>
+#include <time.h>
+#include <sys/types.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#include "kr_typ.h"
+#include "glob_typ.h"
+#include "kr_mac.h"
+
+#ifndef rand
+#include "random.h"      /*  Randomize Library Function Prototypes  */
+#endif
+
+#include "kernel.h"
+#include "kr_const.h"
+#include "kr_funcs.h"
+/* for dlvq */
+#include "dlvq_learn.h"
+#include "kr_newpattern.ph"
+#include "kr_pat_scan.h"
+#include "kr_pat_parse.h"
+
+
+#ifndef __GNUC__
+#ifndef __FUNCTION__
+#define __FUNCTION__ "(unknown function)"
+#endif
+#endif
+
+#if defined(DEBUG_PATTERN) && defined(TRACE_PATTERN)
+static _t_indent = 0;
+#define TRACE_IN(); \
+{ \
+    int _i; \
+    if (_t_indent == 0) printf("\n"); \
+    for (_i=0; _i<_t_indent; _i++) \
+	printf(" "); \
+    printf("%s\n", __FUNCTION__); \
+    _t_indent += 2; \
+}
+#define TRACE_RETURN(x) \
+{ \
+    long _t_tmp; \
+    int _i; \
+    _t_tmp = (x); \
+    _t_indent -= 2; \
+    for (_i=0; _i<_t_indent; _i++) \
+	printf(" "); \
+    printf("<- %ld\n", _t_tmp); \
+    return(_t_tmp); \
+}
+#define TRACE_RETURN_VOID() \
+{ \
+    _t_indent -= 2; \
+    return; \
+}
+#define TRACE_INDENT() \
+{ \
+    int _i; \
+    for (_i=0; _i<_t_indent-2; _i++) \
+	printf(" "); \
+} 
+#else
+#define TRACE_IN()
+#define TRACE_RETURN(x) return(x)
+#define TRACE_RETURN_VOID() return
+#define TRACE_INDENT()
+#endif
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE KERNEL USER INTERFACE TO PERFORM
+ THE KERNEL INTERFACE OF THE NEW PATTERN MANAGEMENT
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : kr_npui_setCurrPatSet
+
+  PURPOSE  : determines the number of the current pattern set (in
+             kernel terminology) numbering starts with 0
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_setCurrPatSet(int number)
+{
+    TRACE_IN();
+
+    if (number<0 || number>=npui_number_pat_sets)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    npui_curr_pat_set = number;
+    npui_curr_pattern = 1;
+    npui_train_defined = FALSE;
+    npui_show_defined = FALSE;
+    np_abs_count_valid = FALSE;
+    np_sub_pat_sizes_valid = FALSE;
+    np_pat_mapping_valid = FALSE;
+    
+    /* for dlvq */
+    newPatternsLoaded = 1;
+
+    TRACE_RETURN(kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]));
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_deletePatSet
+
+  PURPOSE  : deletes the specified pattern set from memory and
+             undefines the current pattern set, pattern, training
+	     scheme and display scheme
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_deletePatSet(int number)
+{
+    int i;
+    int pat_set;
+
+    TRACE_IN();
+
+    if (number<0 || number>=npui_number_pat_sets)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    pat_set = npui_pat_sets[number];
+
+    for (i=number; i<npui_number_pat_sets-1; i++)
+	npui_pat_sets[i] = npui_pat_sets[i+1];
+    npui_number_pat_sets--;
+    npui_curr_pat_set = -1;
+    npui_curr_pattern = -1;
+    npui_train_defined = FALSE;
+    npui_show_defined = FALSE;
+    np_abs_count_valid = FALSE;
+    np_sub_pat_sizes_valid = FALSE;
+    np_pat_mapping_valid = FALSE;
+    
+    TRACE_RETURN(kr_np_DeletePatternSet(pat_set));
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_GetPatInfo
+
+  PURPOSE  : retrieves all available information concerning the
+             current pattern set and the current pattern which both
+	     must be defined. The given parameter fields are filled
+	     with the information.
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_GetPatInfo(pattern_set_info *set_info, 
+                            pattern_descriptor *pat_info)
+{
+    np_pattern_set_info int_pat_set_info;
+    np_pattern_descriptor *int_pat_info;
+    krui_err err_code;
+
+    TRACE_IN();
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    err_code = kr_np_GetInfo(npui_pat_sets[npui_curr_pat_set],
+			     &int_pat_set_info);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    *set_info = int_pat_set_info.pub;
+
+    err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		   kr_np_virtual_to_physical(npui_curr_pattern-1),
+		   &int_pat_info);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    *pat_info = int_pat_info->pub;
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_DefShowSubPat
+
+  PURPOSE  : Define the display scheme:
+             Size and position of a sub pattern for the current
+             pattern in the current pattern set is defined. <insize>
+	     is a pointer to an array of integer values which define
+	     the dimensional sizes of the input sub pattern. <inpos>
+	     is a pointer to an array of integer values which defines
+	     the offset (position) of this sub pattern inside the
+	     pattern. <outsize> and <outpos> are used to define the
+	     respective output sub pattern 
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_DefShowSubPat(int *insize, int *outsize, 
+                               int *inpos, int *outpos)
+{
+    krui_err err_code;
+    np_pattern_descriptor *pattern;
+    int i;
+
+    TRACE_IN();
+
+    npui_show_defined = FALSE;
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		   kr_np_virtual_to_physical(npui_curr_pattern-1),
+		   &pattern);
+
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    for (i=0; i<pattern->pub.input_dim; i++)
+    {
+	if ((pattern->pub.input_dim_sizes)[i] < insize[i] + inpos[i] - 1)
+	    err_code = KRERR_NP_DIMENSION;
+    }
+    for (i=0; i<pattern->pub.output_dim; i++)
+    {
+	if ((pattern->pub.output_dim_sizes)[i] < outsize[i] + outpos[i] - 1)
+	    err_code = KRERR_NP_DIMENSION;
+    }
+
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    memcpy(npui_insize, insize, MAX_NO_OF_VAR_DIM * sizeof(int));
+    memcpy(npui_outsize, outsize, MAX_NO_OF_VAR_DIM * sizeof(int));
+    memcpy(npui_inpos, inpos, MAX_NO_OF_VAR_DIM * sizeof(int));
+    memcpy(npui_outpos, outpos, MAX_NO_OF_VAR_DIM * sizeof(int));
+    for (i=0; i<MAX_NO_OF_VAR_DIM; i++)
+    {
+	npui_inpos[i]--;
+	npui_outpos[i]--;
+    }
+
+    npui_show_defined = TRUE;
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_DefTrainSubPat
+
+  PURPOSE  : Define the training scheme:
+             Size and step size of sub pattern for the current pattern
+             in the current pattern set is defined for training and
+	     testing. <insize> is a pointer to an array of integer
+	     values which define the dimensional sizes of the input sub
+	     pattern. <instep> is a pointer to an array of integer
+	     values which defines the step size which is used to move
+	     the sub pattern over the pattern.
+             <outsize> and <outpos> are used to define the respective
+	     output sub pattern. 
+             <max_n_pos> (if not NULL) returns the number of valid
+	     input sub pattern positions for the current pattern and
+	     the given training scheme.
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_DefTrainSubPat(int *insize, int *outsize, 
+                                int *instep, int *outstep, int *max_n_pos)
+{
+    krui_err err_code;
+    int n;
+    np_pattern_descriptor *p;
+    int changes = 0;
+
+    TRACE_IN();
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    if (npui_train_defined)
+    {
+	for (n=0; n<MAX_NO_OF_VAR_DIM && changes==0; n++)
+	    if (npui_insize[n] != insize[n] ||
+		npui_outsize[n] != outsize[n] ||
+		npui_instep[n] != instep[n] ||
+		npui_outstep[n] != outstep[n])
+		changes++;
+    }
+
+    if (!npui_train_defined  || changes != 0)
+    {
+	npui_train_defined = FALSE;
+	np_abs_count_valid = FALSE;
+	np_sub_pat_sizes_valid = FALSE;
+
+	memcpy(npui_insize, insize, MAX_NO_OF_VAR_DIM * sizeof(int));
+	memcpy(npui_outsize, outsize, MAX_NO_OF_VAR_DIM * sizeof(int));
+	memcpy(npui_instep, instep, MAX_NO_OF_VAR_DIM * sizeof(int));
+	memcpy(npui_outstep, outstep, MAX_NO_OF_VAR_DIM * sizeof(int));
+	
+	err_code = 
+	    kr_np_DefineSubPatternOrdering(npui_pat_sets[npui_curr_pat_set],
+					   TRUE, npui_insize, npui_instep);
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+
+	err_code = 
+	    kr_np_DefineSubPatternOrdering(npui_pat_sets[npui_curr_pat_set],
+					   FALSE, npui_outsize,
+					   npui_outstep);
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+
+	npui_train_defined = TRUE;
+
+	err_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+    }
+
+    if (max_n_pos != (int *) NULL)
+    {
+	err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		       kr_np_virtual_to_physical(npui_curr_pattern-1), &p);
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+
+	if (!kr_np_gen_sub_pos(p->pub.input_dim, &n, p->pub.input_dim_sizes, 
+			       npui_insize, npui_instep, (int *) NULL, 
+			       TRUE))
+	    { TRACE_RETURN(KRERR_NP_DIMENSION); }
+	*max_n_pos = n;
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_npui_AlignSubPat
+
+  PURPOSE  : Align the position of a sub pattern:
+             Using the current training scheme and the current pattern
+	     of the current pattern set, the given position of an
+	     input sub pattern <inpos> and the given position of the
+	     corresponding output sub pattern <outpos> is aligned to fit
+	     the currently defined training scheme.
+	     E.g. if the training scheme defines a step width of 5 for
+	     a specific dimension, only the positions 0, 5, 10, 15 ...
+	     are valid positions for a sub pattern.
+	     The position of each dimension is aligned independently
+	     from all other dimensions by moving to the next valid
+	     position which is lower or equal to the given position.
+             <no> (if not NULL) returns the number of the sub pattern
+	     which corresponds to the new aligned position which is
+	     returned in place (<inpos> <outpos>).
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_AlignSubPat(int *inpos, int *outpos, int *no)
+{
+    krui_err err_code;
+    np_pattern_descriptor *p;
+    int pos;
+    int i;
+
+    TRACE_IN();
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    if (npui_train_defined == FALSE)
+	{ TRACE_RETURN(KRERR_NP_NO_TRAIN_SCHEME); }
+
+    err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		   kr_np_virtual_to_physical(npui_curr_pattern-1), &p);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    /* enumeration starts with 0, not with 1 */
+    for (i=0; i< p->pub.input_dim; i++)
+	inpos[i] -= 1;
+
+    /* align the position of the input sub pattern */
+    if (!kr_np_align_sub_pos(p->pub.input_dim, &pos, 
+			     p->pub.input_dim_sizes, npui_insize, 
+			     npui_instep, inpos))
+    {
+	for (i=0; i< p->pub.input_dim; i++)
+	    inpos[i] = 1;
+	{ TRACE_RETURN(KRERR_NP_DIMENSION); }
+    }
+
+    /* now enumeration starts with 1 again */
+    for (i=0; i< p->pub.input_dim; i++)
+	inpos[i] += 1;
+
+    /* find the output sub pattern which is related to the aligned */
+    /* input sub pattern */
+    if (!kr_np_gen_sub_pos(p->pub.output_dim, &pos, 
+			   p->pub.output_dim_sizes, npui_outsize, 
+			   npui_outstep, outpos, FALSE))
+    {
+	for (i=0; i< p->pub.output_dim; i++)
+	    outpos[i] = 1;
+	{ TRACE_RETURN(KRERR_NP_DIMENSION); }
+    }
+
+    /* now enumeration starts with 1 again */
+    for (i=0; i< p->pub.output_dim; i++)
+	outpos[i] += 1;
+
+    /* return the absolute position */
+    *no = pos+1;
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_allocNewPatternSet
+
+  PURPOSE : Allocate an (additional) empty pattern set: A new pattern
+  set is allocated if the maximum number of loaded pattern sets
+  (NO_OF_PAT_SETS) is not exceeded. The corresponding pattern set
+  handle is returned in <set_no>.  The new allocated pattern set
+  becomes the current set.  There is no current pattern defined.
+  Training scheme and display scheme both become undefined.
+
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_allocNewPatternSet(int *set_no)
+{
+    int pat_set;
+    krui_err err_code;
+
+    TRACE_IN();
+
+    if (npui_number_pat_sets >= NO_OF_PAT_SETS)
+	{ TRACE_RETURN(KRERR_NP_NO_MORE_ENTRIES); }
+
+    /* allocate pattern set with zero pattern */
+    err_code = kr_np_AllocatePatternSet(&pat_set, 0);
+    if (err_code == KRERR_NO_ERROR)
+    {
+	npui_curr_pat_set = npui_number_pat_sets;
+	npui_number_pat_sets++;
+	npui_curr_pattern = -1;
+	npui_pat_sets[npui_curr_pat_set] = pat_set;
+	*set_no = npui_curr_pat_set;
+	npui_train_defined = FALSE;
+	npui_show_defined = FALSE;
+	np_abs_count_valid = FALSE;
+	np_sub_pat_sizes_valid = FALSE;
+	np_pat_mapping_valid = FALSE;
+	np_info_valid[pat_set] = FALSE;
+	err_code = kr_np_ValidateInfo(pat_set);
+    }
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_loadNewPatterns
+
+  PURPOSE  : Load an (additional) pattern file:
+             The file with name <filename> is loaded into memory if
+	     existent and if the maximum number of loaded pattern sets
+	     (NO_OF_PAT_SETS) is not exceeded. The corresponding
+	     pattern set handle is returned in <set_no>.
+
+	     The new loaded pattern set becomes the current set. The
+	     first pattern inside this set becomes the current
+	     pattern. Training scheme and display scheme both become
+	     undefined.
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_loadNewPatterns(char *filename, int *set_no)
+{
+    FILE *infile;
+    int pat_set;
+    int read_from_pipe = 0;
+    char *buf;
+    krui_err err_code;
+
+    TRACE_IN();
+
+    if (npui_number_pat_sets >= NO_OF_PAT_SETS)
+	{ TRACE_RETURN(KRERR_NP_NO_MORE_ENTRIES); }
+
+    if (access(filename, F_OK) != 0)
+	{ TRACE_RETURN(KRERR_FILE_OPEN); }
+    if (strcmp(&filename[strlen(filename)-2], ".Z") == 0)
+    {
+	buf = (char *) malloc(strlen(filename)+strlen("zcat ")+1);
+	if (buf == (char *) NULL)
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	sprintf(buf, "zcat %s", filename);
+	infile = popen(buf,"r");
+	read_from_pipe = 1;
+    }
+    else if (strcmp(&filename[strlen(filename)-3], ".gz") == 0)
+    {
+	buf = (char *) malloc(strlen(filename)+strlen("gunzip -c ")+1);
+	if (buf == (char *) NULL)
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	sprintf(buf, "gunzip -c %s", filename);
+	infile = popen(buf,"r");
+	read_from_pipe = 1;
+    }
+    else
+	infile = fopen(filename, "r");
+    if (infile == (FILE *) NULL)
+	{ TRACE_RETURN(KRERR_FILE_OPEN); }
+
+    err_code = kr_np_LoadPatternFile(infile, &pat_set);
+    if (err_code == KRERR_NO_ERROR)
+    {
+	/* for dlvq */
+	newPatternsLoaded = 1;
+	
+	npui_curr_pat_set = npui_number_pat_sets;
+	npui_number_pat_sets++;
+	npui_curr_pattern = 1;
+	npui_pat_sets[npui_curr_pat_set] = pat_set;
+	*set_no = npui_curr_pat_set;
+	npui_train_defined = FALSE;
+	npui_show_defined = FALSE;
+	np_abs_count_valid = FALSE;
+	np_sub_pat_sizes_valid = FALSE;
+	np_pat_mapping_valid = FALSE;
+	np_info_valid[pat_set] = FALSE;
+	err_code = kr_np_ValidateInfo(pat_set);
+    }
+
+    if (read_from_pipe)
+    {
+	pclose(infile);
+	free(buf);
+    }
+    else
+	fclose(infile);
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_saveNewPatterns
+
+  PURPOSE  : The given pattern set <set_no> is written to file
+             <filename> in new style format. No side effects.
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_saveNewPatterns(char *filename, int set_no)
+{
+    FILE *outfile;
+    krui_err err_code;
+
+    TRACE_IN();
+
+    if (set_no<0 || set_no>=npui_number_pat_sets)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    outfile = fopen(filename, "w");
+    if (outfile == (FILE *) NULL)
+	{ TRACE_RETURN(KRERR_FILE_OPEN); }
+
+    err_code = kr_np_SavePatternFile(outfile, npui_pat_sets[set_no]);
+
+    fclose(outfile);
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_GetShapeOfSubPat
+
+  PURPOSE  : Get the shape of a sub pattern which is specified by a
+             number:
+             After kr_npui_DefTrainSubPat has been called for the
+	     current pattern set and a current pattern is defined,
+	     this function retrieves the <n_pos>th valid sub pattern
+	     pair which matches the defined training scheme. Size and
+	     position of the sub pattern pair is returned in <insize>
+	     <inpos> <outsize> and <outpos> which are all pointer to
+	     integer arrays.
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_GetShapeOfSubPat(int *insize, int *outsize, 
+                                int *inpos, int *outpos, int n_pos)
+{
+    int sp[MAX_NO_OF_VAR_DIM];
+    np_pattern_descriptor *p;
+    krui_err err_code;
+    int n;
+    int i;
+
+    TRACE_IN();
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    if (!npui_train_defined)
+	{ TRACE_RETURN(KRERR_NP_NO_TRAIN_SCHEME); }
+
+    err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		   kr_np_virtual_to_physical(npui_curr_pattern-1), &p);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    n = n_pos-1;
+    if (!kr_np_gen_sub_pos(p->pub.input_dim, &n, p->pub.input_dim_sizes, 
+			   npui_insize, npui_instep, sp, FALSE))
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN); }
+    
+    memcpy((char *) inpos, (char *) sp, p->pub.input_dim * sizeof(int));
+    for (i=0; i<p->pub.input_dim; i++)
+	inpos[i]++;
+
+    if (!kr_np_gen_sub_pos(p->pub.output_dim, &n, p->pub.output_dim_sizes, 
+			   npui_outsize, npui_outstep, sp, FALSE))
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN); }
+
+    memcpy((char *) outpos, (char *) sp, p->pub.output_dim *sizeof(int));
+    for (i=0; i<p->pub.output_dim; i++)
+	outpos[i]++;
+
+    memcpy((char *) insize, (char *) npui_insize, p->pub.input_dim *sizeof(int));
+    memcpy((char *) outsize, (char *) npui_outsize, p->pub.input_dim *sizeof(int));
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_setRemapFunction
+
+  PURPOSE  : 
+
+Set the remap function for the current pattern set and use the given 
+parameters.
+<name> points to a remap function name, provided by the user interface. The 
+function name is checked and the pointer for this function is looked up in the 
+function table. If no function name is given (NULL pointer) or if the default 
+remaping function is given the default remap function is used 
+(no remaping of patterns occurs). The name of the remap function is stored in
+the pattern set description for future access by the interface.
+<params> points to an array of function parameters of size NO_OF_REMAP_PARAMS
+provided by the user interface. The parameters used for the given remap 
+function are read out of the array and copied to the local pattern set
+description.
+
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_setRemapFunction(char *name, float *params)
+{
+    krui_err err_code = KRERR_NO_ERROR;
+    krui_err err_code_2 = KRERR_NO_ERROR;
+    int pattern_set;
+    int use_default = 0;
+    int i;
+    struct FuncInfoDescriptor func_descr;
+    int has_changed = 0;
+
+    TRACE_IN();
+
+#ifdef DEBUG_REMAP
+    TRACE_INDENT();
+    printf("%s(%s, %s)\n", __FUNCTION__, 
+	   name ? name : "<default>",
+	   params ? "float[]" : "NULL");
+#endif
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    pattern_set = npui_pat_sets[npui_curr_pat_set];
+
+    if (name == NULL)
+	use_default = 1;
+    else
+    {
+	func_descr.func_type = REMAP_FUNC;
+	err_code = krf_getFuncInfo(GET_DEFAULT_FUNC, &func_descr);
+	if (err_code != KRERR_NO_ERROR ||
+	    strcmp(func_descr.func_name, name) == 0)
+	    use_default = 1;
+	else
+	{
+	    func_descr.func_type = REMAP_FUNC;
+	    strcpy(func_descr.func_name, name);
+	    err_code = krf_getFuncInfo(SEARCH_FUNC, &func_descr);
+	    if (err_code == KRERR_NO_ERROR)
+	    {	    
+		if (np_info[pattern_set].rmf_ptr !=
+		    (RemapFuncPtr) func_descr.function)
+		    has_changed++;
+
+		np_info[pattern_set].rmf_ptr = 
+		    (RemapFuncPtr) func_descr.function;
+		for (i=0; i<func_descr.no_of_input_parameters; i++)
+		    np_info[pattern_set].pub.remap_params[i] = params[i];
+		np_info[pattern_set].pub.no_of_remap_params = 
+		    func_descr.no_of_input_parameters;
+		if (np_info[pattern_set].pub.remap_function != NULL)
+		    free(np_info[pattern_set].pub.remap_function);
+		np_info[pattern_set].pub.remap_function = strdup(name);
+		if (np_info[pattern_set].pub.remap_function == NULL)
+		    err_code = KRERR_INSUFFICIENT_MEM;
+	    }
+	    else
+	    {
+		use_default = 1;
+	    }
+	}
+    }
+
+    if (use_default)
+    {
+	if (np_info[pattern_set].rmf_ptr != NULL)
+	    has_changed++;
+	np_info[pattern_set].rmf_ptr = NULL;
+	if (np_info[pattern_set].pub.remap_function != NULL)
+	    free(np_info[pattern_set].pub.remap_function);
+	np_info[pattern_set].pub.remap_function = NULL;		
+	np_info[pattern_set].pub.no_of_remap_params = 0;
+    }
+
+    if (has_changed>0)
+    {
+	/* everything is done already, so I don't have to do this (?): */
+	/*
+	np_info_valid[npui_pat_sets[npui_curr_pat_set]] = FALSE;
+	err_code_2 = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+	*/
+    }
+
+    { TRACE_RETURN(err_code != KRERR_NO_ERROR ? err_code : err_code_2); }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_npui_setClassDistribution
+
+  PURPOSE  : 
+
+Set the class distribution for the current pattern set.
+This function may only be called if the current pattern set provides class 
+information. If <class_sizes> is not NULL it must locate an integer array of 
+size that matches the number of classes in the current set. The values of 
+this array are copied to the pattern set area. If <class_sizes> is the NULL
+pointer, then the real distribution of classes in the pattern set is 
+computed and stored in the class distribution area of the pattern set. So the
+interface may retrieve default values for the class distribution which match
+the real distribution of the pattern set.
+
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_setClassDistribution(unsigned int *class_sizes)
+{
+    int has_changed = 0;
+    krui_err err_code = KRERR_NO_ERROR;
+    struct np_symtab *list;
+    int index;
+    int chunk_sum;
+
+    TRACE_IN();
+
+#ifdef DEBUG_CLASSES
+    TRACE_INDENT();
+    printf("%s(%s)\n", __FUNCTION__, class_sizes ? "unsigned int[]" : "NULL");
+#endif
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes <= 0)
+	{ TRACE_RETURN(KRERR_NO_CLASSES); }
+
+    list = np_st[npui_pat_sets[npui_curr_pat_set]];
+    if (class_sizes == NULL)
+    {
+	while (list)
+	{
+	    if (list->chunk_amount != list->set_amount)
+	    {
+		list->chunk_amount = list->set_amount;
+		has_changed++;
+	    }
+	    list = list->next;
+	}
+    }
+    else
+    {
+	chunk_sum = 0;
+	for (index=0; index<np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes; 
+	     index++)
+	    chunk_sum += class_sizes[index];
+	if (chunk_sum == 0)
+	    { TRACE_RETURN(KRERR_ILL_CLASS_DISTRIB); }
+
+	index = 0;
+	while (list)
+	{
+	    if (list->chunk_amount != class_sizes[index])
+	    {
+		list->chunk_amount = class_sizes[index];
+		has_changed++;
+	    }
+	    list = list->next;
+	    index++;
+	}
+	if (index != np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes)
+	    fprintf(stderr, "internal error, file %s, line %d", __FILE__, __LINE__);
+    }
+
+    if (has_changed > 0)
+    {
+	np_pat_mapping_valid = FALSE;
+	np_abs_count_valid = FALSE;
+	err_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+    }
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_useChunk
+
+  PURPOSE  : 
+
+Switch on or off the class distribution process.
+If <active> is TRUE, the distribution process is activated. Therefore the 
+internal representation of the pattern set is virtually reorganized to match
+the requested values of <class_sizes>. After that step the number of patterns
+in the set virtually increases or decreases because each epoch must cover 
+every pattern of all classes that have a requested distribution amount bigger
+than 0. This also implies that several patterns from a specific class are 
+reused several times during one epoch.
+
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_useChunk(bool active)
+{
+    krui_err err_code = KRERR_NO_ERROR;
+
+    TRACE_IN();
+
+#ifdef DEBUG_CLASSES
+    TRACE_INDENT();
+    printf("%s(%s)\n", __FUNCTION__, active ? "TRUE" : "FALSE");
+#endif
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes <= 0)
+	{ TRACE_RETURN(KRERR_NO_CLASSES); }
+
+    if (np_info[npui_pat_sets[npui_curr_pat_set]].pub.class_distrib_active !=
+	active)
+    {
+	np_info[npui_pat_sets[npui_curr_pat_set]].pub.class_distrib_active =
+	active;
+
+	np_pat_mapping_valid = FALSE;
+	np_abs_count_valid = FALSE;
+	err_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+    }
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_npui_setClass
+
+  PURPOSE  : 
+
+Set the class name for the current pattern.
+If the pattern set already contains class information, only the
+current pattern is affected. If there are no classes in the pattern
+set so far, all patterns of the current set are set to the given class
+name, since every pattern must belong to a class in that case.
+If the given class name is the NULL pointer, nothing happens at all.
+
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_npui_setClass(char *classname)
+{
+    np_pattern_descriptor *p;
+    krui_err err_code = KRERR_NO_ERROR;
+    struct np_symtab *old_entry;
+    struct np_symtab *new_entry;
+    int phys_num;
+
+    TRACE_IN();
+
+#ifdef DEBUG_CLASSES
+    TRACE_INDENT();
+    printf("%s(%s)\n", __FUNCTION__, classname ? classname : "NULL");
+#endif
+
+    if (!classname)
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN_SET); }
+
+    if (npui_curr_pattern == -1)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    phys_num = kr_np_virtual_to_physical(npui_curr_pattern-1);
+    err_code = kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		   phys_num, &p);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    old_entry = p->mysym;
+    err_code = kr_np_lookupSym(npui_pat_sets[npui_curr_pat_set],
+				   classname, &new_entry);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    if (old_entry == NULL)
+    {
+	int num, i;
+
+	/* all physical patterns are used here! */
+	num = np_info[npui_pat_sets[npui_curr_pat_set]].pub.number_of_pattern;
+
+	p = np_pat_sets[npui_pat_sets[npui_curr_pat_set]];
+	for (i=0; i<num; i++)
+	{
+	    p->mysym = new_entry;
+	    p++;
+	    new_entry->set_amount++;
+	}
+	new_entry->chunk_amount = new_entry->set_amount;
+	np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes++;
+    }
+    else
+    {
+	if (new_entry == old_entry)
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+	else
+	{
+	    old_entry->set_amount--;
+	    if (old_entry->set_amount < old_entry->chunk_amount)
+		old_entry->chunk_amount = old_entry->set_amount;
+	    if (old_entry->set_amount <= 0)
+	    {
+		old_entry->chunk_amount = 0;
+		np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes--;
+		kr_np_delSym(npui_pat_sets[npui_curr_pat_set], old_entry);
+	    }
+
+	    if (new_entry->set_amount == 0)
+		np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes++;
+	    new_entry->set_amount++;
+	    if (new_entry->chunk_amount == 0)
+		new_entry->chunk_amount = 1;
+	}
+    }
+    p->mysym = new_entry;
+    np_pat_mapping_valid = FALSE;
+    np_abs_count_valid = FALSE;
+    err_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+
+    npui_curr_pattern = 1 + kr_np_physical_to_virtual(phys_num);
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY OTHER KERNEL FUNCTIONS LIKE TRAINING
+ AND INITIALIZATION FUNCTIONS:
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : kr_np_pattern
+
+  PURPOSE  : multiple pattern handling functions depending on mode and mode1
+  RETURNS  : result, depending on operation or kernel error code
+  NOTES    : KernelErrorCode is set to the valid kernel error code
+
+  UPDATE   : 
+******************************************************************************/
+int  kr_np_pattern(int mode ,int mode1 ,int pattern_no)
+{
+    int return_code;
+    int new_pattern;
+    np_pattern_set_info info;
+    np_pattern_descriptor *pattern;
+    np_pattern_descriptor *c_pattern;
+
+
+    TRACE_IN();
+
+#ifdef DEBUG_PATTERN
+    TRACE_INDENT();
+    printf("%s(", __FUNCTION__);
+    switch (mode)
+    {
+      case PATTERN_SET: printf("PATTERN_SET"); break;
+      case PATTERN_GET: printf("PATTERN_GET"); break;
+      case PATTERN_DELETE: printf("PATTERN_DELETE"); break;
+      case PATTERN_MODIFY: printf("PATTERN_MODIFY"); break;
+      case PATTERN_SHOW: printf("PATTERN_SHOW"); break;
+      case PATTERN_NEW: printf("PATTERN_NEW"); break;
+      case PATTERN_DELETE_ALL: printf("PATTERN_DELETE_ALL"); break;
+      case PATTERN_SHUFFLE_ON: printf("PATTERN_SHUFFLE_ON"); break;
+      case PATTERN_SHUFFLE_OFF: printf("PATTERN_SHUFFLE_OFF"); break;
+      case PATTERN_VECTOR_NEW: printf("PATTERN_VECTOR_NEW"); break;
+      case PATTERN_ARRAY_ALLOC: printf("PATTERN_ARRAY_ALLOC"); break;
+      case PATTERN_SET_NUMBER: printf("PATTERN_SET_NUMBER"); break;
+      case PATTERN_GET_NUMBER: printf("PATTERN_GET_NUMBER"); break;
+      case PATTERN_SUB_SHUFFLE_ON: printf("PATTERN_SUB_SHUFFLE_ON"); break;
+      case PATTERN_SUB_SHUFFLE_OFF: printf("PATTERN_SUB_SHUFFLE_OFF"); break;
+      case GET_SHUFFLE_FLAG: printf("GET_SHUFFLE_FLAG"); break;
+      case GET_SUB_SHUFFLE_FLAG: printf("GET_SUB_SHUFFLE_FLAG"); break;
+      case SUBPATTERN_GET_NUMBER: printf("SUBPATTERN_GET_NUMBER"); break;
+      default: printf("%d", mode); break;
+    }
+    printf(", %d, %d)\n", mode1, pattern_no);
+#endif
+
+    return_code = (int) (KernelErrorCode = KRERR_NO_ERROR);
+
+    if (npui_curr_pat_set == -1)
+    {
+	KernelErrorCode = KRERR_NP_NO_CURRENT_PATTERN_SET;
+	TRACE_RETURN((int) KernelErrorCode);
+    }
+
+    /* for some modes, test current pattern definition */ 
+    switch (mode)
+    {
+      case  PATTERN_GET:	/*  returns the current pattern  */
+      case  PATTERN_DELETE:	/*  delete the current pattern pair  */
+      case  PATTERN_MODIFY:	/*  modify the current pattern pair  */
+      case  PATTERN_SHOW:	/*  show pattern  */
+	if (npui_curr_pattern == -1 && mode != PATTERN_SET)
+	{
+	    KernelErrorCode = KRERR_NP_NO_CURRENT_PATTERN;
+	    TRACE_RETURN((int) KernelErrorCode);
+	}
+      default:
+	break;
+    }
+
+    switch (mode)
+    {
+      case  PATTERN_SET:	/*  set the current pattern  */
+	if (pattern_no < 1 || pattern_no >
+	np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern)
+	{
+	    return_code = (int) (KernelErrorCode = KRERR_PATTERN_NO);
+	    npui_curr_pattern = -1;
+	}
+	else
+	    npui_curr_pattern = pattern_no;
+	break;
+
+      case  PATTERN_GET:	/*  returns the current pattern  */
+	return_code = npui_curr_pattern;
+	break;
+
+      case  PATTERN_DELETE:	/*  delete the current pattern pair  */
+	return_code = kr_np_DeletePattern(npui_pat_sets[npui_curr_pat_set],
+			  kr_np_virtual_to_physical(npui_curr_pattern-1));
+	npui_curr_pattern = -1;
+
+	np_info_valid[npui_pat_sets[npui_curr_pat_set]] = FALSE;
+	np_pat_mapping_valid = FALSE;
+	np_abs_count_valid = FALSE;
+	return_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+
+	break;
+
+      case  PATTERN_MODIFY:	/*  modify the current pattern pair  */
+	return_code = (int) (KernelErrorCode = kr_np_modifyPattern());
+	break;
+
+      case  PATTERN_SHOW:	/*  show pattern  */
+	return_code = (int) (KernelErrorCode = kr_np_showPatternSTD(mode1));
+	break;
+
+      case  PATTERN_NEW:	/*  new pattern  */
+	/* before creating a new pattern, first ensure that new pattern */
+	/* fits into existing set */
+	return_code = kr_np_GetInfo(npui_pat_sets[npui_curr_pat_set], &info);
+	if (return_code != KRERR_NO_ERROR)
+	    break;
+	(void) kr_IOCheck();
+	if (NoOfInputUnits == 0)
+	{
+	    return_code = KernelErrorCode = KRERR_NO_INPUT_UNITS;
+	    break;
+	}
+
+	if (info.pub.number_of_pattern > 0)
+	{
+	    if (info.pub.in_number_of_dims != 0 || 
+		info.pub.out_number_of_dims != 0 ||
+		info.pub.in_fixsize != NoOfInputUnits || 
+		 info.pub.out_fixsize != NoOfOutputUnits)
+	    {
+		/* creation of variable sized patterns is not possible */
+		/* also the new pattern must be of equal size compared to */
+		/* existing pattern */
+		return_code = KRERR_NP_INCOMPATIBLE_NEW;
+		break;
+	    }
+	}
+
+	if (npui_curr_pattern != -1)
+	    (void) kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+		  kr_np_virtual_to_physical(npui_curr_pattern-1), 
+		  &c_pattern);
+	else
+	    c_pattern = NULL;
+
+	return_code = KernelErrorCode =
+	    kr_np_AddPattern(npui_pat_sets[npui_curr_pat_set], &new_pattern);
+	if (return_code != KRERR_NO_ERROR)
+	    break;
+
+	(void) kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+				   new_pattern, &pattern);
+
+	if (np_info[npui_pat_sets[npui_curr_pat_set]].pub.classes > 0)
+	{
+	    /* the new pattern gets a symbol which is in use for the
+	       current chunk composition */
+	    if (c_pattern != NULL)
+		pattern->mysym = c_pattern->mysym;
+	    else
+	    {
+		pattern->mysym = np_st[npui_pat_sets[npui_curr_pat_set]];
+		while (pattern->mysym && pattern->mysym->chunk_amount <= 0)
+		    pattern->mysym = pattern->mysym->next;
+		if (pattern->mysym == NULL)
+		{
+		    pattern->mysym = np_st[npui_pat_sets[npui_curr_pat_set]];
+		    pattern->mysym->chunk_amount = 1;
+		}
+	    }
+	    pattern->mysym->set_amount++;
+	}
+
+	
+	/* update internal information which is used to compute the new 
+	   current pattern. To do this, the right pattern sizes must be set. 
+	   They must be reset to 0 to allow allocation of memory space 
+	   during later pattern modifikation */
+	pattern->pub.input_fixsize = NoOfInputUnits;
+	pattern->pub.output_fixsize = NoOfOutputUnits;
+	np_info_valid[npui_pat_sets[npui_curr_pat_set]] = FALSE;
+	np_pat_mapping_valid = FALSE;
+	np_abs_count_valid = FALSE;
+	return_code = kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+	npui_curr_pattern = 1 + kr_np_physical_to_virtual(new_pattern);
+	pattern->pub.input_fixsize = 0;
+	pattern->pub.output_fixsize = 0;
+
+	return_code = (int) (KernelErrorCode = kr_np_modifyPattern());
+	if (return_code != KRERR_NO_ERROR)
+	{
+	    (void) kr_np_DeletePattern(npui_pat_sets[npui_curr_pat_set],
+				       new_pattern);
+	    npui_curr_pattern = -1;
+
+	    np_info_valid[npui_pat_sets[npui_curr_pat_set]] = FALSE;
+	    np_pat_mapping_valid = FALSE;
+	    np_abs_count_valid = FALSE;
+	    (void) kr_np_ValidateInfo(npui_pat_sets[npui_curr_pat_set]);
+	    break;
+	}
+
+	break;
+
+      case  PATTERN_DELETE_ALL:	/*  delete all pattern  */
+	break;
+
+      case  PATTERN_SHUFFLE_ON:	/*  shuffle pattern  */
+	npui_shuffle_pattern = TRUE;
+	break;
+
+      case  PATTERN_SHUFFLE_OFF: /*  shuffle pattern off */
+	npui_shuffle_pattern = FALSE;
+	break;
+
+      case  PATTERN_SET_NUMBER:
+	break;
+
+      case  PATTERN_GET_NUMBER:
+	return_code = 
+	    np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern;
+	break;
+
+      case  SUBPATTERN_GET_NUMBER:
+	return_code = 
+            kr_TotalNoOfSubPatPairs();
+	break;
+
+	
+      case  PATTERN_SUB_SHUFFLE_ON:
+	npui_shuffle_sub_pattern = TRUE;
+	break;
+
+      case  PATTERN_SUB_SHUFFLE_OFF:
+	npui_shuffle_sub_pattern = FALSE;
+	break;
+
+      case GET_SHUFFLE_FLAG:
+	return_code = npui_shuffle_pattern;
+	break;
+
+      case GET_SUB_SHUFFLE_FLAG:
+	return_code = npui_shuffle_sub_pattern;
+	break;
+
+      default:
+	KernelErrorCode = KRERR_PARAMETERS;
+    }
+
+    { TRACE_RETURN(return_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_initSubPatternOrder
+
+  PURPOSE  : The sub pattern ordering for the current pattern set is
+             reset for the next training or initialization run. During
+	     this run all sub patterns from pattern <start> up to
+	     pattern <end> are generated according to current shuffle
+	     flags for patterns and sub patterns.  
+             kr_getSubPatByOrder is to be called to get the next sub
+	     pattern number during the run (see below) 
+
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_initSubPatternOrder(int start, int end)
+{
+    int pat_set;
+    int n_sub;
+
+    TRACE_IN();
+
+    if (!npui_train_defined)
+	{ TRACE_RETURN(KRERR_NP_NO_TRAIN_SCHEME); }
+
+    pat_set = npui_pat_sets[npui_curr_pat_set];
+
+    if (npui_shuffle_pattern && npui_shuffle_sub_pattern)
+    {
+	np_random_train_number = kr_TotalNoOfSubPatPairs();
+	np_next_train_random = 0;
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+    }
+
+    if (!kr_np_allocate_pat_train_entries(np_info[pat_set].pub.virtual_no_of_pattern))
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+    if (np_info[pat_set].pub.class_distrib_active)
+    {
+	kr_np_order_chunk_arrays(npui_shuffle_pattern, pat_set);
+	kr_np_order_chunked_pat_entries(pat_set, start, end);	
+    }
+    else
+    {
+	kr_np_order_pat_entries(start, end);
+    }
+
+    np_current_pattern = 
+	&(np_pat_sets[pat_set][np_pat_train_order[0]]);
+    np_next_train_pat = 0;
+
+    kr_np_gen_sub_pos(np_current_pattern -> pub.input_dim, &n_sub,
+		      np_current_pattern -> pub.input_dim_sizes, np_t_insize, 
+		      np_t_instep, NULL, TRUE);
+
+    if (!kr_np_allocate_sub_pat_train_entries(n_sub))
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+    kr_np_order_sub_pat_entries(0, n_sub-1);
+    np_next_train_sub_pat = 0;
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getSubPatternByOrder
+
+  PURPOSE : According to the last call to kr_initSubPatternOrder, the
+  last call to this function and the shuffle flags, the next position
+  of pattern and sub pattern is determined. This numbers are returned
+  in <pattern> and <sub> (beginning with 0). 
+
+  RETURNS : If there are no more sub pattern avaliable the return
+  value is FALSE, otherwise TRUE.
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+bool kr_getSubPatternByOrder(int *pattern, int *sub)
+{
+    int n_sub;
+
+    TRACE_IN();
+
+    if (npui_shuffle_pattern && npui_shuffle_sub_pattern)
+    {
+	if (np_next_train_random == -1)
+	    { TRACE_RETURN(FALSE); }
+
+	if (++np_next_train_random >= np_random_train_number)
+	    np_next_train_random = -1;
+
+	TRACE_RETURN((kr_getSubPatternByNo(pattern, sub, 
+				     lrand48() % np_random_train_number)));
+    }
+
+    if (np_next_train_pat == -1)
+	{ TRACE_RETURN(FALSE); }
+
+    *pattern = np_pat_train_order[np_next_train_pat];
+    *sub = np_sub_pat_train_order[np_next_train_sub_pat];
+
+    np_next_train_sub_pat++;
+    if (np_next_train_sub_pat >= np_sub_pat_train_number)
+    {
+	np_next_train_pat++;
+	if (np_next_train_pat >= np_pat_train_number)
+	{
+	    np_next_train_pat = -1;
+	    { TRACE_RETURN(TRUE); }
+	}
+
+	np_current_pattern = 
+	    &(np_pat_sets[npui_pat_sets[npui_curr_pat_set]]
+	                 [np_pat_train_order[np_next_train_pat]]);
+    
+	kr_np_gen_sub_pos(np_current_pattern -> pub.input_dim, &n_sub,
+			  np_current_pattern -> pub.input_dim_sizes, np_t_insize, 
+			  np_t_instep, NULL, TRUE);
+
+	if (!kr_np_allocate_sub_pat_train_entries(n_sub))
+	{
+	    KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	    { TRACE_RETURN(FALSE); }
+	}
+
+	kr_np_order_sub_pat_entries(0, n_sub-1);
+	np_next_train_sub_pat = 0;
+    }
+
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getSubPatternByNo
+
+  PURPOSE : According to the current pattern set, the position of the
+  <n>th sub pattern is determined and returned in <pattern> (the
+  pattern which includes the subpattern) and <sub> (the sub pattern
+  inside the pattern) (beginning with 0).  
+  This function does not effect the ordering of the function
+  kr_getSubPatByOrder. <n> ranges from 0 to kr_TotalNoOfSubPatPairs()-1.
+
+  RETURNS : If the sub pattern is available, TRUE is returned,
+  otherwise FALSE.
+
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+bool kr_getSubPatternByNo(int *pattern, int *sub, int n)
+{
+    register int ts;
+    register int tp;
+    register int low, high, mid;
+
+    TRACE_IN();
+
+    ts = kr_TotalNoOfSubPatPairs();
+    if (n<0 || n>=ts)
+	{ TRACE_RETURN(FALSE); }
+
+    tp = np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern;
+
+    if (tp == 1)
+	/* only one pattern present, sub pattern must be here */
+	high = 0;
+    else
+    {
+	/* more than one pattern present.... */
+	/* first try to find the right position by a direct jump */
+	high = (int)(((double)n*(double)tp)/(double)ts);
+
+	if (np_abs_count[high] <= n || (high != 0 && np_abs_count[high-1] > n))
+	{
+	    /* direct jump was not sucessfull, now perform binary search */
+	    low = 0;
+	    high = tp-1;
+	    while (low < high)
+	    {
+		mid = (high+low)/2;
+		if (np_abs_count[mid] > n)
+		    high = mid;
+		else
+		    low = mid+1;
+	    }
+	}
+    }
+
+    /* now high gives the index of the pattern where the sub pattern is in */
+    /* but np_abs_count is based on virtual pattern, while this function must 
+       return a physical pattern number: */
+    *pattern = kr_np_virtual_to_physical(high);
+
+    /* calculate the position of the sub pattern inside the found pattern */
+    if (high != 0)
+	*sub = n - np_abs_count[high-1];
+    else
+	*sub = n;
+
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_TotalNoOfSubPatPairs
+
+  PURPOSE : This function returns the total number of available sub
+  patterns for the current pattern set or 0 if no pattern set is
+  defined.  The result is the sum of the numbers of subpattern for all
+  patterns in the current set.
+
+  RETURNS  : number of sub pattern or 0
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_TotalNoOfSubPatPairs(void)
+{
+    int n;
+    int i;
+    int sum;
+    int n_sub;
+    np_pattern_descriptor *pat;
+
+    TRACE_IN();
+
+    if (np_abs_count_valid)
+	{ TRACE_RETURN(np_abs_count_No); }
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(0); }
+
+    n = np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern;
+
+    if (n > np_abs_count_size)
+    {
+	if (np_abs_count != (int *) NULL)
+	    free(np_abs_count);
+	np_abs_count_size = 0;
+	np_abs_count = (int *) malloc(n * sizeof(int));
+	if (np_abs_count == (int *) NULL && n != 0)
+	    { TRACE_RETURN(0); }
+	np_abs_count_size = n;
+    }
+
+    sum = 0;
+    for (i=0; i<n; i++)
+    {
+	kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+			    kr_np_virtual_to_physical(i), &pat);
+	kr_np_gen_sub_pos(pat -> pub.input_dim, &n_sub, 
+			  pat -> pub.input_dim_sizes, np_t_insize,
+			  np_t_instep, NULL, TRUE);
+	sum += n_sub;
+	np_abs_count[i] = sum;
+    }
+    np_abs_count_No = sum;
+    np_abs_count_valid = TRUE;
+
+    { TRACE_RETURN(np_abs_count_No); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_NoOfSubPatPairs
+
+  PURPOSE  : This function returns the number of available sub patterns
+  for the pattern <pattern> of the current pattern set or 0 if this
+  pattern is not defined.
+
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_NoOfSubPatPairs(int pattern)
+{
+    register int ps;
+
+    TRACE_IN();
+
+    if (!np_abs_count_valid)
+    {
+	if (kr_TotalNoOfSubPatPairs() == 0)
+	    { TRACE_RETURN(0); }
+    }
+
+    if (pattern<0 || 
+	pattern > np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern)
+	{ TRACE_RETURN(0); }
+
+    ps = np_abs_count[pattern];
+
+    if (pattern == 0)
+    { TRACE_RETURN(ps); }
+    else
+	TRACE_RETURN((ps - np_abs_count[pattern-1]));
+}
+
+/*****************************************************************************
+  FUNCTION : kr_AbsPosOfFirstSubPat
+
+  PURPOSE  : This function returns the absolute position of the first
+  sub pattern of pattern <pattern> in the current pattern set. This
+  position is defined as the Sum of kr_NoOfSubPatPairs(i) where i runs
+  from 0 to <pattern>-1.  The absolute position of the first sub
+  pattern of pattern 0 is 0.  The returned value may be used as
+  argument for the function kr_getSubPatternByNo.
+
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_AbsPosOfFirstSubPat(int pattern)
+{
+    TRACE_IN();
+
+    if (!np_abs_count_valid)
+    {
+	if (kr_TotalNoOfSubPatPairs() == 0)
+	    { TRACE_RETURN(0); }
+    }
+
+    if (pattern <= 0 || 
+	pattern > np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern)
+	{ TRACE_RETURN(0); }
+
+    { TRACE_RETURN(np_abs_count[pattern-1]); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_TotalNoOfPattern
+
+  PURPOSE : This function returns the total number of available
+  patterns for the current pattern set or 0 if no pattern set is
+  defined.  
+
+  RETURNS  : number of pattern or 0
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_TotalNoOfPattern(void)
+{
+    TRACE_IN();
+
+    if (npui_curr_pat_set == -1)
+	{ TRACE_RETURN(0); }
+
+    { TRACE_RETURN(np_info[npui_pat_sets[npui_curr_pat_set]].pub.virtual_no_of_pattern); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getSubPatData
+
+  PURPOSE : For the current pattern set and the specified sub pattern
+  size, the data array of the <sub_no>th sub pattern of the <pat_no>th
+  pattern is returned. io_type spcifies whether the input (INPUT) or
+  output (OUTPUT) data is requested. If <size> is != NULL the size of
+  the data array is returned is this parameter.  
+
+  RETURNS : The function returns a pointer to the data array (type
+  Patterns) or NULL if an error occured.
+  NOTES    : KernelErrorCode is set if an error occured
+
+  UPDATE   : 
+******************************************************************************/
+Patterns kr_getSubPatData(int pat_no, int sub_no, int io_type, int *size)
+{
+    int set;
+    np_pattern_descriptor *pat;
+    int subpos[MAX_NO_OF_VAR_DIM];
+    float *data;
+    krui_err err;
+    static float dummy_data = 0.0;
+    int intsize;
+
+    TRACE_IN();
+
+#ifdef DEBUG_PATTERN
+    TRACE_INDENT();
+    fprintf(stderr, "pattern %d, sub %d, %s\n", pat_no, sub_no, io_type == INPUT ? "INPUT" : "OUTPUT");
+#endif
+
+    set = npui_pat_sets[npui_curr_pat_set];
+    pat = np_pat_sets[set];
+    
+    if (pat_no >= np_info[set].pub.number_of_pattern)
+	TRACE_RETURN((Patterns) NULL);
+
+    pat += pat_no;
+    np_current_pattern = pat;
+    switch (io_type)
+    {
+      case INPUT:
+	if (!kr_np_gen_sub_pos(pat->pub.input_dim, &sub_no, pat->pub.input_dim_sizes,
+			       np_t_insize, np_t_instep, subpos, FALSE))
+	{
+	    KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	    TRACE_RETURN((Patterns) NULL);
+	}
+	if ((err = kr_np_GetSubPat(TRUE, subpos, np_t_insize, &data, &intsize))
+	    != KRERR_NO_ERROR)
+	{
+	    KernelErrorCode = err;
+	    TRACE_RETURN((Patterns) NULL);
+	}
+	if (size != NULL)
+	    *size = intsize;
+
+#ifdef PRINT_USED_PATTERNS
+	{
+	    int ind;
+	    printf("I %d %d '%s' ", pat_no, sub_no, 
+		   pat->mysym != NULL && pat->mysym->symname ? 
+		   pat->mysym->symname : "");
+	    for (ind=0; ind<intsize; ind++)
+		printf("%g ", data[ind]);
+	    printf("\n");
+	}
+#endif
+
+	TRACE_RETURN((Patterns) data);
+	break;
+      case OUTPUT:
+	if (!kr_np_gen_sub_pos(pat->pub.output_dim, &sub_no, pat->pub.output_dim_sizes,
+			       np_t_outsize, np_t_outstep, subpos, FALSE))
+	{
+	    KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	    TRACE_RETURN((Patterns) NULL);
+	}
+	if ((err = kr_np_GetSubPat(FALSE, subpos, np_t_outsize, &data, &intsize))
+	    != KRERR_NO_ERROR)
+	{
+	    KernelErrorCode = err;
+	    TRACE_RETURN((Patterns) NULL);
+	}
+	if (size != NULL)
+	    *size = intsize;
+
+#ifdef PRINT_USED_PATTERNS
+	{
+	    int ind;
+	    printf("O %d %d '%s' ", pat_no, sub_no, 
+		   pat->mysym != NULL && pat->mysym->symname ? 
+		   pat->mysym->symname : "");
+	    for (ind=0; ind<intsize; ind++)
+		printf("%g ", data[ind]);
+	    printf("\n");
+	}
+#endif
+
+	/* kr_np_GetSubPat reports no error if a zero length output sub */
+	/* pattern is requested. Instead a NULL pointer is returned but */
+	/* must be exchanged by a dummy non NULL pointer because this */
+	/* function reports errors by NULL pointers */
+	if (data == 0)
+	    TRACE_RETURN((Patterns) &dummy_data);
+
+	TRACE_RETURN((Patterns) data);
+	break;
+      default:
+	KernelErrorCode = KRERR_PARAMETERS;
+	TRACE_RETURN((Patterns) NULL);
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_getPatClass
+
+  PURPOSE : For the current pattern set and the specified sub pattern,
+  the class index (>=0) is returned. If the pattern set does not
+  provide class information, the return value is -1
+  RETURNS  : class index or -1, if no classes available
+  NOTES    : sub_no is of no effect, since class information only refers
+             to patterns and not to sub patterns
+             The parameter is kept for future improvements.
+
+  UPDATE   : 
+*****************************************************************************/
+extern int kr_getSubPatClass(int pat_no, int sub_no)
+{
+    int set;
+    np_pattern_descriptor *pat;
+
+    TRACE_IN();
+
+    set = npui_pat_sets[npui_curr_pat_set];
+    pat = np_pat_sets[set];
+    
+    if (pat_no < 0 || pat_no >= np_info[set].pub.number_of_pattern)
+	TRACE_RETURN(-1);
+
+    pat += pat_no;
+    TRACE_RETURN(pat->pub.my_class);
+}
+
+/*****************************************************************************
+  FUNCTION : kr_SizeOfInputSubPat
+
+  PURPOSE  : For the current pattern set and the specified sub pattern size, 
+  the size of the input part of the first sub pattern of the first pattern is 
+  returned. Negative return values indicate KernelErrorCode. Size 0 is a valid 
+  return value since the pattern may contain no data.
+  RETURNS  : negative Kernel Error Codes or positive valid value
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_SizeOfInputSubPat(void)
+{
+    krui_err err;
+
+    TRACE_IN();
+
+    if (np_sub_pat_sizes_valid)
+	{ TRACE_RETURN(np_sub_pat_input_size); }
+
+    err = kr_np_GetSubPatSizes(&np_sub_pat_input_size, 
+			       &np_sub_pat_output_size);
+
+    if (err == KRERR_NO_ERROR)
+    {
+	np_sub_pat_sizes_valid = TRUE;
+	{ TRACE_RETURN(np_sub_pat_input_size); }
+    }
+
+    { TRACE_RETURN(err); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_SizeOfOutputSubPat
+
+  PURPOSE  : For the current pattern set and the specified sub pattern size, 
+  the size of the output part of the first sub pattern of the first pattern is 
+  returned. Negative return values indicate KernelErrorCode. Size 0 is a valid 
+  return value since the pattern may contain no data.
+  RETURNS  : negative Kernel Error Codes or positive valid value
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int kr_SizeOfOutputSubPat(void)
+{
+    krui_err err;
+
+    TRACE_IN();
+
+    if (np_sub_pat_sizes_valid)
+	{ TRACE_RETURN(np_sub_pat_output_size); }
+    
+    err = kr_np_GetSubPatSizes(&np_sub_pat_input_size, 
+			       &np_sub_pat_output_size);
+
+    if (err == KRERR_NO_ERROR)
+    {
+	np_sub_pat_sizes_valid = TRUE;
+	{ TRACE_RETURN(np_sub_pat_output_size); }
+    }
+
+    { TRACE_RETURN(err); }
+}
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE PATTERN PARSER OR FROM INSIDE THIS
+ MODULE. DON'T USE THESE FUNCTIONS FOR OTHER PURPOSES !!!!!
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : kr_np_AllocatePatternSet
+
+  PURPOSE  : looks for a free slot in pattern set array and allocates <number>
+             of free pattern descriptors
+
+  RETURNS  : kernel error code
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_np_AllocatePatternSet(int *pat_set, int number)
+{
+    krui_err err_code;
+    int i;
+    int set = -1;
+
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+    {
+	/* never patterns allocated */
+	err_code = kr_np_InitPattern();
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+    }
+
+    /* check for free pattern set entry */
+    for (i=0; i<np_used_pat_set_entries; i++)
+    {
+	if (!np_pat_set_used[i])
+	{
+	    set = i;
+	    break;
+	}
+    }
+    if (set == -1)
+    {
+	/* no more free entries */
+	{ TRACE_RETURN(KRERR_NP_NO_MORE_ENTRIES); }
+    }
+
+    /* allocate array of pattern descriptors */
+    np_pat_sets[set] = 
+	(np_pattern_descriptor *) malloc(number * sizeof(np_pattern_descriptor));
+    if (np_pat_sets[set] == (np_pattern_descriptor *) NULL && number != 0)
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+    /* initialize part of the pattern descriptors */
+    for (i=0; i<number; i++)
+    {
+	np_pat_sets[set][i].pub.input_fixsize = 0;
+	np_pat_sets[set][i].pub.output_fixsize = 0;
+	np_pat_sets[set][i].pub.my_class = -1;
+
+	np_pat_sets[set][i].input_pattern = (float *) NULL;
+	np_pat_sets[set][i].output_pattern = (float *) NULL;
+
+	np_pat_sets[set][i].mysym = (struct np_symtab *) NULL;
+    }
+
+    /* store number of allocated descriptors */
+    np_info[set].pub.number_of_pattern = number;
+    np_info[set].pub.virtual_no_of_pattern = number;
+    np_info[set].pub.classes = 0;
+    np_info[set].pub.class_names = NULL;
+    np_info[set].pub.class_distrib_active = FALSE;
+    np_info[set].pub.class_redistribution = NULL;
+    np_info[set].pub.remap_function = NULL;
+    np_info[set].pub.no_of_remap_params = 0;
+    np_info[set].rmf_ptr = NULL;
+    np_info_valid[set] = FALSE; /* only number_of_pattern is valid */
+
+    /* sucessfull return */
+    np_pat_set_used[set] = TRUE;
+    *pat_set = set;
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_AllocatePattern
+
+  PURPOSE  : uses the information provided in given pattern descriptor to
+             allocate memory for pattern data
+
+  RETURNS  : kernel error code
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_np_AllocatePattern(np_pattern_descriptor *pattern,
+			       bool input)
+{
+    int i;
+    int size;
+
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (input)
+    {
+	size = pattern -> pub.input_fixsize;
+	for (i=0; i<pattern -> pub.input_dim; i++)
+	    size *= (pattern -> pub.input_dim_sizes)[i];
+
+	if (pattern -> pub.input_dim > 0)
+	    pattern -> input_pattern = (float *) malloc(size * sizeof(float));
+	else
+	    pattern -> input_pattern = kr_np_floatmalloc(size);
+
+	if (pattern -> input_pattern == (float *) NULL && size != 0)
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	else
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+    }
+    else
+    {
+	size = pattern -> pub.output_fixsize;
+	for (i=0; i<pattern -> pub.output_dim; i++)
+	    size *= (pattern -> pub.output_dim_sizes)[i];
+
+	if (pattern -> pub.output_dim > 0)
+	    pattern -> output_pattern = (float *) malloc(size * sizeof(float));
+	else
+	    pattern -> output_pattern = kr_np_floatmalloc(size);
+
+	if (pattern -> output_pattern == (float *) NULL && size != 0)
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	else
+	    { TRACE_RETURN(KRERR_NO_ERROR); }
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_freePattern
+
+  PURPOSE  : frees the area of the pattern data for this pattern
+
+  RETURNS  : 
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+  UPDATE   : 
+******************************************************************************/
+void kr_np_FreePattern(np_pattern_descriptor *pattern)
+{
+    if (pattern -> input_pattern)
+    {
+	if (pattern -> pub.input_dim > 0)
+	    free(pattern -> input_pattern);
+	else
+	    kr_np_floatfree(pattern -> input_pattern);
+    }
+
+    if (pattern -> output_pattern)
+    {
+	if (pattern -> pub.output_dim > 0)
+	    free(pattern -> output_pattern);
+	else
+	    kr_np_floatfree(pattern -> output_pattern);
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_GetDescriptor
+
+  PURPOSE  : determine a pointer to a specified pattern descriptor
+             and make this pattern to be the current pattern
+
+  RETURNS  : kernel error code
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+	     <number> is a physical pattern number!
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_np_GetDescriptor(int pat_set, int number, 
+			     np_pattern_descriptor **pattern)
+{
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set < 0 || pat_set >= np_used_pat_set_entries ||
+	!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    if (number >= np_info[pat_set].pub.number_of_pattern)
+	{ TRACE_RETURN(KRERR_PATTERN_NO); }
+
+    *pattern = np_current_pattern = &(np_pat_sets[pat_set][number]);
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_lookupSym
+
+  PURPOSE  : Find an entry in the set specific symbol table or create a 
+  new entry. If a new entry is created, also the numbering of symbols
+  must be re-updated. 
+
+  RETURNS  : kernel error code
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+  UPDATE   : 
+******************************************************************************/
+krui_err kr_np_lookupSym(int pat_set, char *symbol, struct np_symtab **entry)
+{
+    struct np_symtab *list;
+    struct np_symtab *newsym;
+    struct np_symtab *last = NULL;
+    int list_cmp;
+    int last_cmp;
+    int i;
+
+    TRACE_IN();
+
+    list = np_st[pat_set];
+    while (list != NULL && (list_cmp = strcmp(symbol, list->symname)) > 0)
+    {
+	last = list;
+	last_cmp = list_cmp;
+	list = list->next;
+    }
+    
+    if (list != NULL && list_cmp == 0)
+	*entry = list;
+    else
+    {
+	newsym = (struct np_symtab *) malloc(sizeof(struct np_symtab));
+	if (!newsym)
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	newsym->symname = strdup(symbol);
+	if (!newsym->symname)
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	newsym->set_amount = 0;
+	newsym->chunk_amount = 0;
+	newsym->symnum = 0;
+	newsym->my_chunks_per_set = 0;
+	newsym->global_chunks = 0;
+	newsym->pat_nums_size = 0;
+	newsym->pat_nums_valid = 0;
+	newsym->pat_nums = NULL;
+	newsym->within_chunk_pos = -1;
+	newsym->pat_num_pos = -1;
+	newsym->next = list;
+	if (last)
+	    last->next = newsym;
+	else
+	    np_st[pat_set] = newsym;
+	*entry = newsym;
+
+	list = np_st[pat_set];
+	i = 0;
+	while (list)
+	{
+	    list->symnum = i++;
+	    list = list->next;
+	}
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+ INTERNAL FUNCTIONS OF THIS MODULE. IMPOSSIBLE TO CALL THESE FUNCTIONS
+ FROM OUTSIDE THE MODULE (IF NOBODY CHANGES THE STATIC DECLARATION) !!!!!!!
+******************************************************************************/
+
+#ifdef DEBUG_PATTERN
+static print_page_info(struct patternpage *page)
+{
+    int fl;
+    int cnt;
+
+    if (!page)
+	printf("empty page\n");
+    else
+    {
+	printf("id: %0lx, size: %d, slots: %d, free_slots: %d, list: ",
+	       (long) page, page->slotsize, page->no_of_slots, page->no_of_free_slots);
+	fl = page->firstfree;
+	cnt = 0;
+	do
+	{
+	    printf("%d ", fl);
+	    fl = *((int *) ((float *) page->data + fl));
+	    cnt++;
+	} while (fl != -1 && cnt < 20);
+	if (fl != -1)
+	    printf("...");
+	printf("\n");
+    }
+}
+#endif
+
+/*****************************************************************************
+  FUNCTION : kr_np_floatmalloc
+
+  PURPOSE  : allocate pattern memory within a private memory page
+             <size> is based on sizeof(float) !!!
+  RETURNS  : float* pointer or NULL if
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static float *kr_np_floatmalloc(int size)
+{
+    struct patternpage *page;
+    int no_of_slots;
+    int i;
+    float *retval;
+
+    /* size must be >= 0 */
+    if (size < 0)
+	return NULL;
+
+    /* size must be at least big enough to hold the index free list */
+    if (size*sizeof(float) < sizeof(int))
+	size = ((sizeof(int)-1)/sizeof(float) + 1);
+
+    /* check for page with requested slotsize */
+    page = np_pages;
+    while (page != NULL && (page->slotsize != size || page->no_of_free_slots == 0))
+	page = page->next;
+
+    if (!page)
+    {
+	/* we need to allocate a new page */
+	no_of_slots = KRNP_FIXED_PAGESIZE/(size * sizeof(float));
+	if (no_of_slots < 1)
+	    no_of_slots = 1;
+
+	page = (struct patternpage *) malloc(sizeof(struct patternpage));
+	if (!page)
+	    return NULL;
+#ifdef DEBUG_PATTERN
+	printf("allocating 0x%lx bytes for new pattern page\n",
+	       size * no_of_slots * sizeof(float));
+#endif
+	page->data = (float *) malloc(size * no_of_slots * sizeof(float));
+	if (!page->data)
+	    return NULL;
+
+	page->slotsize = size;
+	page->no_of_slots = page->no_of_free_slots = no_of_slots;
+
+	/* this is tricky:
+	   one slot is at least big enough to hold one integer value.
+	   To optimize memory consumption, free list management is done
+	   in place: each empty slot stores the index (based on float *) to
+	   the next free slot.
+	*/
+	for (i=0; i<no_of_slots-1; i++)
+	{
+	    *((int *) ((float *) (page->data + i*size))) = (i+1)*size;
+	}
+	*((int *) ((float *) (page->data + (no_of_slots-1)*size))) = -1;
+
+	page->firstfree = 0;
+	page->next = np_pages;
+	np_pages = page;
+    }
+
+    /* here we have a page with at least one empty slot of right size: */
+    page->no_of_free_slots--;
+    retval = page->data + page->firstfree;
+    page->firstfree = *((int *) retval);
+
+#ifdef DEBUG_PATTERN
+    print_page_info(page);
+#endif
+
+    return retval;
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_floatfree
+
+  PURPOSE  : free the pattern memory within a private memory page
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_floatfree(float *ptr)
+{
+    struct patternpage *page;
+    struct patternpage *prev;
+
+    /* look for the page which includes the given address */
+    prev = NULL;
+    page = np_pages;
+    while (page != NULL && 
+	   (ptr < page->data || 
+	    ptr >= (page->data + page->no_of_slots*page->slotsize)))
+    {
+	prev = page;
+	page = page->next;
+    }
+
+    if (!page)
+	/* we have not allocated this memory slot !
+	   gracefull return but print out error */
+    {
+	fprintf(stderr, 
+		"kr_np_floatfree: function called with illegal argument\n");
+	return;
+    }
+
+    *((int *) ptr) = page->firstfree;
+    page->firstfree = (ptr - page->data);
+    page->no_of_free_slots++;
+
+    if (page->no_of_free_slots == page->no_of_slots)
+    {
+	/* page is no longer used, give it back to the OS */
+	free(page->data);
+	if (prev != NULL)
+	    prev->next = page->next;
+	else
+	    np_pages = page->next;
+	free(page);
+	page = NULL;
+    }
+
+#ifdef DEBUG_PATTERN
+    print_page_info(page);
+#endif
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_InitPattern
+
+  PURPOSE  : initialization of pattern descriptor array
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_InitPattern(void)
+{
+    int i;
+
+    TRACE_IN();
+
+    np_pat_sets = (np_pattern_descriptor **) 
+	malloc(NO_OF_PAT_SETS * sizeof(np_pattern_descriptor *));
+
+    np_pat_set_used = (bool *) 
+	malloc(NO_OF_PAT_SETS * sizeof(bool));
+
+    np_info = (np_pattern_set_info *) 
+	malloc(NO_OF_PAT_SETS * sizeof(np_pattern_set_info));
+
+    np_info_valid = (bool *) 
+	malloc(NO_OF_PAT_SETS * sizeof(bool));
+
+    np_st = (struct np_symtab **) 
+	malloc(NO_OF_PAT_SETS * sizeof(struct np_symtab *));
+
+    if (np_pat_sets == (np_pattern_descriptor **) NULL ||
+	np_info == (np_pattern_set_info *) NULL ||
+	np_info_valid == (bool *) NULL ||
+	np_st == (struct np_symtab **) NULL)
+    {
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+    }
+    else
+    {
+	np_used_pat_set_entries = NO_OF_PAT_SETS;
+	for (i=0; i<NO_OF_PAT_SETS; i++)
+	{
+	    np_pat_sets[i] = (np_pattern_descriptor *) NULL;
+	    np_pat_set_used[i] = FALSE;
+	    np_info_valid[i] = FALSE;
+	    np_st[i] = NULL;
+	}
+
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_np_ReallocatePatternSet
+
+  PURPOSE  : reallocates the pattern set <pat_set> to contain <new_number> 
+             of pattern entries.
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_ReallocatePatternSet(int pat_set, int new_number)
+{
+    np_pattern_descriptor *new_mem;
+
+    TRACE_IN();
+
+    /* check whether patterns are allocated */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    /* check whether the pattern set is present */
+    if (!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    /* reallocate array of pattern descriptors */
+    if (np_pat_sets[pat_set] != (np_pattern_descriptor *) NULL)
+    {
+	new_mem = (np_pattern_descriptor *) 
+	    realloc(np_pat_sets[pat_set],
+		    new_number * sizeof(np_pattern_descriptor));
+    }
+    else
+    {
+	new_mem = (np_pattern_descriptor *) 
+	    malloc(new_number * sizeof(np_pattern_descriptor));
+    }
+
+    if (new_mem == (np_pattern_descriptor *) NULL && new_number != 0)
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+    np_pat_sets[pat_set] = new_mem;
+
+    /* store number of allocated descriptors */
+    np_info[pat_set].pub.number_of_pattern = new_number;
+    np_info[pat_set].pub.virtual_no_of_pattern = new_number;
+    np_info_valid[pat_set] = FALSE; /* only number_of_pattern is valid */
+    /* do not revalidate here, since this done by the calling function! */
+
+    /* sucessfull return */
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_DeletePatternSet
+
+  PURPOSE  : delete a pattern set and free all memory
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_DeletePatternSet(int pat_set)
+{
+    int i;
+    np_pattern_descriptor *p;
+
+    TRACE_IN();
+
+    /* check for valid number of pattern set */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set<0 || pat_set>=np_used_pat_set_entries)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+	
+    p = np_pat_sets[pat_set];
+    if (!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    /* free all pattern */
+    for (i=0; i<np_info[pat_set].pub.number_of_pattern; i++)
+    {
+	kr_np_FreePattern(p);
+	p++;
+    }
+
+    /* free the pattern descriptors */ 
+    if (np_pat_sets[pat_set] != (np_pattern_descriptor *) NULL)
+	free(np_pat_sets[pat_set]);
+    np_pat_sets[pat_set] = (np_pattern_descriptor *) NULL;
+    np_pat_set_used[pat_set] = FALSE;
+
+    np_info[pat_set].pub.number_of_pattern = 0;
+    np_info[pat_set].pub.virtual_no_of_pattern = 0;
+    np_info_valid[pat_set] = FALSE;
+    np_current_pattern = (np_pattern_descriptor *) NULL;
+
+    /* free the symbol table */
+    while (np_st[pat_set])
+    {
+	struct np_symtab *help;
+
+	free(np_st[pat_set]->symname);
+	help = np_st[pat_set]->next;
+	free(np_st[pat_set]);
+	np_st[pat_set] = help;
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_DeletePattern
+
+  PURPOSE  : delete a specific pattern form a pattern set
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+             <pattern> is a physical pattern number
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_DeletePattern(int pat_set, int pattern)
+{
+    np_pattern_descriptor *p;
+    int i;
+
+    TRACE_IN();
+
+    /* check for valid number of pattern set */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set<0 || pat_set>=np_used_pat_set_entries)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+	
+    p = np_pat_sets[pat_set];
+    if (!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    if (pattern < 0 || pattern >= np_info[pat_set].pub.number_of_pattern)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN); }
+
+    /* free memory for the specified pattern */
+    p += pattern;
+    kr_np_FreePattern(p);
+
+    /* if classes available fix class information */
+    if (p->mysym != NULL)
+    {
+	p->mysym->set_amount--;
+	if (p->mysym->set_amount < p->mysym->chunk_amount)
+	    p->mysym->chunk_amount = p->mysym->set_amount;
+	if (p->mysym->set_amount <= 0)
+	{
+	    p->mysym->chunk_amount = 0;
+	    np_info[pat_set].pub.classes--;
+	    kr_np_delSym(pat_set, p->mysym);
+	}
+    }
+
+    /* move tail of array one position to fill up the empty entry */
+    for (i=pattern+1; i<np_info[pat_set].pub.number_of_pattern; i++)
+    {
+	(void) memcpy((char *) p, (char *) (p+1), sizeof(np_pattern_descriptor));
+	p++;
+    }
+
+    np_info_valid[pat_set] = FALSE;
+    /* do not revalidate here, since this done by the calling function */
+
+    /* last entry of the array is no longer active */
+    TRACE_RETURN(kr_np_ReallocatePatternSet(pat_set, 
+				   np_info[pat_set].pub.number_of_pattern-1));
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_delSym
+
+  PURPOSE  : Delete the symbol table entry from the given pattern set.
+
+  RETURNS  : 
+  NOTES    : don't call this function. This function is only to be
+             called by the parser or by functions inside this module
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_delSym(int pat_set, struct np_symtab *entry)
+{
+    struct np_symtab *list;
+    struct np_symtab *last = NULL;
+    int i;
+
+    TRACE_IN();
+
+    list = np_st[pat_set];
+    while (list != NULL && list != entry)
+    {
+	last = list;
+	list = list->next;
+    }
+    
+    if (list != NULL && list == entry)
+    {
+	if (last != NULL)
+	    last -> next = list->next;
+	else
+	    np_st[pat_set] = list->next;
+
+	if (list->symname != NULL)
+	    free(list->symname);
+	if (list->pat_nums != NULL)
+	    free(list->pat_nums);
+	free(list);
+    }
+    else
+    {
+	/* symbol must be in the list of the given pattern
+           set. Otherwise an error inside the pattern handling occured
+           at some other place.... */
+
+	fprintf(stderr, "internal error, file %s, line %d", __FILE__, __LINE__);
+    }
+
+    list = np_st[pat_set];
+    i = 0;
+    while (list)
+    {
+	list->symnum = i++;
+	list = list->next;
+    }
+
+    { TRACE_RETURN_VOID(); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_AddPattern
+
+  PURPOSE  : Add an empty pattern descriptor to the specified pattern set. 
+             The position of the pattern inside the set is returned 
+             in <pattern>.
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_AddPattern(int pat_set, int *pattern)
+{
+    krui_err err;
+    np_pattern_descriptor *p;
+    int number;
+
+    TRACE_IN();
+
+    /* check for valid number of pattern set */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set<0 || pat_set>=np_used_pat_set_entries)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+	
+    p = np_pat_sets[pat_set];
+    if (!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    number = np_info[pat_set].pub.number_of_pattern + 1;
+    err = kr_np_ReallocatePatternSet(pat_set, number);
+
+    if (err != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err); }
+
+    p = np_pat_sets[pat_set];
+    p += (number-1);
+
+    /* initialize part of the new pattern descriptors */
+    {
+	p -> pub.input_fixsize = 0;
+	p -> pub.output_fixsize = 0;
+	p -> pub.input_dim = 0;
+	p -> pub.output_dim = 0;
+	p -> pub.my_class = -1;
+	p -> input_pattern = (float *) NULL;
+	p -> output_pattern = (float *) NULL;
+	p -> mysym = (struct np_symtab *) NULL;
+    }
+
+    *pattern = (number-1);
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_LoadPatternFile
+
+  PURPOSE  : loads new or old pattern file from pat_file. The number of the 
+             associated pattern set is returned in pat_set.
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_LoadPatternFile(FILE *pat_file, int *pat_set)
+{
+    int i;
+    bool free;
+    krui_err err_code = KRERR_NO_ERROR;
+    int pattern_set;
+    np_pattern_set_info set_info;
+
+    TRACE_IN();
+
+    /* be sure to have a place where to put the patterns */
+    if (np_used_pat_set_entries == 0)
+    {
+	/* never patterns allocated */
+	err_code = kr_np_InitPattern();
+	if (err_code != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err_code); }
+    }
+    else
+    {
+	free = FALSE;
+
+	/* check for free entry before starting parser */
+	for (i=0; i<np_used_pat_set_entries; i++)
+	{
+	    if (!np_pat_set_used[i])
+	    {
+		free = TRUE;
+		break;
+	    }
+	}
+
+	if (!free)
+	    { TRACE_RETURN(KRERR_NP_NO_MORE_ENTRIES); }	    
+    }
+
+    /* reset the scanner and the parser */
+    scanner_init_scanner(pat_file);
+
+    /* parse pattern file and check for errors */
+    if (parse_pattern_file(&pattern_set, &set_info) != 0)
+    {
+	(void) kr_np_DeletePatternSet(pattern_set);
+	{ TRACE_RETURN(KRERR_FILE_FORMAT); }
+    }
+    else
+    {
+	int i;
+	struct np_symtab *list;
+
+	*pat_set = pattern_set;
+	np_info[pattern_set].pub.classes = set_info.pub.classes;
+	np_info[pattern_set].pub.class_names = set_info.pub.class_names;
+	np_info[pattern_set].pub.class_distrib_active = set_info.pub.class_distrib_active;
+	np_info[pattern_set].pub.class_redistribution = set_info.pub.class_redistribution;
+
+	list = np_st[pattern_set];
+	i = 0;
+	while (list)
+	{
+	    if (np_info[pattern_set].pub.class_distrib_active)
+		list->chunk_amount =
+		    np_info[pattern_set].pub.class_redistribution[i];
+	    else
+		list->chunk_amount = list->set_amount;
+	    i++;
+	    list = list -> next;
+	}
+
+	np_info[pattern_set].pub.remap_function = set_info.pub.remap_function;
+	np_info[pattern_set].pub.no_of_remap_params = set_info.pub.no_of_remap_params;
+	for (i=0; i<NO_OF_REMAP_PARAMS; i++)
+	    np_info[pattern_set].pub.remap_params[i] = set_info.pub.remap_params[i];
+
+	if (np_info[pattern_set].pub.remap_function != NULL)
+	{
+	    struct FuncInfoDescriptor func_descr;
+	    
+	    func_descr.func_type = REMAP_FUNC;
+	    strcpy(func_descr.func_name, np_info[pattern_set].pub.remap_function);
+	    err_code = krf_getFuncInfo(SEARCH_FUNC, &func_descr);
+
+	    if (err_code == KRERR_NO_ERROR)
+	    {
+		np_info[pattern_set].rmf_ptr = (RemapFuncPtr) func_descr.function;
+		if (np_info[pattern_set].pub.no_of_remap_params 
+		    != func_descr.no_of_input_parameters)
+		{
+		    np_info[pattern_set].rmf_ptr = NULL;
+		    np_info[pattern_set].pub.remap_function = NULL;
+		    np_info[pattern_set].pub.no_of_remap_params = 0;
+		    err_code = KRERR_PARAMETERS;
+		}
+	    }
+	    else
+	    {
+		np_info[pattern_set].rmf_ptr = NULL;
+		np_info[pattern_set].pub.remap_function = NULL;		
+		np_info[pattern_set].pub.no_of_remap_params = 0;	
+	    }
+	}
+	{ TRACE_RETURN(err_code); }
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_SavePatternFile
+
+  PURPOSE  : save the pattern set pat_set to out_file
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_SavePatternFile(FILE *out_file, int pat_set)
+{
+    np_pattern_set_info info;
+    krui_err err_code;
+    int i, j, n;
+    int with_classes = 0;
+    float *in_pat, *out_pat;
+    time_t clock;
+    
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set<0 || pat_set>=np_used_pat_set_entries)
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+	
+    if (!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    err_code = kr_np_GetInfo(pat_set, &info);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    if (info.pub.number_of_pattern == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    fprintf(out_file, "SNNS pattern definition file V%d.%d\n",
+	    CURRENT_VERSION_V, CURRENT_VERSION_R);
+    clock = time((time_t *) NULL);
+    fprintf(out_file, "generated at %s\n\n", (char *) ctime(&clock));
+    fprintf(out_file, "No. of patterns : %d\n", info.pub.number_of_pattern);
+    fprintf(out_file, "No. of input units : %d\n", info.pub.in_fixsize);
+    if (info.pub.out_fixsize != 0)
+	fprintf(out_file, "No. of output units : %d\n", info.pub.out_fixsize);
+    if (info.pub.in_number_of_dims != 0)
+    {
+	fprintf(out_file, "No. of variable input dimensions : %d\n", 
+		info.pub.in_number_of_dims);
+	fprintf(out_file, "Maximum input dimensions : [ ");
+	for (i=0; i<info.pub.in_number_of_dims; i++)
+	{
+	    fprintf(out_file, "%d ", info.pub.in_max_dim_sizes[i]);
+	}
+	fprintf(out_file, "]\n");
+    }
+    if (info.pub.out_fixsize != 0 && info.pub.out_number_of_dims != 0)
+    {
+	fprintf(out_file, "No. of variable output dimensions : %d\n", 
+		info.pub.out_number_of_dims);
+	fprintf(out_file, "Maximum output dimensions : [ ");
+	for (i=0; i<info.pub.out_number_of_dims; i++)
+	{
+	    fprintf(out_file, "%d ", info.pub.out_max_dim_sizes[i]);
+	}
+	fprintf(out_file, "]\n");
+    }
+    if (info.pub.classes > 0)
+    {
+	with_classes = 1;
+	fprintf(out_file, "No. of classes : %d\n", info.pub.classes);
+	if (info.pub.class_distrib_active)
+	{
+	    fprintf(out_file, "Class redistribution : [ ");
+	    for (i=0; i<info.pub.classes; i++)
+		fprintf(out_file, "%d ", info.pub.class_redistribution[i]);
+	    fprintf(out_file, "]\n");
+	}
+    }
+    if (info.pub.remap_function)
+    {
+	fprintf(out_file, "Remap function : %s\n",
+		info.pub.remap_function);
+	if (info.pub.no_of_remap_params > 0)
+	{
+	    fprintf(out_file, "Remap parameters : [ ");
+	    for (i=0; i<info.pub.no_of_remap_params; i++)
+		fprintf(out_file, "%g ", info.pub.remap_params[i]);
+	    fprintf(out_file, "]\n");
+	}
+    }
+    fprintf(out_file, "\n");
+
+    for (j=0; j<info.pub.number_of_pattern; j++)
+    {
+	if (np_pat_sets[pat_set][j].pub.input_fixsize > 0)
+	{
+	    fprintf(out_file, "# Input pattern %d:\n", j+1);
+	    n = info.pub.in_fixsize;
+	    if (info.pub.in_number_of_dims != 0)
+	    {
+		fprintf(out_file, "[ ");
+		for (i=0; i<np_pat_sets[pat_set][j].pub.input_dim; i++)
+		{
+		    fprintf(out_file, "%d ", 
+			    np_pat_sets[pat_set][j].pub.input_dim_sizes[i]);
+		    n *= np_pat_sets[pat_set][j].pub.input_dim_sizes[i];
+		}
+		fprintf(out_file, "]\n");
+	    }
+	    in_pat = np_pat_sets[pat_set][j].input_pattern;
+	    for (i=0; i<n; i++)
+	    {
+		fprintf(out_file, "%g ", *in_pat++);
+		if (i == n - 1 || i%10 == 9)
+		    fprintf(out_file, "\n");
+	    }
+	}
+
+	if (np_pat_sets[pat_set][j].pub.output_fixsize > 0)
+	{
+	    fprintf(out_file, "# Output pattern %d:\n", j+1);
+	    n = info.pub.out_fixsize;
+	    if (info.pub.out_number_of_dims != 0)
+	    {
+		fprintf(out_file, "[ ");
+		for (i=0; i<np_pat_sets[pat_set][j].pub.output_dim; i++)
+		{
+		    fprintf(out_file, "%d ", 
+			    np_pat_sets[pat_set][j].pub.output_dim_sizes[i]);
+		    n *= np_pat_sets[pat_set][j].pub.output_dim_sizes[i];
+		}
+		fprintf(out_file, "]\n");
+	    }
+	    out_pat = np_pat_sets[pat_set][j].output_pattern;
+	    for (i=0; i<n; i++)
+	    {
+		fprintf(out_file, "%g ", *out_pat++);
+		if (i == n - 1 || i%10 == 9)
+		    fprintf(out_file, "\n");
+	    }
+	}
+
+	if (with_classes)
+	{
+	    fprintf(out_file, "# Class:\n");
+	    fprintf(out_file, "%s\n", np_pat_sets[pat_set][j].mysym->symname);
+	}
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_GetInfo
+
+  PURPOSE  : get some information about the specified pattern set
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_GetInfo(int pat_set, np_pattern_set_info *info)
+{
+    krui_err err_code;
+
+    TRACE_IN();
+
+    err_code = kr_np_ValidateInfo(pat_set);
+    if (err_code == KRERR_NO_ERROR)
+	*info = np_info[pat_set];;
+
+    { TRACE_RETURN(err_code); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_ValidateInfo
+
+  PURPOSE  : update pattern set information if necessary
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_ValidateInfo(int pat_set)
+{
+    int i, j;
+    np_pattern_descriptor *p;
+
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set < 0 || pat_set >= np_used_pat_set_entries ||
+	!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    if (np_info_valid[pat_set] && np_abs_count_valid && np_pat_mapping_valid)
+    {
+	{ TRACE_RETURN(KRERR_NO_ERROR); }
+    }
+
+    /* controlled by np_info_valid flag: */
+    if (!np_info_valid[pat_set])
+    {
+	p = np_pat_sets[pat_set];
+	np_info[pat_set].pub.fixed_fixsizes = TRUE;
+	if (np_info[pat_set].pub.number_of_pattern > 0 && p != (np_pattern_descriptor *) NULL)
+	{
+	    np_info[pat_set].pub.output_present = p-> pub.output_fixsize != 0;
+	    np_info[pat_set].pub.in_fixsize = p -> pub.input_fixsize;
+	    np_info[pat_set].pub.out_fixsize = p-> pub.output_fixsize;
+	    np_info[pat_set].pub.in_number_of_dims = p->pub.input_dim;
+	    np_info[pat_set].pub.out_number_of_dims = p->pub.output_dim;
+
+	    for (j=0; j < p->pub.input_dim; j++)
+	    {
+		(np_info[pat_set].pub.in_max_dim_sizes)[j] = (np_info[pat_set].pub.in_min_dim_sizes)[j] =
+		    (p -> pub.input_dim_sizes)[j];
+	    }
+	    for (j=0; j < p->pub.output_dim; j++)
+	    {
+		(np_info[pat_set].pub.out_max_dim_sizes)[j] = (np_info[pat_set].pub.out_min_dim_sizes)[j] =
+		    (p -> pub.output_dim_sizes)[j];
+	    }
+	}
+    
+	p = np_pat_sets[pat_set];
+	for (i=0; i<np_info[pat_set].pub.number_of_pattern; i++)
+	{
+	    if (p -> pub.input_fixsize != np_info[pat_set].pub.in_fixsize)
+	    {
+		np_info[pat_set].pub.fixed_fixsizes = FALSE;
+		np_info[pat_set].pub.in_fixsize = -1;
+	    }
+	    if (p -> pub.output_fixsize != np_info[pat_set].pub.out_fixsize)
+	    {
+		np_info[pat_set].pub.fixed_fixsizes = FALSE;
+		np_info[pat_set].pub.out_fixsize = -1;
+	    }
+
+	    for (j=0; j < p->pub.input_dim; j++)
+	    {
+		if ((p -> pub.input_dim_sizes)[j] > (np_info[pat_set].pub.in_max_dim_sizes)[j])
+		    (np_info[pat_set].pub.in_max_dim_sizes)[j] = p -> pub.input_dim_sizes[j];
+		if ((p -> pub.input_dim_sizes)[j] < (np_info[pat_set].pub.in_min_dim_sizes)[j])
+		    (np_info[pat_set].pub.in_min_dim_sizes)[j] = p -> pub.input_dim_sizes[j];
+	    }
+	    for (j=0; j < p->pub.output_dim; j++)
+	    {
+		if ((p -> pub.output_dim_sizes)[j] > (np_info[pat_set].pub.out_max_dim_sizes)[j])
+		    (np_info[pat_set].pub.out_max_dim_sizes)[j] = p -> pub.output_dim_sizes[j];
+		if ((p -> pub.output_dim_sizes)[j] < (np_info[pat_set].pub.out_min_dim_sizes)[j])
+		    (np_info[pat_set].pub.out_min_dim_sizes)[j] = p -> pub.output_dim_sizes[j];
+	    }
+	    p++;
+	}
+	np_info[pat_set].pub.virtual_no_of_pattern = np_info[pat_set].pub.number_of_pattern;
+	np_info_valid[pat_set] = TRUE;
+    }
+
+    if (!np_pat_mapping_valid)
+    {
+	/* reallocate and refill class information */
+	if (np_info[pat_set].pub.classes > 0)
+	{
+	    struct np_symtab *list;
+	    int count=0;
+	    int global_chunks = 0;
+	    int total_virtual = 0;
+
+	    p = np_pat_sets[pat_set];
+	    for (i=0; i<np_info[pat_set].pub.number_of_pattern; i++)
+	    {
+		p->pub.my_class = p->mysym ? p->mysym->symnum : -1;
+		p++;
+	    }
+
+#ifdef DEBUG_CLASSES
+	    TRACE_INDENT();
+	    printf("%s: there are now %d classes:\n", __FUNCTION__, np_info[pat_set].pub.classes);
+#endif
+
+	    np_info[pat_set].chunk_order_valid = FALSE;
+
+	    if (np_info[pat_set].pub.class_names)
+		np_info[pat_set].pub.class_names = 
+		    (char **) realloc(np_info[pat_set].pub.class_names, 
+				      np_info[pat_set].pub.classes * sizeof(char *));
+	    else
+		np_info[pat_set].pub.class_names = 
+		    (char **) malloc(np_info[pat_set].pub.classes * sizeof(char *));
+	
+	    if (np_info[pat_set].pub.class_redistribution)
+		np_info[pat_set].pub.class_redistribution = 
+		    (int *) realloc(np_info[pat_set].pub.class_redistribution, 
+				    np_info[pat_set].pub.classes * sizeof(int));
+	    else
+		np_info[pat_set].pub.class_redistribution = 
+		    (int *) malloc(np_info[pat_set].pub.classes * sizeof(int));
+	
+	    if (!(np_info[pat_set].pub.class_names) || !(np_info[pat_set].pub.class_redistribution))
+		{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+	    list = np_st[pat_set];
+	    while (count < np_info[pat_set].pub.classes && list != NULL)
+	    {
+		np_info[pat_set].pub.class_names[count] = list->symname;
+		np_info[pat_set].pub.class_redistribution[count] = list->chunk_amount;
+	    
+		list->my_chunks_per_set = (list->chunk_amount > 0) ?
+		    (list->set_amount-1)/list->chunk_amount + 1 : 0;
+
+		if (list->my_chunks_per_set > global_chunks)
+		    global_chunks = list->my_chunks_per_set;
+
+		count++;
+		list = list->next;
+	    }
+	    if (count != np_info[pat_set].pub.classes || list != NULL)
+	    {
+		fprintf(stderr, "internal error, file %s, line %d\n",
+			__FILE__, __LINE__);
+		{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	    }
+	    list = np_st[pat_set];
+	    count = 0;
+	    while (list != NULL)
+	    {
+		int n;
+
+		list->global_chunks = global_chunks;
+
+#ifdef DEBUG_CLASSES
+		TRACE_INDENT();
+		printf("%s: index %d, name %s, set amount %d, chunk amount %d\n", 
+		       __FUNCTION__, count, list->symname,
+		       list->set_amount, list->chunk_amount);
+#endif
+
+		n = list->global_chunks * list->chunk_amount;
+		if (n < list->set_amount)
+		    n = list->set_amount;
+		if (n > list->pat_nums_size)
+		{
+		    if (list->pat_nums != NULL)
+			free(list->pat_nums);
+		    list->pat_nums_size = 0;
+		    list->pat_nums = (int *) malloc(n * sizeof(int));
+		    if (list->pat_nums == NULL && n != 0)
+			{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+		    list->pat_nums_size = n;
+		}
+
+#ifdef DEBUG_CLASSES
+		TRACE_INDENT();
+		printf("%s: epoch chunks %d, pat nums table %d\n",
+		       __FUNCTION__, list->global_chunks, list->pat_nums_size);
+#endif
+
+		total_virtual += list->global_chunks * list->chunk_amount;
+		count++;
+		list = list->next;
+	    }
+	    if (np_info[pat_set].pub.class_distrib_active)
+	    {
+		np_info[pat_set].pub.virtual_no_of_pattern = total_virtual;
+		kr_np_order_chunk_arrays(FALSE, pat_set);
+	    }
+	    else
+		np_info[pat_set].pub.virtual_no_of_pattern = 
+		    np_info[pat_set].pub.number_of_pattern;
+	}
+
+#ifdef DEBUG_CLASSES
+	TRACE_INDENT();
+	printf("%s: physical %d, virtual %d, chunk active %s\n",
+	       __FUNCTION__, 
+	       np_info[pat_set].pub.number_of_pattern, 
+	       np_info[pat_set].pub.virtual_no_of_pattern,
+	       np_info[pat_set].pub.class_distrib_active ? "TRUE" : "FALSE");
+#endif
+
+	if (!kr_np_allocate_pat_mapping_entries(np_info[pat_set].pub.virtual_no_of_pattern))
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	kr_np_fill_virtual_to_void_mapping(pat_set);
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_GetSubPatSizes
+
+  PURPOSE  : Depending on the current pattern set and the sub pattern 
+  training scheme, which must be defined, the size of the first input sub 
+  pattern and the size of the first output sub pattern is computed.
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_GetSubPatSizes(int *input_size, int *output_size)
+{
+    int pat_set;
+    np_pattern_descriptor *pattern;
+    int i;
+
+    TRACE_IN();
+
+    if (!npui_train_defined)
+	{ TRACE_RETURN(KRERR_NP_NO_TRAIN_SCHEME); }
+
+    pat_set = npui_pat_sets[npui_curr_pat_set];
+    pattern = &(np_pat_sets[pat_set][0]);
+
+    *input_size = pattern -> pub.input_fixsize;
+    for (i=0; i<pattern -> pub.input_dim; i++)
+    {
+	*input_size *= np_t_insize[i];
+    }
+
+    *output_size = pattern -> pub.output_fixsize;
+    for (i=0; i<pattern -> pub.output_dim; i++)
+    {
+	*output_size *= np_t_outsize[i];
+    }
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_GetSubPat
+
+  PURPOSE  : copy a sub pattern into another area 
+
+A sub pattern is cut out of the current pattern at position
+<pos_coord> with size <size_coord>. According to <input> the input
+part or the output part of the current pattern is used. A pointer to
+an array of float which contains the cut part is returned in <data>.
+<pos_coord> is an array of int which defines the position of the sub
+pattern inside the variable sized dimensions of the pattern.
+<size_coord> is an array of int which defines the size of the sub
+pattern in each dimensional direction. Both arrays must contain
+<input_dim> (or <output_dim>) entries (see pattern descriptor).
+
+Example: pattern with input_fixsize 2, input_dim 2, input_dim_sizes [4 5]
+(hint: the values of the pattern represent the position)
+
+{
+0.00, 0.01, 0.10, 0.11, 0.20, 0.21, 0.30, 0.31, 0.40, 0.41,
+1.00, 1.01, 1.10, 1.11, 1.20, 1.21, 1.30, 1.31, 1.40, 1.41,
+2.00, 2.01, 2.10, 2.11, 2.20, 2.21, 2.30, 2.31, 2.40, 2.41,
+3.00, 3.01, 3.10, 3.11, 3.20, 3.21, 3.30, 3.31, 3.40, 3.41,
+}
+
+the sub pattern with <pos_coord> [1 2], <size_coord> [3 2] looks like
+this:
+
+{
+1.20, 1.21, 1.30, 1.31,
+2.20, 2.21, 2.30, 2.31,
+3.20, 3.21, 3.30, 3.31,
+}
+
+The parameter entries returns the number of entries in the data field.
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_GetSubPat(bool input, int *pos_coord, int *size_coord,
+				float **data, int *entries)
+{
+    int u_dim;                   /* copy of all necessary variables from */
+    int u_size;                  /* pattern descriptor, depending on */
+    int *u_dim_sizes;            /* <input> */
+    float *u_pattern;
+    int npu_subpatsize;
+    float *npu_subpat;
+
+    int f_size;                  /* size of copy area */
+    int i;
+    int c[MAX_NO_OF_VAR_DIM];    /* counter for the dimensions */
+    int copy_size;               /* size of copy block for each memcpy */
+    float *cf;                   /* pointer into pattern (copy source) */
+    float *cdest;                /* copy destination */
+    bool stop;                   /* TRUE if all done */
+    int offset;                  /* offset in multidimensional array */
+
+    krui_err err;
+
+    int set = npui_pat_sets[npui_curr_pat_set];
+
+    TRACE_IN();
+
+    /* check for valid pattern */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (np_current_pattern == (np_pattern_descriptor *) NULL)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    /* make a copy of all pattern info to work with */
+    if (input)
+    {
+	u_dim = np_current_pattern -> pub.input_dim;
+	u_size = np_current_pattern -> pub.input_fixsize;
+	u_dim_sizes = np_current_pattern -> pub.input_dim_sizes;
+	u_pattern = np_current_pattern -> input_pattern;
+	npu_subpatsize = np_i_subpatsize;
+	npu_subpat = np_i_subpat;
+    }
+    else
+    {
+	u_dim = np_current_pattern -> pub.output_dim;
+	u_size = np_current_pattern -> pub.output_fixsize;
+	u_dim_sizes = np_current_pattern -> pub.output_dim_sizes;
+	u_pattern = np_current_pattern -> output_pattern;
+	npu_subpatsize = np_o_subpatsize;
+	npu_subpat = np_o_subpat;
+    }
+
+    /* check whether this pattern exists */
+    if (u_size == 0)
+    {
+	if (input)
+	    { TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN); }
+	else
+	{
+	    /* this may be a network without output neurons, so don't */
+	    /* produce an error but set the data pointer to NULL */
+
+	    *data = (float *) NULL;
+	    if (entries != (int *) NULL)
+		*entries = 0;
+	    { TRACE_RETURN(KRERR_NO_ERROR); }
+	}
+    }
+
+    /* calculate size of the sub pattern and check dimensions */
+    f_size = u_size;
+    for (i=0; i<u_dim; i++)
+    {
+	f_size *= size_coord[i];
+	if (pos_coord[i] + size_coord[i] > u_dim_sizes[i])
+	    { TRACE_RETURN(KRERR_NP_DIMENSION); }
+	c[i] = 0;
+    }
+
+    /* allocate space for sub pattern if necessary */
+    if (f_size > npu_subpatsize)
+    {
+	if (npu_subpat != (float *) NULL)
+	    free(npu_subpat);
+	npu_subpat = (float *) malloc(f_size * sizeof(float));
+	if (npu_subpat == (float *) NULL && f_size != 0)
+	{
+	    { TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+	}
+	npu_subpatsize = f_size;
+
+	/* copy back new address and size */
+	if (input)
+	{
+	    np_i_subpatsize = npu_subpatsize;
+	    np_i_subpat = npu_subpat;
+	}
+	else
+	{
+	    np_o_subpatsize = npu_subpatsize;
+	    np_o_subpat = npu_subpat;
+	}
+    }
+
+
+    /* calculate size of one copy block. this includes the size of the */
+    /* dimension with highest index (least significant dimension) */
+    copy_size = u_size;
+    if (u_dim>0)
+	copy_size *= size_coord[u_dim-1];
+
+    /* copy the sub pattern */
+    cdest = npu_subpat;
+    do
+    {
+	/* calculate offset in source pattern */
+	offset = 0;
+	for (i=0; i<u_dim; i++)
+	{
+	    offset *= u_dim_sizes[i];
+	    offset += pos_coord[i] + c[i];
+	}
+	offset *= u_size;
+	cf = u_pattern + offset;
+
+	/* copy part of the pattern. this inlcudes the least significant */
+	/* dimension */
+	(void) memcpy((char *) cdest, (char *) cf, copy_size * sizeof(float));
+	cdest += copy_size;
+
+	/* count the dimensions and check whether we have to go on. */
+	/* the least significant dimension is omitted, because it is already */
+	/* copied */
+	stop = TRUE;
+	for (i=u_dim-2; i>=0; i--)
+	{
+	    c[i]++;
+	    if (c[i] == size_coord[i])
+		c[i] = 0;
+	    else
+	    {
+		stop = FALSE;
+		break;
+	    }
+	}
+    } while (!stop);
+
+    /* remaping if necessary */
+    if (!input && np_info[set].rmf_ptr != NULL)
+    {
+	err = np_info[set].rmf_ptr(npu_subpat, f_size,
+				   np_info[set].pub.remap_params,
+				   np_info[set].pub.no_of_remap_params);
+	if (err != KRERR_NO_ERROR)
+	    { TRACE_RETURN(err); }
+    }
+
+    /* all done, return results */
+    *data = npu_subpat;
+    if (entries != (int *) NULL)
+	*entries = f_size;
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_SetSubPat
+
+  PURPOSE  : copy another area into a sub pattern
+
+A sub pattern is cut out of the current pattern at position
+<pos_coord> with size <size_coord>. According to <input> the input
+part or the output part of the current pattern is used. 
+<pos_coord> is an array of int which defines the position of the sub
+pattern inside the variable sized dimensions of the pattern.
+<size_coord> is an array of int which defines the size of the sub
+pattern in each dimensional direction. Both arrays must contain
+<input_dim> (or <output_dim>) entries (see pattern descriptor).
+
+Example: pattern with input_fixsize 2, input_dim 2, input_dim_sizes [4 5]
+(hint: the values of the pattern represent the position)
+
+{
+0.00, 0.01, 0.10, 0.11, 0.20, 0.21, 0.30, 0.31, 0.40, 0.41,
+1.00, 1.01, 1.10, 1.11, 1.20, 1.21, 1.30, 1.31, 1.40, 1.41,
+2.00, 2.01, 2.10, 2.11, 2.20, 2.21, 2.30, 2.31, 2.40, 2.41,
+3.00, 3.01, 3.10, 3.11, 3.20, 3.21, 3.30, 3.31, 3.40, 3.41,
+}
+
+the sub pattern with <pos_coord> [1 2], <size_coord> [3 2] looks like
+this:
+
+{
+1.20, 1.21, 1.30, 1.31,
+2.20, 2.21, 2.30, 2.31,
+3.20, 3.21, 3.30, 3.31,
+}
+
+The parameter entries returns the number of entries in the data field.
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_SetSubPat(bool input, int *pos_coord, int *size_coord,
+				float *data, int entries)
+{
+    int u_dim;                   /* copy of all necessary variables from */
+    int u_size;                  /* pattern descriptor, depending on */
+    int *u_dim_sizes;            /* <input> */
+    float *u_pattern;
+
+    int f_size;                  /* size of copy area */
+    int i;
+    int c[MAX_NO_OF_VAR_DIM];    /* counter for the dimensions */
+    int copy_size;               /* size of copy block for each memcpy */
+    float *cf;                   /* pointer into pattern (copy destination) */
+    float *csource;              /* copy source */
+    bool stop;                   /* TRUE if all done */
+    int offset;                  /* offset in multidimensional array */
+
+    TRACE_IN();
+
+    /* check for valid pattern */
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (np_current_pattern == (np_pattern_descriptor *) NULL)
+	{ TRACE_RETURN(KRERR_NP_NO_CURRENT_PATTERN); }
+
+    /* make a copy of all pattern info to work with */
+    if (input)
+    {
+	u_dim = np_current_pattern -> pub.input_dim;
+	u_size = np_current_pattern -> pub.input_fixsize;
+	u_dim_sizes = np_current_pattern -> pub.input_dim_sizes;
+	u_pattern = np_current_pattern -> input_pattern;
+    }
+    else
+    {
+	u_dim = np_current_pattern -> pub.output_dim;
+	u_size = np_current_pattern -> pub.output_fixsize;
+	u_dim_sizes = np_current_pattern -> pub.output_dim_sizes;
+	u_pattern = np_current_pattern -> output_pattern;
+    }
+
+    /* check whether this pattern exists or whether all is done */
+    if (u_size == 0)
+    {
+	if (entries == 0)
+	    { TRACE_RETURN(KRERR_NO_ERROR); }
+	else
+	    { TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN); }
+    }
+
+    /* calculate size of the sub pattern and check dimensions */
+    f_size = u_size;
+    for (i=0; i<u_dim; i++)
+    {
+	f_size *= size_coord[i];
+	if (pos_coord[i] + size_coord[i] > u_dim_sizes[i])
+	    { TRACE_RETURN(KRERR_NP_DIMENSION); }
+	c[i] = 0;
+    }
+
+    /* check whether calculated space fits the delievered data block */
+    if (f_size != entries)
+	{ TRACE_RETURN(KRERR_NP_DOES_NOT_FIT); }
+
+    /* calculate size of one copy block. this includes the size of the */
+    /* dimension with highest index (least significant dimension) */
+    copy_size = u_size;
+    if (u_dim>0)
+	copy_size *= size_coord[u_dim-1];
+
+    /* copy the sub pattern */
+    csource = data;
+    do
+    {
+	/* calculate offset in destination pattern */
+	offset = 0;
+	for (i=0; i<u_dim; i++)
+	{
+	    offset *= u_dim_sizes[i];
+	    offset += pos_coord[i] + c[i];
+	}
+	offset *= u_size;
+	cf = u_pattern + offset;
+
+	/* copy part of the pattern. this inlcudes the least significant */
+	/* dimension */
+	(void) memcpy((char *) cf, (char *)csource, copy_size * sizeof(float));
+	csource += copy_size;
+
+	/* count the dimensions and check whether we have to go on. */
+	/* the least significant dimension is omitted, because it is already */
+	/* copied */
+	stop = TRUE;
+	for (i=u_dim-2; i>=0; i--)
+	{
+	    c[i]++;
+	    if (c[i] == size_coord[i])
+		c[i] = 0;
+	    else
+	    {
+		stop = FALSE;
+		break;
+	    }
+	}
+    } while (!stop);
+
+    /* all done, return results */
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_align_sub_pos
+
+  PURPOSE  : For a given pattern dimension size <psize> of <dim>
+             dimensions and a given sub pattern size <ssize> the position
+	     <spos> of the sub pattern is alligned to a valid position
+	     and the ordering number of this sub pattern is returned
+	     in <n>. The shift pattern given in <sstep> is used to
+	     find valid allignment positions
+
+  RETURNS  : TRUE if succesfull, FALSE if inconsistent parameters
+
+             <n> starts with 0 and ends with <number of possible
+	     positions> - 1
+	     <spos> gives the new aligned position
+
+  NOTES    : internal function
+
+  UPDATE   : 
+******************************************************************************/
+static bool kr_np_align_sub_pos(int dim, int *n, int *psize, int *ssize, 
+				int *sstep, int *spos)
+{
+    int ns[MAX_NO_OF_VAR_DIM];
+    register int i;
+    register int ts = 0;
+
+    TRACE_IN();
+
+    for (i=0; i<dim; i++)
+    {
+	/* calculate how much steps could be made in each dimension */
+	ns[i] = (psize[i] - ssize[i] + sstep[i]) / sstep[i];
+	if (ns[i] == 0)
+	    { TRACE_RETURN(FALSE); }
+
+	/* align the position of this dimension */
+	spos[i] -= spos[i] % sstep[i];
+	if (spos[i]+ssize[i] >= psize[i]+1)
+	    spos[i] = 0;
+
+	/* add the position of this dimension to the absolute position */
+	ts *= ns[i];
+	ts += spos[i]/sstep[i];
+    }
+
+    *n = ts;
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_gen_sub_pos
+
+  PURPOSE  : For a given pattern dimension size <psize> of <dim>
+             dimensions and a given sub pattern size <ssize> the position
+	     <spos> of the <n>th sub pattern is calculated. The shift
+	     pattern given in <sstep> is used to move sub pattern over
+	     the pattern.
+
+	     If <count> is TRUE, only the number of possible positions
+	     is determined and returned in <n> if at least 1 valid
+	     position exists. <spos> is of no effect and may be NULL.
+
+  RETURNS  : TRUE if the <n>th subpattern exists or if <count> is TRUE
+             and at least 1 valid position exists, FALSE if <n> < 0.
+	     If <n> is higher than the available number of subpattern, a 
+	     wraparound occurs.
+
+             <n> starts with 0 and ends with <number of possible
+	     positions> - 1 or returns number of possible positions.
+
+  NOTES    : internal function
+
+  UPDATE   : 
+******************************************************************************/
+static bool kr_np_gen_sub_pos(int dim, int *n, int *psize, int *ssize, 
+			      int *sstep, int *spos, bool count)
+{
+    int ns[MAX_NO_OF_VAR_DIM];
+    int i;
+    int ts;
+    int nn;
+
+    TRACE_IN();
+
+    nn = *n;
+
+    /* calculate how much steps could be made in each dimension */
+    /* and the total number of positions ts (define the bases of a */
+    /* multi base numerative system and determine the highest */
+    /* representable number) */
+    ts = 1;
+    for (i=dim-1; i>=0; i--)
+    {
+	ns[i] = (psize[i] - ssize[i] + sstep[i]) / sstep[i];
+	if (ns[i] == 0)
+	    { TRACE_RETURN(FALSE); }
+	ts *= ns[i];
+    }
+
+    /* check whether this is all what we want to do now */
+    if (count)
+    {
+	*n = ts;
+	{ TRACE_RETURN(TRUE); }
+    }
+	
+    /* check range of requested step position */ 
+    if (nn<0)
+	{ TRACE_RETURN(FALSE); }
+
+    /* if requested position is higher than available positions, perform */
+    /* wraparaound (this is usefull/necessary for pattern without subpattern */
+    nn = nn%ts;
+
+    /* calculate step position of the <n>th sub pattern (like counting */
+    /* in a multi base numerative system) */
+    for (i=dim-1; i>=0; i--)
+    {
+	spos[i] = (nn % ns[i]) * sstep[i];
+	nn /= ns[i];
+    }
+    
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_allocate_pat_train_entries
+
+  PURPOSE  : allocate or reallocate an array which will later include
+             the sorted or shuffled pattern order (during training)
+  RETURNS  : FALSE if malloc fails
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static bool kr_np_allocate_pat_train_entries(int n)
+{
+    TRACE_IN();
+
+    if (n > np_pat_train_size)
+    {
+	if (np_pat_train_order != (int *) NULL)
+	    free(np_pat_train_order);
+	np_pat_train_size = 0;
+	np_pat_train_order = (int *) malloc(n * sizeof(int));
+	if (np_pat_train_order == (int *) NULL && n != 0)
+	    { TRACE_RETURN(FALSE); }
+	np_pat_train_size = n;
+	np_pat_train_valid = FALSE;
+    }
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_allocate_sub_pat_train_entries
+
+  PURPOSE  : allocate or reallocate an array which will later include
+             the sorted or shuffled order of the sub pattern of the
+	     current pattern
+  RETURNS  : FALSE if malloc fails
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static bool kr_np_allocate_sub_pat_train_entries(int n)
+{
+    TRACE_IN();
+
+    if (n > np_sub_pat_train_size)
+    {
+	if (np_sub_pat_train_order != (int *) NULL)
+	    free(np_sub_pat_train_order);
+	np_sub_pat_train_size = 0;
+	np_sub_pat_train_order = (int *) malloc(n * sizeof(int));
+	if (np_sub_pat_train_order == (int *) NULL && n != 0)
+	    { TRACE_RETURN(FALSE); }
+	np_sub_pat_train_size = n;
+	np_sub_pat_train_valid = FALSE;
+    }
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_allocate_pat_mapping_entries
+
+  PURPOSE  : allocate or reallocate an array which will later include
+             the virtual to physical pattern number mapping
+  RETURNS  : FALSE if malloc fails
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static bool kr_np_allocate_pat_mapping_entries(int n)
+{
+    TRACE_IN();
+
+    if (n > np_pat_mapping_size)
+    {
+	if (np_pat_mapping_order != (int *) NULL)
+	    free(np_pat_mapping_order);
+	np_pat_mapping_size = 0;
+	np_pat_mapping_order = (int *) malloc(n * sizeof(int));
+	if (np_pat_mapping_order == (int *) NULL && n != 0)
+	    { TRACE_RETURN(FALSE); }
+	np_pat_mapping_size = n;
+	np_pat_mapping_valid = FALSE;
+    }
+    { TRACE_RETURN(TRUE); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_order_pat_entries
+
+  PURPOSE  : Fills the allocated array for the pattern ordering with
+             increasing numbers if patterns are sorted or with a
+	     random permutation if patterns are shuffled.
+	     <start> and <end> define the first and last pattern
+	     number to be used
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_order_pat_entries(int start, int end)
+{
+    static bool shuffle;
+    static int c_start;
+    static int c_end;
+
+    register int i;
+    register int *fp;
+    register int h;
+    register int s;
+    register int n;
+
+    TRACE_IN();
+
+    if (!np_pat_train_valid || c_start != start || c_end != end 
+	|| shuffle != npui_shuffle_pattern)
+    {
+	fp = np_pat_train_order;
+	for (i=start; i<=end; i++)
+	    *fp++ = i;
+	np_pat_train_valid = TRUE;
+	np_pat_train_number = end - start + 1;
+	c_start = start;
+	c_end = end;
+	shuffle = npui_shuffle_pattern;
+    }
+
+    if (shuffle)
+    {
+	n = np_pat_train_number;
+	fp = np_pat_train_order;
+	for (i=0; i<n; i++)
+	{
+	    s = lrand48() % (n-i);
+	    h = *fp;
+	    *fp++ = np_pat_train_order[s+i];
+	    np_pat_train_order[s+i] = h;
+	}
+    }
+
+    { TRACE_RETURN_VOID(); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_order_sub_pat_entries
+
+  PURPOSE  : Fills the allocated array for the sub pattern ordering with
+             increasing numbers if sub patterns are sorted or with a
+	     random permutation if sub patterns are shuffled.
+	     <start> and <end> define the first and last sub pattern
+	     number to be used
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_order_sub_pat_entries(int start, int end)
+{
+    static bool shuffle;
+    static int c_start;
+    static int c_end;
+
+    register int i;
+    register int *fp;
+    register int h;
+    register int s;
+    register int n;
+
+    TRACE_IN();
+
+    if (!np_sub_pat_train_valid || c_start != start || c_end != end 
+	|| shuffle != npui_shuffle_sub_pattern)
+    {
+	fp = np_sub_pat_train_order;
+	for (i=start; i<=end; i++)
+	    *fp++ = i;
+	np_sub_pat_train_valid = TRUE;
+	np_sub_pat_train_number = end - start + 1;
+	c_start = start;
+	c_end = end;
+	shuffle = npui_shuffle_sub_pattern;
+    }
+
+    if (shuffle)
+    {
+	n = np_sub_pat_train_number;
+	fp = np_sub_pat_train_order;
+	for (i=0; i<n; i++)
+	{
+	    s = lrand48() % (n-i);
+	    h = *fp;
+	    *fp++ = np_sub_pat_train_order[s+i];
+	    np_sub_pat_train_order[s+i] = h;
+	}
+    }
+
+    { TRACE_RETURN_VOID(); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_order_chunk_arrays
+
+  PURPOSE  : Fills the allocated array for the pattern ordering with
+             increasing numbers if patterns are sorted or with a
+	     random permutation if patterns are shuffled.
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+             ordering within pat_nums list after finishing this function:
+
+                     s_a              s_a              s_a        p s_a
+	     |                |                |                |        |  
+	     -------------------------------------------------------------
+	     |     |     |     |     |     |     |     |     |     |     |
+               c_a   c_a   c_a   c_a   c_a   c_a   c_a   c_a   c_a   c_a
+
+
+	     c_a: chunk_amount
+             s_a: set_amount
+             p s_a: partial set_amount
+
+             global_chunks    = number of c_a repetitions
+             pat_nums_valid   = global_chunks * chunk_amount
+	     pat_num_pos      = 0
+
+	     algorithm:
+	     1: fill in first s_a section
+	     2: (partially) copy this section to further positions while
+	        shuffling if necessary
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_order_chunk_arrays(bool shuffle, int pattern_set)
+{
+    struct np_symtab *list;
+    np_pattern_descriptor *pattern;
+    int no_of_pattern;
+    int i;
+    int sc, ps;
+    int total = 0;
+
+    TRACE_IN();
+
+    list = np_st[pattern_set];
+    while (list != NULL)
+    {
+	list->pat_num_pos = 0;
+	list = list->next;
+    }
+
+    if (np_info[pattern_set].chunk_order_valid &&
+	!np_info[pattern_set].chunk_shuffle &&
+	!shuffle)
+	{ TRACE_RETURN_VOID(); }
+
+    /* fill first set amount */
+    if (!np_info[pattern_set].chunk_order_valid)
+    {
+	no_of_pattern = np_info[pattern_set].pub.number_of_pattern;
+
+	list = np_st[pattern_set];
+	while (list != NULL)
+	{
+	    list->pat_nums_valid = 0;
+	    list = list->next;
+	}
+
+	pattern = np_pat_sets[pattern_set];
+	for (i=0; i<no_of_pattern; i++, pattern++)
+	    pattern->mysym->pat_nums[pattern->mysym->pat_nums_valid++] = i;
+    }
+    
+    /* copy set amounts without shuffling */
+    if (!np_info[pattern_set].chunk_order_valid && !shuffle)
+    {
+	list = np_st[pattern_set];
+	while (list != NULL)
+	{
+	    if (list->chunk_amount > 0)
+	    {
+		sc = 1 + (list->global_chunks * list->chunk_amount - 1) / 
+		  list->set_amount;
+		ps = list->global_chunks * list->chunk_amount -
+		  (sc-1) * list->set_amount;
+		for (i=1; i<sc; i++)
+		  {
+		    if (i!=(sc-1))
+		      memcpy(list->pat_nums + i*list->set_amount,
+			     list->pat_nums, list->set_amount * sizeof(int));
+		    else
+		      memcpy(list->pat_nums + i*list->set_amount,
+			     list->pat_nums, ps * sizeof(int));
+		  }
+		
+		total += list->global_chunks * list->chunk_amount;
+	    }
+	    list = list->next;
+	}
+
+	if (total != np_info[pattern_set].pub.virtual_no_of_pattern)
+	    fprintf(stderr, "internal error, file %s, line %d", __FILE__, __LINE__);
+    }
+
+    /* copy set amounts with shuffling */
+    np_info[pattern_set].chunk_shuffle = shuffle;
+    if (shuffle)
+    {
+	int n,j,s,h;
+	int *fp;
+
+	list = np_st[pattern_set];
+	while (list != NULL)
+	{
+	    if (list->chunk_amount > 0)
+	    {
+	        sc = 1 + (list->global_chunks * list->chunk_amount - 1) / 
+		  list->set_amount;
+		ps = list->global_chunks * list->chunk_amount -
+		  (sc-1) * list->set_amount;
+		for (i=1; i<sc; i++)
+		{
+		    /* shuffle first copy of set */
+		    n = list->set_amount;
+		    fp = list->pat_nums;
+		    for (j=0; j<n; j++)
+		    {
+			s = lrand48() % (n-j);
+			h = *fp;
+			*fp++ = list->pat_nums[s+j];
+			list->pat_nums[s+j] = h;
+		    }
+		    
+		    /* copy shuffled set */
+		    if (i!=(sc-1))
+		      memcpy(list->pat_nums + i*list->set_amount,
+			     list->pat_nums, list->set_amount * sizeof(int));
+		    else
+		      memcpy(list->pat_nums + i*list->set_amount,
+			     list->pat_nums, ps * sizeof(int));
+		}
+
+		/* reshuffle first copy of set, because part of it has been copied */
+		n = list->set_amount;
+		fp = list->pat_nums;
+		for (j=0; j<n; j++)
+		{
+		    s = lrand48() % (n-j);
+		    h = *fp;
+		    *fp++ = list->pat_nums[s+j];
+		    list->pat_nums[s+j] = h;
+		}
+	    }
+	    list = list->next;
+	}
+    }
+
+    np_info[pattern_set].chunk_order_valid = TRUE;
+
+    { TRACE_RETURN_VOID(); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_order_chunked_pat_entries
+
+  PURPOSE  : Fills the allocated array for the pattern ordering with
+             the contents of all chunk arrays.
+	     <start> and <end> define the first and last pattern
+	     number to be used
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_order_chunked_pat_entries(int pat_set, int start, int end)
+{
+    static int c_start;
+    static int c_end;
+
+    struct np_symtab *list;
+    int insert_pos;
+    int total_pos;
+    int within_chunk_count;
+    int chunk_size;
+
+    TRACE_IN();
+
+    if (np_pat_train_valid && c_start == start && c_end == end 
+	&& !npui_shuffle_pattern)
+	{ TRACE_RETURN_VOID(); }
+
+    /* chunk lists are already prepared and shuffled if necessary */
+
+    list = np_st[pat_set];
+    chunk_size = 0;
+    while (list != NULL)
+    {
+	chunk_size += list->chunk_amount;
+	list = list->next;
+    }
+    if (chunk_size == 0)
+	fprintf(stderr, "internal error, file %s, line %d", __FILE__, __LINE__);
+
+    list = np_st[pat_set];
+    while (list != NULL)
+    {
+	list->chunk_comp_base = (list->chunk_amount > 0) ?
+	    chunk_size / list->chunk_amount : 0;
+	list = list->next;
+    }
+
+    insert_pos = 0;
+    total_pos = 0;
+    list = NULL;
+    within_chunk_count = 0;
+    while (total_pos <= end)
+    {
+	if (within_chunk_count == 0)
+	{
+	    list = np_st[pat_set];
+	    while (list != NULL)
+	    {
+		list->chunk_comp_count = list->chunk_comp_base;
+		list->within_chunk_pos = 0;
+		list = list->next;
+	    }
+	    within_chunk_count = chunk_size;
+	}
+	if (list == NULL)
+	    list = np_st[pat_set];
+	if (list->within_chunk_pos < list->chunk_amount && 
+	    --(list->chunk_comp_count) == 0)
+	{
+	    if (total_pos >= start)
+	    {
+		np_pat_train_order[insert_pos++] =
+		    list->pat_nums[list->pat_num_pos];
+	    }
+	    list->chunk_comp_count = list->chunk_comp_base;
+	    list->within_chunk_pos++;
+	    list->pat_num_pos++;
+	    total_pos++;
+	    within_chunk_count--;
+	}
+	list = list->next;
+    }
+
+/*
+    while (total_pos <= end)
+    {
+	list = np_st[pat_set];
+	while (list != NULL && total_pos <= end)
+	{
+	    list->within_chunk_pos = 0;
+	    while (list->within_chunk_pos < list->chunk_amount && total_pos <= end)
+	    {
+		if (total_pos >= start)
+		{
+		    np_pat_train_order[insert_pos++] =
+			list->pat_nums[list->pat_num_pos];
+		}
+		list->within_chunk_pos++;
+		list->pat_num_pos++;
+		total_pos++;
+	    }
+	    list = list->next;
+	}
+    }
+*/
+
+    c_start  = start;
+    c_end = end;
+    np_pat_train_valid = TRUE;
+    np_pat_train_number = end - start + 1;
+
+    { TRACE_RETURN_VOID(); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_fill_virtual_to_void_mapping
+
+  PURPOSE  : Fills the allocated mapping array for the pattern ordering with
+             the contents of all chunk arrays.
+  RETURNS  : nothing
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static void kr_np_fill_virtual_to_void_mapping(int pat_set)
+{
+    struct np_symtab *list;
+    int insert_pos;
+    int chunk_size;
+    int within_chunk_count;
+
+    TRACE_IN();
+
+    if (np_pat_mapping_valid)
+	{ TRACE_RETURN_VOID(); }
+
+    if (np_info[pat_set].pub.class_distrib_active)
+    {
+	/* chunk lists are already prepared (not shuffled!) */
+	list = np_st[pat_set];
+	chunk_size = 0;
+	while (list != NULL)
+	{
+	    chunk_size += list->chunk_amount;
+	    list = list->next;
+	}
+	if (chunk_size == 0)
+	    fprintf(stderr, "internal error, file %s, line %d", __FILE__, __LINE__);
+	
+	list = np_st[pat_set];
+	while (list != NULL)
+	{
+	    list->chunk_comp_base = (list->chunk_amount > 0) ?
+		chunk_size / list->chunk_amount : 0;
+	    list = list->next;
+	}
+	
+	insert_pos = 0;
+	list = NULL;
+	within_chunk_count = 0;
+	while (insert_pos < np_info[pat_set].pub.virtual_no_of_pattern)
+	{
+	    if (within_chunk_count == 0)
+	    {
+		list = np_st[pat_set];
+		while (list != NULL)
+		{
+		    list->chunk_comp_count = list->chunk_comp_base;
+		    list->within_chunk_pos = 0;
+		    list = list->next;
+		}
+		within_chunk_count = chunk_size;
+	    }
+	    if (list == NULL)
+		list = np_st[pat_set];
+	    if (list->within_chunk_pos < list->chunk_amount && 
+		--(list->chunk_comp_count) == 0)
+	    {
+		np_pat_mapping_order[insert_pos++] =
+		    list->pat_nums[list->pat_num_pos++];
+		list->chunk_comp_count = list->chunk_comp_base;
+		list->within_chunk_pos++;
+		within_chunk_count--;
+	    }
+	    list = list->next;
+	}
+
+/*
+	insert_pos = 0;
+	list = NULL;
+	
+	while (insert_pos < np_info[pat_set].pub.virtual_no_of_pattern)
+	{
+	    list = np_st[pat_set];
+	    while (list != NULL)
+	    {
+		list->within_chunk_pos = 0;
+		while (list->within_chunk_pos < list->chunk_amount)
+		{
+		    np_pat_mapping_order[insert_pos++] =
+			list->pat_nums[list->pat_num_pos++];
+		    list->within_chunk_pos++;
+		}
+		list = list->next;
+	    }
+	}
+*/
+
+	if (insert_pos != np_info[pat_set].pub.virtual_no_of_pattern)
+	    fprintf(stderr, "internal error, file %s, line %d\n", __FILE__, __LINE__);
+    }
+    else
+    {
+	/* no class distribution, virtual numbers = physical numbers */
+	for (insert_pos=0; insert_pos < np_info[pat_set].pub.virtual_no_of_pattern;
+	     insert_pos++)
+	    np_pat_mapping_order[insert_pos] = insert_pos;
+    }
+
+    np_pat_mapping_valid = TRUE;
+
+    { TRACE_RETURN_VOID(); }
+}
+
+
+/*****************************************************************************
+  FUNCTION : kr_np_virtual_to_physical
+
+  PURPOSE  : mapping of virtual pattern numbers to physically stored patterns
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static int kr_np_virtual_to_physical(int vnum)
+{
+    TRACE_IN();
+
+    { TRACE_RETURN(np_pat_mapping_order[vnum]); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_physical_to_virtual
+
+  PURPOSE  : mapping of physical pattern number to a virtual number
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static int kr_np_physical_to_virtual(int pnum)
+{
+    int vnum;
+    TRACE_IN();
+
+    if (np_pat_mapping_order[pnum] == pnum)
+	/* first guess: if no chunks are defined, virtual numbers are
+	   equal to physical numbers */
+	vnum = pnum;
+    else
+    {
+	/* we need to search for a virtual number.
+	   The field is only partially sorted, so it is not possible
+	   to perform a binary search. There is no other way than to
+	   start at the beginning and find the first occurence of pnum
+	*/
+	vnum = 0;
+	while (np_pat_mapping_order[vnum] != pnum)
+	    vnum++;	
+    }
+    
+    { TRACE_RETURN(vnum); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_DefineSubPatternOrdering
+
+  PURPOSE : definition of generation of sub pattern during training
+
+  The shape and ordering of sub patterns for training and display is
+  defined.  <pat_set> specifies the pattern set to use. The flag
+  <input> determines whether input or output sub patterns are to be
+  defined. The array size_coord spezifies the shape of the sub pattern
+  like in kr_np_GetSubPat. The array incr_coord specifies how sub
+  patterns are generated from the whole pattern by shifting the shape
+  over this pattern. Each value in this array gives an incremental
+  offset for one dimensional direction. The start position is at [0 0
+  0 ...]. New positions are generated by adding the rightmost value of
+  incr_coord to the old position. If an overflow in this dimension
+  occurs, this coordinate is reset to 0 and the next position to the
+  left is incremented (and so on ...). After all sub patterns of one
+  pattern are generated the next pattern is used.  Depending on
+  npui_shuffle_pattern and npui_shuffle_sub_pattern shuffling is
+  activated.
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_DefineSubPatternOrdering(int pat_set, bool input, 
+					       int *size_coord, 
+					       int *incr_coord)
+{
+    krui_err err_code;
+    np_pattern_descriptor *p;
+
+    TRACE_IN();
+
+    if (np_used_pat_set_entries == 0)
+	{ TRACE_RETURN(KRERR_NO_PATTERNS); }
+
+    if (pat_set < 0 || pat_set >= np_used_pat_set_entries ||
+	!np_pat_set_used[pat_set])
+	{ TRACE_RETURN(KRERR_NP_NO_SUCH_PATTERN_SET); }
+
+    err_code = kr_np_GetDescriptor(pat_set, 0, &p);
+    if (err_code != KRERR_NO_ERROR)
+	{ TRACE_RETURN(err_code); }
+
+    if (input)
+    {
+	memcpy((char *) np_t_insize, (char *) size_coord, 
+	       p->pub.input_dim * sizeof(int));
+	memcpy((char *) np_t_instep, (char *) incr_coord, 
+	       p->pub.input_dim * sizeof(int));
+    }
+    else
+    {
+	memcpy((char *) np_t_outsize, (char *) size_coord, 
+	       p->pub.input_dim * sizeof(int));
+	memcpy((char *) np_t_outstep, (char *) incr_coord, 
+	       p->pub.input_dim * sizeof(int));
+    }
+
+    np_pat_train_valid = FALSE;
+    np_sub_pat_train_valid = FALSE;
+    np_pat_mapping_valid = FALSE;
+
+    { TRACE_RETURN(KRERR_NO_ERROR); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_showPatternSTD
+
+  PURPOSE  :  According to the mode kr_np_showPatternSTD stores the current
+              Pattern/sub Pattern into the units activation (and/or output) 
+	      values.
+              The modes are:
+              - OUTPUT_NOTHING
+              store input pattern into input units activations
+              - OUTPUT_ACT
+              store input pattern into input units activations and
+              store output pattern into output units activations
+              - OUTPUT_OUT
+              store input pattern into input units activations,
+              store output pattern into output units activations and
+              update output units output
+  RETURNS  :  kernel error code
+  NOTES    :  See include file glob_typ.h for mode constants.
+              internal use only
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_showPatternSTD(int mode)
+{
+    register struct Unit *unit_ptr;
+    float *in_pat, *out_pat;
+    np_pattern_descriptor *pattern;
+    int in_pat_size, out_pat_size;
+
+    TRACE_IN();
+
+    /* make the pattern to become the current pattern */ 
+    if ((KernelErrorCode = 
+	 kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+	     kr_np_virtual_to_physical(npui_curr_pattern-1), &pattern)) 
+	!= KRERR_NO_ERROR)
+	{ TRACE_RETURN(KernelErrorCode); }
+  
+    /*  calc. startaddress of patterns  */
+    if ((KernelErrorCode = 
+	 kr_np_GetSubPat(TRUE, npui_inpos, npui_insize, &in_pat, 
+			 &in_pat_size)) 
+	!= KRERR_NO_ERROR)
+	{ TRACE_RETURN(KernelErrorCode); }
+
+    if ((KernelErrorCode = 
+	 kr_np_GetSubPat(FALSE, npui_outpos, npui_outsize, &out_pat, 
+			 &out_pat_size)) 
+	!= KRERR_NO_ERROR)
+	{ TRACE_RETURN(KernelErrorCode); }
+
+    /* calculate the units, ignore error code concerning old pattern format */
+    (void) kr_IOCheck();
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    /* check whether pattern fits the network, do not complain about */
+    /* missing output pattern */
+    if (NoOfInputUnits != in_pat_size ||
+	(NoOfOutputUnits != out_pat_size && out_pat_size != 0))
+	{ TRACE_RETURN(KernelErrorCode = KRERR_NP_DOES_NOT_FIT); }
+
+    switch (mode)
+    {
+      case  OUTPUT_NOTHING:
+	FOR_ALL_UNITS( unit_ptr )
+	    if ( IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+		if (in_pat_size--)
+		    unit_ptr->act = *in_pat++;
+	break;
+
+      case  OUTPUT_ACT:
+	FOR_ALL_UNITS( unit_ptr )
+	    if UNIT_IN_USE( unit_ptr )
+	    {
+		if IS_INPUT_UNIT( unit_ptr )
+		    unit_ptr->act = *in_pat++;
+		if (IS_OUTPUT_UNIT( unit_ptr ) && out_pat_size != 0)
+		    unit_ptr->act = *out_pat++;
+	    }
+	break;
+
+      case  OUTPUT_OUT:
+	FOR_ALL_UNITS( unit_ptr )
+	    if UNIT_IN_USE( unit_ptr )
+	    {
+		if IS_INPUT_UNIT( unit_ptr )
+		    unit_ptr->act = *in_pat++;
+		if (IS_OUTPUT_UNIT( unit_ptr ) && out_pat_size != 0)
+		{
+		    unit_ptr->act = *out_pat++;
+		    if (unit_ptr->out_func == NULL)
+			/*  Identity Function   */
+			unit_ptr->Out.output = unit_ptr->act;
+		    else
+			unit_ptr->Out.output = 
+			    (*unit_ptr->out_func) (unit_ptr->act);
+		}
+	    }
+	break;
+    
+      default:
+	KernelErrorCode = KRERR_PARAMETERS;
+    }
+
+    { TRACE_RETURN(KernelErrorCode); }
+}
+
+/*****************************************************************************
+  FUNCTION : kr_np_modifyPattern
+
+  PURPOSE  : The current activation of the input and output units is used to
+             modify the current sub pattern.
+
+  RETURNS  : kernel error code
+  NOTES    : internal use only
+  UPDATE   : 
+******************************************************************************/
+static krui_err kr_np_modifyPattern(void)
+{
+    register struct Unit *unit_ptr;
+    float *in_pat, *out_pat;
+    float *ip, *op;
+    np_pattern_descriptor *pattern;
+
+    TRACE_IN();
+
+    /* make the pattern to become the current pattern */ 
+    if ((KernelErrorCode = 
+	 kr_np_GetDescriptor(npui_pat_sets[npui_curr_pat_set],
+	     kr_np_virtual_to_physical(npui_curr_pattern-1), &pattern)) 
+	!= KRERR_NO_ERROR)
+	{ TRACE_RETURN(KernelErrorCode); }
+  
+    /* calculate the units, ignore error code concerning old pattern format */
+    (void) kr_IOCheck();
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    /* allocate memory to hold the sub pattern */
+    in_pat = (float *) malloc(NoOfInputUnits * sizeof(float));
+    out_pat = (float *) malloc(NoOfOutputUnits * sizeof(float));
+    if ((in_pat == (float *) NULL && NoOfInputUnits != 0) 
+	|| (out_pat == (float *) NULL && NoOfOutputUnits != 0))
+	{ TRACE_RETURN(KRERR_INSUFFICIENT_MEM); }
+
+    /* copy unit activations into sub pattern area */
+    ip = in_pat;
+    op = out_pat;
+
+    FOR_ALL_UNITS(unit_ptr)
+        if (UNIT_IN_USE(unit_ptr))
+	{
+	    if (IS_INPUT_UNIT(unit_ptr))
+		*ip++ = unit_ptr->act;
+	    if (IS_OUTPUT_UNIT(unit_ptr))
+		*op++ =  unit_ptr->act;
+        }
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    /* test whether pattern already contains data. */
+    /* allocate space if necessary (for new allocated patterns) */
+    if (pattern -> pub.input_fixsize == 0)
+    {
+	pattern -> pub.input_fixsize = NoOfInputUnits;
+	pattern -> pub.output_fixsize = NoOfOutputUnits;
+	pattern -> pub.input_dim = 0;
+	pattern -> pub.output_dim = 0;
+	KernelErrorCode = kr_np_AllocatePattern(pattern, TRUE);
+	if (KernelErrorCode == KRERR_NO_ERROR)
+	    KernelErrorCode = kr_np_AllocatePattern(pattern, FALSE);
+    }
+
+    /* modify the copied sub pattern */
+    if (KernelErrorCode == KRERR_NO_ERROR)
+    {
+	KernelErrorCode = kr_np_SetSubPat(TRUE, npui_inpos, npui_insize,
+					  in_pat, NoOfInputUnits);
+    }
+
+    if (KernelErrorCode == KRERR_NO_ERROR)
+    {
+	KernelErrorCode = kr_np_SetSubPat(FALSE, npui_outpos, npui_outsize,
+					  out_pat, NoOfOutputUnits);
+    }
+
+    /* free the memory */
+    if (in_pat != (float *) NULL)
+	free(in_pat);
+    if (out_pat != (float *) NULL)
+	free(out_pat);
+
+    { TRACE_RETURN(KernelErrorCode); }
+}
+
+/*****************************************************************************
+END OF FILE
+******************************************************************************/
diff -Naur snort-2.3.3/src/kernel_snns/kr_newpattern.h snort-2.3.3.new/src/kernel_snns/kr_newpattern.h
--- snort-2.3.3/src/kernel_snns/kr_newpattern.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_newpattern.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,399 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_newpattern.h,v $
+  SHORTNAME      : newpattern
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : handling of new pattern format
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/04/08 09:16:51 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_NEWPATTERN_DEFINED_
+#define _KR_NEWPATTERN_DEFINED_
+
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE KERNEL USER INTERFACE TO PERFORM
+ THE KERNEL INTERFACE OF THE NEW PATTERN MANAGEMENT
+******************************************************************************/
+
+extern krui_err kr_npui_setCurrPatSet(int number);
+/*****************************************************************************
+determines the number of the current pattern set (in kernel terminology) 
+numbering starts with 0
+******************************************************************************/
+
+extern krui_err kr_npui_deletePatSet(int number);
+/*****************************************************************************
+deletes the specified pattern set from memory and undefines the
+current pattern set, pattern, training scheme and display scheme
+******************************************************************************/
+
+extern krui_err kr_npui_GetPatInfo(pattern_set_info *set_info, 
+			    pattern_descriptor *pat_info);
+/*****************************************************************************
+retrieves all available information concerning the current pattern set
+and the current pattern which both must be defined. The given
+parameter fields are filled with the information.
+******************************************************************************/
+
+extern krui_err kr_npui_DefShowSubPat(int *insize, int *outsize, 
+			       int *inpos, int *outpos);
+/*****************************************************************************
+Define the display scheme:
+Size and position of a sub pattern for the current pattern in the
+current pattern set is defined. <insize> is a pointer to an array of
+integer values which define the dimensional sizes of the input sub
+pattern. <inpos> is a pointer to an array of integer values which
+defines the offset (position) of this sub pattern inside the
+pattern. <outsize> and <outpos> are used to define the respective
+output sub pattern
+******************************************************************************/
+
+extern krui_err kr_npui_DefTrainSubPat(int *insize, int *outsize, 
+				int *instep, int *outstep, int *max_n_pos);
+/*****************************************************************************
+Define the training scheme:
+Size and step size of sub pattern for the current pattern in the
+current pattern set is defined for training and testing. <insize> is a
+pointer to an array of integer values which define the dimensional
+sizes of the input sub pattern. <instep> is a pointer to an array of
+integer values which defines the step size which is used to move the
+sub pattern over the pattern.
+<outsize> and <outpos> are used to define the respective output sub
+pattern.
+<max_n_pos> (if not NULL) returns the number of valid input sub
+pattern positions for the current pattern and the given training
+scheme.
+******************************************************************************/
+
+extern krui_err kr_npui_AlignSubPat(int *inpos, int *outpos, int *no);
+/*****************************************************************************
+Align the position of a sub pattern:
+Using the current training scheme and the current pattern of the
+current pattern set, the given position of an input sub pattern
+<inpos> and the given position of the corresponding output sub pattern
+<outpos> is aligned to fit the currently defined training scheme.
+E.g. if the training scheme defines a step width of 5 for a specific
+dimension, only the positions 0, 5, 10, 15 ...  are valid positions
+for a sub pattern.
+The position of each dimension is aligned independently from all other
+dimensions by moving to the next valid position which is lower or
+equal to the given position.  <no> (if not NULL) returns the number of
+the sub pattern which corresponds to the new aligned position which is
+returned in place (<inpos> <outpos>).
+******************************************************************************/
+
+extern krui_err kr_npui_allocNewPatternSet(int *set_no);
+/*****************************************************************************
+Allocate an (additional) empty pattern set: A new pattern set is
+allocated if the maximum number of loaded pattern sets
+(NO_OF_PAT_SETS) is not exceeded. The corresponding pattern set handle
+is returned in <set_no>.  The new allocated pattern set becomes the
+current set.  There is no current pattern defined.  Training scheme
+and display scheme both become undefined.
+******************************************************************************/
+
+extern krui_err kr_npui_loadNewPatterns(char *filename, int *set_no);
+/*****************************************************************************
+Load an (additional) pattern file:
+The file with name <filename> is loaded into memory if existent and if
+the maximum number of loaded pattern sets (NO_OF_PAT_SETS) is not
+exceeded. The corresponding pattern set handle is returned in
+<set_no>.
+The new loaded pattern set becomes the current set. The first pattern
+inside this set becomes the current pattern. Training scheme and
+display scheme both become undefined.
+******************************************************************************/
+
+extern krui_err kr_npui_saveNewPatterns(char *filename, int set_no);
+/*****************************************************************************
+The given pattern set <set_no> is written to file <filename> in new
+style format. No side effects.
+******************************************************************************/
+
+extern krui_err kr_npui_GetShapeOfSubPat(int *insize, int *outsize, 
+				  int *inpos, int *outpos, int n_pos);
+/*****************************************************************************
+Get the shape of a sub pattern which is specified by a number:
+After kr_npui_DefTrainSubPat has been called for the current pattern
+set and a current pattern is defined, this function retrieves the
+<n_pos>th valid sub pattern pair which matches the defined training
+scheme. Size and position of the sub pattern pair is returned in
+<insize> <inpos> <outsize> and <outpos> which are all pointer to
+integer arrays.
+******************************************************************************/
+
+extern krui_err kr_npui_setRemapFunction(char *name, float *params);
+/*****************************************************************************
+Set the remap function for the current pattern set and use the given 
+parameters.
+<name> points to a remap function name, provided by the user interface. The 
+function name is checked and the pointer for this function is looked up in the 
+function table. If no function name is given (NULL pointer) or if the default 
+remaping function is given the default remap function is used 
+(no remaping of patterns occurs). The name of the remap function is stored in
+the pattern set description for future access by the interface.
+<params> points to an array of function parameters of size NO_OF_REMAP_PARAMS
+provided by the user interface. The parameters used for the given remap 
+function are read out of the array and copied to the local pattern set
+description.
+******************************************************************************/
+
+extern krui_err kr_npui_setClassDistribution(unsigned int *class_sizes);
+/*****************************************************************************
+Set the class distribution for the current pattern set.
+This function may only be called if the current pattern set provides class 
+information. If <class_sizes> is not NULL it must locate an integer array of 
+size that matches the number of classes in the current set. The values of 
+this array are copied to the pattern set area. If <class_sizes> is the NULL
+pointer, then the real distribution of classes in the pattern set is 
+computed and stored in the class distribution area of the pattern set. So the
+interface may retrieve default values for the class distribution which match
+the real distribution of the pattern set.
+******************************************************************************/
+
+extern krui_err kr_npui_useChunk(bool active);
+/*****************************************************************************
+Switch on or off the class distribution process.
+If <active> is TRUE, the distribution process is activated. Therefore the 
+internal representation of the pattern set is virtually reorganized to match
+the requested values of <class_sizes>. After that step the number of patterns
+in the set virtually increases or decreases because each epoch must cover 
+every pattern of all classes that have a requested distribution amount bigger
+than 0. This also implies that several patterns from a specific class are 
+reused several times during one epoch.
+******************************************************************************/
+
+extern krui_err kr_npui_setClass(char *classname);
+/*****************************************************************************
+Set the class name for the current pattern.
+If the pattern set already contains class information, only the
+current pattern is affected. If there are no classes in the pattern
+set so far, all patterns of the current set are set to the given class
+name, since every pattern must belong to a class in that case.
+If the given class name is the NULL pointer, nothing happens at all.
+******************************************************************************/
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY OTHER KERNEL FUNCTIONS LIKE TRAINING
+ AND INITIALIZATION FUNCTIONS:
+******************************************************************************/
+
+struct np_symtab
+{
+    char *symname;             /* name of the class */
+    int set_amount;            /* total number of patterns of this
+				  class in the set */ 
+    int chunk_amount;          /* defined chunk size of this class
+				  within the set */
+    int symnum;                /* index to user visible class names
+				  list. This index has to be reset
+				  whenever the symbol table changes */
+
+    int my_chunks_per_set;     /* minimum number of chunks to use all
+				  patterns from this class */
+    int global_chunks;         /* global number of chunks to use all
+				  patterns from all classes from this
+				  set */
+    int pat_nums_size;         /* number of entries (size) of the
+				  pattern number list for this class
+				  */
+    int pat_nums_valid;        /* number of valid entries in the
+				  pattern number list (usually
+				  global_chunks * chunk_amount
+				  entries) */
+    int *pat_nums;             /* array of duplicated pattern numbers
+				  for this class */
+    int within_chunk_pos;      /* position counter within current
+				  chunk ( < chunk_amount) */
+    int chunk_comp_count;      /* backward counter used for chunk composition */
+    int chunk_comp_base;       /* base value used for chunk composition */
+    int pat_num_pos;           /* index to pat_nums[] for next pattern
+				  in chunk ( < pat_nums_valid) */
+
+    struct np_symtab *next;    /* next entry in symbol table */
+};
+
+typedef struct 
+{
+    pattern_set_info pub;      /* public part of the pattern set             */
+
+    bool chunk_shuffle;        /* chunk shuffle flag from last ordering      */
+    bool chunk_order_valid;    /* TRUE if all chunk arrays are valid         */
+    RemapFuncPtr rmf_ptr;      /* remap function pointer or NULL             */
+} np_pattern_set_info;
+
+typedef struct
+{
+    pattern_descriptor pub;    /* public part of the current pattern         */
+
+    float *input_pattern;      /* pointer to the input pattern data          */
+    float *output_pattern;     /* pointer to the output pattern data         */
+
+    struct np_symtab *mysym;   /* pointer to my symbol table entry */
+} np_pattern_descriptor;
+
+extern int  kr_np_pattern(int mode ,int mode1 ,int pattern_no);
+/*****************************************************************************
+multiple pattern handling functions depending on mode and mode1
+*****************************************************************************/
+
+extern krui_err kr_initSubPatternOrder(int start, int end);
+/*****************************************************************************
+The sub pattern ordering for the current pattern set is reset for the
+next training or initialization run. During this run all sub patterns
+from pattern <start> up to pattern <end> are generated according to
+current shuffle flags for patterns and sub patterns.
+kr_getSubPatByOrder is to be called to get the next sub pattern number
+during the run (see below)
+*****************************************************************************/
+
+extern bool kr_getSubPatternByOrder(int *pattern, int *sub);
+/*****************************************************************************
+According to the last call to kr_initSubPatternOrder, the last call to
+this function and the shuffle flags, the next position of pattern and
+sub pattern is determined. This numbers are returned in <pattern> and
+<sub> (beginning with 0). If there are no more sub pattern avaliable
+the return value is FALSE, otherwise TRUE.
+*****************************************************************************/
+
+extern bool kr_getSubPatternByNo(int *pattern, int *sub, int n);
+/*****************************************************************************
+According to the current pattern set, the position of the <n>th sub
+pattern is determined and returned in <pattern> (the pattern which
+includes the subpattern) and <sub> (the sub pattern inside the
+pattern) (beginning with 0). 
+This function does not effect the ordering of the function
+kr_getSubPatByOrder. <n> ranges from 0 to kr_TotalNoOfSubPatPairs()-1.
+If the sub pattern is available, TRUE is returned, otherwise FALSE.
+*****************************************************************************/
+
+extern int kr_TotalNoOfSubPatPairs(void);
+/*****************************************************************************
+This function returns the total number of available sub patterns for
+the current pattern set or 0 if no pattern set is defined.
+The result is the sum of the numbers of subpattern for all patterns in
+the current set.
+*****************************************************************************/
+
+extern int kr_NoOfSubPatPairs(int pattern);
+/*****************************************************************************
+This function returns the number of available sub patterns for the
+pattern <pattern> of the current pattern set or 0 if this pattern is
+not defined.
+*****************************************************************************/
+
+extern int kr_AbsPosOfFirstSubPat(int pattern);
+/*****************************************************************************
+This function returns the absolute position of the first sub pattern
+of pattern <pattern> in the current pattern set. This position is
+defined as the Sum of kr_NoOfSubPatPairs(i) where i runs from 0 to
+<pattern>-1.
+The absolute position of the first sub pattern of pattern 0 is 0.
+The returned value may be used as argument for the function
+kr_getSubPatternByNo.
+*****************************************************************************/
+
+extern int kr_TotalNoOfPattern(void);
+/*****************************************************************************
+This function returns the total number of available patterns for
+the current pattern set or 0 if no pattern set is defined.
+*****************************************************************************/
+
+extern Patterns kr_getSubPatData(int pat_no, int sub_no, int io_type, 
+				 int *size);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the
+data array of the <sub_no>th sub pattern of the <pat_no>th pattern is
+returned. io_type spcifies whether the input (INPUT) or output
+(OUTPUT) data is requested. If <size> is != NULL the size of the data
+array is returned is this parameter.
+The function returns a pointer to the data array (type Patterns) or
+NULL if an error occured.
+*****************************************************************************/
+
+extern int kr_getSubPatClass(int pat_no, int sub_no);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern, the class index 
+(>=0) is returned. If the pattern set does not provide class information, the 
+return value is -1
+*****************************************************************************/
+
+extern int kr_SizeOfInputSubPat(void);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the size of 
+the input part of the first sub pattern of the first pattern is returned. 
+Negative return values indicate KernelErrorCode. Size 0 is a valid return value
+since the pattern may contain no data.
+*****************************************************************************/
+
+extern int kr_SizeOfOutputSubPat(void);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the size of 
+the output part of the first sub pattern of the first pattern is returned. 
+Negative return values indicate KernelErrorCode. Size 0 is a valid return value
+since the pattern may contain no data.
+*****************************************************************************/
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE PATTERN PARSER OR FROM INSIDE THIS
+ MODULE. DON'T USE THESE FUNCTIONS FOR OTHER PURPOSES !!!!!
+******************************************************************************/
+
+extern krui_err kr_np_AllocatePatternSet(int *pat_set, int number);
+/*****************************************************************************
+A new set of patterns with <number> number of patterns is defined. An
+internal pattern set number is assigned to reference this pattern set.
+It is returned in <pat_set>.
+******************************************************************************/
+
+extern krui_err kr_np_AllocatePattern(np_pattern_descriptor *pattern,
+			       bool input);
+/*****************************************************************************
+Depending on the entries input_dim, input_dim_sizes, input_fixsize resp.
+output_dim, output_dim_sizes, output_fixsize of the pattern descriptor
+<pattern> new memory for this pattern is allocated (input_pattern resp.
+output_pattern). input_info resp. output_info is set to (char *) NULL.
+The function allocates space for an input pattern if input is TRUE,
+output pattern otherwise.
+******************************************************************************/
+
+extern krui_err kr_np_FreePattern(np_pattern_descriptor *pattern);
+/*****************************************************************************
+frees the area of the pattern data for this pattern
+******************************************************************************/
+
+extern krui_err kr_np_GetDescriptor(int pat_set, int number, 
+			     np_pattern_descriptor **pattern);
+/*****************************************************************************
+A pointer to the pattern pattern descriptor of pattern <number> in
+pattern set <pat_set> is returned in <pattern>. The structure pattern
+must be provided by the calling routine. A call to this function makes
+the specified pattern to become the current pattern.  Return value:
+error status
+******************************************************************************/
+
+extern krui_err kr_np_lookupSym(int pat_set, char *symbol, 
+				struct np_symtab **entry);
+/*****************************************************************************
+Looks for the class name <symbol> ind set <pat_set>. If the name is
+not present up to now, a new entry is allocated and initialized. In
+case of success <*entry> is set to the symbol table entry.
+******************************************************************************/
+
+
+
+#endif
+
+/* 230 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/kr_newpattern.ph snort-2.3.3.new/src/kernel_snns/kr_newpattern.ph
--- snort-2.3.3/src/kernel_snns/kr_newpattern.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_newpattern.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,856 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_newpattern.ph,v $
+  SHORTNAME      : newpattern
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : handling of new pattern format
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/04/22 16:10:17 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_NEWPATTERN_DEFINED_
+#define _KR_NEWPATTERN_DEFINED_
+
+/* begin global definition section */
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE KERNEL USER INTERFACE TO PERFORM
+ THE KERNEL INTERFACE OF THE NEW PATTERN MANAGEMENT
+******************************************************************************/
+
+krui_err kr_npui_setCurrPatSet(int number);
+/*****************************************************************************
+determines the number of the current pattern set (in kernel terminology) 
+numbering starts with 0
+******************************************************************************/
+
+krui_err kr_npui_deletePatSet(int number);
+/*****************************************************************************
+deletes the specified pattern set from memory and undefines the
+current pattern set, pattern, training scheme and display scheme
+******************************************************************************/
+
+krui_err kr_npui_GetPatInfo(pattern_set_info *set_info, 
+			    pattern_descriptor *pat_info);
+/*****************************************************************************
+retrieves all available information concerning the current pattern set
+and the current pattern which both must be defined. The given
+parameter fields are filled with the information.
+******************************************************************************/
+
+krui_err kr_npui_DefShowSubPat(int *insize, int *outsize, 
+			       int *inpos, int *outpos);
+/*****************************************************************************
+Define the display scheme:
+Size and position of a sub pattern for the current pattern in the
+current pattern set is defined. <insize> is a pointer to an array of
+integer values which define the dimensional sizes of the input sub
+pattern. <inpos> is a pointer to an array of integer values which
+defines the offset (position) of this sub pattern inside the
+pattern. <outsize> and <outpos> are used to define the respective
+output sub pattern
+******************************************************************************/
+
+krui_err kr_npui_DefTrainSubPat(int *insize, int *outsize, 
+				int *instep, int *outstep, int *max_n_pos);
+/*****************************************************************************
+Define the training scheme:
+Size and step size of sub pattern for the current pattern in the
+current pattern set is defined for training and testing. <insize> is a
+pointer to an array of integer values which define the dimensional
+sizes of the input sub pattern. <instep> is a pointer to an array of
+integer values which defines the step size which is used to move the
+sub pattern over the pattern.
+<outsize> and <outpos> are used to define the respective output sub
+pattern.
+<max_n_pos> (if not NULL) returns the number of valid input sub
+pattern positions for the current pattern and the given training
+scheme.
+******************************************************************************/
+
+krui_err kr_npui_AlignSubPat(int *inpos, int *outpos, int *no);
+/*****************************************************************************
+Align the position of a sub pattern:
+Using the current training scheme and the current pattern of the
+current pattern set, the given position of an input sub pattern
+<inpos> and the given position of the corresponding output sub pattern
+<outpos> is aligned to fit the currently defined training scheme.
+E.g. if the training scheme defines a step width of 5 for a specific
+dimension, only the positions 0, 5, 10, 15 ...  are valid positions
+for a sub pattern.
+The position of each dimension is aligned independently from all other
+dimensions by moving to the next valid position which is lower or
+equal to the given position.  <no> (if not NULL) returns the number of
+the sub pattern which corresponds to the new aligned position which is
+returned in place (<inpos> <outpos>).
+******************************************************************************/
+
+krui_err kr_npui_allocNewPatternSet(int *set_no);
+/*****************************************************************************
+Allocate an (additional) empty pattern set: A new pattern set is
+allocated if the maximum number of loaded pattern sets
+(NO_OF_PAT_SETS) is not exceeded. The corresponding pattern set handle
+is returned in <set_no>.  The new allocated pattern set becomes the
+current set.  There is no current pattern defined.  Training scheme
+and display scheme both become undefined.
+******************************************************************************/
+
+krui_err kr_npui_loadNewPatterns(char *filename, int *set_no);
+/*****************************************************************************
+Load an (additional) pattern file:
+The file with name <filename> is loaded into memory if existent and if
+the maximum number of loaded pattern sets (NO_OF_PAT_SETS) is not
+exceeded. The corresponding pattern set handle is returned in
+<set_no>.
+The new loaded pattern set becomes the current set. The first pattern
+inside this set becomes the current pattern. Training scheme and
+display scheme both become undefined.
+******************************************************************************/
+
+krui_err kr_npui_saveNewPatterns(char *filename, int set_no);
+/*****************************************************************************
+The given pattern set <set_no> is written to file <filename> in new
+style format. No side effects.
+******************************************************************************/
+
+krui_err kr_npui_GetShapeOfSubPat(int *insize, int *outsize, 
+				  int *inpos, int *outpos, int n_pos);
+/*****************************************************************************
+Get the shape of a sub pattern which is specified by a number:
+After kr_npui_DefTrainSubPat has been called for the current pattern
+set and a current pattern is defined, this function retrieves the
+<n_pos>th valid sub pattern pair which matches the defined training
+scheme. Size and position of the sub pattern pair is returned in
+<insize> <inpos> <outsize> and <outpos> which are all pointer to
+integer arrays.
+******************************************************************************/
+
+krui_err kr_npui_setRemapFunction(char *name, float *params);
+/*****************************************************************************
+Set the remap function for the current pattern set and use the given 
+parameters.
+<name> points to a remap function name, provided by the user interface. The 
+function name is checked and the pointer for this function is looked up in the 
+function table. If no function name is given (NULL pointer) or if the default 
+remaping function is given the default remap function is used 
+(no remaping of patterns occurs). The name of the remap function is stored in
+the pattern set description for future access by the interface.
+<params> points to an array of function parameters of size NO_OF_REMAP_PARAMS
+provided by the user interface. The parameters used for the given remap 
+function are read out of the array and copied to the local pattern set
+description.
+******************************************************************************/
+
+krui_err kr_npui_setClassDistribution(unsigned int *class_sizes);
+/*****************************************************************************
+Set the class distribution for the current pattern set.
+This function may only be called if the current pattern set provides class 
+information. If <class_sizes> is not NULL it must locate an integer array of 
+size that matches the number of classes in the current set. The values of 
+this array are copied to the pattern set area. If <class_sizes> is the NULL
+pointer, then the real distribution of classes in the pattern set is 
+computed and stored in the class distribution area of the pattern set. So the
+interface may retrieve default values for the class distribution which match
+the real distribution of the pattern set.
+******************************************************************************/
+
+krui_err kr_npui_useChunk(bool active);
+/*****************************************************************************
+Switch on or off the class distribution process.
+If <active> is TRUE, the distribution process is activated. Therefore the 
+internal representation of the pattern set is virtually reorganized to match
+the requested values of <class_sizes>. After that step the number of patterns
+in the set virtually increases or decreases because each epoch must cover 
+every pattern of all classes that have a requested distribution amount bigger
+than 0. This also implies that several patterns from a specific class are 
+reused several times during one epoch.
+******************************************************************************/
+
+krui_err kr_npui_setClass(char *classname);
+/*****************************************************************************
+Set the class name for the current pattern.
+If the pattern set already contains class information, only the
+current pattern is affected. If there are no classes in the pattern
+set so far, all patterns of the current set are set to the given class
+name, since every pattern must belong to a class in that case.
+If the given class name is the NULL pointer, nothing happens at all.
+******************************************************************************/
+
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY OTHER KERNEL FUNCTIONS LIKE TRAINING
+ AND INITIALIZATION FUNCTIONS:
+******************************************************************************/
+
+struct np_symtab
+{
+    char *symname;             /* name of the class */
+    int set_amount;            /* total number of patterns of this
+				  class in the set */ 
+    int chunk_amount;          /* defined chunk size of this class
+				  within the set */
+    int symnum;                /* index to user visible class names
+				  list. This index has to be reset
+				  whenever the symbol table changes */
+
+    int my_chunks_per_set;     /* minimum number of chunks to use all
+				  patterns from this class */
+    int global_chunks;         /* global number of chunks to use all
+				  patterns from all classes from this
+				  set */
+    int pat_nums_size;         /* number of entries (size) of the
+				  pattern number list for this class
+				  */
+    int pat_nums_valid;        /* number of valid entries in the
+				  pattern number list (usually
+				  global_chunks * chunk_amount >= set_amount
+				  entries) */
+    int *pat_nums;             /* array of duplicated pattern numbers
+				  for this class */
+    int within_chunk_pos;      /* position counter within current
+				  chunk ( < chunk_amount) */
+    int chunk_comp_count;      /* backward counter used for chunk composition */
+    int chunk_comp_base;       /* base value used for chunk composition */
+    int pat_num_pos;           /* index to pat_nums[] for next pattern
+				  in chunk ( < pat_nums_valid) */
+
+    struct np_symtab *next;    /* next entry in symbol table */
+};
+
+typedef struct 
+{
+    pattern_set_info pub;      /* public part of the pattern set             */
+
+    bool chunk_shuffle;        /* chunk shuffle flag from last ordering      */
+    bool chunk_order_valid;    /* TRUE if all chunk arrays are valid         */
+    RemapFuncPtr rmf_ptr;      /* remap function pointer or NULL             */
+} np_pattern_set_info;
+
+typedef struct
+{
+    pattern_descriptor pub;    /* public part of the current pattern         */
+
+    float *input_pattern;      /* pointer to the input pattern data          */
+    float *output_pattern;     /* pointer to the output pattern data         */
+
+    struct np_symtab *mysym;   /* pointer to my symbol table entry */
+} np_pattern_descriptor;
+
+int  kr_np_pattern(int mode ,int mode1 ,int pattern_no);
+/*****************************************************************************
+multiple pattern handling functions depending on mode and mode1
+*****************************************************************************/
+
+krui_err kr_initSubPatternOrder(int start, int end);
+/*****************************************************************************
+The sub pattern ordering for the current pattern set is reset for the
+next training or initialization run. During this run all sub patterns
+from pattern <start> up to pattern <end> are generated according to
+current shuffle flags for patterns and sub patterns.
+kr_getSubPatByOrder is to be called to get the next sub pattern number
+during the run (see below)
+*****************************************************************************/
+
+bool kr_getSubPatternByOrder(int *pattern, int *sub);
+/*****************************************************************************
+According to the last call to kr_initSubPatternOrder, the last call to
+this function and the shuffle flags, the next position of pattern and
+sub pattern is determined. This numbers are returned in <pattern> and
+<sub> (beginning with 0). If there are no more sub pattern avaliable
+the return value is FALSE, otherwise TRUE.
+*****************************************************************************/
+
+bool kr_getSubPatternByNo(int *pattern, int *sub, int n);
+/*****************************************************************************
+According to the current pattern set, the position of the <n>th sub
+pattern is determined and returned in <pattern> (the pattern which
+includes the subpattern) and <sub> (the sub pattern inside the
+pattern) (beginning with 0). 
+This function does not effect the ordering of the function
+kr_getSubPatByOrder. <n> ranges from 0 to kr_TotalNoOfSubPatPairs()-1.
+If the sub pattern is available, TRUE is returned, otherwise FALSE.
+*****************************************************************************/
+
+int kr_TotalNoOfSubPatPairs(void);
+/*****************************************************************************
+This function returns the total number of available sub patterns for
+the current pattern set or 0 if no pattern set is defined.
+The result is the sum of the numbers of subpattern for all patterns in
+the current set.
+*****************************************************************************/
+
+int kr_NoOfSubPatPairs(int pattern);
+/*****************************************************************************
+This function returns the number of available sub patterns for the
+pattern <pattern> of the current pattern set or 0 if this pattern is
+not defined.
+*****************************************************************************/
+
+int kr_AbsPosOfFirstSubPat(int pattern);
+/*****************************************************************************
+This function returns the absolute position of the first sub pattern
+of pattern <pattern> in the current pattern set. This position is
+defined as the Sum of kr_NoOfSubPatPairs(i) where i runs from 0 to
+<pattern>-1.
+The absolute position of the first sub pattern of pattern 0 is 0.
+The returned value may be used as argument for the function
+kr_getSubPatternByNo.
+*****************************************************************************/
+
+int kr_TotalNoOfPattern(void);
+/*****************************************************************************
+This function returns the total number of available patterns for
+the current pattern set or 0 if no pattern set is defined.
+*****************************************************************************/
+
+Patterns kr_getSubPatData(int pat_no, int sub_no, int io_type, int *size);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the
+data array of the <sub_no>th sub pattern of the <pat_no>th pattern is
+returned. io_type spcifies whether the input (INPUT) or output
+(OUTPUT) data is requested. If <size> is != NULL the size of the data
+array is returned is this parameter.
+The function returns a pointer to the data array (type Patterns) or
+NULL if an error occured.
+*****************************************************************************/
+
+int kr_getSubPatClass(int pat_no, int sub_no);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern, the class index 
+(>=0) is returned. If the pattern set does not provide class information, the 
+return value is -1
+*****************************************************************************/
+
+int kr_SizeOfInputSubPat(void);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the size of 
+the input part of the first sub pattern of the first pattern is returned. 
+Negative return values indicate KernelErrorCode. Size 0 is a valid return value
+since the pattern may contain no data.
+*****************************************************************************/
+
+int kr_SizeOfOutputSubPat(void);
+/*****************************************************************************
+For the current pattern set and the specified sub pattern size, the size of 
+the output part of the first sub pattern of the first pattern is returned. 
+Negative return values indicate KernelErrorCode. Size 0 is a valid return value
+since the pattern may contain no data.
+*****************************************************************************/
+
+/*****************************************************************************
+ FUNCTIONS WHICH ARE CALLED BY THE PATTERN PARSER OR FROM INSIDE THIS
+ MODULE. DON'T USE THESE FUNCTIONS FOR OTHER PURPOSES !!!!!
+******************************************************************************/
+
+krui_err kr_np_AllocatePatternSet(int *pat_set, int number);
+/*****************************************************************************
+A new set of patterns with <number> number of patterns is defined. An
+internal pattern set number is assigned to reference this pattern set.
+It is returned in <pat_set>.
+******************************************************************************/
+
+krui_err kr_np_AllocatePattern(np_pattern_descriptor *pattern,
+			       bool input);
+/*****************************************************************************
+Depending on the entries input_dim, input_dim_sizes, input_fixsize resp.
+output_dim, output_dim_sizes, output_fixsize of the pattern descriptor
+<pattern> new memory for this pattern is allocated (input_pattern resp.
+output_pattern). input_info resp. output_info is set to (char *) NULL.
+The function allocates space for an input pattern if input is TRUE,
+output pattern otherwise.
+******************************************************************************/
+
+void kr_np_FreePattern(np_pattern_descriptor *pattern);
+/*****************************************************************************
+frees the area of the pattern data for this pattern
+******************************************************************************/
+
+krui_err kr_np_GetDescriptor(int pat_set, int number, 
+			     np_pattern_descriptor **pattern);
+/*****************************************************************************
+A pointer to the pattern pattern descriptor of pattern <number> in
+pattern set <pat_set> is returned in <pattern>. The structure pattern
+must be provided by the calling routine. A call to this function makes
+the specified pattern to become the current pattern.  Return value:
+error status
+******************************************************************************/
+
+krui_err kr_np_lookupSym(int pat_set, char *symbol, 
+			 struct np_symtab **entry);
+/*****************************************************************************
+Looks for the class name <symbol> ind set <pat_set>. If the name is
+not present up to now, a new entry is allocated and initialized. In
+case of success <*entry> is set to the symbol table entry.
+******************************************************************************/
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* size of memory pages for fixed size pattern: 0.5MB, 2KB in debug mode */
+#ifdef DEBUG_PATTERN
+#define KRNP_FIXED_PAGESIZE 0x800
+#else
+#define KRNP_FIXED_PAGESIZE 0x80000
+#endif
+
+/* data structure to handle pattern space management */
+struct patternpage
+{
+    int slotsize;              /* size of slots in multiples of sizeof(float) */
+    int no_of_slots;           /* total number of slots in this page */
+    int no_of_free_slots;      /* number of free slots in this page */
+    int firstfree;             /* index (base: *float) to first free slot or -1 */
+    float *data;               /* data area, total size:
+				  (no_of_slots * slotsize * sizeof(float)) */
+    struct patternpage *next;  /* next page */
+};
+
+/*****************************************************************************
+ INTERNAL FUNCTIONS OF THIS MODULE. IMPOSSIBLE TO CALL THESE FUNCTIONS
+ FROM OUTSIDE THE MODULE (IF NOBODY CHANGES THE STATIC DECLARATION) !!!!!!!
+******************************************************************************/
+
+static float *kr_np_floatmalloc(int size);
+/*****************************************************************************
+allocate pattern memory within a private memory page
+<size> is based on sizeof(float) !!
+******************************************************************************/
+
+static void kr_np_floatfree(float *ptr);
+/*****************************************************************************
+free the pattern memory within a private memory page
+******************************************************************************/
+
+static krui_err kr_np_InitPattern(void);
+/*****************************************************************************
+initialization of pattern descriptor array
+******************************************************************************/
+
+static krui_err kr_np_ReallocatePatternSet(int pat_set, int new_number);
+/*****************************************************************************
+reallocates the pattern set <pat_set> to contain <new_number> 
+of pattern entries.
+******************************************************************************/
+
+static krui_err kr_np_DeletePatternSet(int pat_set);
+/*****************************************************************************
+The pattern set <pat_set> is deleted. All memory of all pattern is
+given back to the operating system.
+******************************************************************************/
+
+static krui_err kr_np_DeletePattern(int pat_set, int pattern);
+/*****************************************************************************
+delete a specific pattern form a pattern set
+******************************************************************************/
+
+static void kr_np_delSym(int pat_set, struct np_symtab *entry);
+/*****************************************************************************
+delete the symbol table entry from the given pattern set.
+******************************************************************************/
+
+static krui_err kr_np_AddPattern(int pat_set, int *pattern);
+/*****************************************************************************
+Add an empty pattern descriptor to the specified pattern set. The position
+of the pattern inside the set is returned in <pattern>.
+******************************************************************************/
+
+static krui_err kr_np_LoadPatternFile(FILE *pat_file, int *pat_set);
+/*****************************************************************************
+The pattern file <pat_file> is loaded into memory. An internal pattern
+set number is assigned to this pattern file and returned in <pat_set>.
+Return value: error status
+******************************************************************************/
+
+static krui_err kr_np_SavePatternFile(FILE *pat_file, int pat_set);
+/*****************************************************************************
+The pattern set <pat_set> is saved to FILE <pat_file>.
+Return value: error status
+******************************************************************************/
+
+static krui_err kr_np_GetInfo(int pat_set, np_pattern_set_info *info);
+/*****************************************************************************
+All information concerning pattern set <pat_set> is copied into the
+informational structure <info> which must be provided by the calling
+routine.
+The current pattern set is set to pat_set.
+Return value: error status
+******************************************************************************/
+
+static krui_err kr_np_ValidateInfo(int pat_set);
+/*****************************************************************************
+update pattern set information if necessary
+******************************************************************************/
+
+static krui_err kr_np_GetSubPatSizes(int *input_size, int *output_size);
+/*****************************************************************************
+Depending on the current pattern set and the sub pattern training scheme,
+which must be defined, the size of the first input sub pattern and the size
+of the first output sub pattern is computed.
+******************************************************************************/
+
+static krui_err kr_np_GetSubPat(bool input, int *pos_coord, int *size_coord,
+				float **data, int *entries);
+/*****************************************************************************
+A sub pattern is cut out of the current pattern at position
+<pos_coord> with size <size_coord>. According to <input> the input
+part or the output part of the current pattern is used. A pointer to
+an array of float which contains the cut part is returned in <data>.
+<pos_coord> is an array of int which defines the position of the sub
+pattern inside the variable sized dimensions of the pattern.
+<size_coord> is an array of int which defines the size of the sub
+pattern in each dimensional direction. Both arrays must contain
+<input_dim> (or <output_dim>) entries (see pattern descriptor).
+
+Example: pattern with input_fixsize 2, input_dim 2, input_dim_sizes [4 5]
+(hint: the values of the pattern represent the position)
+
+{
+0.00, 0.01, 0.10, 0.11, 0.20, 0.21, 0.30, 0.31, 0.40, 0.41,
+1.00, 1.01, 1.10, 1.11, 1.20, 1.21, 1.30, 1.31, 1.40, 1.41,
+2.00, 2.01, 2.10, 2.11, 2.20, 2.21, 2.30, 2.31, 2.40, 2.41,
+3.00, 3.01, 3.10, 3.11, 3.20, 3.21, 3.30, 3.31, 3.40, 3.41,
+}
+
+the sub pattern with <pos_coord> [1 2], <size_coord> [3 2] looks like
+this:
+
+{
+1.20, 1.21, 1.30, 1.31,
+2.20, 2.21, 2.30, 2.31,
+3.20, 3.21, 3.30, 3.31,
+}
+
+The parameter entries returns the number of entries in the data field.
+
+******************************************************************************/
+
+static krui_err kr_np_SetSubPat(bool input, int *pos_coord, int *size_coord,
+				float *data, int entries);
+/*****************************************************************************
+Equivalent to kr_np_GetSubPat, but copies the <data> into the specified 
+sub pattern
+*****************************************************************************/
+
+static bool kr_np_align_sub_pos(int dim, int *n, int *psize, int *ssize, 
+				int *sstep, int *spos);
+/*****************************************************************************
+For a given pattern dimension size <psize> of <dim> dimensions and a
+given sub pattern size <ssize> the position <spos> of the sub pattern
+is alligned to a valid position and the ordering number of this sub
+pattern is returned in <n>. The shift pattern given in <sstep> is used
+to find valid allignment positions
+*****************************************************************************/
+
+static bool kr_np_gen_sub_pos(int dim, int *n, int *psize, int *ssize, 
+			      int *sstep, int *spos, bool count);
+/*****************************************************************************
+For a given pattern dimension size <psize> of <dim> dimensions and a
+given sub pattern size <ssize> the position <spos> of the <n>th sub
+pattern is calculated. The shift pattern given in <sstep> is used to
+move sub pattern over the pattern.
+If <count> is TRUE, only the number of possible positions is
+determined and returned in <n> if at least 1 valid position
+exists. <spos> is of no effect and may be NULL.
+RETURNS  : 
+TRUE if the <n>th subpattern exists or if <count> is TRUE and at least
+1 valid position exists, FALSE if <n> < 0.  If <n> is higher than the
+available number of subpattern, a wraparound occurs.
+<n> starts with 0 and ends with <number of possible positions> - 1 or
+returns number of possible positions.
+*****************************************************************************/
+
+static bool kr_np_allocate_pat_train_entries(int n);
+/*****************************************************************************
+allocate or reallocate an array which will later include the sorted or
+shuffled pattern order (during training)
+*****************************************************************************/
+
+static bool kr_np_allocate_sub_pat_train_entries(int n);
+/*****************************************************************************
+allocate or reallocate an array which will later include the sorted or
+shuffled order of the sub pattern of the current pattern
+*****************************************************************************/
+
+static bool kr_np_allocate_pat_mapping_entries(int n);
+/*****************************************************************************
+allocate or reallocate an array which will later include
+the virtual to physical pattern number mapping
+*****************************************************************************/
+
+static void kr_np_order_pat_entries(int start, int end);
+/*****************************************************************************
+Fills the allocated array for the pattern ordering with increasing
+numbers if patterns are sorted or with a random permutation if
+patterns are shuffled.  <start> and <end> define the first and last
+pattern number to be used
+*****************************************************************************/
+
+static void kr_np_order_sub_pat_entries(int start, int end);
+/*****************************************************************************
+Fills the allocated array for the sub pattern ordering with increasing
+numbers if sub patterns are sorted or with a random permutation if sub
+patterns are shuffled.  <start> and <end> define the first and last
+sub pattern number to be used
+*****************************************************************************/
+
+static void kr_np_order_chunk_arrays(bool shuffle, int pattern_set);
+/*****************************************************************************
+Fills the allocated array for the pattern ordering with increasing
+numbers if patterns are sorted or with a random permutation if
+patterns are shuffled.
+*****************************************************************************/
+
+static void kr_np_order_chunked_pat_entries(int pat_set, int start, int end); 
+/*****************************************************************************
+Fills the allocated array for the pattern ordering with the
+contents of all chunk arrays.  <start> and <end> define the first and
+last pattern number to be used
+*****************************************************************************/
+
+
+static void kr_np_fill_virtual_to_void_mapping(int pat_set);
+/*****************************************************************************
+Fills the allocated mapping array for the pattern ordering with
+the contents of all chunk arrays.
+*****************************************************************************/
+
+static int kr_np_virtual_to_physical(int vnum);
+/*****************************************************************************
+mapping of virtual pattern numbers to physically stored patterns
+*****************************************************************************/
+
+static int kr_np_physical_to_virtual(int pnum);
+/*****************************************************************************
+mapping of physical pattern number to a virtual number
+*****************************************************************************/
+
+static krui_err kr_np_DefineSubPatternOrdering(int pat_set, bool input, 
+					       int *size_coord, 
+					       int *incr_coord);
+/*****************************************************************************
+The shape and ordering of sub patterns for training and display is
+defined.  <pat_set> specifies the pattern set to use. The flag <input>
+determines whether input or output sub patterns are to be defined. The
+array size_coord spezifies the shape of the sub pattern like in
+kr_np_GetSubPat. The array incr_coord specifies how sub patterns are
+generated from the whole pattern by shifting the shape over this
+pattern. Each value in this array gives an incremental offset for one
+dimensional direction. The start position is at [0 0 0 ...]. New
+positions are generated by adding the rightmost value of incr_coord to
+the old position. If an overflow in this dimension occurs, this
+coordinate is reset to 0 and the next position to the left is
+incremented (and so on ...). After all sub patterns of one pattern are
+generated the next pattern is used. Depending on npui_shuffle_pattern
+and npui_shuffle_sub_pattern shuffling is activated.
+*****************************************************************************/
+
+static krui_err kr_np_showPatternSTD(int mode);
+/*****************************************************************************
+According to the mode kr_np_showPatternSTD stores the current
+Pattern/sub Pattern into the units activation (and/or output) values.
+The modes are:
+- OUTPUT_NOTHING
+store input pattern into input units activations
+- OUTPUT_ACT
+store input pattern into input units activations and store output
+pattern into output units activations
+- OUTPUT_OUT
+store input pattern into input units activations, store output pattern
+into output units activations and update output units output
+*****************************************************************************/
+
+static krui_err kr_np_modifyPattern(void);
+/*****************************************************************************
+The current activation of the input and output units is used to
+modify the current sub pattern.
+*****************************************************************************/
+
+/*****************************************************************************
+ STATIC VARIABLE DEFINITIONS
+*****************************************************************************/
+
+/* table for mapping of external pattern set numbers to internal
+   numbers. This array is always filled from the beginning. If a set
+   is deleted, all higher entries are moved down inside the table. */
+static int                npui_pat_sets[NO_OF_PAT_SETS];
+
+/* the number of used entries in the above table */
+static int                npui_number_pat_sets             = 0;
+
+/* the index of the current pattern set into the above table */
+static int                npui_curr_pat_set                = -1;
+
+/* the number of the current pattern for the current pattern set. This
+ is the pattern which is used for several user actions (modify, show,
+ ...). This is a virtual pattern number. */
+static int                npui_curr_pattern                = -1;
+
+/* stored values for the sub pattern size, position and shifting step
+   size */
+static int                npui_insize[MAX_NO_OF_VAR_DIM];
+static int                npui_outsize[MAX_NO_OF_VAR_DIM];
+static int                npui_inpos[MAX_NO_OF_VAR_DIM];
+static int                npui_outpos[MAX_NO_OF_VAR_DIM];
+static int                npui_instep[MAX_NO_OF_VAR_DIM];
+static int                npui_outstep[MAX_NO_OF_VAR_DIM];
+
+/* TRUE if size and position fields above are valid */
+static bool               npui_show_defined                = FALSE;
+
+/* TRUE if size and step sizes fields above are valid */
+static bool               npui_train_defined               = FALSE;
+
+/* shuffle flags as set by the user */
+static bool               npui_shuffle_pattern             = FALSE;
+static bool               npui_shuffle_sub_pattern         = FALSE;
+
+
+
+
+/* array of (sub) pattern numbers that are to be trained with the
+   current pattern set (pattern). numbers within this array may be
+   shuffled */
+static int                *np_pat_train_order              = NULL;
+static int                *np_sub_pat_train_order          = NULL;
+static int                *np_pat_mapping_order            = NULL;
+
+/* contents of np_(sub_)pat_train_order is valid, if this variable is
+ TRUE */
+static bool               np_pat_train_valid               = FALSE;
+static bool               np_sub_pat_train_valid           = FALSE;
+static bool               np_pat_mapping_valid             = FALSE;
+
+/* this is the allocated size of np_(sub_)pat_train_order. It is used
+   during reallocation for other pattern sets or different training
+   situations */
+static int                np_pat_train_size                = 0;
+static int                np_sub_pat_train_size            = 0;
+static int                np_pat_mapping_size              = 0;
+
+/* actual number of valid entries in the np_(sub_)pat_train_order
+   field. This number may be smaller than np_(sub_)pat_train_size */
+static int                np_pat_train_number              = 0;
+static int                np_sub_pat_train_number          = 0;
+
+/* index into np_(sub_)pat_train_order field which defines the
+   position of the next pattern number that is to be returned by an
+   ordered (or shuffled) pattern access. -1 means that alle field
+   antries have been processed in an ordered (shuffled) way. */
+static int                np_next_train_pat                = -1;
+static int                np_next_train_sub_pat            = -1;
+
+/* if pattern shuffling AND sub pattern shuffling is activated at the
+   same time, one epoch does not match the usual criterion that each
+   (sub-)pattern has to be presented once. Instead one epoch means
+   that np_random_train_number sub patterns from the current pattern
+   set are trained where several sub patterns may be trained more than
+   once. This done due to big overhead, if normal epoch definition is
+   used.
+   np_random_train_number equals the total number of sub patterns for
+   a mixed shuffled access */
+static int                np_random_train_number           = 0;
+
+/* This is the pattern-in-epoch counter for the mixed shuffled
+   access. -1 means that the epoch is completed */
+static int                np_next_train_random             = -1;
+
+
+
+/* This is the sub pattern definition/shifting scheme for the current
+   pattern set */
+static int                np_t_insize[MAX_NO_OF_VAR_DIM];
+static int                np_t_outsize[MAX_NO_OF_VAR_DIM];
+static int                np_t_instep[MAX_NO_OF_VAR_DIM];
+static int                np_t_outstep[MAX_NO_OF_VAR_DIM];
+
+/* size of the input and output parts of sub pattern for the current
+   sub pattern definition. */
+static int                np_sub_pat_input_size            = 0;
+static int                np_sub_pat_output_size           = 0;
+
+/* this flag denotes whether the above two variables are valid */
+static bool               np_sub_pat_sizes_valid           = FALSE;
+
+
+
+
+/* internal memory for the total number of sub patterns in the current
+   pattern set */
+static int                np_abs_count_No                  = 0;
+
+/* internal flag that determines, whether np_abs_count_No has a valid
+   entry or has to be recomputed otherwise. This flag is set to FALSE
+   during every operation, which may change the access structure to
+   the pattern set. */
+static bool               np_abs_count_valid               = FALSE;
+
+/* the field np_abs_count[n] contains the accumulated number of sub
+   patterns up to the pattern n. This field is used to find a specific
+   sub pattern by number. */
+static int                *np_abs_count                    = NULL;
+
+/* This is the allocated size of the field np_abs_count. */
+static int                np_abs_count_size                = 0;
+
+
+
+/* size of all following set specific arrays (equals NO_OF_PAT_SETS,
+   but kept as variable for further virtualization) */
+static int                   np_used_pat_set_entries       = 0;
+
+/* array if flags which are TRUE if the index is used for a loaded
+   pattern set */
+static bool                  *np_pat_set_used              = NULL;
+
+/* array of fields of pattern descriptors, here the patterns are stored
+   as defined in the pattern file */
+static np_pattern_descriptor **np_pat_sets                 = NULL;
+
+/* array of set descriptors which hold set specific data independent
+   from a specific pattern */
+static np_pattern_set_info   *np_info                      = NULL;
+
+/* array of flags which are true if the indexed set descriptor holds
+   valid data. These flags are reset if the structure of the pattern
+   set changes. To make the set descriptor valid, usually all patterns
+   in the set have to be examined */
+static bool                  *np_info_valid                = NULL;
+
+/* array of symbol tables to store the class names of the indexed
+   set. If NULL, the symbol table is empty which is equivalent that
+   the pattern set holds no class information */
+static struct np_symtab      **np_st                       = NULL;
+
+
+
+/* internal pointer to the current physical pattern in the current set */
+static np_pattern_descriptor *np_current_pattern           = NULL;
+
+
+
+/* data areas and allocated sizes to hold a sub pattern which is ready
+   for external usage (training, etc...). Note: the data within these
+   fields is read only, which means that modifications have no effect
+   on the stored pattern set */
+static float                 *np_i_subpat                  = NULL;
+static int                   np_i_subpatsize               = 0;
+static float                 *np_o_subpat                  = NULL;
+static int                   np_o_subpatsize               = 0;
+
+/* entry to private memory management */
+static struct patternpage    *np_pages                     = NULL;
+
+/* end private definition section */
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_parse_bison.y snort-2.3.3.new/src/kernel_snns/kr_pat_parse_bison.y
--- snort-2.3.3/src/kernel_snns/kr_pat_parse_bison.y	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_parse_bison.y	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,509 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_parse_bison.y,v $
+  SHORTNAME      : pat_parse
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : parser for new pattern format; bison format 
+  NOTES          : impossible to use with yacc
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/31 13:07:57 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+%{
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "kr_typ.h"
+#include "glob_typ.h"
+#include "kernel.h"
+#include "kr_pat_scan.h"
+#include "kr_newpattern.h"
+#include "kr_pat_parse.ph"
+%}
+
+%union
+{
+	float	value;		/* allgemeine Zahl */	
+        char    *name;          /* allgemeiner String */
+	struct
+	{
+		int	v;
+		int	r;
+	}	version;	/* Versionsnummer #.# */
+}
+
+%token	L_BRACKET R_BRACKET
+%token	VERSION_HEADER
+%token	GENERATED_AT
+%token	NO_OF_PATTERN NO_OF_INPUT NO_OF_OUTPUT
+%token	NO_OF_VAR_IDIM NO_OF_VAR_ODIM
+%token	MAXIMUM_IDIM MAXIMUM_ODIM
+%token  NO_OF_CLASSES CLASS_REDISTRIB
+%token  REMAPFUNCTION REMAP_PARAM
+%token	ERROR PATTERNEND PATTERNNOCLASS
+
+%token	<value> NUMBER
+%token  <name> NAME
+%token	<version> V_NUMBER
+
+%%
+
+pattern_file:	header
+		{	
+		    current_pattern = 0;
+		    next_pattern_is_input = 1;
+
+		    if (kr_np_AllocatePatternSet(&pattern_set, no_of_pattern)
+			!= KRERR_NO_ERROR)
+		    { 
+			yyerror("can't allocate memory"); 
+			YYABORT; 
+		    }
+		}		
+		pattern_list
+		{
+		    if (current_pattern < no_of_pattern ||
+			!next_pattern_is_input)
+		    { 
+			yyerror("unexpected end of file"); 
+			YYABORT; 
+		    }
+		    if (with_classes != this_set->pub.classes)
+		    {
+			yyerror("real number of classes does not match pattern file header");
+			YYABORT;
+		    }
+		}
+;
+
+header:	VERSION_HEADER V_NUMBER 
+	{
+		if (($2.v == CURRENT_VERSION_V && $2.r > CURRENT_VERSION_R) ||
+		    $2.v > CURRENT_VERSION_V)
+		{ 
+		    yyerror("version of pattern file not supported"); 
+		    YYABORT; 
+		}
+	}
+	GENERATED_AT NO_OF_PATTERN NUMBER
+	{
+		no_of_pattern = (int) $6;
+		if (no_of_pattern <= 0)
+		{ 
+		    yyerror("illegal number of pattern"); 
+		    YYABORT; 
+		}
+	}
+        i_head o_head vi_head vo_head 
+        {
+	    this_set->pub.classes = 0;
+	    this_set->pub.class_names = NULL;
+	    this_set->pub.class_distrib_active = FALSE;
+	    this_set->pub.class_redistribution = NULL;
+        }
+	cl_head
+        {
+	    this_set->pub.remap_function = NULL;
+	    this_set->pub.no_of_remap_params = 0;
+	}
+	rm_head
+;
+
+i_head:	NO_OF_INPUT NUMBER
+	{ 
+		no_of_input = (int) $2;
+		if (no_of_input < 0)
+		{ 
+		    yyerror("illegal number of input units"); 
+		    YYABORT; 
+		} 
+	}
+;
+
+o_head:	NO_OF_OUTPUT NUMBER
+	{ 
+		no_of_output = (int) $2;
+		if (no_of_output < 0)
+		{ 
+		    yyerror("illegal number of output units"); 
+		    YYABORT; 
+		} 
+	}
+	|
+	{ no_of_output = 0; }
+;
+
+vi_head: NO_OF_VAR_IDIM NUMBER MAXIMUM_IDIM actual_dim
+	{
+		variable_input_dim = $2; 
+		if (variable_input_dim < 0 || 
+		    variable_input_dim > MAX_NO_OF_VAR_I_DIM)
+		{ 
+		    yyerror("illegal variable input dimensions"); 
+		    YYABORT; 
+		}
+		if (actual_dim_count != variable_input_dim)
+		{ 
+		    yyerror("illegal number of entries in dimension list"); 
+		    YYABORT; 
+		}
+		for (i=0; i<variable_input_dim; i++)
+			max_i_dims[i] = dims[i];
+	}
+	|
+	{ variable_input_dim = 0; }
+;
+
+vo_head: NO_OF_VAR_ODIM NUMBER MAXIMUM_ODIM actual_dim
+	{
+		variable_output_dim = $2; 
+		if (variable_output_dim < 0 || 
+		    variable_output_dim > MAX_NO_OF_VAR_O_DIM ||
+		    no_of_output == 0)
+		{ 
+		    yyerror("illegal variable output dimensions"); 
+		    YYABORT; 
+		}
+		if (actual_dim_count != variable_output_dim)
+		{ 
+		    yyerror("illegal number of entries in dimension list"); 
+		    YYABORT; 
+		}
+		for (i=0; i<variable_output_dim; i++)
+			max_o_dims[i] = dims[i];	
+	}
+	|
+	{ variable_output_dim = 0; }
+;
+
+cl_head: NO_OF_CLASSES NUMBER
+{
+    with_classes = (int) $2;
+}
+| NO_OF_CLASSES NUMBER CLASS_REDISTRIB L_BRACKET 
+{
+    with_classes = (int) $2;
+    num_param = 0;
+}
+paramlist R_BRACKET
+{
+    int i;
+
+    this_set->pub.class_redistribution = 
+	(int *) malloc(num_param * sizeof(int));
+    if (!this_set->pub.class_redistribution)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+    for (i=0; i<num_param; i++)
+	this_set->pub.class_redistribution[i] = abs((int) parameter[i]);
+    this_set->pub.class_distrib_active = TRUE;
+    if (num_param != with_classes)
+    {
+	yyerror("contradictory definition of class redistribution and number of classes in pattern file header");
+	YYABORT;
+    }
+}
+| /* empty */
+{
+    with_classes = 0;
+}
+;
+
+rm_head: REMAPFUNCTION NAME
+{
+    this_set->pub.remap_function = strdup($2);
+    if (!this_set->pub.remap_function)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+}
+| REMAPFUNCTION NAME REMAP_PARAM L_BRACKET 
+{
+    num_param = 0;
+}
+paramlist R_BRACKET
+{
+    int i;
+
+    this_set->pub.remap_function = strdup($2);
+    if (!this_set->pub.remap_function)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+
+    if (num_param > NO_OF_REMAP_PARAMS)
+    {
+	yyerror("to many parameters for remap function");
+	YYABORT;
+    }
+
+    this_set->pub.no_of_remap_params = num_param;
+    for (i=0; i<num_param; i++)
+	this_set->pub.remap_params[i] = parameter[i];
+}
+| /* empty */
+;
+
+paramlist: param
+| paramlist param
+;
+
+param: NUMBER
+{
+    num_param++;
+    if (num_param > 1)
+	parameter = (float *) realloc(parameter, num_param * sizeof(float));
+    else
+	parameter = (float *) malloc(sizeof(float));
+
+    parameter[num_param-1] = $1;
+}
+;
+
+actual_dim: L_BRACKET 
+		{
+			actual_dim_count = 0;
+		}
+	    actual_dim_rest R_BRACKET
+        | L_BRACKET R_BRACKET                
+                {
+		        actual_dim_count = 0;
+		}
+;
+
+actual_dim_rest: dim_entry
+	| actual_dim_rest dim_entry
+;
+
+dim_entry: NUMBER
+	{
+		if (actual_dim_count >= MAX_NO_OF_VAR_DIM)
+		{ 
+		    yyerror("to many entries in dimension list"); 
+		    YYABORT; 
+		}
+		dims[actual_dim_count] = (int) $1;
+		if (dims[actual_dim_count] <= 0)
+		{ 
+		    yyerror("illegal size of dimension"); 
+		    YYABORT; 
+		}
+		actual_dim_count++;
+	}
+;
+
+pattern_list: pattern
+	|     pattern_list pattern
+;
+
+pattern: 
+{
+    if (current_pattern >= no_of_pattern)
+    { 
+	yyerror("to many patterns"); 
+	YYABORT; 
+    }
+} 
+pattern_start 
+{
+    if (kr_np_GetDescriptor(pattern_set, current_pattern, &pattern)
+	!= KRERR_NO_ERROR)
+    {
+	yyerror("pattern parser internal error");
+	YYABORT;
+    }
+    if (next_pattern_is_input)
+    {
+	pattern -> pub.input_fixsize = no_of_input;
+	pattern -> pub.input_dim = variable_input_dim;
+	pattern -> pub.output_fixsize = no_of_output;
+	pattern -> pub.output_dim = variable_output_dim;
+	if (actual_dim_count != variable_input_dim)
+	{ 
+	    yyerror("illegal number of entries in dimension list"); 
+	    YYABORT; 
+	}
+	act_size = no_of_input;
+	for (i=0; i<variable_input_dim; i++)
+	{
+	    if (dims[i] > max_i_dims[i])
+	    { 
+		yyerror("variable dimension overflow"); 
+		YYABORT; 
+	    }
+	    act_size *= dims[i];
+	    (pattern -> pub.input_dim_sizes)[i] = dims[i];
+	}
+	if (kr_np_AllocatePattern(pattern, next_pattern_is_input)
+	    != KRERR_NO_ERROR)
+	{ 
+	    yyerror("can't allocate memory"); 
+	    YYABORT; 
+	}
+	pat_mem = pattern -> input_pattern;
+    }
+    else
+    {
+	if (actual_dim_count != variable_output_dim)
+	{ 
+	    yyerror("illegal number of entries in dimension list"); 
+	    YYABORT; 
+	}
+	act_size = no_of_output;
+	for (i=0; i<variable_output_dim; i++)
+	{
+	    if (dims[i] > max_o_dims[i])
+	    { 
+		yyerror("variable dimension overflow"); 
+		YYABORT; 
+	    }
+	    act_size *= dims[i];
+	    (pattern -> pub.output_dim_sizes)[i] = dims[i];
+	}
+	if (kr_np_AllocatePattern(pattern, next_pattern_is_input)
+	    != KRERR_NO_ERROR)
+	{ 
+	    yyerror("can't allocate memory"); 
+	    YYABORT; 
+	}
+	pat_mem = pattern -> output_pattern;
+    }
+}
+pattern_body 
+{
+    if (act_size > 0)
+    { 
+	yyerror("to little values in pattern"); 
+	YYABORT; 
+    }
+}
+PATTERNEND
+{
+    if (with_classes == 0 || (next_pattern_is_input && no_of_output > 0))
+	scanner_await_no_class();
+    else
+	scanner_await_class();
+}
+pattern_class
+{
+    if (no_of_output > 0)
+	next_pattern_is_input = !next_pattern_is_input;
+    
+    if (next_pattern_is_input)
+	current_pattern++;
+}
+;
+
+pattern_start: actual_dim
+        | /* empty */
+{
+    actual_dim_count = 0;
+}
+;
+
+
+pattern_body: pattern_entry
+	|     pattern_body pattern_entry
+;
+
+pattern_entry: NUMBER
+	{
+		if (act_size == 0)
+		{ 
+		    yyerror("to many values in pattern"); 
+		    YYABORT; 
+		}
+		*pat_mem++ = $1;
+		if (--act_size == 0)
+		    scanner_await_pattern_end(); 
+	}
+;
+
+pattern_class: 
+PATTERNNOCLASS
+{
+    pattern->mysym = NULL;
+}
+| NAME
+{
+    if (kr_np_lookupSym(pattern_set, $1, &this_class) != KRERR_NO_ERROR)
+    { 
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+    if (this_class->set_amount == 0)
+	this_set->pub.classes++;
+    this_class->set_amount++;
+    pattern->mysym = this_class;    
+}
+;
+
+%%
+
+/*****************************************************************************
+  FUNCTION : yyerror
+
+  PURPOSE  : must be provided for the parser.
+             reports errors in pattern file to stderr
+  RETURNS  : nothing
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+static void yyerror(char *error)
+{
+    fprintf(stderr, "Parse error in pattern file at line %d:\n%s\n",
+	    lineno, error);
+}
+
+/*****************************************************************************
+  FUNCTION : parse_pattern_file
+
+  PURPOSE  : calls the real parser
+
+  RETURNS  : parser error code and the handle to the loaded pattern set
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int parse_pattern_file(int *set, np_pattern_set_info *set_info)
+{
+    int err;
+
+#if YYDEBUG != 0
+#ifdef DEBUG_PARSER
+    yydebug = 1;
+#else
+    yydebug = 0;
+#endif
+#endif
+
+    lineno = 1;
+    this_set = set_info;
+    err = yyparse();
+    *set = pattern_set;
+
+    if (err == 0)
+	lineno = 0;
+
+    return err;
+}
+
+/*****************************************************************************
+END OF FILE
+******************************************************************************/
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_parse.c snort-2.3.3.new/src/kernel_snns/kr_pat_parse.c
--- snort-2.3.3/src/kernel_snns/kr_pat_parse.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_parse.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1392 @@
+
+/*  A Bison parser, made from kr_pat_parse_bison.y
+ by  GNU Bison version 1.25
+  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse ppparse
+#define yylex pplex
+#define yyerror pperror
+#define yylval pplval
+#define yychar ppchar
+#define yydebug ppdebug
+#define yynerrs ppnerrs
+#define	L_BRACKET	258
+#define	R_BRACKET	259
+#define	VERSION_HEADER	260
+#define	GENERATED_AT	261
+#define	NO_OF_PATTERN	262
+#define	NO_OF_INPUT	263
+#define	NO_OF_OUTPUT	264
+#define	NO_OF_VAR_IDIM	265
+#define	NO_OF_VAR_ODIM	266
+#define	MAXIMUM_IDIM	267
+#define	MAXIMUM_ODIM	268
+#define	NO_OF_CLASSES	269
+#define	CLASS_REDISTRIB	270
+#define	REMAPFUNCTION	271
+#define	REMAP_PARAM	272
+#define	ERROR	273
+#define	PATTERNEND	274
+#define	PATTERNNOCLASS	275
+#define	NUMBER	276
+#define	NAME	277
+#define	V_NUMBER	278
+
+#line 59 "kr_pat_parse_bison.y"
+
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "kr_typ.h"
+#include "glob_typ.h"
+#include "kernel.h"
+#include "kr_pat_scan.h"
+#include "kr_newpattern.h"
+#include "kr_pat_parse.ph"
+
+#line 74 "kr_pat_parse_bison.y"
+typedef union
+{
+	float	value;		/* allgemeine Zahl */	
+        char    *name;          /* allgemeiner String */
+	struct
+	{
+		int	v;
+		int	r;
+	}	version;	/* Versionsnummer #.# */
+} YYSTYPE;
+#ifndef YYDEBUG
+#define YYDEBUG 1
+#endif
+
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		74
+#define	YYFLAG		-32768
+#define	YYNTBASE	24
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 278 ? yytranslate[x] : 55)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
+    16,    17,    18,    19,    20,    21,    22,    23
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     1,     5,     6,     7,     8,     9,    25,    28,    31,
+    32,    37,    38,    43,    44,    47,    48,    56,    57,    60,
+    61,    69,    70,    72,    75,    77,    78,    83,    86,    88,
+    91,    93,    95,    98,    99,   100,   101,   102,   111,   113,
+   114,   116,   119,   121,   123
+};
+
+static const short yyrhs[] = {    -1,
+    26,    25,    45,     0,     0,     0,     0,     0,     5,    23,
+    27,     6,     7,    21,    28,    31,    32,    33,    34,    29,
+    35,    30,    37,     0,     8,    21,     0,     9,    21,     0,
+     0,    10,    21,    12,    41,     0,     0,    11,    21,    13,
+    41,     0,     0,    14,    21,     0,     0,    14,    21,    15,
+     3,    36,    39,     4,     0,     0,    16,    22,     0,     0,
+    16,    22,    17,     3,    38,    39,     4,     0,     0,    40,
+     0,    39,    40,     0,    21,     0,     0,     3,    42,    43,
+     4,     0,     3,     4,     0,    44,     0,    43,    44,     0,
+    21,     0,    46,     0,    45,    46,     0,     0,     0,     0,
+     0,    47,    51,    48,    52,    49,    19,    50,    54,     0,
+    41,     0,     0,    53,     0,    52,    53,     0,    21,     0,
+    20,     0,    22,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   101,   114,   129,   138,   147,   155,   160,   162,   173,   182,
+   186,   203,   207,   225,   229,   233,   238,   258,   264,   273,
+   277,   298,   301,   302,   305,   317,   321,   322,   328,   329,
+   332,   349,   350,   353,   362,   427,   435,   442,   451,   452,
+   459,   460,   463,   476,   481
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","L_BRACKET",
+"R_BRACKET","VERSION_HEADER","GENERATED_AT","NO_OF_PATTERN","NO_OF_INPUT","NO_OF_OUTPUT",
+"NO_OF_VAR_IDIM","NO_OF_VAR_ODIM","MAXIMUM_IDIM","MAXIMUM_ODIM","NO_OF_CLASSES",
+"CLASS_REDISTRIB","REMAPFUNCTION","REMAP_PARAM","ERROR","PATTERNEND","PATTERNNOCLASS",
+"NUMBER","NAME","V_NUMBER","pattern_file","@1","header","@2","@3","@4","@5",
+"i_head","o_head","vi_head","vo_head","cl_head","@6","rm_head","@7","paramlist",
+"param","actual_dim","@8","actual_dim_rest","dim_entry","pattern_list","pattern",
+"@9","@10","@11","@12","pattern_start","pattern_body","pattern_entry","pattern_class", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+    25,    24,    27,    28,    29,    30,    26,    31,    32,    32,
+    33,    33,    34,    34,    35,    36,    35,    35,    37,    38,
+    37,    37,    39,    39,    40,    42,    41,    41,    43,    43,
+    44,    45,    45,    47,    48,    49,    50,    46,    51,    51,
+    52,    52,    53,    54,    54
+};
+
+static const short yyr2[] = {     0,
+     0,     3,     0,     0,     0,     0,    15,     2,     2,     0,
+     4,     0,     4,     0,     2,     0,     7,     0,     2,     0,
+     7,     0,     1,     2,     1,     0,     4,     2,     1,     2,
+     1,     1,     2,     0,     0,     0,     0,     8,     1,     0,
+     1,     2,     1,     1,     1
+};
+
+static const short yydefact[] = {     0,
+     0,     1,     3,    34,     0,    34,    32,    40,     0,    33,
+    26,    39,    35,     0,    28,     0,     0,     4,    31,     0,
+    29,    43,    36,    41,     0,    27,    30,     0,    42,     0,
+    10,    37,     8,     0,    12,     0,     9,     0,    14,    44,
+    45,    38,     0,     0,     5,     0,     0,    18,    11,     0,
+     0,     6,    13,    15,    22,     0,     0,     7,    16,    19,
+     0,     0,    25,     0,    23,    20,    17,    24,     0,     0,
+    21,     0,     0,     0
+};
+
+static const short yydefgoto[] = {    72,
+     4,     2,     5,    25,    48,    55,    31,    35,    39,    45,
+    52,    61,    58,    69,    64,    65,    12,    16,    20,    21,
+     6,     7,     8,    17,    28,    36,    13,    23,    24,    42
+};
+
+static const short yypact[] = {     1,
+   -13,-32768,-32768,-32768,     5,    12,-32768,    10,     7,-32768,
+    11,-32768,-32768,    -5,-32768,    -1,     0,-32768,-32768,    -4,
+-32768,-32768,     0,-32768,    14,-32768,-32768,     4,-32768,     3,
+    16,-32768,-32768,     6,    18,   -15,-32768,     8,    15,-32768,
+-32768,-32768,    19,     9,-32768,    10,    20,    21,-32768,    10,
+    13,-32768,-32768,    17,    22,    33,    23,-32768,-32768,    24,
+    25,    34,-32768,    -3,-32768,-32768,-32768,-32768,    25,    -2,
+-32768,    39,    40,-32768
+};
+
+static const short yypgoto[] = {-32768,
+-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
+-32768,-32768,-32768,-32768,   -27,   -61,   -42,-32768,-32768,    27,
+-32768,    37,-32768,-32768,-32768,-32768,-32768,-32768,    26,-32768
+};
+
+
+#define	YYLAST		49
+
+
+static const short yytable[] = {    26,
+    67,    71,    68,    49,    40,     1,    41,    53,    68,     3,
+     9,    -2,    11,    14,    15,    18,    19,    63,    63,    19,
+    22,    30,    32,    33,    34,    44,    37,    38,    43,    47,
+    46,    56,    50,    54,    51,    59,    66,    57,    73,    74,
+    62,    70,    10,     0,    60,    63,    27,     0,    29
+};
+
+static const short yycheck[] = {     4,
+     4,     4,    64,    46,    20,     5,    22,    50,    70,    23,
+     6,     0,     3,     7,     4,    21,    21,    21,    21,    21,
+    21,     8,    19,    21,     9,    11,    21,    10,    21,    21,
+    12,    15,    13,    21,    14,     3,     3,    16,     0,     0,
+    17,    69,     6,    -1,    22,    21,    20,    -1,    23
+};
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/local/share/bison.simple"
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+#ifndef alloca
+#ifdef __GNUC__
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
+#include <alloca.h>
+#else /* not sparc */
+#if defined (MSDOS) && !defined (__TURBOC__)
+#include <malloc.h>
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+#include <malloc.h>
+ #pragma alloca
+#else /* not MSDOS, __TURBOC__, or _AIX */
+#ifdef __hpux
+#ifdef __cplusplus
+extern "C" {
+void *alloca (unsigned int);
+};
+#else /* not __cplusplus */
+void *alloca ();
+#endif /* not __cplusplus */
+#endif /* __hpux */
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc.  */
+#endif /* not GNU C.  */
+#endif /* alloca not defined.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	return(0)
+#define YYABORT 	return(1)
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+int yyparse (void);
+#endif
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, int count)
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 196 "/usr/local/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 1:
+#line 102 "kr_pat_parse_bison.y"
+{	
+		    current_pattern = 0;
+		    next_pattern_is_input = 1;
+
+		    if (kr_np_AllocatePatternSet(&pattern_set, no_of_pattern)
+			!= KRERR_NO_ERROR)
+		    { 
+			yyerror("can't allocate memory"); 
+			YYABORT; 
+		    }
+		;
+    break;}
+case 2:
+#line 114 "kr_pat_parse_bison.y"
+{
+		    if (current_pattern < no_of_pattern ||
+			!next_pattern_is_input)
+		    { 
+			yyerror("unexpected end of file"); 
+			YYABORT; 
+		    }
+		    if (with_classes != this_set->pub.classes)
+		    {
+			yyerror("real number of classes does not match pattern file header");
+			YYABORT;
+		    }
+		;
+    break;}
+case 3:
+#line 130 "kr_pat_parse_bison.y"
+{
+		if ((yyvsp[0].version.v == CURRENT_VERSION_V && yyvsp[0].version.r > CURRENT_VERSION_R) ||
+		    yyvsp[0].version.v > CURRENT_VERSION_V)
+		{ 
+		    yyerror("version of pattern file not supported"); 
+		    YYABORT; 
+		}
+	;
+    break;}
+case 4:
+#line 139 "kr_pat_parse_bison.y"
+{
+		no_of_pattern = (int) yyvsp[0].value;
+		if (no_of_pattern <= 0)
+		{ 
+		    yyerror("illegal number of pattern"); 
+		    YYABORT; 
+		}
+	;
+    break;}
+case 5:
+#line 148 "kr_pat_parse_bison.y"
+{
+	    this_set->pub.classes = 0;
+	    this_set->pub.class_names = NULL;
+	    this_set->pub.class_distrib_active = FALSE;
+	    this_set->pub.class_redistribution = NULL;
+        ;
+    break;}
+case 6:
+#line 155 "kr_pat_parse_bison.y"
+{
+	    this_set->pub.remap_function = NULL;
+	    this_set->pub.no_of_remap_params = 0;
+	;
+    break;}
+case 8:
+#line 163 "kr_pat_parse_bison.y"
+{ 
+		no_of_input = (int) yyvsp[0].value;
+		if (no_of_input < 0)
+		{ 
+		    yyerror("illegal number of input units"); 
+		    YYABORT; 
+		} 
+	;
+    break;}
+case 9:
+#line 174 "kr_pat_parse_bison.y"
+{ 
+		no_of_output = (int) yyvsp[0].value;
+		if (no_of_output < 0)
+		{ 
+		    yyerror("illegal number of output units"); 
+		    YYABORT; 
+		} 
+	;
+    break;}
+case 10:
+#line 183 "kr_pat_parse_bison.y"
+{ no_of_output = 0; ;
+    break;}
+case 11:
+#line 187 "kr_pat_parse_bison.y"
+{
+		variable_input_dim = yyvsp[-2].value; 
+		if (variable_input_dim < 0 || 
+		    variable_input_dim > MAX_NO_OF_VAR_I_DIM)
+		{ 
+		    yyerror("illegal variable input dimensions"); 
+		    YYABORT; 
+		}
+		if (actual_dim_count != variable_input_dim)
+		{ 
+		    yyerror("illegal number of entries in dimension list"); 
+		    YYABORT; 
+		}
+		for (i=0; i<variable_input_dim; i++)
+			max_i_dims[i] = dims[i];
+	;
+    break;}
+case 12:
+#line 204 "kr_pat_parse_bison.y"
+{ variable_input_dim = 0; ;
+    break;}
+case 13:
+#line 208 "kr_pat_parse_bison.y"
+{
+		variable_output_dim = yyvsp[-2].value; 
+		if (variable_output_dim < 0 || 
+		    variable_output_dim > MAX_NO_OF_VAR_O_DIM ||
+		    no_of_output == 0)
+		{ 
+		    yyerror("illegal variable output dimensions"); 
+		    YYABORT; 
+		}
+		if (actual_dim_count != variable_output_dim)
+		{ 
+		    yyerror("illegal number of entries in dimension list"); 
+		    YYABORT; 
+		}
+		for (i=0; i<variable_output_dim; i++)
+			max_o_dims[i] = dims[i];	
+	;
+    break;}
+case 14:
+#line 226 "kr_pat_parse_bison.y"
+{ variable_output_dim = 0; ;
+    break;}
+case 15:
+#line 230 "kr_pat_parse_bison.y"
+{
+    with_classes = (int) yyvsp[0].value;
+;
+    break;}
+case 16:
+#line 234 "kr_pat_parse_bison.y"
+{
+    with_classes = (int) yyvsp[-2].value;
+    num_param = 0;
+;
+    break;}
+case 17:
+#line 239 "kr_pat_parse_bison.y"
+{
+    int i;
+
+    this_set->pub.class_redistribution = 
+	(int *) malloc(num_param * sizeof(int));
+    if (!this_set->pub.class_redistribution)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+    for (i=0; i<num_param; i++)
+	this_set->pub.class_redistribution[i] = abs((int) parameter[i]);
+    this_set->pub.class_distrib_active = TRUE;
+    if (num_param != with_classes)
+    {
+	yyerror("contradictory definition of class redistribution and number of classes in pattern file header");
+	YYABORT;
+    }
+;
+    break;}
+case 18:
+#line 259 "kr_pat_parse_bison.y"
+{
+    with_classes = 0;
+;
+    break;}
+case 19:
+#line 265 "kr_pat_parse_bison.y"
+{
+    this_set->pub.remap_function = strdup(yyvsp[0].name);
+    if (!this_set->pub.remap_function)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+;
+    break;}
+case 20:
+#line 274 "kr_pat_parse_bison.y"
+{
+    num_param = 0;
+;
+    break;}
+case 21:
+#line 278 "kr_pat_parse_bison.y"
+{
+    int i;
+
+    this_set->pub.remap_function = strdup(yyvsp[-5].name);
+    if (!this_set->pub.remap_function)
+    {
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+
+    if (num_param > NO_OF_REMAP_PARAMS)
+    {
+	yyerror("to many parameters for remap function");
+	YYABORT;
+    }
+
+    this_set->pub.no_of_remap_params = num_param;
+    for (i=0; i<num_param; i++)
+	this_set->pub.remap_params[i] = parameter[i];
+;
+    break;}
+case 25:
+#line 306 "kr_pat_parse_bison.y"
+{
+    num_param++;
+    if (num_param > 1)
+	parameter = (float *) realloc(parameter, num_param * sizeof(float));
+    else
+	parameter = (float *) malloc(sizeof(float));
+
+    parameter[num_param-1] = yyvsp[0].value;
+;
+    break;}
+case 26:
+#line 318 "kr_pat_parse_bison.y"
+{
+			actual_dim_count = 0;
+		;
+    break;}
+case 28:
+#line 323 "kr_pat_parse_bison.y"
+{
+		        actual_dim_count = 0;
+		;
+    break;}
+case 31:
+#line 333 "kr_pat_parse_bison.y"
+{
+		if (actual_dim_count >= MAX_NO_OF_VAR_DIM)
+		{ 
+		    yyerror("to many entries in dimension list"); 
+		    YYABORT; 
+		}
+		dims[actual_dim_count] = (int) yyvsp[0].value;
+		if (dims[actual_dim_count] <= 0)
+		{ 
+		    yyerror("illegal size of dimension"); 
+		    YYABORT; 
+		}
+		actual_dim_count++;
+	;
+    break;}
+case 34:
+#line 354 "kr_pat_parse_bison.y"
+{
+    if (current_pattern >= no_of_pattern)
+    { 
+	yyerror("to many patterns"); 
+	YYABORT; 
+    }
+;
+    break;}
+case 35:
+#line 362 "kr_pat_parse_bison.y"
+{
+    if (kr_np_GetDescriptor(pattern_set, current_pattern, &pattern)
+	!= KRERR_NO_ERROR)
+    {
+	yyerror("pattern parser internal error");
+	YYABORT;
+    }
+    if (next_pattern_is_input)
+    {
+	pattern -> pub.input_fixsize = no_of_input;
+	pattern -> pub.input_dim = variable_input_dim;
+	pattern -> pub.output_fixsize = no_of_output;
+	pattern -> pub.output_dim = variable_output_dim;
+	if (actual_dim_count != variable_input_dim)
+	{ 
+	    yyerror("illegal number of entries in dimension list"); 
+	    YYABORT; 
+	}
+	act_size = no_of_input;
+	for (i=0; i<variable_input_dim; i++)
+	{
+	    if (dims[i] > max_i_dims[i])
+	    { 
+		yyerror("variable dimension overflow"); 
+		YYABORT; 
+	    }
+	    act_size *= dims[i];
+	    (pattern -> pub.input_dim_sizes)[i] = dims[i];
+	}
+	if (kr_np_AllocatePattern(pattern, next_pattern_is_input)
+	    != KRERR_NO_ERROR)
+	{ 
+	    yyerror("can't allocate memory"); 
+	    YYABORT; 
+	}
+	pat_mem = pattern -> input_pattern;
+    }
+    else
+    {
+	if (actual_dim_count != variable_output_dim)
+	{ 
+	    yyerror("illegal number of entries in dimension list"); 
+	    YYABORT; 
+	}
+	act_size = no_of_output;
+	for (i=0; i<variable_output_dim; i++)
+	{
+	    if (dims[i] > max_o_dims[i])
+	    { 
+		yyerror("variable dimension overflow"); 
+		YYABORT; 
+	    }
+	    act_size *= dims[i];
+	    (pattern -> pub.output_dim_sizes)[i] = dims[i];
+	}
+	if (kr_np_AllocatePattern(pattern, next_pattern_is_input)
+	    != KRERR_NO_ERROR)
+	{ 
+	    yyerror("can't allocate memory"); 
+	    YYABORT; 
+	}
+	pat_mem = pattern -> output_pattern;
+    }
+;
+    break;}
+case 36:
+#line 427 "kr_pat_parse_bison.y"
+{
+    if (act_size > 0)
+    { 
+	yyerror("to little values in pattern"); 
+	YYABORT; 
+    }
+;
+    break;}
+case 37:
+#line 435 "kr_pat_parse_bison.y"
+{
+    if (with_classes == 0 || (next_pattern_is_input && no_of_output > 0))
+	scanner_await_no_class();
+    else
+	scanner_await_class();
+;
+    break;}
+case 38:
+#line 442 "kr_pat_parse_bison.y"
+{
+    if (no_of_output > 0)
+	next_pattern_is_input = !next_pattern_is_input;
+    
+    if (next_pattern_is_input)
+	current_pattern++;
+;
+    break;}
+case 40:
+#line 453 "kr_pat_parse_bison.y"
+{
+    actual_dim_count = 0;
+;
+    break;}
+case 43:
+#line 464 "kr_pat_parse_bison.y"
+{
+		if (act_size == 0)
+		{ 
+		    yyerror("to many values in pattern"); 
+		    YYABORT; 
+		}
+		*pat_mem++ = yyvsp[0].value;
+		if (--act_size == 0)
+		    scanner_await_pattern_end(); 
+	;
+    break;}
+case 44:
+#line 478 "kr_pat_parse_bison.y"
+{
+    pattern->mysym = NULL;
+;
+    break;}
+case 45:
+#line 482 "kr_pat_parse_bison.y"
+{
+    if (kr_np_lookupSym(pattern_set, yyvsp[0].name, &this_class) != KRERR_NO_ERROR)
+    { 
+	yyerror("can't allocate memory"); 
+	YYABORT; 
+    }
+    if (this_class->set_amount == 0)
+	this_set->pub.classes++;
+    this_class->set_amount++;
+    pattern->mysym = this_class;    
+;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 498 "/usr/local/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+}
+#line 495 "kr_pat_parse_bison.y"
+
+
+/*****************************************************************************
+  FUNCTION : yyerror
+
+  PURPOSE  : must be provided for the parser.
+             reports errors in pattern file to stderr
+  RETURNS  : nothing
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+static void yyerror(char *error)
+{
+    fprintf(stderr, "Parse error in pattern file at line %d:\n%s\n",
+	    lineno, error);
+}
+
+/*****************************************************************************
+  FUNCTION : parse_pattern_file
+
+  PURPOSE  : calls the real parser
+
+  RETURNS  : parser error code and the handle to the loaded pattern set
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+int parse_pattern_file(int *set, np_pattern_set_info *set_info)
+{
+    int err;
+
+#if YYDEBUG != 0
+#ifdef DEBUG_PARSER
+    yydebug = 1;
+#else
+    yydebug = 0;
+#endif
+#endif
+
+    lineno = 1;
+    this_set = set_info;
+    err = yyparse();
+    *set = pattern_set;
+
+    if (err == 0)
+	lineno = 0;
+
+    return err;
+}
+
+/*****************************************************************************
+END OF FILE
+******************************************************************************/
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_parse.h snort-2.3.3.new/src/kernel_snns/kr_pat_parse.h
--- snort-2.3.3/src/kernel_snns/kr_pat_parse.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_parse.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,36 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_parse.h,v $
+  SHORTNAME      : pat_parse
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : parser for new pattern format; bison format 
+  NOTES          : impossible to use with yacc
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:26:59 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_PAT_PARSE_DEFINED_
+#define _KR_PAT_PARSE_DEFINED_
+
+/* begin global definition section */
+
+#define CURRENT_VERSION_V       4  /* current version of pattern file        */
+#define CURRENT_VERSION_R       2  /* format                                 */
+
+extern int parse_pattern_file(int *set, np_pattern_set_info *this_set);
+
+
+/* end global definition section */
+
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_parse.ph snort-2.3.3.new/src/kernel_snns/kr_pat_parse.ph
--- snort-2.3.3/src/kernel_snns/kr_pat_parse.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_parse.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,64 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_parse.ph,v $
+  SHORTNAME      : pat_parse
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : parser for new pattern format; bison format 
+  NOTES          : impossible to use with yacc
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:00 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_PAT_PARSE_DEFINED_
+#define _KR_PAT_PARSE_DEFINED_
+
+/* begin global definition section */
+
+#define CURRENT_VERSION_V       4  /* current version of pattern file        */
+#define CURRENT_VERSION_R       2  /* format                                 */
+
+int parse_pattern_file(int *set, np_pattern_set_info *this_set);
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+static int	i;
+static int	dims[MAX_NO_OF_VAR_DIM];
+static int	max_i_dims[MAX_NO_OF_VAR_I_DIM];
+static int	max_o_dims[MAX_NO_OF_VAR_O_DIM];
+static int	actual_dim_count;
+static int	variable_input_dim;
+static int	variable_output_dim;
+static int	current_pattern;
+static int	next_pattern_is_input;
+static int	no_of_input;
+static int	no_of_output;
+static int	no_of_pattern;
+static int	act_size;
+static float	*pat_mem;
+static int      pattern_set;
+static np_pattern_descriptor *pattern;
+static int      with_classes;
+static struct np_symtab *this_class;
+static int      num_param = 0;
+static float    *parameter = NULL;
+
+static np_pattern_set_info *this_set;
+
+static void yyerror(char *error);
+
+/* end private definition section */
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_scan.c snort-2.3.3.new/src/kernel_snns/kr_pat_scan.c
--- snort-2.3.3/src/kernel_snns/kr_pat_scan.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_scan.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1958 @@
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_scan.c,v 2.7 1998/04/08 09:16:54 vogtm Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 29
+#define YY_END_OF_BUFFER 30
+static yyconst short int yy_accept[284] =
+    {   0,
+        2,    2,   30,   27,    2,    5,    4,    6,    1,   27,
+       27,   10,   27,   27,   27,   27,   27,   27,    7,    8,
+       27,   27,   28,   27,    2,    3,    1,    1,   27,   10,
+       13,   12,   27,   27,   27,   27,   27,   27,   27,   27,
+       27,   12,   27,   27,   11,   27,   27,   27,   27,   27,
+       27,   27,   27,   13,   27,   27,   12,   27,   27,    0,
+       27,   27,    9,   27,   27,   12,   27,   27,    0,   27,
+        0,    9,   27,    0,   27,    0,    0,    0,    9,    9,
+        9,    9,   27,    0,   27,    0,    0,    0,    0,   27,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+       27,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   27,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   15,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       15,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,   23,    0,    0,    0,
+        0,    0,   25,    0,    0,    0,    0,    0,    0,    0,
+        0,   16,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,   26,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   17,    0,    0,
+        0,    0,    0,    0,    0,    0,   18,    0,    0,    0,
+        0,   24,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   21,    0,    0,    0,    0,    0,   22,
+        0,    0,    0,    0,    0,    0,    0,    0,   14,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   19,    0,
+        0,   20,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    5,    1,    1,    1,    1,
+        1,    6,    1,    1,    7,    1,    1,    1,    1,    1,
+        1,    1,    8,    1,    9,   10,    1,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   12,    1,    1,
+        1,    1,    1,    1,    1,    1,   13,    1,   14,    1,
+        1,    1,    1,    1,    1,    1,   15,   16,    1,    1,
+        1,   17,   18,    1,    1,   19,    1,    1,    1,    1,
+       20,    1,   21,    1,    1,    1,   22,   23,   24,   25,
+
+       26,   27,   28,    1,   29,    1,    1,   30,   31,   32,
+       33,   34,    1,   35,   36,   37,   38,   39,    1,   40,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[41] =
+    {   0,
+        1,    2,    3,    4,    5,    2,    6,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    7,
+        7,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst short int yy_base[294] =
+    {   0,
+        0,    0,  633,   37,   40,  634,  629,  634,   41,   44,
+       49,   67,   59,   78,   87,   91,   99,  108,    0,    0,
+      113,  118,  628,    0,   66,  634,  110,    0,  126,    0,
+      131,  136,  145,  150,  155,  163,  168,  174,  182,  187,
+      195,  200,  214,  206,  219,  224,  232,  238,  243,  245,
+      256,  262,  264,  269,  283,  275,  288,  293,  301,  597,
+      307,  314,  325,  312,  332,  334,  343,  345,  602,  356,
+      594,  370,  370,  592,  375,  620,   25,  603,  391,    0,
+      398,   90,  399,  598,  416,  399,  585,  600,  584,  429,
+      595,   57,  589,  586,  579,  594,  593,  582,  578,  575,
+
+      434,  582,  578,  571,  586,  573,  569,  568,  569,  579,
+      580,  575,  440,  564,  563,  559,  559,  552,  555,  551,
+      554,  544,  545,  540,  552,  532,  529,  528,  525,  523,
+      518,  529,  532,  524,  526,  516,  509,  507,  502,  497,
+      507,  526,  492,  493,  503,  492,  486,  512,    0,  486,
+      504,  470,  466,  461,  488,  459,  456,  451,  452,  450,
+        0,  447,  442,  452,  225,  417,  409,  401,  408,  275,
+      394,  398,  383,  391,  392,  294,  634,  387,  383,  429,
+      408,  450,  634,  372,  380,  368,  372,  370,  357,  359,
+      451,  634,  134,  459,  358,  350,  352,  344,  337,  331,
+
+      333,  326,  462,  634,  331,  328,  320,  324,  467,  301,
+      297,  293,  287,  281,  274,  276,  470,  634,  475,  267,
+      250,  231,  478,  233,  215,  483,  634,  210,  203,  210,
+      486,  634,  203,  189,  209,  175,  174,  170,  158,  162,
+      180,  151,  144,  143,  141,  143,  152,  491,  115,  118,
+      119,  116,  494,  634,  499,  112,  104,  104,  502,  634,
+       94,   95,   81,   70,   72,   77,   66,   48,  634,   50,
+       47,   43,   40,   31,   18,  507,   13,  510,  634,  515,
+      518,  634,  634,  530,  537,  543,  550,  557,  564,  571,
+      578,  585,  592
+
+    } ;
+
+static yyconst short int yy_def[294] =
+    {   0,
+      283,    1,  283,  284,  283,  283,  285,  283,  286,  284,
+      284,  284,  284,  284,  284,   12,   12,   12,  287,  287,
+       12,   12,  285,  287,  283,  283,  286,  288,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,  283,
+       12,   12,   12,   12,   12,   12,   12,   12,  283,   12,
+      283,  289,   12,  283,   12,  283,  283,  283,  289,  290,
+      291,  292,   12,  283,   12,  283,  283,  283,  283,   12,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+
+       12,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,   12,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  293,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      293,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,    0,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283
+
+    } ;
+
+static yyconst short int yy_nxt[675] =
+    {   0,
+        4,    5,    6,    7,    8,    5,    9,   10,   10,   11,
+       12,    4,   13,    4,   14,   15,   16,   17,   18,   19,
+       20,    4,    4,    4,    4,    4,    4,   21,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,   18,    4,
+       23,   25,   28,   23,   23,   25,   28,   23,  280,  277,
+       23,   87,   23,   29,   30,   23,   24,   24,   88,   31,
+       28,   28,   23,   24,   24,   23,  276,   25,   24,   24,
+       23,   25,  275,   23,  274,  273,   32,   30,   24,   24,
+       33,   23,  272,  271,   23,  103,   24,   24,   34,  104,
+       23,   80,   33,   23,  270,   80,   80,   24,   24,   35,
+
+       22,   22,  269,  268,   22,  267,   24,   24,   22,   22,
+      266,   28,   22,   23,   38,   28,   37,   22,   39,   36,
+      265,   22,   22,   22,   22,  264,   22,   22,   22,   28,
+       28,   22,  263,   22,  262,   22,   31,  261,   40,   22,
+       22,   31,  258,   22,   41,   22,   42,  257,  256,   43,
+      255,   22,   44,   44,   22,   45,   41,  252,   22,   22,
+       22,   43,  201,   22,   22,   22,  202,  251,   22,  250,
+       22,   46,   48,   22,  249,   22,   22,   22,   22,  248,
+       22,   22,  247,   22,   22,  246,  245,   22,   22,   50,
+      244,   51,   39,   22,   47,   22,   22,   22,   49,   22,
+
+       22,  243,   53,   53,   22,   54,  242,   22,   22,   22,
+       42,  241,   22,   55,  240,   22,   45,  239,   52,   22,
+       22,   56,   56,   22,   57,   55,  176,   22,   22,   45,
+      176,   22,   22,   22,   22,  238,  177,   22,  237,   22,
+      236,   22,   22,   60,   22,   22,  235,   22,   22,   22,
+      234,   22,   22,   22,   22,   22,   22,   22,   22,   58,
+       59,  233,   62,   22,   61,   22,   63,  230,   22,   22,
+       22,   22,   22,   22,   54,   22,  182,   22,   22,   54,
+      182,   22,   22,  229,   22,   57,  183,   64,   22,   22,
+       65,   65,   22,   66,   22,  176,   22,   22,   57,  176,
+
+       22,   22,   22,   22,  228,  177,   22,  225,   22,  224,
+       22,   22,  223,   22,   22,  222,   22,   22,   22,   71,
+       22,   22,   22,   22,   22,   22,   22,   22,   67,  221,
+      220,   68,   22,   72,   22,   63,  219,   22,   22,   22,
+       70,   22,   66,   22,   66,   22,   73,   22,   74,  216,
+       22,  215,   22,   22,   22,   22,   22,   22,   22,   22,
+      214,   77,  213,  212,  211,   22,   22,  210,   22,   22,
+       22,   80,  209,   23,  208,   80,   81,  207,  206,   22,
+       22,   22,   75,   22,   22,   22,  205,  200,   22,   82,
+       82,   83,   80,  199,   23,   22,   80,   81,  198,   80,
+
+       22,   23,  197,   80,  196,   85,  195,  194,   22,   22,
+       82,   82,   22,  193,  190,  189,  188,   80,   80,  187,
+      186,   92,   93,  185,   22,   22,   22,   94,  184,   22,
+      191,   95,   96,  181,  191,   90,  180,   97,   22,   22,
+      192,   22,   22,   22,   22,  125,  179,   22,  178,   22,
+       22,  182,  191,   22,  101,  182,  191,  175,  113,   22,
+      203,  183,  192,  203,  203,   22,  174,  203,  217,  173,
+      204,  217,  217,  204,  172,  217,  226,  171,  218,  231,
+      226,  218,  170,  231,  226,  169,  227,  231,  226,  232,
+      168,  231,  253,  167,  227,  253,  253,  232,  166,  253,
+
+      259,  165,  254,  259,  259,  254,  164,  259,  278,  163,
+      260,  278,  278,  260,  162,  278,  281,  160,  279,  281,
+      281,  279,  159,  281,  158,  157,  282,  156,  155,  282,
+       22,  154,  153,   22,  152,   22,   22,   23,  151,   23,
+       23,  150,   23,   27,   27,  149,   27,  148,   27,   27,
+       24,  147,  146,  145,  144,  143,   24,   28,   28,  142,
+      141,  140,   28,   28,   79,   79,  139,   79,  138,   79,
+       79,   80,   80,  137,  136,  135,   80,   80,   81,   81,
+      134,   81,  133,   81,   81,   82,   82,  132,  131,  130,
+       82,   82,  161,  161,  129,  128,  127,  161,  161,  126,
+
+      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
+      114,  112,  111,  110,  109,  108,  107,  106,  105,  102,
+      100,   99,   98,   91,   89,   86,   84,   78,   76,   69,
+      283,   26,  283,    3,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283
+    } ;
+
+static yyconst short int yy_chk[675] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        4,    5,    9,    4,    9,    5,    9,   10,  277,  275,
+       10,   77,   11,   10,   10,   11,    4,    4,   77,   11,
+        9,    9,   13,   10,   10,   13,  274,   25,   11,   11,
+       12,   25,  273,   12,  272,  271,   12,   12,   13,   13,
+       12,   14,  270,  268,   14,   92,   12,   12,   13,   92,
+       15,   82,   12,   15,  267,   82,   82,   14,   14,   14,
+
+       16,   16,  266,  265,   16,  264,   15,   15,   17,   17,
+      263,   27,   17,   27,   17,   27,   16,   18,   18,   15,
+      262,   18,   21,   21,   17,  261,   21,   22,   22,   27,
+       27,   22,  258,   18,  257,   29,   29,  256,   21,   29,
+       31,   31,  252,   22,   31,   32,   32,  251,  250,   32,
+      249,   29,   33,   33,   33,   33,   31,  247,   33,   34,
+       34,   32,  193,   34,   35,   35,  193,  246,   35,  245,
+       33,   34,   36,   36,  244,   34,   36,   37,   37,  243,
+       35,   37,  242,   38,   38,  241,  240,   38,   36,   38,
+      239,   39,   39,   37,   35,   39,   40,   40,   37,   38,
+
+       40,  238,   41,   41,   41,   41,  237,   39,   41,   42,
+       42,  236,   40,   42,  235,   44,   44,  234,   40,   44,
+       41,   43,   43,   43,   43,   42,  165,   43,   45,   45,
+      165,   44,   45,   46,   46,  233,  165,   46,  230,   43,
+      229,   47,   47,   48,   45,   47,  228,   48,   48,   46,
+      225,   48,   49,   49,   50,   50,   49,   47,   50,   46,
+       47,  224,   50,   48,   49,   51,   51,  222,   49,   51,
+       50,   52,   52,   53,   53,   52,  170,   53,   54,   54,
+      170,   51,   54,  221,   56,   56,  170,   52,   56,   53,
+       55,   55,   55,   55,   54,  176,   55,   57,   57,  176,
+
+       56,   57,   58,   58,  220,  176,   58,  216,   55,  215,
+       59,   59,  214,   57,   59,  213,   61,   61,   58,   62,
+       61,   64,   64,   62,   62,   64,   59,   62,   58,  212,
+      211,   59,   61,   63,   63,   63,  210,   64,   63,   62,
+       61,   65,   65,   66,   66,   65,   64,   66,   67,  208,
+       63,  207,   67,   67,   68,   68,   67,   65,   68,   66,
+      206,   70,  205,  202,  201,   70,   70,  200,   67,   70,
+       68,   72,  199,   72,  198,   72,   72,  197,  196,   73,
+       73,   70,   68,   73,   75,   75,  195,  190,   75,   72,
+       72,   73,   79,  189,   79,   73,   79,   79,  188,   81,
+
+       75,   81,  187,   81,  186,   75,  185,  184,   83,   83,
+       79,   79,   83,  181,  179,  178,  175,   81,   81,  174,
+      173,   85,   86,  172,   83,   85,   85,   86,  171,   85,
+      180,   86,   86,  169,  180,   83,  168,   86,   90,   90,
+      180,   85,   90,  101,  101,  113,  167,  101,  166,  113,
+      113,  182,  191,  113,   90,  182,  191,  164,  101,  101,
+      194,  182,  191,  203,  194,  113,  163,  203,  209,  162,
+      194,  217,  209,  203,  160,  217,  219,  159,  209,  223,
+      219,  217,  158,  223,  226,  157,  219,  231,  226,  223,
+      156,  231,  248,  155,  226,  253,  248,  231,  154,  253,
+
+      255,  153,  248,  259,  255,  253,  152,  259,  276,  151,
+      255,  278,  276,  259,  150,  278,  280,  148,  276,  281,
+      280,  278,  147,  281,  146,  145,  280,  144,  143,  281,
+      284,  142,  141,  284,  140,  284,  284,  285,  139,  285,
+      285,  138,  285,  286,  286,  137,  286,  136,  286,  286,
+      287,  135,  134,  133,  132,  131,  287,  288,  288,  130,
+      129,  128,  288,  288,  289,  289,  127,  289,  126,  289,
+      289,  290,  290,  125,  124,  123,  290,  290,  291,  291,
+      122,  291,  121,  291,  291,  292,  292,  120,  119,  118,
+      292,  292,  293,  293,  117,  116,  115,  293,  293,  114,
+
+      112,  111,  110,  109,  108,  107,  106,  105,  104,  103,
+      102,  100,   99,   98,   97,   96,   95,   94,   93,   91,
+       89,   88,   87,   84,   78,   76,   74,   71,   69,   60,
+       23,    7,    3,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
+      283,  283,  283,  283
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "kr_pat_scan.l"
+#define INITIAL 0
+#line 2 "kr_pat_scan.l"
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_scan.c,v $
+  SHORTNAME      : pattern scanner
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : pattern file scanner, lex file
+  NOTES          : preliminary
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/04/08 09:16:54 $
+
+    Copyright (c) 1990-1998  SNNS Group, IPVR, Univ. Stuttgart, Germany
+
+******************************************************************************/
+
+#include "y.tab.h"
+#include <stdlib.h>
+#include <string.h>
+#include "glob_typ.h"
+#include "kr_typ.h"
+#include "kernel.h"
+#include "kr_newpattern.h"
+#include "kr_pat_parse.h"
+#include "kr_pat_scan.ph"
+
+#line 653 "lex.yy.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 56 "kr_pat_scan.l"
+
+
+#line 807 "lex.yy.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 284 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 634 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+#line 59 "kr_pat_scan.l"
+case 2:
+YY_RULE_SETUP
+#line 59 "kr_pat_scan.l"
+;
+	YY_BREAK
+case 3:
+#line 62 "kr_pat_scan.l"
+case 4:
+#line 63 "kr_pat_scan.l"
+case 5:
+YY_RULE_SETUP
+#line 63 "kr_pat_scan.l"
+lineno++;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 65 "kr_pat_scan.l"
+return(0); /* end of text */
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 67 "kr_pat_scan.l"
+return(L_BRACKET);
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 69 "kr_pat_scan.l"
+return(R_BRACKET);
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 71 "kr_pat_scan.l"
+{
+					s_dotpos = strchr((char *) yytext, '.');
+					*s_dotpos = '\0';
+					yylval.version.v = 
+						atoi((char *) yytext+1);
+					yylval.version.r =
+						atoi((char *) s_dotpos+1);
+					return(V_NUMBER);
+				        }
+	YY_BREAK
+case 10:
+#line 82 "kr_pat_scan.l"
+case 11:
+#line 83 "kr_pat_scan.l"
+case 12:
+#line 84 "kr_pat_scan.l"
+case 13:
+YY_RULE_SETUP
+#line 84 "kr_pat_scan.l"
+{
+                                                    if (numbers_as_names)
+						    {
+							yylval.name = strdup(yytext);
+							return(NAME);
+						    }
+						    else
+						    {
+							yylval.value=atof((char *) yytext);
+							return(NUMBER);
+						    }
+						}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 97 "kr_pat_scan.l"
+return(VERSION_HEADER);
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 99 "kr_pat_scan.l"
+return(GENERATED_AT);
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 101 "kr_pat_scan.l"
+return(NO_OF_PATTERN);
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 103 "kr_pat_scan.l"
+return(NO_OF_INPUT);
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 105 "kr_pat_scan.l"
+return(NO_OF_OUTPUT);
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 107 "kr_pat_scan.l"
+return(NO_OF_VAR_IDIM);
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 109 "kr_pat_scan.l"
+return(NO_OF_VAR_ODIM);
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 111 "kr_pat_scan.l"
+return(MAXIMUM_IDIM);
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 113 "kr_pat_scan.l"
+return(MAXIMUM_ODIM);
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 115 "kr_pat_scan.l"
+return(NO_OF_CLASSES);
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 117 "kr_pat_scan.l"
+return(CLASS_REDISTRIB);
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 119 "kr_pat_scan.l"
+return(REMAPFUNCTION);
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 121 "kr_pat_scan.l"
+return(REMAP_PARAM);
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 123 "kr_pat_scan.l"
+{
+                                                    yylval.name = strdup(yytext);
+                                                    return(NAME);
+                                                }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 128 "kr_pat_scan.l"
+return(ERROR);
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 130 "kr_pat_scan.l"
+ECHO;
+	YY_BREAK
+#line 1039 "lex.yy.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 284 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 284 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 283);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+#ifndef YY_ALWAYS_INTERACTIVE
+#ifndef YY_NEVER_INTERACTIVE
+extern int isatty YY_PROTO(( int ));
+#endif
+#endif
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 130 "kr_pat_scan.l"
+
+
+int pplex(void)
+{
+    int scanned;
+
+    if (scanner_pattern_end_flag)
+    {
+	scanner_pattern_end_flag = 0;
+	yylval.value = 0.0;
+	return PATTERNEND;
+    }
+    else if (scanner_no_class_flag)
+    {
+	scanner_no_class_flag = 0;
+	yylval.value = 0.0;
+	return PATTERNNOCLASS;
+    }
+    else
+    {
+	scanned = yylex();
+	numbers_as_names = 0;
+	return scanned;
+    }
+}
+
+void scanner_await_pattern_end(void)
+{
+    scanner_pattern_end_flag = 1;
+}
+
+void scanner_await_no_class(void)
+{
+    scanner_no_class_flag = 1;
+}
+
+void scanner_await_class(void)
+{
+    numbers_as_names = 1;
+}
+
+void scanner_init_scanner(FILE *in_file)
+{
+    yyin = in_file;
+#ifdef FLEX_SCANNER
+    yyrestart(yyin);
+#endif
+    scanner_pattern_end_flag = 0;
+    scanner_no_class_flag = 0;
+    numbers_as_names = 0;
+}
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_scan.h snort-2.3.3.new/src/kernel_snns/kr_pat_scan.h
--- snort-2.3.3/src/kernel_snns/kr_pat_scan.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_scan.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,36 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_scan.h,v $
+  SHORTNAME      : pattern scanner
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : scanner for pattern files
+  NOTES          : preliminary
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/31 13:08:00 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_PAT_SCAN_DEFINED_
+#define _KR_PAT_SCAN_DEFINED_
+
+/* begin global definition section */
+
+extern int pplex(void);
+extern void scanner_await_pattern_end(void);
+extern void scanner_await_no_class(void);
+extern void scanner_await_class(void);
+extern void scanner_init_scanner(FILE *in_file);
+
+/* end global definition section */
+
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_scan.l snort-2.3.3.new/src/kernel_snns/kr_pat_scan.l
--- snort-2.3.3/src/kernel_snns/kr_pat_scan.l	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_scan.l	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,163 @@
+%{
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_scan.l,v $
+  SHORTNAME      : pattern scanner
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : pattern file scanner, lex file
+  NOTES          : preliminary
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/03/31 13:08:01 $
+
+    Copyright (c) 1990-1998  SNNS Group, IPVR, Univ. Stuttgart, Germany
+
+******************************************************************************/
+
+#include "y.tab.h"
+#include <stdlib.h>
+#include <string.h>
+#include "glob_typ.h"
+#include "kr_typ.h"
+#include "kernel.h"
+#include "kr_newpattern.h"
+#include "kr_pat_parse.h"
+#include "kr_pat_scan.ph"
+
+%}
+
+digit           [0-9]
+white           [ \t]
+free            [^\r\n\032]
+exp		[Ee][-+]?{digit}+
+instring        [^ #\t\r\n\032]
+
+%%
+
+\#{free}*				|
+{white}*					;
+
+\r\n						|
+\r						|
+\n						lineno++;
+
+\032						return(0); /* end of text */
+
+\[						return(L_BRACKET);
+
+\]						return(R_BRACKET);
+
+[Vv]{digit}+"."{digit}+(-{free}*)?      {
+					s_dotpos = strchr((char *) yytext, '.');
+					*s_dotpos = '\0';
+					yylval.version.v = 
+						atoi((char *) yytext+1);
+					yylval.version.r =
+						atoi((char *) s_dotpos+1);
+					return(V_NUMBER);
+				        }
+
+[-+]?{digit}+				|
+[-+]?{digit}+{exp}			|
+[-+]?{digit}+"."{digit}*({exp})?	|
+[-+]?{digit}*"."{digit}+({exp})?	        {
+                                                    if (numbers_as_names)
+						    {
+							yylval.name = strdup(yytext);
+							return(NAME);
+						    }
+						    else
+						    {
+							yylval.value=atof((char *) yytext);
+							return(NUMBER);
+						    }
+						}
+
+"SNNS pattern definition file"			return(VERSION_HEADER);
+
+"generated at"{free}*				return(GENERATED_AT);
+
+"No. of patterns"{white}*:			return(NO_OF_PATTERN);
+
+"No. of input units"{white}*:			return(NO_OF_INPUT);
+
+"No. of output units"{white}*:			return(NO_OF_OUTPUT);
+
+"No. of variable input dimensions"{white}*:	return(NO_OF_VAR_IDIM);
+
+"No. of variable output dimensions"{white}*:	return(NO_OF_VAR_ODIM);
+
+"Maximum input dimensions"{white}*:		return(MAXIMUM_IDIM);
+
+"Maximum output dimensions"{white}*:		return(MAXIMUM_ODIM);
+
+"No. of classes"{white}*:                       return(NO_OF_CLASSES);
+
+"Class redistribution"{white}*:                 return(CLASS_REDISTRIB);
+
+"Remap function"{white}*:                       return(REMAPFUNCTION);
+
+"Remap parameters"{white}*:                     return(REMAP_PARAM);
+
+{instring}*                                     {
+                                                    yylval.name = strdup(yytext);
+                                                    return(NAME);
+                                                }
+
+[^ \t\n\[\]\032]+			       	return(ERROR);
+
+%%
+
+int pplex(void)
+{
+    int scanned;
+
+    if (scanner_pattern_end_flag)
+    {
+	scanner_pattern_end_flag = 0;
+	yylval.value = 0.0;
+	return PATTERNEND;
+    }
+    else if (scanner_no_class_flag)
+    {
+	scanner_no_class_flag = 0;
+	yylval.value = 0.0;
+	return PATTERNNOCLASS;
+    }
+    else
+    {
+	scanned = yylex();
+	numbers_as_names = 0;
+	return scanned;
+    }
+}
+
+void scanner_await_pattern_end(void)
+{
+    scanner_pattern_end_flag = 1;
+}
+
+void scanner_await_no_class(void)
+{
+    scanner_no_class_flag = 1;
+}
+
+void scanner_await_class(void)
+{
+    numbers_as_names = 1;
+}
+
+void scanner_init_scanner(FILE *in_file)
+{
+    yyin = in_file;
+#ifdef FLEX_SCANNER
+    yyrestart(yyin);
+#endif
+    scanner_pattern_end_flag = 0;
+    scanner_no_class_flag = 0;
+    numbers_as_names = 0;
+}
diff -Naur snort-2.3.3/src/kernel_snns/kr_pat_scan.ph snort-2.3.3.new/src/kernel_snns/kr_pat_scan.ph
--- snort-2.3.3/src/kernel_snns/kr_pat_scan.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_pat_scan.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,46 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_pat_scan.ph,v $
+  SHORTNAME      : pattern scanner
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : scanner for pattern files
+  NOTES          : preliminary
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.9.93
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/03/31 13:08:02 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_PAT_SCAN_DEFINED_
+#define _KR_PAT_SCAN_DEFINED_
+
+/* begin global definition section */
+
+int pplex(void);
+void scanner_await_pattern_end(void);
+void scanner_await_no_class(void);
+void scanner_await_class(void);
+void scanner_init_scanner(FILE *in_file);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+#define yylval pplval
+
+static char *s_dotpos;
+static int scanner_pattern_end_flag;
+static int scanner_no_class_flag;
+static int numbers_as_names;
+
+/* end private definition section */
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_rand.c snort-2.3.3.new/src/kernel_snns/kr_rand.c
--- snort-2.3.3/src/kernel_snns/kr_rand.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_rand.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,44 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_rand.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel randomize functions for MS-DOS
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 30.06.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:44 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#ifdef  __MSDOS__
+
+#ifndef  MSDOS_RAND_FUNCS
+#define  MSDOS_RAND_FUNCS
+
+#include <stdlib.h>
+
+void srand48(long seedval)
+{
+        srand((int) seedval);
+}
+
+long lrand48(void )
+{
+        return ((long) rand());
+}
+
+double drand48(void)
+{
+        return ((double) rand() / (double) RAND_MAX);
+}
+
+#endif
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_rand.h snort-2.3.3.new/src/kernel_snns/kr_rand.h
--- snort-2.3.3/src/kernel_snns/kr_rand.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_rand.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,30 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_rand.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel randomize functions for MS-DOS
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 30.06.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:04 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifdef  __MSDOS__
+
+#ifndef  MSDOS_RAND_FUNCS
+#define  MSDOS_RAND_FUNCS
+
+extern void srand48(long seedval);
+extern long lrand48(void);
+extern double drand48(void);
+
+#endif
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_rand.ph snort-2.3.3.new/src/kernel_snns/kr_rand.ph
--- snort-2.3.3/src/kernel_snns/kr_rand.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_rand.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,30 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_rand.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS Kernel randomize functions for MS-DOS
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 30.06.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:05 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifdef  __MSDOS__
+
+#ifndef  MSDOS_RAND_FUNCS
+#define  MSDOS_RAND_FUNCS
+
+void srand48(long seedval);
+long lrand48(void);
+double drand48(void);
+
+#endif
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_td.c snort-2.3.3.new/src/kernel_snns/kr_td.c
--- snort-2.3.3/src/kernel_snns/kr_td.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_td.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,853 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_td.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions for Time Delay networks
+  NOTES          : with following learning functions:
+                   - Backpropagation
+
+  AUTHOR         : Oliver Schnabel, Guenter Mamier
+  DATE           : 
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/03/13 16:23:57 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants  */
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"	 /*  Default Values  */
+#include "kernel.h"	 /*  kernel function prototypes  */
+#include "kr_mac.h"	 /*  Kernel Macros   */
+#include "kr_newpattern.h"
+
+#include "kr_td.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : initializeTDBackprop
+
+  PURPOSE  : initialize the learning algorithm TD-backprop
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 19.02.1993 
+******************************************************************************/
+static krui_err initializeTDBackprop(void)
+{
+  register FlagWord      flags;
+  register struct Link   *link_ptr;
+  register struct Unit   *unit_ptr;
+  register struct Site   *site_ptr; 
+
+  /*  set unit's bias to zero  */
+  FOR_ALL_UNITS( unit_ptr ){
+      flags = unit_ptr->flags;
+
+      if ( (unit_ptr->flags & UFLAG_IN_USE) == UFLAG_IN_USE){
+	  if (flags & UFLAG_SITES){ /*  unit has sites  */
+	      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		  link_ptr->value_b = 
+		      link_ptr->value_c = 
+			  unit_ptr->value_a = 
+			      unit_ptr->value_b = 
+				  unit_ptr->value_c = (FlintType) 0;
+	  }else{		/* TD-units have no sites: direct links */
+	      if (flags & UFLAG_DLINKS){ /*  unit has direct links */
+		  FOR_ALL_LINKS( unit_ptr, link_ptr ) 
+		      link_ptr->value_b = 
+			  link_ptr->value_c = 
+			      unit_ptr->value_a = 
+				  unit_ptr->value_b = 
+				      unit_ptr->value_c = (FlintType) 0;
+	      }
+	  } /* else */
+      } /* if */
+  } /* FOR_ALL_UNITS */
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : propagateTDNetForward
+
+  PURPOSE  : topological TimeDelay forward propagation
+  NOTES    : needs only the weight matrix of one receptive field for 
+	     propagating one pattern through the net
+	     If the provided pattern_no is < 0, no pattern is loaded into
+             the input layer but all other layers are propagated as usual
+  RETURNS  :
+  UPDATE   : 19.02.1993
+******************************************************************************/
+void  propagateTDNetForward(int pattern_no, int sub_pat_no)
+{ 
+  register struct Unit    *unit_ptr;
+  register struct Link    *link_ptr;
+  register Patterns       in_pat;
+  register TopoPtrArray   topo_ptr;
+  int                     i;
+
+  if (pattern_no >= 0){
+      /*  calculate startaddress for input pattern array  */
+
+      in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+      topo_ptr = topo_ptr_array;
+
+      /* copy pattern into input unit's activation and calculate output of the 
+	 input units. */
+      /* order of the topoptrarray: input-, hidden- and then outputunits */    
+
+      unit_ptr = *++topo_ptr;
+      while (unit_ptr != (struct Unit *) NULL){
+	  /*  topo_ptr points to a (topological sorted) unit stucture 
+	      (input units first)  */
+
+	  if (unit_ptr->out_func == OUT_IDENTITY){
+	      /*  identity output function: don't call the output function  */
+	      unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	  }else{
+	      /*  no identity output function: calculate unit's output also  */
+	      unit_ptr->Out.output = 
+		  (*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+	  } /*if*/
+	  unit_ptr = *++topo_ptr;
+      }
+  }else{
+      /* set unit_ptr and topo_ptr as if an input pattern was provided */
+      topo_ptr = topo_ptr_array;
+      unit_ptr = *++topo_ptr;
+      while (unit_ptr != (struct Unit *) NULL)
+      {
+	  unit_ptr = *++topo_ptr;
+      }
+  }
+      
+  /* Propagate input to hidden, hidden to hidden and hidden to output */
+
+  for (i=0; i<2; i++){
+      unit_ptr = *++topo_ptr;
+      while (unit_ptr != NULL){
+	  /*  initialization for propagating hidden units  */
+	  /*  clear error values */
+	  unit_ptr->Aux.flint_no = 0.0;
+
+	  if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)){
+	      /* this is a reference unit, initialize link weight change */
+	      /* and counter of link usage */
+	      FOR_ALL_LINKS(unit_ptr, link_ptr){
+		  link_ptr->value_b = link_ptr->value_c = 0.0;
+	      }
+	  }
+
+	  /* reset bias-change and td-step-counter before each lerning epoch */
+	  unit_ptr->value_b = unit_ptr->value_c = 0.0;
+
+	  unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+	  if (unit_ptr->out_func == OUT_IDENTITY){
+	      /*  identity output function: don't call the output function  */
+	      unit_ptr->Out.output = unit_ptr->act;
+	  }else{
+	      /*  no identity output function: calculate unit's output also  */
+	      unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	  }      
+	  unit_ptr = *++topo_ptr;
+      }
+  }
+} /*endfunction*/
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateTDNetBackward
+
+  PURPOSE  : Time Delay Backward error propagation (topological).
+  NOTES    : Start calculating the average of the corresponding links in 
+             all TD-steps. This average is used to update the links of the 
+	     1st. receptive field.
+  RETURNS  : network error
+  UPDATE   : 19.02.1993
+******************************************************************************/
+static	float propagateTDNetBackward(int pattern_no, int sub_pat_no,
+				     float learn_parameter, 
+				     float delta_max)
+{ 
+    register struct Link   *link_ptr;
+    register struct Site   *site_ptr;
+    register struct Unit   *unit_ptr, *unit_ptr1 ;
+    register struct Unit   *ref_unit;
+    register Patterns      out_pat;
+    register float         error,  sum_error,  eta,  devit, learn_error;
+    register TopoPtrArray  topo_ptr;
+    int                    last_log_layer, i;
+    int                    size;
+
+    sum_error = 0.0;		/*  reset network error  */
+    eta = learn_parameter;	/*  store learn_parameter in CPU register  */
+
+    /*  calculate address of the output pattern (with number pattern_no + 1) */
+
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 2);
+    last_log_layer = (*topo_ptr)->lln;
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /* calculate output units only: begin at the end of topo_pointer_array */
+    unit_ptr = *topo_ptr;
+    while (unit_ptr != (struct Unit *) NULL){
+	devit = *(--out_pat) - unit_ptr->Out.output; /*  calc. devitation */
+
+	if ( (float) fabs( devit ) <= delta_max ){
+	    unit_ptr = *--topo_ptr;
+	    continue;
+	}
+
+	sum_error += devit * devit; /*  sum up the error of the network  */
+
+	/* calculate error for output units	 */
+	/* output layer cannot have time delay structure, so no 
+	   distinction is necessary*/
+	error = devit * (unit_ptr->act_deriv_func) ( unit_ptr ); 
+
+	/* calc. the error for adjusting weights and bias of pred. units  */
+	learn_error = eta * error; 
+
+	/* adjust bias value  */
+	unit_ptr->value_b += learn_error;
+	unit_ptr->value_c += 1.0;
+
+	if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){ /* the unit has direkt links */
+	    /* error must be saved for each unit of the hiddenlayer */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr ){
+		/* adjust link weights and calc. sum of errors of pred. units*/
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_b += learn_error * link_ptr->to->Out.output;
+		link_ptr->value_c += 1.0;
+	    }
+	}else{ /* the unit has sites: not necessary for TD-Network  */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		/* adjust link weights and calc. sum of errors of pred. units */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->weight += learn_error * link_ptr->to->Out.output;
+            }
+	}
+     
+	unit_ptr = *--topo_ptr; 
+    } /* while */
+
+
+    /*  calculate hidden units only. add the weight changes of all receptive 
+	fields ; stored for every linkin the Linkstructure value_c of only the 
+	first recept. field! 
+    */
+  
+    unit_ptr = *--topo_ptr;
+    while (unit_ptr != (struct Unit *) NULL){
+	/* calc. the error of the hidden units */
+	error = (unit_ptr->act_deriv_func) (unit_ptr) * unit_ptr->Aux.flint_no;
+    
+	/* calc. the error for adjusting weights and bias of pred. units */
+	learn_error = eta * error;
+
+
+	if (unit_ptr->TD.td_connect_typ == 1){
+	    /* this is a time delay connection type layer */
+
+	    ref_unit = *(unit_ptr->TD.my_topo_ptr + unit_ptr->TD.target_offset);
+	    /*	adjust bias value  */
+	    ref_unit->value_b += learn_error;
+	    ref_unit->value_c += 1.0;
+	
+	    if (UNIT_HAS_DIRECT_INPUTS( ref_unit )){
+		/*  the unit has direkt links	*/
+	    
+		FOR_ALL_LINKS( ref_unit, link_ptr ) {
+		    /* adjust link weights and calc. sum of err of pred. units*/
+		    /* unit_ptr1 points to the actual predecessor unit, 
+		       determined by the actual link */
+		    unit_ptr1 = *(link_ptr->to->TD.my_topo_ptr 
+				  + unit_ptr->TD.source_offset);
+		
+		    if (IS_HIDDEN_UNIT (unit_ptr1)) {
+			/* this unit is a hidden unit: add the error from 
+			   previous units dependent on type of this predecessor 
+			   unit   */
+			(unit_ptr1)->Aux.flint_no += link_ptr->weight * error;
+		    }
+		    /* immediately updating the links cannot fit for TD 
+		       Networks! Add the the delta(ij) of all td_steps in the 
+		       Linkarray(value_c) of the first recept. field  */
+		    link_ptr->value_b += learn_error * (unit_ptr1)->Out.output;
+		    link_ptr->value_c += 1.0;
+		}
+	    }
+	}else{
+	    /* fully connected layers */
+	    /* immediately update of all physical links */
+	    unit_ptr->bias += learn_error;
+
+	    if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+		/*  the unit has direkt links  */
+		/* error must be saved for each unit of the hiddenlayer */
+		FOR_ALL_LINKS( unit_ptr, link_ptr ){
+		    /* adjust link weights and calc. sum of err of pred units*/
+		    if (IS_HIDDEN_UNIT (link_ptr->to))
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		  
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    }else{ /* the unit has sites: not necessary for TD-Network  */
+		FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		    /*  adjust link weights and calc. sum of errors of the 
+			predecessor units */
+		    if (IS_HIDDEN_UNIT (link_ptr->to)) 
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    }
+	}
+	unit_ptr = *--topo_ptr;
+    } /* while */
+  
+
+    /* update receptive fields: propagate and calculate all featureunits of 
+       the first td-step of each layer.   */
+    /* topo_ptr points to the NULL pointer between input and hidden units */
+
+    for (i=0; i<2; i++){
+	unit_ptr = *++topo_ptr;
+	while (unit_ptr != NULL){
+	    if (unit_ptr->TD.td_connect_typ==1 && 
+		UNIT_HAS_DIRECT_INPUTS(unit_ptr) &&
+		unit_ptr->value_c > 0.0){
+		/* this is a reference unit of a time delay layer */
+
+		/* update bias of reference unit by average bias change */
+		unit_ptr->bias += unit_ptr->value_b / unit_ptr->value_c;
+
+		FOR_ALL_LINKS( unit_ptr, link_ptr ){ 
+		    /* store average linkweigth changes of all Td-steps */
+		    link_ptr->weight += link_ptr->value_b / link_ptr->value_c;
+		} /*for_all_links*/
+	    }
+	    unit_ptr = *++topo_ptr;
+	}
+    }
+    return( sum_error );	/*  return the error of the network */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_TDbackprop
+
+  PURPOSE  : Time Delay Backpropagation Learning Function
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  RETURNS  :
+  UPDATE   : 19.02.1993
+******************************************************************************/
+krui_err  LEARN_TDbackprop( int start_pattern, int end_pattern, 
+			   float parameterInArray[], int NoOfInParams,
+			   float * *parameterOutArray, int *NoOfOutParams )
+
+{
+    static  float  OutParameter[1]; /* OutParameter[0] stores learning error */
+    int     ret_code, pattern_no, sub_pat_no;
+    struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)  
+	return( KRERR_NO_UNITS ); /*  No Units defined	*/
+    if (NoOfInParams < 1)	/*  #  has to be changed (must be 2) # */
+	return( KRERR_PARAMETERS ); /*  Not enough input parameters  */
+
+    *NoOfOutParams = 1;	 /* One return value is available (the learning error)*/
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_LOGICAL)){
+	/*  Net has been modified or topologic array isn't initialized */
+	/*  check the topology of the network  */
+	/* first: save the logical layer numbers, restore them after check */
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> Aux.int_no = unit_ptr -> lln;
+	ret_code = kr_topoCheck();
+
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> lln = unit_ptr -> Aux.int_no;
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );	/*  an error has occured  */
+	if (ret_code < 2)  
+	    return( KRERR_NET_DEPTH ); /* the network has less then 2 layers */
+
+	/*	count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );
+
+	ret_code = kr_topoSort( TOPOLOGIC_LOGICAL );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+
+#ifdef DEBUG
+	/* M.V. */
+	j=1;
+	while (krui_setCurrentUnit(j) == KRERR_NO_ERROR) {
+	    printf("Unit %d: lln = %d, lun = %d\n",j,
+		   kr_getUnitPtr(j) -> lln, kr_getUnitPtr(j) -> lun);
+	    j++;
+	}
+#endif
+
+	NetModified = FALSE;
+    }
+
+    if (NetInitialize || LearnFuncHasChanged){
+	/*  Net has been modified or initialized, initialize TDbackprop now */
+	ret_code = initializeTDBackprop();
+	if (ret_code != KRERR_NO_ERROR)  
+	    return( ret_code );
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateTDNetForward(pattern_no,sub_pat_no); /* Forward propagation */
+
+	/*  Backward propagation  */
+	/*  1st parameter is the learning parameter
+	    2nd parameter is the max. devitation between output pattern and
+	    the output of the output unit (delta max)
+	    */
+	NET_ERROR( OutParameter ) +=
+	    propagateTDNetBackward(pattern_no,sub_pat_no,
+				   LEARN_PARAM1( parameterInArray ),
+				   LEARN_PARAM2( parameterInArray ) );
+    }
+
+    return( ret_code );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_TDBP_McClelland
+
+  PURPOSE  : Time Delay Backpropagation Learning Function With McClelland
+             Error function: E = sum(log(1-(oi-ti)^2))
+
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  RETURNS  :
+  UPDATE   : 19.02.1993
+******************************************************************************/
+krui_err  LEARN_TDBP_McClelland( int start_pattern, int end_pattern, 
+				float parameterInArray[], int NoOfInParams,
+				float * *parameterOutArray, int *NoOfOutParams )
+
+{
+    static  float  OutParameter[1]; /* OutParameter[0] stores learning error*/
+    int   ret_code, pattern_no, sub_pat_no;
+    struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)  
+	return( KRERR_NO_UNITS ); /*  No Units defined	*/
+    if (NoOfInParams < 1)	/*  #  has to be changed (must be 2) # */
+	return( KRERR_PARAMETERS ); /*  Not enough input parameters  */
+
+    *NoOfOutParams = 1;	/* One return value is available (the learning error)*/
+    *parameterOutArray = OutParameter; /* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_LOGICAL)){
+	/*  Net has been modified or topologic array isn't initialized */
+	/*  check the topology of the network  */
+	/* first: save the logical layer numbers, restore them after check */
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> Aux.int_no = unit_ptr -> lln;
+	ret_code = kr_topoCheck();
+
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> lln = unit_ptr -> Aux.int_no;
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );	/*  an error has occured  */
+	if (ret_code < 2)  
+	    return( KRERR_NET_DEPTH ); /* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );
+
+	ret_code = kr_topoSort( TOPOLOGIC_LOGICAL );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+
+#ifdef DEBUG
+	/* M.V. */
+	j=1;
+	while (krui_setCurrentUnit(j) == KRERR_NO_ERROR) {
+	    printf("Unit %d: lln = %d, lun = %d\n",  j,
+		   kr_getUnitPtr(j) -> lln, kr_getUnitPtr(j) -> lun);
+	    j++;
+	}
+#endif
+
+	NetModified = FALSE;
+    }
+
+    if (NetInitialize || LearnFuncHasChanged){
+	/*  Net has been modified or initialized, initialize TDbackprop now  */
+	ret_code = initializeTDBackprop();
+	if (ret_code != KRERR_NO_ERROR)  
+	    return( ret_code );
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateTDNetForward(pattern_no,sub_pat_no); /*  Forward propagation */
+
+	/*  Backward propagation  */
+	/*  1st parameter is the learning parameter
+	    2nd parameter is the max. devitation between output pattern and
+	    the output of the output unit (delta max)
+	    */
+	NET_ERROR( OutParameter ) +=
+	    propagateTDNetBackMcClelland(pattern_no,sub_pat_no,
+					 LEARN_PARAM1( parameterInArray ),
+					 LEARN_PARAM2( parameterInArray ) );
+    }
+
+    return( ret_code );
+}
+
+
+/*****************************************************************************
+  FUNCTION : propagateTDNetBackMcClelland
+
+  PURPOSE  : Time Delay Backward error propagation (topological).
+  NOTES    : Start calculating the average of the corresponding links in 
+             all TD-steps. This average is used to update the links of the 
+	     1st. receptive field.
+  RETURNS  : network error
+  UPDATE   : 19.02.1993
+******************************************************************************/
+static	float propagateTDNetBackMcClelland(int pattern_no, int sub_pat_no,
+					   float learn_parameter,
+					   float delta_max)
+{ 
+    register struct Link   *link_ptr;
+    register struct Site   *site_ptr;
+    register struct Unit   *unit_ptr, *unit_ptr1 ;
+    register struct Unit   *ref_unit;
+    register Patterns      out_pat;
+    register float         error,  sum_error,  eta,  devit, learn_error;
+    register TopoPtrArray  topo_ptr;
+    int                    last_log_layer, i;
+    int                    size;
+
+
+    sum_error = 0.0;		/*  reset network error  */
+    eta = learn_parameter;	/*  store learn_parameter in CPU register  */
+
+    /*  calculate address of the output pattern (with number pattern_no + 1) */
+
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 2);
+    last_log_layer = (*topo_ptr)->lln;
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /* calculate output units only: begin at the end of topo_pointer_array */
+    unit_ptr = *topo_ptr;
+    while (unit_ptr != (struct Unit *) NULL){
+	devit = *(--out_pat) - unit_ptr->Out.output; /*  calc. devitation */
+
+	if ( (float) fabs( devit ) <= delta_max ){
+	    unit_ptr = *--topo_ptr;
+	    continue;
+	}
+
+	sum_error += -log10(1- fabs(devit)); /* sum up error of the network */
+
+	/* calculate error for output units	 */
+	/* output layer cannot have time delay structure, so no 
+	   distinction is necessary*/
+	error = log10(1- fabs(devit)) * (unit_ptr->act_deriv_func) (unit_ptr); 
+	if(devit > 0) error = -error;
+
+	/* calc. error for adjusting weights and bias of predecessor units */
+	learn_error = eta * error; 
+
+	/* adjust bias value  */
+	unit_ptr->value_b += learn_error;
+	unit_ptr->value_c += 1.0;
+
+	if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+	    /*  the unit has direkt links  */
+	    /* error must be saved for each unit of the hiddenlayer */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr ){
+		/* adjust link weights and calc. sum of errors of pred. units*/
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_b += learn_error * link_ptr->to->Out.output;
+		link_ptr->value_c += 1.0;
+	    }
+	}else{ /* the unit has sites: not necessary for TD-Network  */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		/* adjust link weights and calc. sum of errors of 
+		   predecessor units */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->weight += learn_error * link_ptr->to->Out.output;
+            }
+	}
+     
+	unit_ptr = *--topo_ptr; 
+    } /* while */
+
+
+    /*  calculate hidden units only. add the weightchanges of all receptive 
+	fields ; stored for every link in the Linkstructure value_c of only 
+	the first recept. field! 
+    */
+  
+    unit_ptr = *--topo_ptr;
+    while (unit_ptr != (struct Unit *) NULL){
+	/* calc. the error of the hidden units */
+	error = (unit_ptr->act_deriv_func) (unit_ptr) * unit_ptr->Aux.flint_no;
+    
+	/* calc. error for adjusting weights and bias of predecessor units */
+	learn_error = eta * error;
+
+
+	if (unit_ptr->TD.td_connect_typ == 1){
+	    /* this is a time delay connection type layer */
+
+	    ref_unit = *(unit_ptr->TD.my_topo_ptr + unit_ptr->TD.target_offset);
+	    /*	adjust bias value  */
+	    ref_unit->value_b += learn_error;
+	    ref_unit->value_c += 1.0;
+	
+	    if (UNIT_HAS_DIRECT_INPUTS( ref_unit )){
+		/*  the unit has direkt links	*/
+	    
+		FOR_ALL_LINKS( ref_unit, link_ptr ){
+		    /* adjust link weights and calc. sum of err of pred. units*/
+		    /* unit_ptr1 points to the actual predecessor unit, 
+		       determined by the actual link */
+		    unit_ptr1 = *(link_ptr->to->TD.my_topo_ptr 
+				  + unit_ptr->TD.source_offset);
+		
+		    if (IS_HIDDEN_UNIT (unit_ptr1)){
+			/* this unit is a hidden unit: add the error from 
+			   previous units dependent on type of this predecessor 
+			   unit   */
+			(unit_ptr1)->Aux.flint_no += link_ptr->weight * error;
+		    }
+		    /* immediately updating the links cannot fit for TD 
+		       Networks! Add the the delta(ij) of all td_steps in the 
+		       Linkarray(value_c) of the first recept. field  */
+		    link_ptr->value_b += learn_error * (unit_ptr1)->Out.output;
+		    link_ptr->value_c += 1.0;
+		}
+	    }
+	}else{
+	    /* fully connected layers */
+	    /* immediately update of all physical links */
+	    unit_ptr->bias += learn_error;
+
+	    if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+		/*  the unit has direkt links  */
+		/* error must be saved for each unit of the hiddenlayer */
+		FOR_ALL_LINKS( unit_ptr, link_ptr ){
+		    /* adjust link weights and calc. sum of 
+		       errors of predecessor units  */
+		    if (IS_HIDDEN_UNIT (link_ptr->to))
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		  
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    }else{/* the unit has sites: not necessary for TD-Network  */
+		FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		    /*  adjust link weights and calc. sum of errors of the 
+			predecessor units */
+		    if (IS_HIDDEN_UNIT (link_ptr->to)) 
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    }
+	}
+	unit_ptr = *--topo_ptr;
+    } /* while */
+  
+
+    /* update receptive fields: propagate and calculate all featureunits of 
+       the first td-step of each layer.   */
+    /* topo_ptr points to the NULL pointer between input and hidden units */
+
+    for (i=0; i<2; i++){
+	unit_ptr = *++topo_ptr;
+	while (unit_ptr != NULL){
+	    if (unit_ptr->TD.td_connect_typ==1 && 
+		UNIT_HAS_DIRECT_INPUTS(unit_ptr) &&
+		unit_ptr->value_c > 0.0){
+		/* this is a reference unit of a time delay layer */
+
+		/* update bias of reference unit by average bias change */
+		unit_ptr->bias += unit_ptr->value_b / unit_ptr->value_c;
+
+		FOR_ALL_LINKS( unit_ptr, link_ptr ){ 
+		    /* store average linkweigth changes of all Td-steps */
+		    link_ptr->weight += link_ptr->value_b / link_ptr->value_c;
+		} /*for_all_links*/
+	    }
+	    unit_ptr = *++topo_ptr;
+	}
+    }
+    return( sum_error );/*  return the error of the network */
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : TEST_TDbackprop
+
+  PURPOSE  : Time Delay Backpropagation testing Function
+  NOTES    : Input Parameters:   2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  RETURNS  : 
+  UPDATE   : 21.01.95
+******************************************************************************/
+krui_err  TEST_TDbackprop( int start_pattern, int end_pattern, 
+			   float parameterInArray[], int NoOfInParams,
+			   float * *parameterOutArray, int *NoOfOutParams )
+
+{
+    static  float  OutParameter[1]; /* OutParameter[0] stores learning error */
+    int     ret_code, pattern_no, sub_pat_no;
+
+    if (NoOfInParams < 1)	/*  #  has to be changed (must be 2) # */
+	return( KRERR_PARAMETERS ); /*  Not enough input parameters  */
+
+    *NoOfOutParams = 1;	 /* One return value is available (the learning error)*/
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateTDNetForward(pattern_no,sub_pat_no); /* Forward propagation */
+
+	/*  Backward propagation  */
+	/*  1st parameter is the learning parameter
+	    2nd parameter is the max. devitation between output pattern and
+	    the output of the output unit (delta max)
+	    */
+	NET_ERROR( OutParameter ) +=
+	    testTDNetBackward(pattern_no,sub_pat_no,
+				   LEARN_PARAM1( parameterInArray ),
+				   LEARN_PARAM2( parameterInArray ) );
+    }
+
+    return( ret_code );
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : testTDNetBackward
+
+  PURPOSE  : Error Calculation for Time Delay Backward error propagation (topological).
+  NOTES    : Start calculating the average of the corresponding links in 
+             all TD-steps. This average is used to update the links of the 
+	     1st. receptive field.
+  RETURNS  : network error
+  UPDATE   : 21.01.95
+******************************************************************************/
+static	float testTDNetBackward(int pattern_no, int sub_pat_no,
+				     float learn_parameter, 
+				     float delta_max)
+{ 
+    register struct Unit   *unit_ptr;
+    register Patterns      out_pat;
+    register float         sum_error,  eta,  devit;
+    register TopoPtrArray  topo_ptr;
+    int                    last_log_layer;
+    int                    size;
+
+    sum_error = 0.0;		/*  reset network error  */
+    eta = learn_parameter;	/*  store learn_parameter in CPU register  */
+
+    /*  calculate address of the output pattern (with number pattern_no + 1) */
+
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 2);
+    last_log_layer = (*topo_ptr)->lln;
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /* calculate output units only: begin at the end of topo_pointer_array */
+    unit_ptr = *topo_ptr;
+    while (unit_ptr != (struct Unit *) NULL){
+	devit = *(--out_pat) - unit_ptr->Out.output; /*  calc. devitation */
+
+/* der Fehler wird auch summiert, wenn die Gewichtsfaktoren nicht adaptiert werden */
+	sum_error += devit * devit; /*  sum up the error of the network  */
+	if ( (float) fabs( devit ) <= delta_max ){
+            devit = 0; /* joe: sonst koennen Fehler auftreten*/
+	}
+	unit_ptr = *--topo_ptr;
+
+    }
+
+    return( sum_error );	/*  return the error of the network */
+}
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_td.h snort-2.3.3.new/src/kernel_snns/kr_td.h
--- snort-2.3.3/src/kernel_snns/kr_td.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_td.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,42 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_td.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Time delay learning and propagation functions
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 20.02.93
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:08 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_TD_DEFINED_
+#define  _KR_TD_DEFINED_
+
+extern void  propagateTDNetForward(int pattern_no, int sub_pat_no);
+
+extern krui_err LEARN_TDbackprop(int start_pattern, int end_pattern, 
+				 float parameterInArray[], int NoOfInParams,
+				 float * *parameterOutArray, 
+				 int *NoOfOutParams );
+
+extern krui_err LEARN_TDBP_McClelland(int start_pattern, int end_pattern, 
+				      float parameterInArray[], 
+				      int NoOfInParams,
+				      float * *parameterOutArray, 
+				      int *NoOfOutParams);
+
+extern krui_err TEST_TDbackprop(int start_pattern, int end_pattern, 
+				 float parameterInArray[], int NoOfInParams,
+				 float * *parameterOutArray, 
+				 int *NoOfOutParams );
+ 
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/kr_td.ph snort-2.3.3.new/src/kernel_snns/kr_td.ph
--- snort-2.3.3/src/kernel_snns/kr_td.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_td.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,62 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_td.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Time delay learning and propagation functions
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 20.02.93
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:09 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef _KR_TD_DEFINED_
+#define  _KR_TD_DEFINED_
+
+/* begin global definition section */
+
+void      propagateTDNetForward(int pattern_no, int sub_pat_no);
+
+krui_err  LEARN_TDbackprop(int start_pattern, int end_pattern, 
+			   float parameterInArray[], int NoOfInParams,
+			   float * *parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_TDBP_McClelland(int start_pattern, int end_pattern, 
+				float parameterInArray[], int NoOfInParams,
+				float * *parameterOutArray, int *NoOfOutParams);
+ 
+/* end global definition section */
+
+
+/* begin private definition section */
+
+#define  NET_ERROR( param )    param[ 0 ] /* returns the net error   */
+#define  LEARN_PARAM1( param ) param[ 0 ] /* contains the 1st learning param.*/
+#define  LEARN_PARAM2( param ) param[ 1 ] /* contains the 2nd learning param.*/
+#define  LEARN_PARAM3( param ) param[ 2 ] /* contains the 3rd learning param.*/
+#define  LEARN_PARAM4( param ) param[ 3 ] /* contains the 4th learning param.*/
+#define  LEARN_PARAM5( param ) param[ 4 ] /* contains the 5th learning param.*/
+
+static krui_err initializeTDBackprop(void);
+
+static float propagateTDNetBackward(int pattern_no, int sub_pat_no, 
+				    float learn_parameter, float delta_max );
+
+static float propagateTDNetBackMcClelland(int pattern_no, int sub_pat_no,
+					   float learn_parameter, 
+					   float delta_max );
+
+static float testTDNetBackward(int pattern_no, int sub_pat_no, 
+				    float learn_parameter, float delta_max );
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/kr_typ.h snort-2.3.3.new/src/kernel_snns/kr_typ.h
--- snort-2.3.3/src/kernel_snns/kr_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,336 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel: Datatypes and Constants for Internal Useage
+  NOTES          : 12.02.90
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 
+ 
+  CHANGED BY     : Sven Doering, Michael Vogt
+  RCS VERSION    : $Revision: 2.11 $
+  LAST CHANGE    : $Date: 1998/04/08 09:26:39 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#include "glob_typ.h"	 /*  Global datatypes and constants  */
+#include "ext_typ.h"     /*  Types and constants for extern kernel */
+
+#ifndef KR_TYPES
+#define KR_TYPES
+
+
+/*#################################################
+
+GROUP: Type Definitions
+
+#################################################*/
+
+#ifdef __BORLANDC__
+
+#ifndef strdup
+#define  strdup  bsd_strdup
+#endif
+
+/*
+#define  int long
+*/
+
+#endif
+
+/*  type definition of input/output pattern array
+*/
+typedef  FlintType     *Patterns;
+
+/*  type definition of integer array for shuffeling input/output patterns
+*/
+typedef  int    *PatternNumbers;
+
+struct Unit ; /* Dummy declaration */
+struct Site ; /* Dummy declaration */
+typedef  FlintType   (* SiteFuncPtr) (struct Site *);
+typedef  FlintType   (* ActFuncPtr)  (struct Unit *);
+typedef  FlintType   (* ActDerivFuncPtr) (struct Unit *);
+
+
+typedef  FlintType   (* OutFuncPtr)  (FlintType);
+typedef  krui_err    (* LearnFuncPtr) (int, int, float *, int, float * *, int *);
+typedef  krui_err    (* UpdateFuncPtr) (float *, int);
+typedef  krui_err    (* InitFuncPtr) (float *, int);
+
+typedef  krui_err    (* RemapFuncPtr) (float *pat_data, int pat_size, 
+				       float *remap_params, int no_of_remap_params);
+
+/*#################################################
+
+GROUP: Type Definition of Name Table
+
+#################################################*/
+
+/*  Name table structure
+*/
+struct   NameTable  {
+  union  {
+    char               *symbol;             /*  stores symbol name  */
+    struct  NameTable  *next;               /*  stores name-table block ptr
+                                                and free name-table entry   */
+  }  Entry;
+
+  unsigned short       sym_type,            /*  stores type of entry   */
+                       ref_count;           /*  stores no. of references to
+                                                this symbol (If more then MAXSHORT
+                                                references are detected the symbol will
+                                                released only by krm_releaseMem()
+                                            */
+};
+
+
+
+/*#################################################
+
+GROUP: Type Definition of Site-Table
+
+#################################################*/
+
+/*  Site table structure
+*/
+struct   SiteTable  {
+  union  {
+    struct NameTable	*site_name;  /*  stores the site symbol (it's not a direkt
+					 pointer to the symbol, but a pointer to the
+					 name-table entry */
+    struct SiteTable	*next;	     /*  stores next site-table block ptr
+					 and free site-table entries */
+  }  Entry;
+
+  SiteFuncPtr   site_func;      /*  stores site function    */
+};
+
+
+
+/*#################################################
+
+GROUP: Type definition of unit functionality table
+
+#################################################*/
+
+/*  Unit prototype structure
+*/
+struct   FtypeUnitStruct  {
+  struct  NameTable     *Ftype_symbol;
+
+  OutFuncPtr      out_func;
+  ActFuncPtr      act_func;
+  ActDerivFuncPtr  act_deriv_func;
+  ActDerivFuncPtr  act_2_deriv_func;
+
+  struct Site              *sites;
+
+  struct FtypeUnitStruct   *next;
+  struct FtypeUnitStruct   *prev;
+};
+
+
+
+/*#################################################
+
+GROUP: Unit/Site/Link type definitions
+
+#################################################*/
+
+/*m.r.*/
+/* BPTT: maximum number additional unit activity copies back in time,
+ (= number of non-input layers for backpropagation)
+*/
+#define MAX_BPTT_BACKSTEP 10
+
+/*  Link structure
+*/
+struct   Link  {
+  struct Unit   *to;      /*  points to the source unit  */
+  FlintType     weight;   /*  link weight  */
+
+  FlintType     value_a,  /*  general purpose elements for the  */
+                value_b,  /*  learning functions  */
+                value_c;
+
+  struct Link   *next;    /*  next link  */
+};
+
+
+/*  Site structure
+*/
+struct   Site  {
+  struct Link   *links;   /*  input links of the site  */
+  struct SiteTable      *site_table;  /*  : site name and function  */
+  struct Site   *next;    /*  next site  */
+};
+
+/*  Type of unit flags
+*/
+typedef  unsigned short  FlagWord;
+
+/*  Unit structure
+*/
+struct   Unit  {
+  /*  output MUST be the first element in unit structure !
+      (access is faster if functions can assume that <output>
+      is the FIRST element of the unit structure)
+  */
+  union  {
+    FlintType     output;       /*  unit's output  */
+    int           nextFreeUnit; /*  used by the unit memory manager  */
+  } Out;
+
+  FlagWord        flags;        /*  unit flags  */
+
+  int             lun;          /*  logical unit number  */
+  int             lln;          /*  logical layer number  */
+
+  struct  FtypeUnitStruct   *Ftype_entry;  /*  pointer to the unit's prototype  */
+
+  union  {
+    FlintType     flint_no;     /*  used by backpropagation: holds errors from successors   */
+    int           int_no;       /*  used by layer sorting: holds the layer no of the unit   */
+    char         *ptr;          /*  used for garbage collection  */
+  }  Aux;   /*  general purpose use  */
+
+  struct
+    {
+    struct Unit   **my_topo_ptr;   /* pointer to coresponding entry in */
+                                   /* topo_ptr_array */
+    int           target_offset;   /* offset to prototype target unit via */
+                                   /* topo_ptr_array */
+    int           source_offset;   /* offset to logioal source unit via */
+                                   /* prototype target and topo_ptr_array */
+    int           td_connect_typ;  /* recept. field or not */
+    }  TD;  /* TimeDelay net datas */
+
+  FlintType	  act,		/*  current activation	*/
+		  i_act,	/*  initial activation	*/
+		  bias; 	/*  bias  */
+
+  FlintType       value_a,      /*  general purpose elements for the  */
+                  value_b,      /*  learning functions  */
+                  value_c;
+
+  unsigned long int usr_flags;  /* long flag word for general purpose usage
+                                   within learning functions */
+
+/*m.r.*/
+  FlintType       olddelta,     /* BPTT-section: delta value at time t */
+                  newdelta;     /* delta value at time t-1 
+				   (deltas are propagated back in time )*/
+  FlintType       actbuf[MAX_BPTT_BACKSTEP]; /*outacts at previous time steps*/
+/*m.r.*/
+
+  OutFuncPtr	  out_func;	    /*	output function  */
+  ActFuncPtr	  act_func;	    /*	activation function */
+  ActDerivFuncPtr  act_deriv_func;  /*	derivation act. function */
+  ActDerivFuncPtr act_2_deriv_func; /*  second derivation act. function */
+
+  char           *unit_name;    /*  unit name */
+
+  short           subnet_no;    /*  subnet no.  */
+  unsigned short  layer_no;     /*  display layer (bitfield)  */
+
+  struct PosType  unit_pos;     /*  unit position  */
+
+
+  /*  unit's center position  */
+  struct PositionVector unit_center_pos[ NO_OF_UNIT_CENTER_POS ];
+
+
+  struct Site     *sites;           /*  points to unit's input links or sites  */
+};
+
+
+
+/*#################################################
+
+GROUP: Var types used by kernel functions
+
+#################################################*/
+
+/*  stucture for storing the error codes and messages of the topologic sorting
+    and network checking functions
+*/
+struct TopologicMessages  {
+  int  error_code,         /*  stores the internal error code  */
+       no_of_cycles,       /*  no. of detected cycles in the network  */
+       no_of_dead_units,   /*  no. of dead units in the network  */
+       no_of_layers,       /*  no. of layers of the network */
+       dest_error_unit,    /*  first error unit (destination unit)  */
+       src_error_unit;     /*  first error unit (source unit)  */
+  char name[20];           /*  a chararcter string that can be passed */
+};
+
+
+/*#################################################
+
+GROUP: Link/Site/Unit and Unit Ptrs Array Type Definitions
+
+#################################################*/
+
+/*  definition of link array
+*/
+typedef  struct Link    *LinkArray;
+
+/*  definition of site array
+*/
+typedef  struct Site    *SiteArray;
+
+/*  definition of pointer array for topological sorting
+*/
+typedef  struct Unit *  *TopoPtrArray;
+
+/*  definition of unit array
+*/
+typedef  struct Unit    *UnitArray;
+
+/*  Definition of Name Table Array
+*/
+typedef  struct NameTable  *NTableArray;
+
+/*  Definition of Site Name Table Array
+*/
+typedef  struct SiteTable  *STableArray;
+
+
+
+
+struct   TransTable  {
+  short  z,
+         x,
+	 y;
+};
+
+
+
+/*#################################################
+
+GROUP: Structure Size Constants
+
+#################################################*/
+
+#define   UNIT_SIZE             sizeof (struct Unit)
+#define   SITE_SIZE             sizeof (struct Site)
+#define   LINK_SIZE             sizeof (struct Link)
+
+#define   PATTERN_SIZE          sizeof (FlintType)
+#define   PATTERN_NO_SIZE       sizeof (int)
+
+#define   TOPO_PTR_SIZE         sizeof (struct Unit *)
+
+#define   NTABLE_SIZE           sizeof (struct NameTable)
+
+#define   STABLE_SIZE           sizeof (struct SiteTable)
+
+#define   FTYPE_UNIT_SIZE       sizeof (struct FtypeUnitStruct)
+
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/kr_ui.c snort-2.3.3.new/src/kernel_snns/kr_ui.c
--- snort-2.3.3/src/kernel_snns/kr_ui.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_ui.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,5339 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_ui.c,v $
+  SHORTNAME      : kr_ui.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel User Interface
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 27.02.90
+
+  CHANGED BY     : Michael Vogt, Guenter Mamier
+  RCS VERSION    : $Revision: 2.51 $
+  LAST CHANGE    : $Date: 1998/05/25 16:00:40 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <string.h>
+#include <memory.h>
+#include <math.h>
+
+#ifndef rand
+#include "random.h"      /*  Randomize Library Function Prototypes  */
+#endif
+
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "glob_typ.h"
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+
+#include "kr_io.h"       /*  Kernel I/O-Routines */
+#include "kr_funcs.h"    /*  Function Prototypes */
+#include "kernel.h"      /*  Function Prototypes */
+#include "kr_mem.h"      /*  Function Prototypes */
+#include "kr_ui.ph"      /*  Interface function prototypes  */
+#include "version.h"     /*  Version and Patchlevel  */
+#include "kr_mac.h"      /*  Kernel Macros  */
+#include "kr_newpattern.h"   /* new style pattern handling */
+#include "kr_inversion.h" /* inversion algorithm routines */
+#include "cc_glob.h"
+#include "cc_display.h"
+#include "trans_f.h"
+#include "learn_f.h"
+
+#ifdef MASPAR_KERNEL
+
+#include "kr_feedf.h"    /*  Function Prototypes */
+
+#endif
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the number of units used by the network.
+  UPDATE   :
+******************************************************************************/
+int krui_getNoOfUnits(void)
+{
+    return( NoOfUnits );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstUnit
+
+  PURPOSE  : Initializes the first available unit for access. If the unit has
+             sites, the first site will be set to the current site.
+  NOTES    :
+
+  RETURNS  : Returns the unit no. of the first unit or 0 if no units available.
+  UPDATE   :
+******************************************************************************/
+int  krui_getFirstUnit(void)
+{
+    return( kr_getUnit( FIRST ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getNextUnit
+
+  PURPOSE  : Initializes the next available unit for access. If the unit has 
+             sites, the first site will be set to the current site.
+  NOTES    :
+
+  RETURNS  : Returns the unit no. of the next unit or 0 if no more units 
+             available.
+  UPDATE   :
+******************************************************************************/
+int  krui_getNextUnit(void)
+{
+    return( kr_getUnit( NEXT ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getCurrentUnit
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the no. of the current unit or 0 if no units available
+  UPDATE   :
+******************************************************************************/
+int  krui_getCurrentUnit(void)
+{
+    return( kr_getUnit( CURRENT ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setCurrentUnit
+
+  PURPOSE  : Initializes a unit for access. If the unit has sites, the first site
+    will be set to the current site.
+  NOTES    :
+
+  RETURNS  : Returns error code if the given unit doesn't exist, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setCurrentUnit(int unit_no)
+{
+    return( kr_setCurrUnit( unit_no ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the unit. (NULL if not available)
+  UPDATE   :
+******************************************************************************/
+char  *krui_getUnitName(int UnitNo)
+{
+    struct Unit   *unit_ptr;
+
+    if ((unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( NULL );         /*  invalid unit #  */
+
+    return( unit_ptr->unit_name );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitName
+
+  PURPOSE  : Sets the name of the unit <UnitNo>.
+             If the unit_name pointer is NULL, the unit's symbol will be deleted.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  : Returns error code if memory allocation fails, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitName(int unit_no, char *unit_name)
+{
+    struct Unit   *unit_ptr;
+    char    *str_ptr;
+
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    NetModified = TRUE;
+
+    if (unit_name == NULL)
+        {
+            krm_NTableReleaseSymbol( unit_ptr->unit_name, UNIT_SYM );
+            unit_ptr->unit_name = NULL;
+            return( KernelErrorCode );
+        }
+
+    if (!kr_symbolCheck( unit_name ))  return( KernelErrorCode );
+
+    if ( (str_ptr = krm_NTableInsertSymbol( unit_name, UNIT_SYM ) ) == NULL)
+        return( KernelErrorCode );
+
+    unit_ptr->unit_name = str_ptr;
+
+    return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_searchUnitName
+
+  PURPOSE  : Searches for a unit with the given name
+  NOTES    :
+
+  RETURNS  : Returns the first unit no. if a unit with the given name was found,
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+int  krui_searchUnitName(char *unit_name)
+{
+    struct  NameTable  *n_ptr;
+
+    if (NoOfUnits <= 0)  {
+        UICurrentNameSearchUnitNo = 0;
+        return( (int) KRERR_NO_UNITS ); /*  No Units defined  */
+    }
+
+    if ((n_ptr = krm_NTableSymbolSearch( unit_name, UNIT_SYM )) == NULL)  {
+        UICurrentNameSearchUnitNo = 0;
+        return( 0 );
+    }
+
+    UICurrentNameSearchUnitSymbolPtr = n_ptr->Entry.symbol;
+    UICurrentNameSearchUnitNo = 
+	kr_unitNameSearch( MinUnitNo, UICurrentNameSearchUnitSymbolPtr );
+
+    return( UICurrentNameSearchUnitNo );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_searchNextUnitName
+
+  PURPOSE  : Searches for the next unit with the given name.
+  NOTES    : Call krui_searchUnitName( unit_name ) before calling krui_searchNextUnitName().
+             Returns error code if no units defined.
+
+  RETURNS  : Returns the first unit no. if a unit with the given name was found,
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+int  krui_searchNextUnitName(void)
+{
+
+    if (NoOfUnits <= 0) {
+        UICurrentNameSearchUnitNo = 0;
+        return( KRERR_NO_UNITS ); /*  No Units defined  */
+    }
+
+    if (UICurrentNameSearchUnitNo != 0) {
+        UICurrentNameSearchUnitNo = 
+	    kr_unitNameSearch( UICurrentNameSearchUnitNo + 1, 
+			       UICurrentNameSearchUnitSymbolPtr );
+        return( UICurrentNameSearchUnitNo );
+    }
+    else
+        return( 0 );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitOutFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the output function name of the unit.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getUnitOutFuncName(int UnitNo)
+{
+    struct Unit   *unit_ptr;
+    static char  out_func_name[FUNCTION_NAME_MAX_LEN];
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( NULL );         /*  invalid unit #  */
+
+    strcpy( out_func_name, krf_getFuncName( (FunctionPtr) unit_ptr->out_func ));
+
+    return( out_func_name );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitOutFunc(
+
+  PURPOSE  : he unit's FType will be set to 0, i.e. the
+             unit's functionality type will be deleted.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  : returns 0, if the function is a valid output function,
+             error code otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitOutFunc(int unit_no, char *unitOutFuncName)
+{
+    struct Unit   *unit_ptr;
+    FunctionPtr func_ptr;
+
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    if ( !krf_funcSearch( unitOutFuncName, OUT_FUNC, &func_ptr ))
+        return( KernelErrorCode );
+
+    unit_ptr->out_func = (OutFuncPtr) func_ptr;
+    unit_ptr->Ftype_entry = NULL;
+
+    NetModified = TRUE;
+
+    return( KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitActFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the activation function name of the unit.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getUnitActFuncName(int UnitNo)
+{
+    struct Unit   *unit_ptr;
+    static char  act_func_name[FUNCTION_NAME_MAX_LEN];
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( NULL );         /*  invalid unit #  */
+
+    strcpy( act_func_name, krf_getFuncName( (FunctionPtr) unit_ptr->act_func ));
+
+    return( act_func_name );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitActFunc
+
+  PURPOSE  : The unit's FType will be set to 0, i.e. the
+             unit's functionality type will be deleted.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  : returns 0, if the function is a valid activation function,
+             error code otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitActFunc(int unit_no, char *unitActFuncName)
+{
+    struct Unit   *unit_ptr;
+    FunctionPtr   act_func_ptr, act_deriv_func_ptr, act_2_deriv_func_ptr;
+
+#ifdef MASPAR_KERNE
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+    if ( !krf_funcSearch( unitActFuncName, ACT_FUNC, &act_func_ptr ))
+        return( KernelErrorCode );
+    /*  set the derivation function of the activation function  */
+    if( !krf_funcSearch( unitActFuncName, ACT_DERIV_FUNC, &act_deriv_func_ptr ))
+        return( KernelErrorCode );
+    /*  set the second derivation function of the activation function  */
+    if ( !krf_funcSearch( unitActFuncName, ACT_2_DERIV_FUNC, 
+			  &act_2_deriv_func_ptr ))
+        return( KernelErrorCode );
+
+
+    unit_ptr->act_func = (ActFuncPtr) act_func_ptr;
+    unit_ptr->act_deriv_func = (ActDerivFuncPtr) act_deriv_func_ptr;
+    unit_ptr->act_2_deriv_func = (ActDerivFuncPtr) act_2_deriv_func_ptr;
+    unit_ptr->Ftype_entry = NULL;
+
+    NetModified = TRUE;
+
+    return( KRERR_NO_ERROR );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitFTypeName
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the functionality type name of the unit.
+             Function has no effect on the current unit.
+             Returns NULL if unit has no FType.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getUnitFTypeName(int UnitNo)
+{
+    struct FtypeUnitStruct    *Ftype_entry;
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( NULL );         /*  invalid unit #  */
+
+    if ( (Ftype_entry = unit_ptr->Ftype_entry) == NULL)
+        return( NULL );
+
+    return( Ftype_entry->Ftype_symbol->Entry.symbol );
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitActivation
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the activation value of the unit.
+  UPDATE   :
+******************************************************************************/
+FlintType  krui_getUnitActivation(int UnitNo)
+{
+
+    if KERNEL_STANDARD {
+        return( kr_getUnitValues( UnitNo, SEL_UNIT_ACT ) );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        return( krff_getUnitValues( UnitNo, SEL_UNIT_ACT ) );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+
+#endif
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitActivation
+
+  PURPOSE  : Sets the activation value of the unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitActivation(int UnitNo, FlintTypeParam unit_activation)
+{
+    krui_err err = KRERR_NO_ERROR;
+
+    if KERNEL_STANDARD  {
+        err = kr_setUnitValues( UnitNo, SEL_UNIT_ACT, unit_activation );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        (void) krff_setUnitValues( UnitNo, SEL_UNIT_ACT, unit_activation );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+
+#endif
+    }
+    return(err);
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitInitialActivation
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the initial activation value of the unit.
+  UPDATE   :
+******************************************************************************/
+FlintType  krui_getUnitInitialActivation(int UnitNo)
+{
+
+    if KERNEL_STANDARD
+        return( kr_getUnitValues( UnitNo, SEL_UNIT_IACT ) );
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        return( krff_getUnitValues( UnitNo, SEL_UNIT_IACT ) );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+
+#endif
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitInitialActivation
+
+  PURPOSE  : Sets the initial activation value of the unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_setUnitInitialActivation(int UnitNo, 
+				    FlintTypeParam unit_i_activation)
+{
+
+    if KERNEL_STANDARD
+        kr_setUnitValues( UnitNo, SEL_UNIT_IACT, unit_i_activation );
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        krff_setUnitValues( UnitNo, SEL_UNIT_IACT, unit_i_activation );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+
+#endif
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitOutput
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the output value of the unit.
+  UPDATE   :
+******************************************************************************/
+FlintType  krui_getUnitOutput(int UnitNo)
+{
+
+    if KERNEL_STANDARD
+        return( kr_getUnitValues( UnitNo, SEL_UNIT_OUT ) );
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        return( krff_getUnitValues( UnitNo, SEL_UNIT_OUT ) );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+
+#endif
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitOutput
+
+  PURPOSE  : Sets the output value of the unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitOutput(int unit_no, FlintTypeParam unit_output)
+{
+
+    if KERNEL_STANDARD  {
+        kr_setUnitValues( unit_no, SEL_UNIT_OUT, unit_output );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        krff_setUnitValues( unit_no, SEL_UNIT_OUT, unit_output );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+
+#endif
+    }
+
+    return( KernelErrorCode );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitBias
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the bias value of the unit.
+  UPDATE   :
+******************************************************************************/
+FlintType  krui_getUnitBias(int UnitNo)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_getUnitValues( UnitNo, SEL_UNIT_BIAS ) );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        return( krff_getUnitValues( UnitNo, SEL_UNIT_BIAS ) );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+
+#endif
+    }
+}
+/*****************************************************************************
+  FUNCTION : krui_setUnitBias
+
+  PURPOSE  : Sets the bias value of the unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_setUnitBias(int UnitNo, FlintTypeParam unit_bias)
+{
+
+    if KERNEL_STANDARD  {
+        kr_setUnitValues( UnitNo, SEL_UNIT_BIAS, unit_bias );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        krff_setUnitValues( UnitNo, SEL_UNIT_BIAS, unit_bias );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+
+#endif
+    }
+}
+
+/****************************************************************************
+  FUNCTION : krui_getUnitValueA
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns Value A of the unit.
+  UPDATE   :
+****************************************************************************/
+FlintType  krui_getUnitValueA(int UnitNo)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_getUnitValues( UnitNo, SEL_UNIT_VALA ) );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        return( krff_getUnitValues( UnitNo, SEL_UNIT_VALA ) );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+
+#endif
+    }
+}
+
+/******************************************************************************
+  FUNCTION : krui_setUnitValueA
+
+  PURPOSE  : Sets value a of the unit.
+  NOTES    : Function has no effect on the current unit.
+
+
+  RETURNS  :
+  UPDATE   :
+*****************************************************************************/
+void  krui_setUnitValueA(int UnitNo, FlintTypeParam unit_valueA)
+{
+
+    if KERNEL_STANDARD  {
+        kr_setUnitValues( UnitNo, SEL_UNIT_VALA, unit_valueA );
+    }
+    else  {
+
+#ifdef MASPAR_KERNEL
+
+        krff_setUnitValues( UnitNo, SEL_UNIT_VALA, unit_valueA );
+
+#else
+
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+
+#endif
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitSubnetNo
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+             The range of the subnet no. is -32736...+32735
+
+  RETURNS  : Returns the subnet number of the unit.
+  UPDATE   :
+******************************************************************************/
+int  krui_getUnitSubnetNo(int UnitNo)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( 0 );            /*  invalid unit #  */
+
+    return( (int) unit_ptr->subnet_no );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitSubnetNo
+
+  PURPOSE  : Sets the subnet number of the unit.
+             Function has no effect on the current unit.
+  NOTES    : The range of the subnet no. is -32736...+32735
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_setUnitSubnetNo(int UnitNo, int subnet_no)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return;                 /*  invalid unit #  */
+
+    NetModified = TRUE;
+
+    unit_ptr->subnet_no = (short) subnet_no;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitLayerNo
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+             The range of the layer no. is -32736...+32735
+
+  RETURNS  : Returns the layer number of the unit.
+  UPDATE   :
+******************************************************************************/
+unsigned short  krui_getUnitLayerNo(int UnitNo)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return( 0 );            /*  invalid unit #  */
+
+    return( (unsigned short) unit_ptr->layer_no );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitLayerNo
+
+  PURPOSE  : Sets the layer number of the unit.
+  NOTES    : Function has no effect on the current unit.
+             The range of the layer no. is -32736...+32735
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void    krui_setUnitLayerNo(int UnitNo, int layer_no)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return;                 /*  invalid unit #  */
+
+    NetModified = TRUE;
+
+    unit_ptr->layer_no = (unsigned short) layer_no;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitPosition
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the position of the unit.
+  UPDATE   :
+******************************************************************************/
+void    krui_getUnitPosition(int UnitNo, struct PosType *position)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return;                 /*  invalid unit #  */
+
+    position->x = unit_ptr->unit_pos.x;
+    position->y = unit_ptr->unit_pos.y;
+    position->z = unit_ptr->unit_pos.z;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitPosition
+
+  PURPOSE  : Sets the position of the unit.
+  NOTES    : Function has no effect on the current unit
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void    krui_setUnitPosition(int UnitNo, struct PosType *position)
+{
+    struct Unit   *unit_ptr;
+
+    if ( (unit_ptr = kr_getUnitPtr( UnitNo ) ) == NULL)
+        return;                 /*  invalid unit #  */
+
+    unit_ptr->unit_pos.x = position->x;
+    unit_ptr->unit_pos.y = position->y;
+    unit_ptr->unit_pos.z = position->z;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitNoAtPosition
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+             This function is slow because it uses linear search to
+             find the unit with the given position.
+  REMARK   : getUnitNoAtPosition is for downward compatibility only.
+             Do not use this function in future applications.
+
+  RETURNS  : Returns the unit no. at the given position and subnet number or 0, if
+             no unit exists at this position
+  UPDATE   :
+******************************************************************************/
+int   krui_getUnitNoAtPosition(struct PosType *position, int subnet_no)
+{
+    register int       i;
+    register short     x, y, net_no;
+    struct Unit     *unit_ptr;
+
+    x = position->x;
+    y = position->y;
+
+    net_no = (short) subnet_no;
+
+    for (i = 1, unit_ptr = unit_array + 1;
+         i <= MaxUnitNo;
+         i++, unit_ptr++)
+        {
+            if ( UNIT_IN_USE( unit_ptr ) &&
+                (unit_ptr->subnet_no == net_no) &&
+                (unit_ptr->unit_pos.x == x) && (unit_ptr->unit_pos.y == y) )
+
+                return( i );
+        }
+
+    return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitNoNearPosition
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+             This function is slow because it uses linear search to
+             find the unit with the given position.
+
+  RETURNS  : Returns the unit no. near the given position and the specified
+             subnet no or 0, if no unit exists at this position.
+  UPDATE   :
+******************************************************************************/
+int  krui_getUnitNoNearPosition(struct PosType *position, int subnet_no, int range, int gridWidth)
+{
+    register int       i, devit, width;
+    register short     x, y, net_no;
+    struct Unit        *unit_ptr;
+
+    x = position->x;
+    y = position->y;
+    net_no = (short) subnet_no;
+    devit = range;
+    width = gridWidth;
+
+    for (i = 1, unit_ptr = unit_array + 1; i <= MaxUnitNo;
+         i++, unit_ptr++)
+        {
+            if ( UNIT_IN_USE( unit_ptr ) &&
+                (unit_ptr->subnet_no == net_no) &&
+                (abs( unit_ptr->unit_pos.x - x) * width <= devit) &&
+                (abs( unit_ptr->unit_pos.y - y) * width <= devit) )
+                return( i );
+        }
+
+    return( 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitTType
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the topologic type, i.e. input, output, hidden
+  UPDATE   :
+******************************************************************************/
+int  krui_getUnitTType(int unit_no)
+{
+    struct Unit   *unit_ptr;
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    return( kr_flags2TType( (int) unit_ptr->flags & UFLAG_TTYP_PAT ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitTType
+
+  PURPOSE  : Sets the topologic type of the unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  : Returns error code if topologic type or unit number is invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitTType(int unit_no, int UnitTType)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    return( kr_unitSetTType( unit_no, UnitTType ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_freezeUnit
+
+  PURPOSE  : Freezes the output of a unit, i.e. the unit is disabled.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_freezeUnit(int unit_no)
+{
+    struct Unit   *unit_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    unit_ptr->flags &= (~UFLAG_ENABLED);
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_unfreezeUnit
+
+  PURPOSE  : Enables a previosly freezed unit.
+             Function has no effect on the current unit.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_unfreezeUnit(int unit_no)
+{
+    struct Unit   *unit_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    unit_ptr->flags |= UFLAG_ENABLED;
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_isUnitFrozen
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns true, if unit is frozen
+  UPDATE   :
+******************************************************************************/
+bool  krui_isUnitFrozen(int unit_no)
+{
+    struct Unit   *unit_ptr;
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    return( (unit_ptr->flags & UFLAG_ENABLED) == 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitInputType
+
+  PURPOSE  :
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the input type of the unit:
+             NO_INPUTS    : if the unit has not inputs (at least not now)
+             SITES        : if the unit has one or more sites (and no direct 
+	                    input links !)
+             DIRECT_LINKS : if the unit has direct input links (and no sites !)
+
+  UPDATE   :
+******************************************************************************/
+int  krui_getUnitInputType(int unit_no)
+{
+    struct Unit  *unit_ptr;
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    switch ((int) unit_ptr->flags & UFLAG_INPUT_PAT)    {
+      case UFLAG_NO_INP :  return( NO_INPUTS    );
+      case UFLAG_SITES  :  return( SITES        );
+      case UFLAG_DLINKS :  return( DIRECT_LINKS );
+
+      default :  return( NO_INPUTS );
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createDefaultUnit
+
+  PURPOSE  :  creates a unit with default properties:
+              1. default activation and output functions
+              2. default activation and bias
+              3. default position, subnet and layer number
+              4. no functionality type
+              5. no sites
+              6. no inputs and outputs
+              7. no unit_name
+  NOTES    :  See file "kr_def.h" for more details about default presettings.
+              Function has no effect on the current unit.
+
+  RETURNS  :  Returns an (negative) error code, if memory allocation fails or
+              invalid functions occured. Returns (positive) unit number otherwise.
+  UPDATE   :
+******************************************************************************/
+int  krui_createDefaultUnit(void)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    NetModified = TRUE;
+    return( kr_makeDefaultUnit() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createUnit
+
+  PURPOSE  : Creates a user defined unit.
+             Returns an (negative) error code, if memory allocation fails or
+             invalid functions occured. Returns (positive) unit number otherwise.
+             Function has no effect on the current unit.
+
+             Unit has additional default settings:
+             1. default position, subnet and layer number
+             2. no functionality type
+             3. no sites
+             4. no inputs and outputs
+
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+int  krui_createUnit(char *unit_name, char *out_func_name, char *act_func_name,
+		     FlintTypeParam i_act, FlintTypeParam bias)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    return( kr_createUnit( unit_name, out_func_name, act_func_name, 
+			   i_act, bias) );
+}
+
+
+/*****************************************************************************
+                 UNDOCUMENTED FUNCTION SINCE SNNS VERSION 3.0
+                   !!!! DO NOT USE THIS FUNCTION ANY MORE  !!!
+                   !!!! USE: krui_deleteUnitList() INSTEAD !!!
+
+  FUNCTION : krui_deleteUnit
+
+  PURPOSE  : Deletes a unit from network. Removes all links to other units.
+  NOTES    : !!!! DO NOT USE THIS FUNCTION ANY MORE !!!
+             !!!! USE: krui_deleteUnitList() INSTEAD !!!
+
+  RETURNS  : Returns error code if unit doesn't exist.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteUnit(int unit_no)
+{
+    struct  Unit      *unit_ptr;
+
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    (void) kr_removeUnit( unit_ptr );
+    NetModified = TRUE;
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteUnitList
+
+  PURPOSE  : Deletes 'no_of_units' from the network. The numbers of the
+             units that have to be deleted are listed up in an array
+             of integers beginning with index 0.
+             This array is passed to parameter 'unit_list'.
+             Removes all links to and from these units.
+
+  NOTES    : Always use this function instead of krui_deleteUnit()
+
+  RETURNS  : Returns error code if unit doesn't exist.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteUnitList(int no_of_units, int unit_list[])
+{
+    struct  Unit      *unit_ptr;
+    int               i;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    for (i=0; i < no_of_units; i++) {
+        if ((unit_ptr = kr_getUnitPtr( unit_list[i] )) == NULL) {
+            return( KernelErrorCode );
+        } /*if*/
+
+        (void) kr_removeUnit( unit_ptr );
+    } /*for*/
+
+    /* Now perform Garbage Collection */
+    kr_forceUnitGC();
+
+    NetModified = TRUE;
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createFTypeUnit
+
+  PURPOSE  : creates a unit with FType properties, but:
+             1. no inputs and outputs
+             2. default position, subnet and layer
+
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns the unit number or (negative) error code if memory 
+             allocation fails or functionality type isn't defined.
+  UPDATE   :
+******************************************************************************/
+int  krui_createFTypeUnit(char *Ftype_symbol)
+{
+    int     unit_no;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    unit_no = kr_makeFtypeUnit( Ftype_symbol );
+    if (KernelErrorCode != KRERR_NO_ERROR)
+        return( KernelErrorCode );
+
+    NetModified = TRUE;
+    return( unit_no );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUnitFType
+
+  PURPOSE  : Changes the properties of unit <UnitNo> to FType properties.
+             Changes: activation/output function and site name/functions.
+  NOTES    : Function has no effect on the current unit.
+
+  RETURNS  : Returns an error code if
+             - FType name doesn't exist or
+             - unit doesn't exist or
+             - memory allocation fails
+             otherwise 0.
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitFType(int unit_no, char *Ftype_symbol)
+{
+    struct  Unit      *unit_ptr;
+    struct  FtypeUnitStruct   *ftype_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+    if (!kr_symbolCheck( Ftype_symbol ))
+        return( KernelErrorCode );
+
+    if ( (ftype_ptr = krm_FtypeSymbolSearch( Ftype_symbol ) ) == NULL)
+        {                       /*  Ftype name isn't defined    */
+            KernelErrorCode = KRERR_FTYPE_SYMBOL;
+            return( KernelErrorCode );
+        }
+
+    NetModified = TRUE;
+    kr_changeFtypeUnit( unit_ptr, ftype_ptr );
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_copyUnit
+
+  PURPOSE  : Copy a given unit, according to the copy mode
+             1. copy unit (with it sites, if available) and input/output links
+             2. copy unit (with it sites, if available) and input links
+             3. copy unit (with it sites, if available) and output links
+             4. copy unit (with it sites, if available) but no input/output link
+  NOTES    : Function has no effect on the current unit.
+             Copying of output links is slow.
+             If return code < 0, an error occured.
+
+  RETURNS  : Returns the unit number of the new unit or error message < 0 
+  UPDATE   :
+******************************************************************************/
+int   krui_copyUnit(int unit_no, int copy_mode)
+{
+    int   new_unit_no;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    new_unit_no = kr_copyUnit( copy_mode, unit_no );
+    if (KernelErrorCode != KRERR_NO_ERROR)
+        return( KernelErrorCode );
+
+    return( new_unit_no );
+}
+
+
+
+/*###########################################################################
+
+GROUP: Functions for manipulation of the Unit-Functionality-List
+REMEMBER: The Unit-Functionality-List stores:
+            1. unit activation and output functions
+            2. if sites:  3. all site functions
+                          4. all site names
+
+
+#############################################################################*/
+
+/*****************************************************************************
+  FUNCTION : krui_setFirstFTypeEntry
+
+  PURPOSE  : Initializes the first FType entry.
+  NOTES    :
+
+  RETURNS  : Returns true, if an entry is available
+  UPDATE   :
+******************************************************************************/
+bool  krui_setFirstFTypeEntry(void)
+{
+    UICurrentFtypeEntry = krm_getFtypeFirstEntry();
+    UICurrentFtypeSite = NULL;
+    return( UICurrentFtypeEntry != NULL );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setNextFTypeEntry
+
+  PURPOSE  : Initializes the next FType entry.
+  NOTES    :
+
+  RETURNS  : Returns true, if an entry is available
+  UPDATE   :
+******************************************************************************/
+bool  krui_setNextFTypeEntry(void)
+{
+    struct  FtypeUnitStruct   *ftype_ptr;
+
+    UICurrentFtypeSite = NULL;
+    if ( (ftype_ptr = krm_getFtypeNextEntry() ) != NULL)
+        {
+            UICurrentFtypeEntry = ftype_ptr;
+            return( TRUE );
+        }
+
+    return( FALSE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFTypeEntry
+
+  PURPOSE  : Initializes the FType entry with the given name.
+  NOTES    :
+
+  RETURNS  : Returns true, if an entry with this name is available.
+  UPDATE   :
+******************************************************************************/
+bool  krui_setFTypeEntry(char *Ftype_symbol)
+{
+    struct  FtypeUnitStruct   *ftype_ptr;
+
+    if ( (ftype_ptr = krm_FtypeSymbolSearch( Ftype_symbol ) ) != NULL)
+        {
+            UICurrentFtypeEntry = ftype_ptr;
+            return( TRUE );
+        }
+
+    return( FALSE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFTypeName
+
+  PURPOSE  :
+  NOTES    : The FType name is definite and will never be
+             a NULL pointer.
+
+  RETURNS  : Returns the name of the current FType entry.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getFTypeName(void)
+{
+
+    if (UICurrentFtypeEntry == NULL)
+        return( NULL );
+
+    return( UICurrentFtypeEntry->Ftype_symbol->Entry.symbol );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFTypeName
+
+  PURPOSE  : Sets the name of the current FType entry.
+  NOTES    : The new FType name have to be definite and must not be
+             a NULL pointer.
+
+  RETURNS  : Returns error code if memory allocation fails or Ftype name
+             isn't definite, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setFTypeName(char *Ftype_symbol)
+{
+    struct NameTable    *NTable_ptr;
+
+    if (UICurrentFtypeEntry == NULL)
+        return( KRERR_FTYPE_ENTRY ); /*  Current Ftype entry isn't defined   */
+
+    if (Ftype_symbol == NULL)
+        return( KRERR_FTYPE_NAME ); /*  Ftype name isn't definite   */
+
+    if (!kr_symbolCheck( Ftype_symbol ))
+        return( KRERR_SYMBOL ); /*  Symbol pattern invalid */
+
+    if (krm_NTableSymbolSearch( Ftype_symbol, FTYPE_UNIT_SYM ) != NULL)
+        return( KRERR_FTYPE_NAME ); /*  Ftype name isn't definite   */
+
+    if((NTable_ptr=krm_NTableCreateEntry(Ftype_symbol, FTYPE_UNIT_SYM)) == NULL)
+        return( KRERR_INSUFFICIENT_MEM ); /*  Insufficient memory  */
+
+    krm_NTableReleaseEntry( UICurrentFtypeEntry->Ftype_symbol );
+
+    UICurrentFtypeEntry->Ftype_symbol = NTable_ptr;
+
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFTypeActFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the activation function in the current
+             FType entry
+  UPDATE   :
+******************************************************************************/
+char  *krui_getFTypeActFuncName(void)
+{
+    static char  act_func_name[FUNCTION_NAME_MAX_LEN];
+
+    if (UICurrentFtypeEntry == NULL)
+        return( NULL );
+
+    strcpy( act_func_name, 
+	    krf_getFuncName( (FunctionPtr) UICurrentFtypeEntry->act_func ) );
+
+    return( act_func_name );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFTypeActFunc
+
+  PURPOSE  :
+  NOTES    : All units (in the existing network) of the current Ftype changes
+             their activation function.
+
+  RETURNS  : Sets the activation function in the current FType entry
+             returns 0, if the function is a valid activation function,
+             error code otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setFTypeActFunc(char *act_func_name)
+{
+    FunctionPtr  act_func_ptr, act_deriv_func_ptr, act_2_deriv_func_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if (UICurrentFtypeEntry == NULL)
+        {                       /*  Current Ftype entry isn't defined   */
+            KernelErrorCode = KRERR_FTYPE_ENTRY;
+            return( KernelErrorCode );
+        }
+
+    if ( !krf_funcSearch( act_func_name, ACT_FUNC, &act_func_ptr ) )
+        return( KernelErrorCode );
+    /*  set the derivation function of the activation function  */
+    if ( !krf_funcSearch( act_func_name, ACT_DERIV_FUNC, &act_deriv_func_ptr ))
+        return( KernelErrorCode );
+    /*  set the second derivation function of the activation function  */
+    if ( !krf_funcSearch( act_func_name, ACT_2_DERIV_FUNC, 
+			  &act_2_deriv_func_ptr ))
+        return( KernelErrorCode );
+
+    UICurrentFtypeEntry->act_func = (ActFuncPtr) act_func_ptr;
+    UICurrentFtypeEntry->act_deriv_func = (ActDerivFuncPtr) act_deriv_func_ptr;
+    UICurrentFtypeEntry->act_2_deriv_func = 
+	(ActDerivFuncPtr) act_2_deriv_func_ptr;
+
+    kr_changeFtypeUnits( UICurrentFtypeEntry );
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFTypeOutFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the output function in the current
+             FType entry
+  UPDATE   :
+******************************************************************************/
+
+char  *krui_getFTypeOutFuncName(void)
+{
+    static char  out_func_name[FUNCTION_NAME_MAX_LEN];
+
+    if (UICurrentFtypeEntry == NULL)
+        return( NULL );
+
+    strcpy( out_func_name, 
+	    krf_getFuncName( (FunctionPtr) UICurrentFtypeEntry->out_func ) );
+
+    return( out_func_name );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFTypeOutFunc
+
+  PURPOSE  : Sets the output function in the current FType entry
+  NOTES    : All units (in the existing network) of the current Ftype changes
+             their output function.
+
+  RETURNS  : Returns 0, if the function is a valid output function,
+             error code otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_setFTypeOutFunc(char *out_func_name)
+{
+    FunctionPtr  out_func_ptr;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if (UICurrentFtypeEntry == NULL)
+        {   /*  Current Ftype entry isn't defined   */
+            KernelErrorCode = KRERR_FTYPE_ENTRY;
+            return( KernelErrorCode );
+        }
+
+    if ( !krf_funcSearch( out_func_name, OUT_FUNC, &out_func_ptr ) )
+        return( KernelErrorCode );
+
+    UICurrentFtypeEntry->out_func = (OutFuncPtr) out_func_ptr;
+
+    kr_changeFtypeUnits( UICurrentFtypeEntry );
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFirstFTypeSite
+
+  PURPOSE  : Initializes the first site of the current FType.
+  NOTES    :
+
+  RETURNS  : Returns FALSE, if no sites are available in the current
+             FType entry.
+  UPDATE   :
+******************************************************************************/
+bool  krui_setFirstFTypeSite(void)
+{
+
+    if (UICurrentFtypeEntry == NULL)  {
+        UICurrentFtypeSite = NULL;
+        return( FALSE );
+    }
+
+    if (UICurrentFtypeEntry->sites == NULL)  {
+        UICurrentFtypeSite = NULL;
+        return( FALSE );
+    } else {
+        UICurrentFtypeSite = UICurrentFtypeEntry->sites;
+        return( TRUE );
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setNextFTypeSite
+
+  PURPOSE  : Initializes the next FType site.
+  NOTES    :
+
+  RETURNS  : Returns FALSE, if no more sites are available in the current
+             FType entry.
+  UPDATE   :
+******************************************************************************/
+bool  krui_setNextFTypeSite(void)
+{
+
+    if (UICurrentFtypeSite == NULL)
+        return( FALSE );
+
+    if (UICurrentFtypeSite->next == NULL)
+        return( FALSE );
+
+    UICurrentFtypeSite = UICurrentFtypeSite->next;
+    return( TRUE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFTypeSiteName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the current FType site (in the current
+             Ftype entry).
+  UPDATE   :
+******************************************************************************/
+char  *krui_getFTypeSiteName(void)
+{
+
+    if (UICurrentFtypeSite == NULL)
+        return( NULL );
+
+    return( ((UICurrentFtypeSite->site_table)->Entry.site_name)->Entry.symbol );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFTypeSiteName
+
+  PURPOSE  : Sets the name and function of the current FType site (in the
+             current FType entry).
+             All sites (in the existing network) of the current Ftype and the
+             same (old) name changes their names and site functions.
+
+  NOTES    :
+
+  RETURNS  : Returns an error code if
+             - current Ftype site isn't defined
+             - site name does not exist in the site name table
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setFTypeSiteName(char *FType_site_name)
+{
+    struct  SiteTable     *stbl_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if (UICurrentFtypeEntry == NULL)
+        {                       /*  Current Ftype entry isn't defined   */
+            KernelErrorCode = KRERR_FTYPE_ENTRY;
+            return( KernelErrorCode );
+        }
+
+    if (!kr_symbolCheck( FType_site_name ))
+        return( KernelErrorCode );
+
+    if ( (stbl_ptr = krm_STableSymbolSearch( FType_site_name )) == NULL)
+        {                       /*   site name isn't defined */
+            KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+            return( KernelErrorCode );
+        }
+
+    kr_changeFtypeSites( UICurrentFtypeEntry, UICurrentFtypeSite->site_table, 
+			 stbl_ptr);
+    UICurrentFtypeSite->site_table = stbl_ptr;
+
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createFTypeEntry
+
+  PURPOSE  : Create a new functionality type, needs a definite FType symbol,
+             the unit output and activation function
+             and the number of sites provided for this unit FType.
+             An additional array with N elements of pointers to site names
+             is required for the definition of the sites.
+  NOTES    : The number of Ftype entries and the number of sites per Ftype is
+             only limited by the size of system memory.
+
+  RETURNS  : Returns error code if:
+             - memory allocation fails
+             - FType name isn't definite (symbol is used for another FType
+               or symbol is a NULL pointer)
+             - one or more site names are undefined
+
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_createFTypeEntry(char *Ftype_symbol, char *act_func_name, 
+				char *out_func_name, int no_of_sites, 
+				char **array_of_site_names)
+{
+    FunctionPtr act_func, out_func, act_deriv_func, act_2_deriv_func;
+    struct  FtypeUnitStruct   *Ftype_entry;
+    struct  SiteTable         *STable_entry;
+    int       i;
+    char      *Ftype_site_name;
+
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    if (Ftype_symbol == NULL)
+    {   /*  Ftype name isn't defined   */
+        KernelErrorCode = KRERR_FTYPE_NAME;
+        return( KernelErrorCode );
+    }
+
+    if (!kr_symbolCheck( Ftype_symbol ))
+        return( KernelErrorCode );
+    if (krm_NTableSymbolSearch( Ftype_symbol, FTYPE_UNIT_SYM ) != NULL)
+        return( KernelErrorCode );
+    if ( !krf_funcSearch( out_func_name, OUT_FUNC, &out_func ) )
+        return( KernelErrorCode );
+    if ( !krf_funcSearch( act_func_name, ACT_FUNC, &act_func ) )
+        return( KernelErrorCode );
+    /*  set the derivation function of the activation function  */
+    if ( !krf_funcSearch( act_func_name, ACT_DERIV_FUNC, &act_deriv_func ))
+        return( KernelErrorCode );
+    /*  set the second derivation function of the activation function  */
+    if ( !krf_funcSearch( act_func_name, ACT_2_DERIV_FUNC, &act_2_deriv_func ))
+	return( KernelErrorCode );
+
+    if ((Ftype_entry = krm_FtypeCreateEntry( Ftype_symbol
+                                            ,(OutFuncPtr) out_func
+                                            ,(ActFuncPtr) act_func
+                                            ,(ActDerivFuncPtr) act_deriv_func
+                                            ,(ActDerivFuncPtr) act_2_deriv_func
+                                            )) == NULL)
+        return( KernelErrorCode );
+
+    /*  create sites at the Ftype  */
+    for (i = 0; i < no_of_sites; i++)  {
+        if ( (Ftype_site_name = array_of_site_names[ i ]) == NULL){
+	    /*   site name isn't defined because it is a NULL pointer  */
+	    KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+	    return( KernelErrorCode );
+	}
+
+        if ((STable_entry = krm_STableSymbolSearch( Ftype_site_name )) == NULL){
+	    /*  site isn't defined  */
+	    krm_releaseFtypeEntry( Ftype_entry );
+	    KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+	    return( KernelErrorCode );
+	}
+
+        if (krm_FtypeAddSite( Ftype_entry , STable_entry ) == NULL){
+	    /*  memory alloc failed */
+	    krm_releaseFtypeEntry( Ftype_entry );
+	    return( KernelErrorCode );
+	}
+    }
+
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteFTypeEntry
+
+  PURPOSE  : Deletes the specified FType entry. If there exists units in the
+             network with this FType, all these units will lost their FType
+             but the functionality of the units will not be changed.
+  NOTES    :
+
+  RETURNS  : Returns error code if FType symbol dosn't exist, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err    krui_deleteFTypeEntry(char *Ftype_symbol)
+{
+    struct  FtypeUnitStruct   *ftype_ptr;
+
+    if ( (ftype_ptr = krm_FtypeSymbolSearch( Ftype_symbol ) ) == NULL)
+        return( KRERR_FTYPE_SYMBOL ); /*  FType symbol isn't defined  */
+
+    kr_deleteUnitsFtype( ftype_ptr );
+    krm_releaseFtypeEntry( ftype_ptr );
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*############################################################################
+
+GROUP: Functions for reading of the function table
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfFunctions
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the number of available functions
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfFunctions(void)
+{
+    return( krf_getNoOfFuncs() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFuncInfo
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the function and the function type (Output,
+             Activation, Site).
+  UPDATE   :
+******************************************************************************/
+void  krui_getFuncInfo(int func_no, char **func_name, int *func_type)
+{
+    static struct FuncInfoDescriptor  functionDescr;
+    functionDescr.number = func_no - 1;
+    KernelErrorCode = krf_getFuncInfo( GET_FUNC_INFO, &functionDescr );
+
+    *func_type = functionDescr.func_type;
+    *func_name = functionDescr.func_name;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_isFunction
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns true if the given function name and type exists.
+  UPDATE   :
+******************************************************************************/
+bool  krui_isFunction(char *func_name, int func_type)
+{
+    FunctionPtr  dummy_func_ptr;
+    bool        is_func;
+
+    is_func = krf_funcSearch( func_name, func_type, &dummy_func_ptr );
+    KernelErrorCode = KRERR_NO_ERROR;
+    return( is_func );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFuncParamInfo
+
+  PURPOSE  : Returns the no. of input and output parameters of the given
+             function (only relevant for learning, update and initialisation
+             functions).
+  NOTES    :
+
+  RETURNS  : Returns TRUE if the given function exists, FALSE otherwise.
+  UPDATE   :
+******************************************************************************/
+bool  krui_getFuncParamInfo(char *func_name, int func_type, 
+			    int *no_of_input_params, int *no_of_output_params)
+{
+    static struct FuncInfoDescriptor  functionDescr;
+
+    functionDescr.func_type = func_type;
+    strcpy( functionDescr.func_name, func_name );
+
+    KernelErrorCode = krf_getFuncInfo( SEARCH_FUNC, &functionDescr );
+
+    if (KernelErrorCode != KRERR_NO_ERROR)  return( FALSE );
+
+    *no_of_input_params = functionDescr.no_of_input_parameters;
+    *no_of_output_params = functionDescr.no_of_output_parameters;
+    return( TRUE );
+}
+
+
+
+/*############################################################################
+
+GROUP: Site Table Functions
+
+#############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstSiteTableEntry
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the first site name/function pair in the site table.
+             Returns FALSE and NULL, if not available.
+  UPDATE   :
+******************************************************************************/
+bool   krui_getFirstSiteTableEntry(char **site_name, char **site_func)
+{
+    struct  SiteTable   *s_ptr;
+
+    if ( (s_ptr = krm_getSTableFirstEntry() ) == NULL) {
+	*site_name = NULL;
+	*site_func = NULL;
+	return( FALSE );
+    } else {
+	*site_name = (s_ptr->Entry.site_name)->Entry.symbol;
+	*site_func = krf_getFuncName( (FunctionPtr) s_ptr->site_func );
+	return( TRUE );
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNextSiteTableEntry
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the next site name/function pair in the site table.
+             Returns FALSE and NULL, if not available.
+  UPDATE   :
+******************************************************************************/
+bool  krui_getNextSiteTableEntry(char **site_name, char **site_func)
+{
+    struct  SiteTable   *s_ptr;
+
+    if ( (s_ptr = krm_getSTableNextEntry() ) == NULL) {
+	*site_name = NULL;
+	*site_func = NULL;
+	return( FALSE );
+    } else {
+	*site_name = (s_ptr->Entry.site_name)->Entry.symbol;
+	*site_func = krf_getFuncName( (FunctionPtr) s_ptr->site_func );
+	return( TRUE );
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getSiteTableFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the site function that is associated with
+             the site name.
+             If the site name do not exist, function returns NULL.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getSiteTableFuncName(char *site_name)
+{
+    struct SiteTable  *s_ptr;
+
+    if ( (s_ptr = krm_STableSymbolSearch( site_name )) == NULL)
+        return( NULL );
+
+    return( krf_getFuncName( (FunctionPtr) s_ptr->site_func ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createSiteTableEntry
+
+  PURPOSE  : Creates a new site name and associate this name with a site
+             function.
+  NOTES    :
+
+  RETURNS  : Returns error code if:
+             - site name already exists or
+             - site function is invalid or
+             - memory allocation has failed
+            0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_createSiteTableEntry(char *site_name, char *site_func)
+{
+    FunctionPtr   func_ptr;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if ( !krf_funcSearch( site_func, SITE_FUNC, &func_ptr ) )
+        return( KernelErrorCode );
+    if (!kr_symbolCheck( site_name ))
+        return( KernelErrorCode );
+    if (krm_STableSymbolSearch( site_name ) != NULL) {
+	/*  symbol is already in the site table */
+	KernelErrorCode = KRERR_REDEF_SITE_NAME;
+	return( KernelErrorCode );
+    }
+
+    (void) krm_STableCreateEntry( site_name, (SiteFuncPtr) func_ptr );
+
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_changeSiteTableEntry
+
+  PURPOSE  : Changes the site function of a previously defined site name.
+  NOTES    : All sites in the network with the name <old_site_name>
+             changes their names and functions.
+
+  RETURNS  : Returns error code if <old_site_name> or <new_site_func>
+             isn't defined, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_changeSiteTableEntry(char *old_site_name, char *new_site_name, 
+				    char *new_site_func)
+{
+    FunctionPtr   func_ptr;
+    SiteFuncPtr     site_func_ptr;
+    struct SiteTable  *stbl_ptr1,
+    *stbl_ptr2;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if (!kr_symbolCheck( new_site_name ))
+        return( KernelErrorCode );
+    if ( !krf_funcSearch( new_site_func, SITE_FUNC, &func_ptr ) )
+        return( KernelErrorCode );
+
+    site_func_ptr = (SiteFuncPtr) func_ptr;
+
+    if ( (stbl_ptr1 = krm_STableSymbolSearch( old_site_name )) == NULL) {
+        /*  old site name isn't defined */
+        KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+        return( KernelErrorCode );
+    }
+
+    stbl_ptr2 = krm_STableSymbolSearch( new_site_name );
+    if ( (stbl_ptr2 != NULL) && (stbl_ptr2 != stbl_ptr1) ){
+        /*  new symbol is already in the site table (and new_site_name and
+            old_site_name are not identical) */
+        KernelErrorCode = KRERR_REDEF_SITE_NAME;
+        return( KernelErrorCode );
+    }
+
+    (void) krm_STableChangeEntry( stbl_ptr1 , new_site_name , site_func_ptr );
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteSiteTableEntry
+
+  PURPOSE  : Removes the current site name entry from the site table.
+  NOTES    :
+
+  RETURNS  : Returns an error code if
+             - there exists sites with the given name in the network or
+             - <site_name> isn't defined
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteSiteTableEntry(char *site_name)
+{
+    struct SiteTable    *st_ptr;
+
+    if ((st_ptr = krm_STableSymbolSearch( site_name )) == NULL)
+        return( KRERR_UNDEF_SITE_NAME ); /*  Site name isn't defined */
+
+    if (kr_searchNetSite( st_ptr ) != 0)
+        return( KRERR_INUSE_SITE ); /* Site is in use and must not be deleted */
+
+    krm_STableRemoveEntry( st_ptr );
+    return( KRERR_NO_ERROR );
+}
+
+
+/*############################################################################
+
+GROUP: Site Functions
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFirstSite
+
+  PURPOSE  : Initializes the first site at the current unit.
+  NOTES    :
+
+  RETURNS  : Returns false if no site available or if no sites permitted at 
+             this unit.
+  UPDATE   :
+******************************************************************************/
+bool  krui_setFirstSite(void)
+{
+    if KERNEL_STANDARD
+        return( kr_setSite( FIRST, NULL ) );
+
+    KernelErrorCode = KRERR_SITES_NO_SUPPORT;
+    return( FALSE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setNextSite
+
+  PURPOSE  : Initializes the next site at the current unit.
+  NOTES    :
+
+  RETURNS  : Returns false if no more sites available.
+  UPDATE   :
+******************************************************************************/
+bool  krui_setNextSite(void)
+{
+    if KERNEL_STANDARD
+        return( kr_setSite( NEXT, NULL ) );
+
+    KernelErrorCode = KRERR_SITES_NO_SUPPORT;
+    return( FALSE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setSite
+
+  PURPOSE  : Initializes the given site at the current unit.
+  NOTES    :
+
+  RETURNS  : Returns error code if
+             - unit dosn't exist
+             - site name doesn't exist
+             - unit don't has sites
+             - unit don't has a site with this name
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setSite(char *site_name)
+{
+
+    if KERNEL_STANDARD
+        return( kr_setSite( NAME, site_name ) );
+
+    KernelErrorCode = KRERR_SITES_NO_SUPPORT;
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getSiteValue
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the actual value of the current site
+  UPDATE   :
+******************************************************************************/
+FlintType   krui_getSiteValue(void)
+{
+
+    if KERNEL_STANDARD  {
+        if (sitePtr == NULL)
+            KernelErrorCode = KRERR_NO_SITES;
+        else
+            return( (*sitePtr->site_table->site_func) (sitePtr) );
+    }else
+        KernelErrorCode = KRERR_SITES_NO_SUPPORT;
+
+    return( (FlintType) 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getSiteName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : returns the name of the current unit/site,
+             NULL if not available.
+  UPDATE   :
+******************************************************************************/
+char  *krui_getSiteName(void)
+{
+
+    if KERNEL_STANDARD    {
+        if (sitePtr == NULL)
+            KernelErrorCode = KRERR_NO_SITES;
+        else
+            return( ((sitePtr->site_table)->Entry.site_name)->Entry.symbol );
+    }else
+        KernelErrorCode = KRERR_SITES_NO_SUPPORT;
+
+    return( NULL );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setSiteName
+
+  PURPOSE  : Sets the name/function of the current unit/site.
+             Current Unit will loose the functionality type.
+  NOTES    :
+
+  RETURNS  : Returns error code if site name isn't defined.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setSiteName(char *site_name)
+{
+    struct  SiteTable     *stbl_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if (sitePtr == NULL) {
+	KernelErrorCode = KRERR_FTYPE_SITE;
+	return( KernelErrorCode );
+    }
+
+    if (!kr_symbolCheck( site_name ))
+        return( KernelErrorCode );
+    if ((stbl_ptr = krm_STableSymbolSearch( site_name )) == NULL){
+	/*   site name isn't defined */
+	KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+	return( KernelErrorCode );
+    }
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    unitPtr->Ftype_entry = NULL;
+    sitePtr->site_table  = stbl_ptr;
+
+    NetModified = TRUE;
+
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getSiteFuncName
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the name of the current unit/site function
+  UPDATE   :
+******************************************************************************/
+char  *krui_getSiteFuncName(void)
+{
+    static char  site_func_name[FUNCTION_NAME_MAX_LEN];
+
+    if (sitePtr == NULL){
+        KernelErrorCode = KRERR_FTYPE_SITE;
+        return( NULL );
+    }
+
+    strcpy( site_func_name, 
+	    krf_getFuncName( (FunctionPtr) sitePtr->site_table->site_func ) );
+
+    return( site_func_name );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_addSite
+
+  PURPOSE  : Adds a site at the current unit. If the unit has already sites, 
+             this new site will be inserted above all other sites, i.e. the 
+	     new created site will be the first site at this unit.
+             If the unit has direct input links, i.e the unit has input links
+             but no sites, the creation of sites is not permitted 
+	     (krui_addSite will return an error code).
+             If there exists already a site with the given name, the creation 
+	     of the new site is prohibited and krui_addSite returns an error 
+	     code.
+             krui_addSite has no effect on the current site. To change the 
+	     current site to this new site, call krui_setFirstSite().
+             The unit's FType will be deleted.
+  NOTES    : The number of sites per unit is nearly unlimited (2^32).
+
+  RETURNS  : Returns error code if
+             - memory allocation fails or
+             - unit has direct input links or
+             - site name isn't defined or
+             - site with the given name exists already at this unit
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_addSite(char *site_name)
+{
+    FlagWord    flags;
+    struct Site       *site_ptr,
+    *site_ptr1;
+    struct SiteTable  *stbl_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    if ( (stbl_ptr = krm_STableSymbolSearch( site_name )) == NULL)
+        {                       /*  site name isn't defined */
+            KernelErrorCode = KRERR_UNDEF_SITE_NAME;
+            return( KernelErrorCode );
+        }
+
+    flags = unitPtr->flags & UFLAG_INPUT_PAT;
+
+    switch (flags){
+    case UFLAG_NO_INP :
+	/*  Unit has no inputs  */
+	if ((site_ptr = kr_createDefaultSite() ) == NULL)
+	    return( KernelErrorCode );
+
+	unitPtr->sites = site_ptr; /*  Connect site    */
+	unitPtr->flags |= UFLAG_SITES; /*  Set site flag   */
+	unitPtr->Ftype_entry = NULL; /*  Delete Ftype    */
+
+	break;
+
+    case UFLAG_SITES :
+	/*  Unit has already sites  */
+	if (kr_searchUnitSite( unitPtr, stbl_ptr ) != NULL){
+	    /* there exists already a site with this name at this unit */
+	    KernelErrorCode = KRERR_DUPLICATED_SITE;
+	    return( KernelErrorCode );
+	}
+
+	if ( (site_ptr = kr_createDefaultSite() ) == NULL)
+	    return( KernelErrorCode );
+
+	site_ptr1 = unitPtr->sites;
+	unitPtr->sites = site_ptr; /*  Connect site    */
+	site_ptr->next = site_ptr1;
+	unitPtr->Ftype_entry = NULL; /*  Delete Ftype    */
+
+	break;
+
+    case UFLAG_DLINKS :
+	/*  Unit has direct input links and can't have sites */
+	KernelErrorCode = KRERR_CREATE_SITE;
+	return( KernelErrorCode );
+
+    default :
+	KernelErrorCode = KRERR_CREATE_SITE;
+	return( KernelErrorCode );
+    }
+
+    site_ptr->site_table = stbl_ptr;
+
+    NetModified = TRUE;
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteSite
+
+  PURPOSE  : Removes the current site at the current unit and removes all
+             links from predecessor units to this site.
+             krui_setFirstSite (krui_setNextSite) must be called at least once
+             before using this function.
+             The current site will be set to the next available site, if no more
+             sites available, krui_deleteSite returns 0 otherwise 1.
+             Returns an error code if ther was a problem.
+             The unit's FType will be set to 0, i.e. the unit's functionality
+             type will be deleted.
+
+  NOTES    : To delete all sites at a unit:
+               if ( krui_setFirstSite() )
+                   while ( krui_deleteSite() > 0) { }
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_deleteSite(void)
+{
+    struct Site   *next_site_ptr;
+    struct Unit   *unit_ptr;
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    unit_ptr = unitPtr;
+
+    if ( UNIT_HAS_SITES( unit_ptr ) && (unit_ptr->sites != NULL) &&
+	 (sitePtr != NULL) ){
+	/*  Unit has sites  */
+	NetModified = TRUE;
+
+	next_site_ptr = sitePtr->next;
+
+	krm_releaseAllLinks( sitePtr->links ); /*   Remove links    */
+	krm_releaseSite( sitePtr ); /*      Remove site     */
+
+	if (prevSitePtr == NULL){
+	    /*  This site is the first site at the current unit */
+
+	    if (next_site_ptr == NULL){
+		/*  Unit has only this site */
+		unit_ptr->sites = NULL; /*  Clear site pointer  */
+		unit_ptr->flags &= (~UFLAG_INPUT_PAT); /* Clear input flags */
+		sitePtr     = NULL; /*  No more sites available  */
+		prevSitePtr = NULL;
+	    } else {
+		/*  It is the first site at the unit but not the only one   */
+		unit_ptr->sites  = next_site_ptr; /*  Connect the other sites */
+		sitePtr = next_site_ptr; 
+	    }
+	} else {
+	    /*  This is not the first site at the unit  */
+	    prevSitePtr->next = next_site_ptr; /*  Connect the previous site
+						   with the next site  */
+	    sitePtr = next_site_ptr; 
+	}
+
+	unit_ptr->Ftype_entry = NULL; /*  Delete unit's Ftype */
+    }
+
+    if (sitePtr != NULL)
+        return( TRUE );         /*  Returns TRUE if more sites available  */
+    else
+        return( FALSE );
+}
+
+
+/*############################################################################
+
+GROUP: Link Functions
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstPredUnit
+
+  PURPOSE  :
+  NOTES    : If a predecessor unit exists, the current link is set to the link
+             between the two units.
+
+  RETURNS  : Returns the no. of first predecessor unit of the current unit/site
+             and the connection strenght.
+             Returns 0 if no predecessor unit available, i.e. if the current 
+	     unit and/or site has no inputs.
+  UPDATE   :
+******************************************************************************/
+int  krui_getFirstPredUnit(FlintType *strength)
+{
+  float dummy1,dummy2,dummy3;
+
+
+    if KERNEL_STANDARD  {
+        return(kr_getPredecessorUnit(FIRST, strength ,&dummy1,&dummy2,&dummy3));
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getPredecessorUnit( FIRST, strength ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstPredUnitAndData
+
+  PURPOSE  :
+  NOTES    : If a predecessor unit exists, the current link is set to the link
+             between the two units.
+
+  RETURNS  : Returns the no. of first predecessor unit of the current unit/site
+             and the connection strenght.
+             Returns 0 if no predecessor unit available, i.e. if the current 
+	     unit and/or site has no inputs.
+  UPDATE   :
+******************************************************************************/
+int  krui_getFirstPredUnitAndData(FlintType *strength,float *val_a,
+				  float *val_b, float *val_c)
+{
+    if KERNEL_STANDARD  {
+        return( kr_getPredecessorUnit( FIRST, strength ,val_a ,val_b ,val_c ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getPredecessorUnit( FIRST, strength ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNextPredUnit
+
+  PURPOSE  : Returns the number of the next logical predecessor unit in a TDNN
+  NOTES    : If another predecessor unit exists, the current link is set to
+             the link between the two units.
+
+
+  RETURNS  : Returns the no. of the next predecessor unit of the current
+             unit/site and the connection strenght.
+             Returns 0 if no more predecessor units exists.
+  UPDATE   :
+******************************************************************************/
+int  krui_getNextPredUnit(FlintType *strength)
+{
+    float dummy1,dummy2,dummy3;
+
+    if KERNEL_STANDARD  {
+        return(kr_getPredecessorUnit(NEXT, strength ,&dummy1,&dummy2,&dummy3));
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getPredecessorUnit( NEXT, strength ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNextPredUnitAndData
+
+  PURPOSE  : Returns the number of the next logical predecessor unit in a TDNN
+  NOTES    : If another predecessor unit exists, the current link is set to
+             the link between the two units.
+
+
+  RETURNS  : Returns the no. of the next predecessor unit of the current
+             unit/site and the connection strenght.
+             Returns 0 if no more predecessor units exists.
+  UPDATE   :
+******************************************************************************/
+int  krui_getNextPredUnitAndData(FlintType *strength,float *val_a,
+				 float *val_b, float *val_c)
+{
+
+    if KERNEL_STANDARD  {
+        return(kr_getPredecessorUnit( NEXT, strength, val_a, val_b, val_c ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getPredecessorUnit( NEXT, strength ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getCurrentPredUnit
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the no. of the current predecessor unit (of the current
+             unit/site) and the connection strenght.
+             Returns 0 if no predecessor unit available, i.e. if the current 
+	     unit and/or site has no inputs
+  UPDATE   :
+******************************************************************************/
+int  krui_getCurrentPredUnit(FlintType *strength)
+{
+    float dummy1,dummy2,dummy3;
+
+    if KERNEL_STANDARD  {
+        return(kr_getPredecessorUnit(CURRENT, strength, &dummy1, &dummy2, 
+				     &dummy3 ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getPredecessorUnit( CURRENT, strength ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstSuccUnit
+
+  PURPOSE  :
+  NOTES    : This function is slow (Units are backward chained only).
+  IMPORTANT: If a successor unit exists, the current unit and site will be
+             set to this successor unit and the attached site.
+
+  RETURNS  : Returns the no. of the first successor unit of the unit 
+             <source_unit_no> and the connection strenght.
+             Returns (negative) error code if unit doesn't exist.
+             Returns 0 if no successor unit available, i.e. if the given unit
+             has no output connection.
+  UPDATE   :
+******************************************************************************/
+int  krui_getFirstSuccUnit(int source_unit_no, FlintType *weight)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_getSuccessorUnit( FIRST, source_unit_no, weight ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getSuccessorUnit( FIRST, source_unit_no, weight ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNextSuccUnit
+
+  PURPOSE  :
+  NOTES    : This function is slow  (Units are backward chained only)
+  IMPORTANT: If a successor unit exists, the current unit and site will be
+             set to this successor unit and the attached site.
+
+  RETURNS  : Returns the no. of the next successor unit and the connection 
+             strenght.
+  UPDATE   :
+******************************************************************************/
+int  krui_getNextSuccUnit(FlintType *weight)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_getSuccessorUnit( NEXT, 0, weight ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getSuccessorUnit( NEXT, 0, weight ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_areConnected
+
+  PURPOSE  : True if there exists a connection between source unit 
+             <source_unit_no> and target unit <target_unit_no>, otherwise false.
+  NOTES    : This function is slow (Units are backward chained only).
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_areConnected(int sourceNo, int targetNo)
+{
+    register struct Link *link_ptr ;
+    register struct Unit *s_unit_ptr, *t_unit_ptr ;
+    register struct Site *site_ptr ;
+
+    s_unit_ptr = kr_getUnitPtr (sourceNo) ;
+    t_unit_ptr = kr_getUnitPtr (targetNo) ;
+
+    if( UNIT_HAS_DIRECT_INPUTS (t_unit_ptr)){
+        for (link_ptr = (struct Link *) t_unit_ptr->sites;
+             link_ptr != NULL; link_ptr = link_ptr->next)
+            if (link_ptr->to == s_unit_ptr) 
+		return (TRUE) ;
+    }else if( UNIT_HAS_SITES (t_unit_ptr)){
+	for (site_ptr = t_unit_ptr->sites; site_ptr != NULL ;
+	     site_ptr = site_ptr->next)
+	    for (link_ptr = site_ptr->links; link_ptr != NULL ;
+		 link_ptr = link_ptr->next)
+		if (link_ptr->to == s_unit_ptr) 
+		    return (TRUE) ;
+    }
+
+    return (FALSE) ;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_areConnectedWeight
+
+  PURPOSE  : True if there exists a connection between source unit 
+             <source_unit_no> and target unit <target_unit_no>, otherwise 
+	     false. If there exist a connection between these units, 
+	     krui_areConnectedWeight returns the connection strength also.
+             Returns FALSE if unit doesn't exist.
+  NOTES    : This function is slow (Units are backward chained only).
+  IMPORTANT: If there exist a connection, the current unit and site will be
+             set to the target unit/site.
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_areConnectedWeight(int source_unit_no, int target_unit_no, 
+			      FlintType *weight)
+{
+    if KERNEL_STANDARD  {
+        return( kr_areConnected( source_unit_no, target_unit_no, weight ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_areConnected( source_unit_no, target_unit_no, weight ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( FALSE );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_isConnected
+
+  PURPOSE  : True if there exists a connection between source unit 
+             <source_unit_no> and the current unit/site, otherwise false.
+  NOTES    : If there exists a connection between the two units, the current 
+             link is set to the link between the two units. (alter the link 
+	     weight with krui_setLinkWeight)
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_isConnected(int source_unit_no)
+{
+    FlintType  weight;
+
+    if KERNEL_STANDARD  {
+        return( kr_isConnected( source_unit_no, &weight ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_isConnected( source_unit_no, &weight ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( FALSE );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getLinkWeight
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the link weight of the current link.
+  UPDATE   :
+******************************************************************************/
+FlintType  krui_getLinkWeight(void)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_getLinkWeight() );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_getLinkWeight() );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( 0.0 );
+#endif
+
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setLinkWeight
+
+  PURPOSE  : Sets the link weight of the current link
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_setLinkWeight(FlintTypeParam weight)
+{
+
+    if KERNEL_STANDARD  {
+        kr_setLinkWeight( weight );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        krff_setLinkWeight( weight );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createLink
+
+  PURPOSE  : Creates a link between source unit and the current unit/site.
+  NOTES    : krui_createLink DO NOT set the current link.
+             If you want to create a link and its unknown if there exists 
+	     already a connection between the two units, use krui_createLink 
+	     and test the return code, instead of the sequence 
+	     krui_isConnected and krui_createLink.
+  RETURNS  : Returns an error code:
+             - if memory allocation fails
+             - if source unit doesn't exist or
+             - if there exists already a connection between current unit/site 
+	       and the source unit
+             0 otherwise.
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_createLink(int source_unit_no, FlintTypeParam weight)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_createLink( source_unit_no, weight ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        return( krff_createLink( source_unit_no, weight ) );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( KernelErrorCode );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_createLinkWithAdditionalParameters
+
+  PURPOSE  : Creates a link between source unit and the current unit/site.
+  NOTES    : krui_createLink DO NOT set the current link.
+             If you want to create a link and its unknown if there exists 
+	     already a connection between the two units, use krui_createLink 
+	     and test the return code, instead of the sequence 
+	     krui_isConnected and krui_createLink.
+  RETURNS  : Returns pointer to new unit.
+
+  UPDATE   : 13.05.96 <Juergen Gatter>
+******************************************************************************/
+struct Link*  krui_createLinkWithAdditionalParameters(int source_unit_no, 
+						      FlintTypeParam weight,
+						      float val_a, float val_b,
+						      float val_c)
+{
+
+    if KERNEL_STANDARD  {
+        return( kr_createLinkWithAdditionalParameters(source_unit_no, weight, 
+						      val_a, val_b, val_c ) );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        KernelErrorCode=krff_createLink( source_unit_no, weight ) 
+        return( NULL );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+        return( NULL );
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteLink
+
+  PURPOSE  : Deletes the current link.
+  NOTES    : To delete a link between the current unit/site and the source unit
+             <source_unit_no>, call krui_isConnected( source_unit_no ) and
+             krui_deleteLink().
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteLink(void)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    return( kr_deleteLink() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteAllInputLinks
+
+  PURPOSE  : Deletes all input links at current unit/site.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteAllInputLinks(void)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    return( kr_deleteAllLinks( INPUTS ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteAllOutputLinks
+
+  PURPOSE  : Deletes all output links at current unit.
+  NOTES    : This function is slow.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deleteAllOutputLinks(void)
+{
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    return( kr_deleteAllLinks( OUTPUTS ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_jogWeights
+
+  PURPOSE  : Add uniform distributed random values to connection weights.
+             <minus> must be less then <plus>.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_jogWeights(FlintTypeParam minus, FlintTypeParam plus)
+{
+
+    if (minus >= plus)  {
+        KernelErrorCode = KRERR_PARAMETERS;
+        return; 
+    }
+
+    if KERNEL_STANDARD  {
+        kr_jogWeights( minus, plus );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        krff_jogWeights( minus, plus );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+#endif
+
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_jogCorrWeights
+
+  PURPOSE  : Add uniform distributed random values to connection weights of
+             highly correlated, non-special hidden units.
+             <minus> must be less then <plus>.
+	     The two hidden units with maximum positive or negative correlation 
+	     with an absolute value higher then mincorr are searched. The 
+	     incoming weights of one of these units are jogged.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus,
+			      FlintTypeParam mincorr)
+{
+    krui_err res = KRERR_NO_ERROR;
+
+    if (minus >= plus)  {
+        KernelErrorCode = KRERR_PARAMETERS;
+        return KernelErrorCode;  
+    }
+
+    if KERNEL_STANDARD  {
+        res = kr_jogCorrWeights( minus, plus, mincorr );
+    } else {
+
+#ifdef MASPAR_KERNEL
+        krff_jogCorrWeights( minus, plus, mincorr );
+#else
+        KernelErrorCode = KRERR_NO_MASPAR_KERNEL;
+#endif
+
+    }
+    return res;
+}
+
+
+/*###########################################################################
+
+GROUP: Functions for network propagation
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getVariance
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Variance
+
+******************************************************************************/
+float krui_getVariance (void)
+{
+    register struct Unit   *unit_ptr;
+    int   pattern_no=0, o, noOfOutputUnits, size, noOfPatternPairs, sub_pat_no;
+    Patterns  out_pat;
+    register float *OutputUnitSumVariance, *OutputUnitVariance,Variance=0;
+
+    noOfOutputUnits=krui_getNoOfOutputUnits();
+    noOfPatternPairs=kr_np_pattern( PATTERN_GET_NUMBER,0, 0 );
+    OutputUnitVariance = (float *)calloc(noOfOutputUnits,sizeof (float));
+    OutputUnitSumVariance = (float *)calloc(noOfOutputUnits,sizeof (float));
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    KernelErrorCode = kr_initSubPatternOrder(0,kr_np_pattern(PATTERN_GET_NUMBER,
+							     0, 0) - 1);
+    if(KernelErrorCode != KRERR_NO_ERROR) {
+	free (OutputUnitSumVariance);
+	free (OutputUnitVariance);
+	return (KernelErrorCode);
+    }
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+	out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+	if(out_pat == NULL){
+	    KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	    free (OutputUnitSumVariance);
+	    free (OutputUnitVariance);
+	    return(-1);
+	}
+	out_pat += size;
+	o=0;
+	FOR_ALL_UNITS( unit_ptr )
+	    if (IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))  {
+		--out_pat;
+		OutputUnitVariance[o] += (*out_pat) * (*out_pat);
+		OutputUnitSumVariance [o] += *out_pat;
+		o++;
+	    }
+    }
+    o=0;
+    FOR_ALL_UNITS( unit_ptr )
+	if (IS_OUTPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))  {
+	    Variance += (OutputUnitVariance[o]/noOfPatternPairs)-
+		pow(OutputUnitSumVariance[o]/noOfPatternPairs,2) ;
+	    o++;
+	}
+    free (OutputUnitSumVariance);
+    free (OutputUnitVariance);
+    return(Variance);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_countLinks
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Number of Parameters
+  UPDATE   :
+******************************************************************************/
+int krui_countLinks(void)
+{
+  register struct Unit   *unit_ptr;
+  register struct Link   *link_ptr;
+  register int i=0;
+
+  FOR_ALL_UNITS( unit_ptr )
+    if ((IS_OUTPUT_UNIT(unit_ptr) || IS_HIDDEN_UNIT(unit_ptr))) {
+      i++;
+      FOR_ALL_LINKS (unit_ptr,link_ptr)
+        i ++;
+    }
+  return i;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_updateSingleUnit
+
+  PURPOSE  : Updates a single unit.
+  NOTES    : Updates also frozen Units.
+
+  RETURNS  : Returns error code if unit doesn't exist, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_updateSingleUnit(int unit_no)
+{
+    register struct Unit   *unit_ptr;
+
+
+#ifdef MASPAR_KERNEL
+    MASPAR_FF1_VALIDATE_OP;
+#endif
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    if (unit_ptr->out_func == NULL)
+        /*  Identity Function   */
+        unit_ptr->Out.output = unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+    else{
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+	unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUpdateFunc
+
+  PURPOSE  : Returns the current update function. The default update function is
+             SerialOrder() (see also kr_def.h).
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char  *krui_getUpdateFunc(void)
+{
+    static char  updateFunc[FUNCTION_NAME_MAX_LEN];
+
+    strcpy( updateFunc, krf_getCurrentNetworkFunc( UPDATE_FUNC ) );
+    return( updateFunc );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setRemapFunc
+
+  PURPOSE  : Changes the current pattern remap function.
+  NOTES    :
+
+  RETURNS  : Returns error code if remap function is invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setRemapFunc(char *name, float *params)
+{
+    return( kr_npui_setRemapFunction(name, params) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setUpdateFunc
+
+  PURPOSE  : Changes the current update function.
+  NOTES    :
+
+  RETURNS  : Returns error code if update function is invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_setUpdateFunc(char *update_func)
+{
+
+    return( krf_setCurrentNetworkFunc( update_func, UPDATE_FUNC ) );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : krui_updateNet
+
+  PURPOSE  : Updates the network according to update function:
+  NOTES    : The network should be feedforward in topological mode,
+             otherwise function will return a warning message.
+
+             See also krui_setSeedNo for initializing the pseudo
+             random generator.
+
+  RETURNS  : Returns error code if an error occured, 0 othrwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_updateNet(float *parameterInArray, int NoOfInParams)
+{
+
+    return( kr_callNetworkFunction( UPDATE_FUNC, parameterInArray, NoOfInParams,
+                                   NULL, NULL, 0, 0 ) );
+}
+
+
+/*############################################################################
+
+GROUP: Initialisation Functions
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getInitialisationFunc
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the current initialisation function. The default 
+             initialisation function is RandomizeWeights (see also kr_def.h).
+  UPDATE   :
+******************************************************************************/
+char  *krui_getInitialisationFunc(void)
+{
+
+    return( krf_getCurrentNetworkFunc( INIT_FUNC ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setInitialisationFunc
+
+  PURPOSE  : Changes the current learning function.  Returns error code if learning
+    function is invalid.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_setInitialisationFunc(char *initialisation_func)
+{
+
+    return( krf_setCurrentNetworkFunc( initialisation_func, INIT_FUNC ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_initializeNet
+
+  PURPOSE  : Initializes the network
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_initializeNet(float *parameterInArray, int NoOfInParams)
+{
+
+    return( kr_callNetworkFunction( INIT_FUNC, parameterInArray, NoOfInParams,
+                                   NULL, NULL, 0, 0 ) );
+}
+
+
+/*############################################################################
+
+GROUP: Learning Functions
+
+#############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getLearnFunc
+
+  PURPOSE  : Returns the current learning function. The default learning 
+             function is Backpropagation (see also kr_def.h).
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char  *krui_getLearnFunc(void)
+{
+    static char  learnFunc[FUNCTION_NAME_MAX_LEN];
+
+    strcpy( learnFunc, krf_getCurrentNetworkFunc( LEARN_FUNC ) );
+
+    return( learnFunc );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setLearnFunc
+
+  PURPOSE  : hanges the current learning function.
+  NOTES    :
+
+  RETURNS  : Returns error code if learning function is invalid
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_setLearnFunc(char *learning_func)
+{
+
+    return( krf_setCurrentNetworkFunc( learning_func, LEARN_FUNC ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_checkPruning
+
+  PURPOSE  : checks if pruning is enabled
+  NOTES    :
+
+  RETURNS  : TRUE or FALSE
+  UPDATE   :
+******************************************************************************/
+int krui_checkPruning ()
+{
+
+    return (!strcmp (krf_getCurrentNetworkFunc (LEARN_FUNC),
+                     "PruningFeedForward"));
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_trainNetwork
+
+  PURPOSE  :  Learn all pattern pairs using current learning method.
+              parameterInArray contains the learning parameter(s). 
+	      NoOfInParams stores the number of learning parameters.
+              parameterOutArray returns the results from the learning function.
+              this array is a static array defined in the learning function.
+              *NoOfOutParams points to a integer value that contains the number
+              of output parameters from the current learning function.
+  NOTES    :  Patterns must be loaded before calling this function.
+  REMEMBER :  The backpropagation learning function takes the learning
+              parameter from parameterInArray[ 0 ]. parameterOutArray[ 0 ]
+              returns the current net error.
+
+
+  RETURNS  : Returns an error code if memory allocation has failed or if
+             the parameters are invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err krui_trainNetwork(NetLearnParameters *parameters)
+{
+    register int i;
+    krui_err error;
+    float parameterInArray[NO_OF_LEARN_PARAMS];
+    float *parameterOutArray;
+
+
+    parameters->noOfErrors = 0;
+    /* This must be done for Type double => float */
+    for (i = 0 ; i < parameters->noOfParameters ; i++)
+        parameterInArray[i] = (float) parameters->parameter[i];
+
+
+    noOfStoredErrors =0;
+    for(i = 0 , dotraining = TRUE , error = KRERR_NO_ERROR;
+        dotraining && i < parameters->noOfEpochs && error == KRERR_NO_ERROR;
+        i++){
+
+        error = kr_callNetworkFunction( LEARN_FUNC,
+                            parameterInArray, parameters->noOfParameters,
+                            &parameterOutArray, &parameters->noOfResults,
+                            parameters->firstPattern,
+                            parameters->lastPattern);
+        if (( parameters->noOfEpochs < NO_OF_STORED_ERRORS) ||
+            (((i+1)%((parameters->noOfEpochs / NO_OF_STORED_ERRORS)+1)) == 0)){
+            storedLearnErrors[noOfStoredErrors] =
+                parameters->learnErrors[parameters->noOfErrors] =
+                    (double) parameterOutArray[0];
+            storedAtEpoch[noOfStoredErrors] =
+                parameters->atEpoch[parameters->noOfErrors] = i;
+            noOfStoredErrors++;
+            parameters->noOfErrors++;
+        }
+
+    }
+    storedLearnErrors[noOfStoredErrors] =
+        parameters->learnErrors[parameters->noOfErrors] =
+            (double) parameterOutArray[0];
+    storedAtEpoch[noOfStoredErrors++] =
+        parameters->atEpoch[parameters->noOfErrors++] = i;
+    parameters->netError = (double) parameterOutArray[0];
+    if( dotraining ){
+        parameters->lastEpoch = parameters->noOfEpochs;
+        parameters->interrupted = FALSE;
+    }else{
+        parameters->lastEpoch = i;
+        parameters->interrupted = TRUE;
+    }
+
+    /* This must be done for Type float => double */
+    for (i = 0 ; i < parameters->noOfResults ; i++)
+        parameters->result[i] = (double) parameterOutArray[i];
+
+    return(error);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNetworkErrorArray
+
+  PURPOSE  : Returns the current errorArray
+  NOTES    : Returns pointer to static Arrays
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err krui_getNetworkErrorArray(double **learnErrors,int **atEpoch,
+				   int *noOfErrors)
+{
+    *learnErrors = &storedLearnErrors[0];
+    *atEpoch = &storedAtEpoch[0];
+    *noOfErrors = noOfStoredErrors;
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_stopTraining
+
+  PURPOSE  : Stop the current trainNetwork training
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err krui_stopTraining(void)
+{
+    dotraining = FALSE;
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_learnAllPatterns
+
+  PURPOSE  :  Learn all pattern pairs using current learning method.
+              parameterInArray contains the learning parameter(s). 
+	      NoOfInParams stores the number of learning parameters.
+              parameterOutArray returns the results from the learning function.
+              this array is a static array defined in the learning function.
+              *NoOfOutParams points to a integer value that contains the number
+              of output parameters from the current learning function.
+  NOTES    :  Patterns must be loaded before calling this function.
+  REMEMBER :  The backpropagation learning function takes the learning
+              parameter from parameterInArray[ 0 ]. parameterOutArray[ 0 ]
+              returns the current net error.
+
+
+  RETURNS  : Returns an error code if memory allocation has failed or if
+             the parameters are invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_learnAllPatterns(float *parameterInArray, int NoOfInParams
+                               , float **parameterOutArray, int *NoOfOutParams)
+/*  REMEMBER:  parameterOutArray[ 0 ] returns the current net error
+               parameterInArray[ 0 ] contains the 1st learning parameter
+*/
+{
+
+    /*  learn all patterns  */
+    return( kr_callNetworkFunction( LEARN_FUNC,
+				    parameterInArray, NoOfInParams,
+				    parameterOutArray, NoOfOutParams,  
+				    0,kr_np_pattern(PATTERN_GET_NUMBER,0,0)-1));
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_testAllPatterns
+
+  PURPOSE  :  Test all pattern pairs using current learning method.
+              parameterInArray contains the learning parameter(s). 
+	      NoOfInParams stores the number of learning parameters.
+              parameterOutArray returns the results from the learning function.
+              this array is a static array defined in the learning function.
+              *NoOfOutParams points to a integer value that contains the number
+              of output parameters from the current learning function.
+  NOTES    :  Patterns must be loaded before calling this function.
+
+              direct copy of krui_learnAllPatterns!!!  joe
+
+  REMEMBER :  The backpropagation learning function takes the learning
+              parameter from parameterInArray[ 0 ]. parameterOutArray[ 0 ]
+              returns the current net error.
+
+
+  RETURNS  : Returns an error code if memory allocation has failed or if
+             the parameters are invalid.
+  UPDATE   : 19.02.95
+******************************************************************************/
+krui_err   krui_testAllPatterns(float *parameterInArray, int NoOfInParams,
+                                float **parameterOutArray, int *NoOfOutParams)
+/*  REMEMBER:  parameterOutArray[ 0 ] returns the current net error
+               parameterInArray[ 0 ] contains the 1st learning parameter
+*/
+{
+
+    /*  test all patterns  */
+    return( kr_callNetworkFunction( TEST_FUNC,
+                                   parameterInArray, NoOfInParams,
+                                   parameterOutArray, NoOfOutParams,   
+				   0, kr_np_pattern(PATTERN_GET_NUMBER,0,0)-1));
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_learnSinglePattern
+
+  PURPOSE  : Same as krui_learnAllPatterns( ... ) but learns only the current
+             pattern pair.
+  NOTES    : Patterns must be loaded before calling this function.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_learnSinglePattern(int pattern_no, float *parameterInArray, 
+				   int NoOfInParams, float **parameterOutArray,
+				   int *NoOfOutParams)
+{
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    return( kr_callNetworkFunction( LEARN_FUNC,
+                                   parameterInArray, NoOfInParams,
+                                   parameterOutArray, NoOfOutParams,
+                                   pattern_no - 1, pattern_no - 1 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_testSinglePattern
+
+  PURPOSE  : Same as krui_learnAllPatterns( ... ) but learns only the current
+             pattern pair.
+  NOTES    : Patterns must be loaded before calling this function.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err   krui_testSinglePattern(int pattern_no, float *parameterInArray, 
+				  int NoOfInParams, float **parameterOutArray, 
+				  int *NoOfOutParams)
+{
+
+    KernelErrorCode = KRERR_NO_ERROR;
+    return( kr_callNetworkFunction( TEST_FUNC,
+                                   parameterInArray, NoOfInParams,
+                                   parameterOutArray, NoOfOutParams,
+                                   pattern_no - 1, pattern_no - 1 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_learnAllPatternsFF
+
+  PURPOSE  :  Learn all pattern pairs using current feed forward
+              learning method.
+              parameterInArray contains the learning parameter(s). 
+	      NoOfInParams stores the number of learning parameters.
+              parameterOutArray returns the results from the learning function.
+              this array is a static array defined in the learning function.
+              *NoOfOutParams points to a integer value that contains the number
+              of output parameters from the current learning function.
+  NOTES    :  Patterns must be loaded before calling this function.
+  REMEMBER :  The backpropagation learning function takes the learning
+              parameter from parameterInArray[ 0 ]. parameterOutArray[ 0 ]
+              returns the current net error.
+
+
+  RETURNS  : Returns an error code if memory allocation has failed or if
+             the parameters are invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err krui_learnAllPatternsFF (float *parameterInArray, int NoOfInParams,
+                                  float **parameterOutArray, int *NoOfOutParams)
+{
+
+  return(kr_callNetworkFunction(FF_LEARN_FUNC | LEARN_FUNC, parameterInArray, 
+				NoOfInParams, parameterOutArray, NoOfOutParams,
+				0, kr_np_pattern(PATTERN_GET_NUMBER, 0, 0)-1));
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_learnSinglePatternFF
+
+  PURPOSE  : Same as krui_learnAllPatternsFF ( ... ) but learns only
+             the current pattern pair.
+  NOTES    : Patterns must be loaded before calling this function.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err krui_learnSinglePatternFF (int pattern_no, float *parameterInArray,
+                                    int NoOfInParams, float **parameterOutArray,
+                                    int *NoOfOutParams)
+{
+
+  KernelErrorCode = KRERR_NO_ERROR;
+  return (kr_callNetworkFunction (FF_LEARN_FUNC | LEARN_FUNC, parameterInArray,
+				  NoOfInParams, parameterOutArray, 
+				  NoOfOutParams, pattern_no-1, pattern_no-1));
+
+}
+
+
+/*############################################################################
+
+GROUP: Pruning Functions
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getPrunFunc
+
+  PURPOSE  : returns the current pruning function
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char *krui_getPrunFunc (void)
+{
+
+    static char prunFunc [FUNCTION_NAME_MAX_LEN];
+
+    strcpy (prunFunc, krf_getCurrentNetworkFunc (PRUNING_FUNC));
+    return (prunFunc);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setPrunFunc
+
+  PURPOSE  : changes the current pruning function
+  NOTES    :
+
+  RETURNS  : returns error code if pruning function is invalid
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setPrunFunc (char *pruning_func)
+{
+
+    return (krf_setCurrentNetworkFunc (pruning_func, PRUNING_FUNC));
+}
+
+
+/*############################################################################
+
+GROUP: FF-Learning Functions
+
+#############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFFLearnFunc
+
+  PURPOSE  : returns the current FF-learning function
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char *krui_getFFLearnFunc (void)
+{
+
+    static char FFLearnFunc [FUNCTION_NAME_MAX_LEN];
+
+    strcpy (FFLearnFunc, krf_getCurrentNetworkFunc(FF_LEARN_FUNC | LEARN_FUNC));
+    return (FFLearnFunc);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setFFLearnFunc
+
+  PURPOSE  : changes the current FF-learning function
+  NOTES    :
+
+  RETURNS  : returns error code if pruning function is invalid
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setFFLearnFunc (char *FF_learning_func)
+{
+
+    return (krf_setCurrentNetworkFunc(FF_learning_func, 
+				      FF_LEARN_FUNC | LEARN_FUNC));
+}
+
+
+/*############################################################################
+
+GROUP: Pattern Management
+
+############################################################################*/
+
+/*****************************************************************************
+  FUNCTION : krui_setClassDistribution
+
+  PURPOSE  : Sets the class distribution in the current pattern.
+  NOTES    : Patterns must be loaded before calling this function.
+
+  RETURNS  : Returns kernel error code 
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setClassDistribution(unsigned int *classDist)
+{
+
+    return(kr_npui_setClassDistribution(classDist));
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setClassInfo
+
+  PURPOSE  : Sets the class name in the current pattern.
+  NOTES    : 
+
+  RETURNS  : Returns kernel error code 
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setClassInfo(char *name)
+{
+    printf("Kernel debug: new pattern class : %s \n",name);
+    return(kr_npui_setClass(name));
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_useClassDistribution
+
+  PURPOSE  : Toggles the use of the user defined distribution of patterns 
+             (TRUE) as compared to the distribution in the pattern file
+  NOTES    : 
+
+  RETURNS  : kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_useClassDistribution(bool use_it)
+{
+
+    return( kr_npui_useChunk(use_it) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_setPatternNo
+
+  PURPOSE  : Sets the current pattern.
+  NOTES    : Patterns must be loaded before calling this function.
+
+  RETURNS  : Returns a error code if pattern number is invalid.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setPatternNo(int pattern_no)
+{
+
+    return( kr_np_pattern( PATTERN_SET, 0, pattern_no ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getPatternNo
+
+  PURPOSE  : Returns the current pattern number.
+  NOTES    : 
+
+  RETURNS  : 
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_getPatternNo(void)
+{
+
+    return( kr_np_pattern( PATTERN_GET, 0, 0 ) );
+}
+
+/*****************************************************************************
+  FUNCTION : krui_deletePattern
+
+  PURPOSE  :delete the current pattern pair
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deletePattern(void)
+{
+
+    return( kr_np_pattern( PATTERN_DELETE, 0 , 0 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_modifyPattern
+
+  PURPOSE  : modify the current pattern pair
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_modifyPattern(void)
+{
+
+    return( kr_np_pattern( PATTERN_MODIFY, 0 , 0 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_showPattern
+
+  PURPOSE  : According to the mode krui_showPattern stores the current
+             Pattern into the units activation (and/or output) values.
+             The modes are:
+               - OUTPUT_NOTHING
+                  store input pattern into input units activations
+               - OUTPUT_ACT
+                  store input pattern into input units activations and
+                  store output pattern into output units activations
+               - OUTPUT_OUT
+                  store input pattern into input units activations,
+                  store output pattern into output units activations and
+                  update output units output
+
+  NOTES    : See include file glob_typ.h for mode constants.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_showPattern(int mode)
+{
+
+    return( kr_np_pattern( PATTERN_SHOW, mode, 0 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_allocNewPatternSet
+
+  PURPOSE  : Allocate a new empty pattern set
+  NOTES    :
+
+  RETURNS  : Returns the number of the allcated pattern set;
+             Returns error code if an error occured
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_allocNewPatternSet(int *set_no)
+{
+
+    KernelErrorCode = kr_npui_allocNewPatternSet(set_no);
+    return KernelErrorCode;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_newPattern
+
+  PURPOSE  : Creates a new pattern pair.
+             A pattern pair can be created by modifying the activation
+             value of the input/output units.
+  NOTES    : krui_newPattern switches pattern shuffeling off.
+             For shuffeling the new pattern pairs call
+                 krui_newPattern(...)
+                 krui_shufflePattern( TRUE )
+
+  RETURNS  : Returns error code if memory is insufficent or no. of
+             input/output units is incompatible, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_newPattern(void)
+{
+
+    return( kr_np_pattern( PATTERN_NEW, 0, 0 ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfPatterns
+
+  PURPOSE  : Returns the no. of available pattern pairs.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfPatterns(void)
+{
+    int number;
+    number = kr_np_pattern( PATTERN_GET_NUMBER, 0, 0 );
+    return (number >= 0) ? number : 0;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getTotalNoOfSubPatterns
+
+  PURPOSE  : Returns the total no. of available subpattern pairs.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+int  krui_getTotalNoOfSubPatterns(void)
+{
+    int number;
+    number = kr_np_pattern( SUBPATTERN_GET_NUMBER, 0, 0 );
+    return (number >= 0) ? number : 0;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteAllPatterns
+  PURPOSE  : [ Release previously defined patterns from memory.
+              Call krui_releasePatterns() if you want to create totally
+              new patterns with krui_newPattern(). ]
+  NOTES    : This function is of no effect any longer since there exists
+             the new function krui_deletePatSet (see below)
+
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_deleteAllPatterns(void)
+{
+
+    (void) kr_np_pattern( PATTERN_DELETE_ALL, 0, 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_shufflePatterns
+
+  PURPOSE  : Shuffle pattern pairs by using pseudo random generator.
+             Shuffeling of patterns is used by krui_learnAllPatterns(...).
+             krui_shufflePatterns( TRUE ) switches shuffeling of patterns
+             on, krui_shufflePatterns( FALSE ) switches shuffeling of
+             patterns off.
+             The default presetting is krui_shufflePatterns( FALSE ).
+  NOTES    : See also krui_setSeedNo( seed )
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_shufflePatterns(bool on_or_off)
+{
+
+    if (on_or_off)
+        return kr_np_pattern( PATTERN_SHUFFLE_ON, 0, 0 );
+    else
+        return kr_np_pattern( PATTERN_SHUFFLE_OFF, 0, 0 );
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_shuffleSubPatterns
+
+  PURPOSE  : Shuffle sub pattern pairs by using pseudo random generator.
+             Shuffeling of patterns is used by krui_learnAllPatterns(...).
+             krui_shuffleSubPatterns(TRUE) switches shuffeling of sub patterns
+             on, krui_shuffleSubPatterns( FALSE ) switches shuffeling of
+             sub patterns off.
+             The default presetting is krui_shuffleSubPatterns( FALSE ).
+  NOTES    : See also krui_setSeedNo( seed )
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_shuffleSubPatterns(bool on_or_off)
+{
+
+    if (on_or_off)
+        return kr_np_pattern( PATTERN_SUB_SHUFFLE_ON, 0, 0 );
+    else
+        return kr_np_pattern( PATTERN_SUB_SHUFFLE_OFF, 0, 0 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setCurrPatSet
+
+  PURPOSE  : Choose the number of the current pattern set.
+             <number> starts from 0.
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setCurrPatSet(int number)
+{
+
+    return kr_npui_setCurrPatSet(number);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deletePatSet
+
+  PURPOSE  : Delete all patterns of pattern set with number <number>
+             The ordering of the remaining pattern sets is reorganized by
+             decrementing the pattern set numbers which are higher than
+             <number> by 1. For example: there exist the pattern sets 0, 1, 2
+             and 3. After deleting pattern set 1 the pattern sets 2 and 3 are
+             renamed to 1 and 2.
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_deletePatSet(int number)
+{
+
+    return kr_npui_deletePatSet(number);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_GetPatInfo
+
+  PURPOSE  : Get all available information concerning the current pattern set
+             and the current pattern.
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_GetPatInfo(pattern_set_info *set_info,
+			  pattern_descriptor *pat_info)
+{
+
+    return kr_npui_GetPatInfo(set_info, pat_info);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_DefShowSubPat
+
+  PURPOSE  : Define the sub pattern to be shown with next call to
+             krui_showPattern
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_DefShowSubPat(int *insize, int *outsize, int *inpos, int *outpos)
+{
+
+    return kr_npui_DefShowSubPat(insize, outsize, inpos, outpos);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_DefTrainSubPat
+
+  PURPOSE  : Define how sub patterns should be generated during training
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_DefTrainSubPat(int *insize, int *outsize,
+                              int *instep, int *outstep, int *max_n_pos)
+{
+
+    return kr_npui_DefTrainSubPat(insize, outsize, instep, outstep, max_n_pos);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_AlignSubPat
+
+  PURPOSE  : Align the given sub pattern position (<inpos> and <outpos>)
+             to a valid position which fits the defined sub pattern training
+             scheme (krui_DefTrainSubPat).
+
+  RETURNS  : kernel error code
+             <inpos> and <outpos> returns the aligned position
+             <no> returns the resulting ordering position of the sub pattern
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err krui_AlignSubPat(int *inpos, int *outpos, int *no)
+{
+
+    return kr_npui_AlignSubPat(inpos, outpos, no);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_GetShapeOfSubPattern
+
+  PURPOSE  : Get shape of sub pattern <n_pos> using current set,
+             current pattern and current train scheme (defined with
+             krui_DefTrainSubPat)
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_GetShapeOfSubPattern(int *insize, int *outsize,
+                                    int *inpos, int *outpos, int n_pos)
+{
+
+    return kr_npui_GetShapeOfSubPat(insize, outsize, inpos, outpos, n_pos);
+}
+
+
+/*############################################################################
+
+GROUP: I/O Functions
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_saveNet
+
+  PURPOSE  : Save a network.
+             If netname is a NULL pointer, the net will get the name "UNTITLED"
+  NOTES    :
+
+  RETURNS  :  Returns error code if an error occured, or 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_saveNet(char *filename, char *netname)
+{
+
+    return( krio_saveNet( filename, netname ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_loadNet
+
+  PURPOSE  : Load a network file and create a network.
+             Returns the name of the net or "UNTITLED" if unknown.
+  NOTES    :
+
+  RETURNS  : Returns error code if an error occured during
+             loading/memory allocation, or 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_loadNet(char *filename, char **netname)
+{
+    char        *netfile_version; /*  isn't used now  */
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    KernelErrorCode = krio_loadNet( filename, netname, &netfile_version );
+    if (KernelErrorCode != KRERR_NO_ERROR)
+        return( KernelErrorCode );
+
+    kr_updateUnitOutputs();
+
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_loadNewPatterns
+
+  PURPOSE  : Load file containing pattern pairs of new Style conventions.
+  NOTES    :
+
+  RETURNS  : Returns the number of the loaded pattern set;
+             Returns error code if an error occured during
+             loading/memory allocation, or 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_loadNewPatterns(char *filename, int *set_no)
+{
+
+    KernelErrorCode = kr_npui_loadNewPatterns(filename, set_no);
+    return KernelErrorCode;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_saveNewPatterns
+
+  PURPOSE  : Save pattern file with new style conventions
+             The pattern set with number <number> is saved.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_saveNewPatterns(char *filename, int set_no)
+{
+
+    KernelErrorCode = kr_npui_saveNewPatterns(filename, set_no);
+    return KernelErrorCode;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_saveResultParam
+
+  PURPOSE  : Save the network result which depends on the loaded patterns.
+             If create is false, the new file will be appended to an existing
+             file. startpattern and endpattern determine the range of patterns
+             to use. The input patterns and the teaching output patterns can
+             be included.
+  NOTES    : This is a new version of the old function krui_saveResult with
+             added parameter passing for the update functions.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_saveResultParam(char *filename, bool create,
+                               int startpattern, int endpattern,
+                               bool includeinput, bool includeoutput,
+                               float *Update_param_array, int NoOfUpdateParam)
+{
+
+    return( krio_saveResult(filename, create, startpattern, endpattern,
+                            includeinput, includeoutput,
+                            Update_param_array, NoOfUpdateParam));
+}
+
+
+/*############################################################################
+
+GROUP: Functions for memory management
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_allocateUnits
+
+  PURPOSE  : Allocates a given number of units, additional units
+             may allocated by calling this function again.
+             This function is called automatically if the user
+             construct more units than have been allocated before, but
+             it is recommended to use this function if a large amount
+             of units is needed (the UNIX System can manage system resources
+             much better, if the amount of memory used for the network is
+             approximately known before the network is created).
+  NOTES    : If krui_create_unit has been called before using this
+             function, at least <UNIT_BLOCK> numbers of units have been
+             allocated.
+             See "kr_def.h" for more information about memory allocation
+             block sizes.
+
+  RETURNS  : Returns error code if memory allocation fails, 0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_allocateUnits(int no_of_units)
+{
+
+    return( krm_allocUnits( no_of_units ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_deleteNet
+
+  PURPOSE  :  Delete network, names and unit types.
+              Frees all memory used for the network.
+  NOTES    : If krui_loadNet is called more then once,  krui_deleteNet will
+             be called by krui_loadNet, because the kernel have to free the
+             memory used for the old network.
+             It is recommended (but not neccessary) to call krui_deleteNet
+             before terminating the SNNS-Kernel.
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_deleteNet(void)
+{
+
+    krm_releaseMem();
+}
+
+
+/*############################################################################
+
+GROUP: Functions for reading/searching the symbol table
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getFirstSymbolTableEntry
+
+  PURPOSE  : Returns the first symbol/symbol type entry in the
+             symbol table. Returns true if this entry is available,
+             false otherwise.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_getFirstSymbolTableEntry(char **symbol_name, int *symbol_type)
+{
+    struct NameTable      *n_tbl;
+
+    n_tbl = krm_getNTableFirstEntry();
+
+    while ( (n_tbl != NULL) && ((int) n_tbl->sym_type == UNUSED_SYM) )
+        n_tbl = krm_getNTableNextEntry();
+
+    if (n_tbl == NULL) {
+	*symbol_name = NULL;
+	*symbol_type = 0;
+	return( FALSE );
+    }
+
+    *symbol_name = n_tbl->Entry.symbol;
+    *symbol_type = (int) n_tbl->sym_type;
+    return( TRUE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNextSymbolTableEntry
+
+  PURPOSE  : Returns the next symbol/symbol type entry in the
+             symbol table. Returns true if another entry is available,
+             false otherwise.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+bool  krui_getNextSymbolTableEntry(char **symbol_name, int *symbol_type)
+{
+    struct NameTable      *n_tbl;
+
+    n_tbl = krm_getNTableNextEntry();
+
+    while ( (n_tbl != NULL) && ((int) n_tbl->sym_type == UNUSED_SYM) )
+        n_tbl = krm_getNTableNextEntry();
+
+    if (n_tbl == NULL) {
+	*symbol_name = NULL;
+	*symbol_type = 0;
+	return( FALSE );
+    }
+
+    *symbol_name = n_tbl->Entry.symbol;
+    *symbol_type = (int) n_tbl->sym_type;
+    return( TRUE );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_symbolSearch
+
+  PURPOSE  : Searches the symbol table for a given symbol and
+             symbol type (unit name symbol, site name symbol,
+             functionality unit name symbol)
+  NOTES    :
+
+  RETURNS  : Returns true, if the symbol exists.
+  UPDATE   :
+******************************************************************************/
+bool  krui_symbolSearch(char *symbol, int symbol_type)
+{
+
+    return( krm_NTableSymbolSearch( symbol, symbol_type ) != NULL );
+}
+
+
+/*###########################################################################
+
+GROUP: Miscellanous
+
+############################################################################*/
+
+
+/*****************************************************************************
+  FUNCTION : krui_getVersion
+
+  PURPOSE  : Returns the current Version of the SNNS-Kernel.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char  *krui_getVersion(void)
+{
+    static char snns_version[128];
+
+    strcpy( snns_version, SNNS_VERSION );
+    strcat( snns_version, KERNEL_PATCH );
+    return( snns_version );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNetInfo
+
+  PURPOSE  : Returns miscellanous information about the current network.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_getNetInfo(int *no_of_sites, int *no_of_links, 
+		      int *no_of_STable_entries, int *no_of_FTable_entries)
+{
+    int   array_size,
+    info_array[ 10 ];
+
+    krm_getMemoryManagerInfo( &array_size, info_array );
+
+    *no_of_sites          = info_array[ 0 ];
+    *no_of_links          = info_array[ 1 ];
+    *no_of_STable_entries = info_array[ 2 ];
+    *no_of_FTable_entries = info_array[ 3 ];
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getMemoryManagerInfo
+
+  PURPOSE  : Returns the number of ALLOCATED (not the number of USED) bytes
+    per entry.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_getMemoryManagerInfo(int *unit_bytes, int *site_bytes, 
+				int *link_bytes, int *NTable_bytes, 
+				int *STable_bytes, int *FTable_bytes)
+{
+    int   array_size,
+    info_array[ 10 ];
+
+    krm_getMemoryManagerInfo( &array_size, info_array );
+
+    *unit_bytes   = info_array[ 4 ] * UNIT_SIZE;
+    *site_bytes   = info_array[ 5 ] * SITE_SIZE;
+    *link_bytes   = info_array[ 6 ] * LINK_SIZE;
+    *NTable_bytes = info_array[ 7 ] * NTABLE_SIZE;
+    *STable_bytes = info_array[ 8 ] * STABLE_SIZE;
+    *FTable_bytes = info_array[ 9 ] * FTYPE_UNIT_SIZE;
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitDefaults
+
+  PURPOSE  : Returns Information about the unit default settings.
+             For more information about default settings see 
+	     krui_createDefaultUnit() and krui_createFTypeUnit( .. ).
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_getUnitDefaults(FlintType *act, FlintType *bias, int *st, 
+			   int *subnet_no, int *layer_no, char **act_func, 
+			   char **out_func)
+{
+    int ttflags;
+
+    kr_getUnitDefaults( act, bias, &ttflags, subnet_no, layer_no,
+                       act_func, out_func );
+
+    *st = kr_flags2TType( ttflags );
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_setUnitDefaults
+
+  PURPOSE  : Changes the unit default settings.
+             For more information about default settings see 
+	     krui_createDefaultUnit() and krui_createFTypeUnit( .. ).
+  NOTES    :
+
+  RETURNS  : Returns error code if
+             - activation/output function is invalid
+             - Topologic type is invalid
+             0 otherwise.
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitDefaults(FlintTypeParam act, FlintTypeParam bias, 
+			       int st, int subnet_no, int layer_no, 
+			       char *act_func, char *out_func)
+{
+    int        ttflags;
+
+    ttflags = kr_TType2Flags( st );
+    if (KernelErrorCode != KRERR_NO_ERROR)
+        return( KernelErrorCode );
+
+    kr_setUnitDefaults( act, bias, ttflags, subnet_no, layer_no,
+                       act_func, out_func );
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_resetNet
+
+  PURPOSE  : Reset the network by changeing the unit activation
+             to the initial activation value.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_resetNet(void)
+{
+    register int   i;
+    register struct Unit   *unit_ptr;
+
+    if ( (unit_array == NULL) || (NoOfUnits == 0) )
+        return;
+
+
+    for (i = MinUnitNo, unit_ptr = unit_array + MinUnitNo; i <= MaxUnitNo; 
+	 i++, unit_ptr++)
+        if UNIT_IN_USE( unit_ptr )  {
+            /*  unit is in use  */
+            unit_ptr->act = unit_ptr->i_act;
+
+            if (unit_ptr->out_func == OUT_IDENTITY)
+                unit_ptr->Out.output = unit_ptr->act;
+            else
+                /*  no identity output function: calculate unit's output also */
+                unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+        }
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_setSeedNo
+
+  PURPOSE  : Initialize the pseudo random generator.
+             0 as argument reinitializes the random generator.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void  krui_setSeedNo(long int seed)
+{
+
+    if (seed != 0)
+        srand48( seed );  
+    else
+        srand48( (long) time( (time_t *) 0) ); 
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfInputUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the no. of input units
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfInputUnits(void)
+{
+
+    return( kr_getNoOfUnits( INPUT ) + kr_getNoOfUnits( DUAL ) +
+	    kr_getNoOfUnits( SPECIAL_I ) + kr_getNoOfUnits( SPECIAL_D ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfOutputUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : returns the no. of output units
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfOutputUnits(void)
+{
+
+    return( kr_getNoOfUnits( OUTPUT ) + kr_getNoOfUnits( DUAL ) +
+	    kr_getNoOfUnits( SPECIAL_O ) + kr_getNoOfUnits( SPECIAL_D ) );
+}
+/*****************************************************************************
+  FUNCTION : krui_getNoOfTTypeUnits
+
+  PURPOSE  : returns the no. of units of the specified topologic type
+             (i.e. Input, Hidden, Output or Special units)
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfTTypeUnits(int UnitTType)
+{
+
+    return( kr_getNoOfUnits( UnitTType ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfSpecialInputUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the no. of special input units
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfSpecialInputUnits(void)
+{
+
+  return( kr_getNoOfSpecialUnits( INPUT ) + kr_getNoOfUnits( DUAL ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getNoOfSpecialOutputUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : returns the no. of special output units
+  UPDATE   :
+******************************************************************************/
+int  krui_getNoOfSpecialOutputUnits(void)
+{
+
+  return( kr_getNoOfSpecialUnits( OUTPUT ) + kr_getNoOfUnits( DUAL ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_xyTransTable
+
+  PURPOSE  : Get/modify the XY-Translation table
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_xyTransTable(int op, int *x, int *y, int z)
+{
+
+    return(kr_xyTransTable(op,x,y,z));
+}
+
+/*****************************************************************************
+  FUNCTION : krui_getUnitCenters
+
+  PURPOSE  : Returns the 3D transform center of the specified unit and center number
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_getUnitCenters(int unit_no, int center_no, 
+			      struct PositionVector **unit_center)
+{
+    struct Unit   *unit_ptr;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    if ((center_no < 0) || (center_no >= NO_OF_UNIT_CENTER_POS))  {
+        KernelErrorCode = KRERR_PARAMETERS;
+        return( KRERR_PARAMETERS );
+    }
+
+    *unit_center = unit_ptr->unit_center_pos + center_no;
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_setUnitCenters
+
+  PURPOSE  : Sets the 3D transform center of the specified unit and center 
+             number
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setUnitCenters(int unit_no, int center_no, 
+			      struct PositionVector *unit_center)
+{
+    struct Unit   *unit_ptr;
+    struct PositionVector    *unit_posvec_ptr;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    if ((unit_ptr = kr_getUnitPtr( unit_no )) == NULL)
+        return( KernelErrorCode );
+
+    if ((center_no < 0) || (center_no >= NO_OF_UNIT_CENTER_POS))  {
+        KernelErrorCode = KRERR_PARAMETERS;
+        return( KRERR_PARAMETERS );
+    }
+
+    unit_posvec_ptr = unit_ptr->unit_center_pos + center_no;
+
+    memcpy( (char *) unit_posvec_ptr, (char *) unit_center, 
+	    sizeof( struct PositionVector ) );
+
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_topo_err_msg
+
+  PURPOSE  : generate a message about an error found while doing a 
+             topologiacal sorting of the network units
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+static char  *krui_topo_err_msg(void)
+{
+    char  *dest_unit_name,  *src_unit_name;
+    static char  msg1[512];
+    static char  msg2[512];
+
+    /* Init */
+    msg1[0] = '\0';
+    msg2[0] = '\0';
+
+    if (topo_msg.dest_error_unit > 0)
+        dest_unit_name = krui_getUnitName( topo_msg.dest_error_unit );
+
+    if (topo_msg.src_error_unit > 0)
+        src_unit_name = krui_getUnitName( topo_msg.src_error_unit );
+
+    if (topo_msg.dest_error_unit > 0)
+        if (dest_unit_name == NULL)
+            sprintf( msg1, "Unit #%d is the destination unit. ", 
+		     topo_msg.dest_error_unit );
+        else
+            sprintf( msg1, "Unit #%d (%s) is the destination unit. ", 
+		     topo_msg.dest_error_unit, dest_unit_name );
+
+    if (topo_msg.src_error_unit > 0)
+        if (src_unit_name == NULL)
+            sprintf( msg2, "Unit #%d is the source unit. ", 
+		     topo_msg.src_error_unit );
+        else
+            sprintf( msg2, "Unit #%d (%s) is the source unit. ", 
+		     topo_msg.src_error_unit, src_unit_name );
+
+    if (topo_msg.dest_error_unit == 0)
+        return( msg2 );
+
+    if (topo_msg.src_error_unit > 0)
+        strcat( msg1, msg2 );
+
+    return( msg1 );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_error
+
+  PURPOSE  : Returns an error message, depending on the error code.
+             If a function returns an error code use krui_error to
+             get the message.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+char  *krui_error(int error_code)
+{
+    static char *err_message[] = {
+        "Invalid error code",
+        "Insufficient memory",
+        "Invalid unit number",
+        "Invalid unit output function",
+        "Invalid unit activation function",
+        "Invalid site function",
+        "Creation of sites isn't permitted because unit has direct input links",
+        "Creation of a link isn't permitted because there exists already a link between these units",
+        "Memory allocation failed during critical operation. Have lost some pointers, but consistency of the network is guaranteed",
+        "Ftype name isn't definite",
+        /*10*/"Current Ftype entry isn't defined",
+        "Invalid copy mode",
+        "Current unit doesn't have sites",
+        "Can't update unit because unit is frozen",
+        "Redefinition of site name isn't permitted (site name already exists)",
+        "Site name isn't defined",
+        "This is not a 3D-Kernel",
+        "This unit has already a site with this name",
+        "Can't delete site table entry because site is in use",
+        "Current Ftype site isn't defined",
+        /*20*/"Ftype symbol isn't defined",
+        "I/O error: ",
+        "Creation of output file failed (line length limit exceeded)",
+        "The network has not enough layers: ",
+        "No Units defined",
+        "Unexpected EOF",
+        "Line length exceeded",
+        "Incompatible file format",
+        "Can't open file",
+        "Syntax error",
+        /*30*/"Memory allocation error #01",
+        "Topologic type invalid",
+        "Symbol pattern invalid (must match [A-Za-z][^|, ]*)",
+        "Current unit doesn't have a site with this name",
+        "No hidden units defined",
+        "Network contains cycle(s): ",
+        "Network contains dead unit(s): ",
+        "Pattern file contains not the same no. of input units as the network",
+        "Pattern file contains not the same no. of output units as the network",
+        "No. of input units have changed",
+        /*40*/"No. of output units have changed",
+        "No input units defined",
+        "No output units defined",
+        "No patterns defined",
+        "In-Core patterns incompatible with current network (remove In-Core patterns before loading a new network)",
+        "Invalid pattern number",
+        "Invalid learning function",
+        "Invalid parameters",
+        "Invalid update function",
+        "Invalid initialisation function",
+        /*50*/"Derivation function of the activation function doesn't exist",
+        "Input unit(s) with input connection(s) to other units: ",
+        "Output unit(s) with output connection(s) to other units: ",
+        "Invalid topological sorting mode",
+        "Learning function doesn't support sites",
+        "Sites are not supported",
+        "This isn't a MasPar Kernel",
+        "Connection(s) between unit(s) in non-neighbour layers are not supported: ",
+        "The network has too much layers: ",
+        "The network layers aren't fully connected",
+        /*60*/"This operation isn't allowed in the parallel kernel mode",
+        "Change of network type isn't possible in parallel kernel mode",
+        "No current link defined",
+        "No current unit defined",
+        "Current unit doesn't have any inputs",
+        "Invalid parameter in topologic definition section",
+        "Creation of link between these units isn't permitted",
+        "MasPar don't respond",
+        "This function isn't implemented yet",
+        "Kernel isn't in parallel mode",
+        /*70*/"MasPar ran out of memory",
+        "MasPar communication error",
+        "MasPar ran out of processors",
+        "Missing default function (check function table)",
+        "MasPar kernel doesn't support multiple unit output functions",
+        "MasPar kernel doesn't support multiple unit activation functions",
+        "The depth of the network doesn't fit to the learning function",
+        "Wrong no of units in layer: ",
+        "Unit is missing or not correctly connected: ",
+        "Unit doesn't belong to a defined layer in the network: ",
+        /*80*/"Unit has wrong activation function: ",
+        "Unit has wrong output function: ",
+        "Unexpected site function at unit: ",
+        "Unit is not expected to have sites: ",
+        "Unit is expected to have sites: ",
+        "Site missing at unit: ",
+        "Unexpected link: ",
+        "Missing link(s) to unit: ",
+        "Link ends at wrong site of destination unit: ",
+        "This network is not fitting the required topology",
+        /*90*/"Wrong beta parameter in unit bias value: ",
+        "CC error: Topo_ptr_array is sorted in the wrong way", /*CC_ERROR1*/
+        "CC error: There is no memory allocated", /*CC_ERROR2*/
+        "CC error: Not enough memory to run Casscade", /*CC_ERROR3*/
+        "Invalid error code", /*RCC_ERROR4*/
+        "Invalid error code", /*RCC_ERROR5*/
+        "CC error: Hidden layer is not fitting the required topology",
+        "Invalid error code", /*RCC_ERROR7*/
+        "Invalid error code", /*RCC_ERROR8*/
+        "Invalid error code", /*RCC_ERROR9*/
+        /*100*/ "Wrong update function",/*CC_ERROR10*/
+        "Wrong init function",  /*CC_ERROR11*/
+        "DLVQ error: There are empty classes",
+        "DLVQ error: There exists a class lower than zero",
+        "DLVQ error: Wrong no. of output units",
+        "DLVQ error: This network is not fitting the required topology",
+        "DLVQ error: There does not exist a unit for every class",
+        "No more free pattern sets available",
+        "No such pattern set defined",
+        "No current pattern defined",
+        /*110*/ "Specified sub pattern does not fit into pattern",
+        "No such pattern available",
+        "No current pattern set defined",
+        "Pattern (sub pattern) does not fit the network",
+        "No sub pattern shifting scheme defined",
+        "Pattern contains no output information",
+        "New pattern does not fit into existing set",
+        "Paragon kernel not initialized",
+        "Paragon kernel already initialized",
+        "Sending a message fails",
+        /*120*/ "Syntax error in received message",
+        "Receive unknown command",
+        "Less patterns then allocated nodes",
+        "Weight update with global sum fails",
+        "Learning function not parallelized",
+        "Invalid error code", /* RPC-Call failed */
+        "Invalid error code", /* RPC-Timeout */
+        "Invalid error code", /* RPC: No Server defined */
+        "Invalid error code", /* RPC: Cooperativ failed */
+        "Invalid error code", /* RPC: No response from the slaves */
+        /*130*/ "Algorithm needs patterns. Please press TEST first to check patterns.",
+	"RBF-DDA: First input parameter out of range 0<theta_pos<=1.",
+	"RBF-DDA: Second input parameter out of range 0<theta_neg<=1.",
+	"RBF-DDA: Third input parameter must be >=0.",
+	"RBF-DDA: More than one desired class in output pattern.",
+	"RBF-DDA: Input-hidden connection pointer problem.",
+	"RBF-DDA: Input-output shortcut connections are not allowed.",
+	"RBF-DDA: Activation function of input units must be Act_Identity.",
+	"RBF-DDA: Activation function of hidden units must be Act_RBF_Gaussian.",
+	"RBF-DDA: Activation function of output units must be Act_Identity.",
+        /*140*/ "CC error : Invalid additional Parameters.",
+        "Activation-functions have to be Act_Threshold.",
+        "Learning function must be online Backpropagation",
+	"No learning possible with only one class",
+	"Invalid pattern remap function",
+        "Patterns don't have class information",
+	"Illegal virtual class distribution",
+	"Patterns can not be normalized"
+    };  /* 147 error messages */
+
+    static char *ext_messages[] = {
+        "SNNS-Kernel No Errors",
+        "SNNS-Kernel Error: ",
+        "SNNS-Kernel Network Topologic Error: "
+        };
+
+    int  NoOfMessages = (sizeof (err_message)) / (sizeof (err_message[0]));
+    static char  mesg[512], aux[512];
+
+
+    if (error_code == 0)        return( ext_messages[0] ); /*   No errors  */
+
+    error_code = abs( error_code );
+    if ( error_code >= NoOfMessages )  error_code = 0; /* invalid error code */
+
+    switch (-error_code)
+        {
+          case KRERR_CYCLES:
+          case KRERR_DEAD_UNITS:
+          case KRERR_I_UNITS_CONNECT:
+          case KRERR_O_UNITS_CONNECT:
+          case KRERR_NOT_NEIGHBOUR_LAYER:
+          case KRERR_ACT_FUNC:
+          case KRERR_OUT_FUNC:
+          case KRERR_SITE_FUNC:
+          case KRERR_UNEXPECTED_SITES:
+          case KRERR_UNEXPECTED_DIRECT_INPUTS:
+          case KRERR_SITE_MISSING:
+          case KRERR_UNEXPECTED_LINK:
+          case KRERR_LINK_MISSING:
+          case KRERR_LINK_TO_WRONG_SITE:
+          case KRERR_PARAM_BETA:
+          case KRERR_UNDETERMINED_UNIT:
+
+            strcpy( mesg, ext_messages[2] );
+            strcat( mesg, err_message[ error_code ] );
+
+            switch (-error_code){
+	    case KRERR_CYCLES:
+		sprintf( aux, "%d cycle(s) in the network. ", 
+			 topo_msg.no_of_cycles );
+		strcat( mesg, aux );
+		break;
+	    case KRERR_DEAD_UNITS:
+		sprintf( aux, "%d dead unit(s) in the network. ", 
+			 topo_msg.no_of_dead_units );
+		strcat( mesg, aux );
+		break;
+
+	    default: break;
+	    }
+
+            strcat( mesg, krui_topo_err_msg() );
+            return( mesg );
+
+
+          case KRERR_FEW_LAYERS:
+          case KRERR_MUCH_LAYERS:
+          case KRERR_NOT_FULLY_CONNECTED:
+	      strcpy( mesg, ext_messages[2] );
+	      strcat( mesg, err_message[ error_code ] );
+
+	      switch (-error_code){
+	      case KRERR_FEW_LAYERS:
+		  sprintf(aux, "Only %d layers found.", topo_msg.no_of_layers );
+		  break;
+	      case KRERR_MUCH_LAYERS:
+		  sprintf( aux, "%d layers found.", topo_msg.no_of_layers );
+		  break;
+
+	      default: break;
+	      }
+
+	      strcat( mesg, aux );
+	      return( mesg );
+
+          case KRERR_NO_OF_UNITS_IN_LAYER:
+	      strcpy (mesg, ext_messages[2]);
+	      strcat (mesg, err_message [error_code]);
+	      sprintf (aux, "The name of the layer is: %s", topo_msg.name);
+	      strcat (mesg, aux);
+	      return (mesg);
+
+          case KRERR_UNIT_MISSING:
+	      strcpy (mesg, ext_messages[2]);
+	      strcat (mesg, err_message [error_code]);
+	      sprintf (aux, "The missing unit is the %s unit.", topo_msg.name);
+	      strcat (mesg, aux);
+	      return (mesg);
+
+
+
+          case KRERR_FILE_OPEN:
+	      lineno = 0;
+
+          default:
+	      if (lineno != 0){               /*  file I/O error  */
+		  strcpy( mesg, ext_messages[1] );
+		  sprintf( aux, "Loading file failed at line %d : ", lineno );
+		  strcat( mesg, aux );
+		  strcat( mesg, err_message[ error_code ] );
+
+		  lineno = 0;
+		  return( mesg );
+	      } else {               /*  standard error  */
+		  strcpy( mesg, ext_messages[1] );
+		  strcat( mesg, err_message[ error_code ] );
+		  return( mesg );
+	      }
+        }
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_NA_Error
+
+  PURPOSE  : calculates the error for the network-analyzer tool
+  NOTES    :
+
+  RETURNS  : Returns the float value of the error
+  UPDATE   :
+******************************************************************************/
+float krui_NA_Error(int currentPattern, int error_unit, int error, bool ave)
+{
+
+  return( kr_NA_Error(currentPattern, error_unit, error, ave) );
+}
+
+
+/*############################################################################
+
+  Functions for the external kernels
+
+########################################################################### */
+
+
+/*****************************************************************************
+  FUNCTION : krui_setSpecialNetworkType
+
+  PURPOSE  : Sets the topologic type of the current network.
+             Returns an error if the topologic type of the current network
+             doesn't fit to this type.
+             Topologic types are:
+               - NET_TYPE_GENERAL
+                 general purpose network type with no limitations
+               - NET_TYPE_FF1
+                 feedforward network with fully connected units in
+                 neighbour layers
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_setSpecialNetworkType(int net_type)
+{
+
+    (void) kr_setSpecialNetworkType( net_type );
+    return( KernelErrorCode );
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_getSpecialNetworkType
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  : Returns the special topologic type of the current network, if set.
+  UPDATE   :
+******************************************************************************/
+int  krui_getSpecialNetworkType(void)
+{
+
+    return( kr_getSpecialNetworkType() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_initInversion
+
+  PURPOSE  : initialize net for inversion algorithm
+  NOTES    :
+  UPDATE   : 06.02.92
+******************************************************************************/
+int krui_initInversion(void)
+{
+
+    return( kr_initInversion() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_inv_forwardPass
+
+  PURPOSE  : topological forward propagation of the inversion algorithm
+  NOTES    :
+  UPDATE   : 29.01.92
+******************************************************************************/
+void  krui_inv_forwardPass(struct UnitList *inputs)
+{
+
+    kr_inv_forwardPass(inputs);
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_inv_backwardPass
+
+  PURPOSE  : Backward error propagation (topological)
+  NOTES    :
+  UPDATE   : 04.02.92
+*****************************************************************************/
+double krui_inv_backwardPass(float learn, float delta_max, int *err_units,
+                             float ratio, struct UnitList *inputs,
+                             struct UnitList *outputs)
+{
+
+    return(kr_inv_backwardPass(learn,delta_max,err_units,
+                               ratio,inputs,outputs) ) ;
+}
+
+
+/*###########################################################################
+
+  Functions for the MasPar kernel
+
+########################################################################### */
+
+
+#ifdef MASPAR_KERNEL
+/*****************************************************************************
+  FUNCTION : krui_MasPar
+
+  PURPOSE  : Connects and disconnects the MasPar.
+             The mode switches are:  MASPAR_CONNECT and MASPAR_DISCONNECT.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_MasPar(int mode )
+{
+
+  return( kr_initMasPar( mode ) );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_getMasParStatus
+
+  PURPOSE  : Returns the status of the MasPar.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_getMasParStatus(void)
+{
+
+  return( kr_getMasParStatus() );
+}
+
+
+/*****************************************************************************
+  FUNCTION : krui_MasParBenchmark
+
+  PURPOSE  : Perform benchmark tests
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err  krui_MasParBenchmark(int func_type,int cycles,float  *result )
+{
+    float  parameterInArray[NO_OF_LEARN_PARAMS];
+    float  *parameterOutArray;
+    int  NoOfOutParams;
+
+
+    parameterInArray[0] = (float) cycles;
+    (void) kr_callNetworkFunction( func_type | BENCH_FUNC,
+				   parameterInArray, 1, &parameterOutArray, 
+				   &NoOfOutParams, 0, 0 );
+
+    *result = parameterOutArray[0];
+    return( KernelErrorCode );
+}
+
+
+#endif
+
+
+/*****************************************************************************
+  FUNCTION :  krui_kohonen_SetExtraParameter
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void krui_kohonen_SetExtraParameter(int x)
+{
+
+    kohonen_SetExtraParameter(x);
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_spanning_tree
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void krui_spanning_tree(void)
+{
+
+    spanning_tree();
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_cc_updatePosOfSpecialUnits
+
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void krui_cc_updatePosOfSpecialUnits(void)
+{
+
+    cc_updatePosOfSpecialUnits();
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_cc_deleteAllSpecialUnits
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err krui_cc_deleteAllSpecialUnits(void)
+{
+
+    return(cc_deleteAllSpecialUnits());
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_getErrorCode
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+int krui_getErrorCode(void)
+{
+
+    return(krui_error_code);
+}
+
+
+/*****************************************************************************
+  FUNCTION :  krui_setErrorHandler
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+krui_err krui_setErrorHandler(void(* error_Handler )(int))
+{
+
+    krui_errorHandler = error_Handler;
+    return(0);
+}
+
+/*****************************************************************************
+  FUNCTION :   krui_execHandler
+  PURPOSE  :
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   :
+******************************************************************************/
+void krui_execHandler(int error_code)
+{
+
+    if(krui_errorHandler != NULL)  ((*krui_errorHandler) (error_code));
+}
diff -Naur snort-2.3.3/src/kernel_snns/kr_ui.h snort-2.3.3.new/src/kernel_snns/kr_ui.h
--- snort-2.3.3/src/kernel_snns/kr_ui.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_ui.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,314 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_ui.h,v $
+  SHORTNAME      : kr_ui.h
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel User Interface Function Prototypes
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 27.02.90
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Christine Bagdi
+  RCS VERSION    : $Revision: 2.23 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:16 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _KR_UI_DEFINED_
+#define  _KR_UI_DEFINED_
+
+
+
+#include "krui_typ.h"	/*  Interface function prototypes  */
+
+/*
+#ifdef __MSDOS__
+
+#ifndef  int
+#define  int long
+#endif
+
+#endif
+*/
+/* pcc */
+extern int       krui_countLinks(void);
+
+extern void    (*krui_errorHandler)(int);
+extern int       krui_error_code;
+
+extern int       krui_getNoOfUnits(void);
+extern int       krui_getFirstUnit(void);
+extern int       krui_getNextUnit(void);
+extern int       krui_getCurrentUnit(void);
+extern krui_err  krui_setCurrentUnit(int unit_no);
+extern char     *krui_getUnitName(int UnitNo);
+extern krui_err  krui_setUnitName(int unit_no, char *unit_name);
+extern int       krui_searchUnitName(char *unit_name);
+extern int       krui_searchNextUnitName(void);
+extern char     *krui_getUnitOutFuncName(int UnitNo);
+extern krui_err  krui_setUnitOutFunc(int unit_no, char *unitOutFuncName);
+extern char     *krui_getUnitActFuncName(int UnitNo);
+extern krui_err  krui_setUnitActFunc(int unit_no, char *unitActFuncName);
+extern char     *krui_getUnitFTypeName(int UnitNo);
+extern FlintType krui_getUnitActivation(int UnitNo);
+extern krui_err  krui_setUnitActivation(int UnitNo, 
+					FlintTypeParam unit_activation);
+extern FlintType krui_getUnitInitialActivation(int UnitNo);
+extern void      krui_setUnitInitialActivation(int UnitNo, 
+					   FlintTypeParam unit_i_activation);
+extern FlintType krui_getUnitOutput(int UnitNo);
+extern krui_err  krui_setUnitOutput(int unit_no, FlintTypeParam unit_output);
+extern FlintType krui_getUnitBias(int UnitNo);
+extern void      krui_setUnitBias(int UnitNo, FlintTypeParam unit_bias);
+extern FlintType krui_getUnitValueA(int UnitNo);
+extern void      krui_setUnitValueA(int UnitNo, FlintTypeParam unit_valueA);
+extern int       krui_getUnitSubnetNo(int UnitNo);
+extern void      krui_setUnitSubnetNo(int UnitNo, int subnet_no);
+extern unsigned short	krui_getUnitLayerNo(int UnitNo);
+extern void      krui_setUnitLayerNo(int UnitNo, int layer_no);
+extern void      krui_getUnitPosition(int UnitNo, struct PosType *position);
+extern void      krui_setUnitPosition(int UnitNo, struct PosType *position);
+extern int       krui_getUnitNoAtPosition(struct PosType *position, 
+					  int subnet_no);
+extern int       krui_getUnitNoNearPosition(struct PosType *position, 
+					    int subnet_no,
+					    int range, int gridWidth);
+extern int       krui_getUnitTType(int unit_no);
+extern krui_err  krui_setUnitTType(int unit_no, int UnitTType);
+extern krui_err  krui_freezeUnit(int unit_no);
+extern krui_err  krui_unfreezeUnit(int unit_no);
+extern bool      krui_isUnitFrozen(int unit_no);
+extern int       krui_getUnitInputType(int unit_no);
+extern int       krui_createDefaultUnit(void);
+extern int       krui_createUnit(char *unit_name, char *out_func_name, 
+				 char *act_func_name, FlintTypeParam i_act, 
+				 FlintTypeParam bias);
+extern krui_err  krui_deleteUnit(int unit_no);
+extern krui_err  krui_deleteUnitList(int no_of_units, int unit_list[]);
+extern int       krui_createFTypeUnit(char *Ftype_symbol);
+extern krui_err  krui_setUnitFType(int unit_no, char *Ftype_symbol);
+extern int       krui_copyUnit(int unit_no, int copy_mode);
+extern bool      krui_setFirstFTypeEntry(void);
+extern bool      krui_setNextFTypeEntry(void);
+extern bool      krui_setFTypeEntry(char *Ftype_symbol);
+extern char     *krui_getFTypeName(void);
+extern krui_err  krui_setFTypeName(char *Ftype_symbol);
+extern char     *krui_getFTypeActFuncName(void);
+extern krui_err  krui_setFTypeActFunc(char *act_func_name);
+extern krui_err  krui_setFTypeOutFunc(char *out_func_name);
+extern bool      krui_setFirstFTypeSite(void);
+extern bool      krui_setNextFTypeSite(void);
+extern char     *krui_getFTypeSiteName(void);
+extern krui_err  krui_setFTypeSiteName(char *FType_site_name);
+extern krui_err  krui_createFTypeEntry(char *Ftype_symbol, char *act_func_name,
+				       char *out_func_name, int no_of_sites, 
+				       char **array_of_site_names);
+extern krui_err  krui_deleteFTypeEntry(char *Ftype_symbol);
+extern int       krui_getNoOfFunctions(void);
+extern void      krui_getFuncInfo(int func_no, char **func_name,int *func_type);
+extern bool      krui_isFunction(char *func_name, int func_type);
+extern bool      krui_getFuncParamInfo(char *func_name, int func_type, 
+				   int *no_of_input_params, 
+				   int *no_of_output_params);
+extern bool      krui_getFirstSiteTableEntry(char **site_name,char **site_func);
+extern bool      krui_getNextSiteTableEntry(char **site_name, char **site_func);
+extern char     *krui_getSiteTableFuncName(char *site_name);
+extern krui_err  krui_createSiteTableEntry(char *site_name, char *site_func);
+extern krui_err  krui_changeSiteTableEntry(char *old_site_name, 
+					   char *new_site_name, 
+					   char *new_site_func);
+extern krui_err  krui_deleteSiteTableEntry(char *site_name);
+extern bool      krui_setFirstSite(void);
+extern bool      krui_setNextSite(void);
+extern krui_err  krui_setSite(char *site_name);
+extern FlintType krui_getSiteValue(void);
+extern char     *krui_getSiteName(void);
+extern krui_err  krui_setSiteName(char *site_name);
+extern char     *krui_getSiteFuncName(void);
+extern krui_err  krui_addSite(char *site_name);
+extern bool      krui_deleteSite(void);
+extern int       krui_getFirstPredUnit(FlintType *strength);
+extern int       krui_getFirstPredUnitAndData(FlintType *strength,float *val_a,float *val_b, float *val_c);
+extern int       krui_getNextPredUnit(FlintType *strength);
+extern int       krui_getNextPredUnitAndData(FlintType *strength,float *val_a,float *val_b, float *val_c);
+extern int       krui_getCurrentPredUnit(FlintType *strength);
+extern int       krui_getFirstSuccUnit(int source_unit_no, FlintType *weight);
+extern int       krui_getNextSuccUnit(FlintType *weight);
+extern bool      krui_areConnected(int source_unit_no, int target_unit_no);
+extern bool      krui_areConnectedWeight(int source_unit_no,int target_unit_no, 
+					 FlintType *weight);
+extern bool      krui_isConnected(int source_unit_no);
+extern FlintType krui_getLinkWeight(void);
+extern void      krui_setLinkWeight(FlintTypeParam weight);
+extern krui_err  krui_createLink(int source_unit_no, FlintTypeParam weight);
+extern struct Link*  krui_createLinkWithAdditionalParameters
+      (int source_unit_no, FlintTypeParam weight,float val_a,float val_b,float val_c);
+extern krui_err  krui_deleteLink(void);
+extern krui_err  krui_deleteAllInputLinks(void);
+extern krui_err  krui_deleteAllOutputLinks(void);
+
+extern void      krui_jogWeights(FlintTypeParam minus, FlintTypeParam plus);
+extern krui_err  krui_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus,
+				     FlintTypeParam mincorr);
+extern krui_err  krui_updateSingleUnit(int unit_no);
+extern char     *krui_getUpdateFunc(void);
+extern krui_err  krui_setUpdateFunc(char *update_func);
+extern krui_err  krui_setRemapFunc(char *name, float *params);
+extern krui_err  krui_updateNet(float *parameterInArray, int NoOfInParams);
+extern char     *krui_getInitialisationFunc(void);
+extern krui_err  krui_setInitialisationFunc(char *initialisation_func);
+extern krui_err  krui_initializeNet(float *parameterInArray, int NoOfInParams);
+
+extern char     *krui_getLearnFunc(void);
+extern krui_err  krui_setLearnFunc(char *learning_func);
+extern krui_err  krui_trainNetwork(NetLearnParameters *parameters);
+extern krui_err  krui_getNetworkErrorArray(double **learnErrors,int **atEpoch,
+					   int *noOfErrors);
+extern krui_err  krui_stopTraining(void);
+extern krui_err  krui_learnAllPatterns(float *parameterInArray,int NoOfInParams,
+				       float **parameterOutArray, 
+				       int *NoOfOutParams);
+extern krui_err  krui_testAllPatterns(float *parameterInArray, int NoOfInParams,
+				      float **parameterOutArray, 
+				      int *NoOfOutParams);
+extern krui_err  krui_learnSinglePattern(int pattern_no,float *parameterInArray,
+					 int NoOfInParams, 
+					 float **parameterOutArray, 
+					 int *NoOfOutParams);
+extern krui_err  krui_testSinglePattern(int pattern_no, float *parameterInArray,
+				        int NoOfInParams, 
+				        float **parameterOutArray, 
+				        int *NoOfOutParams);
+extern int       krui_checkPruning (void);
+extern krui_err  krui_learnAllPatternsFF(float *parameterInArray, 
+					 int NoOfInParams, 
+					 float **parameterOutArray, 
+					 int *NoOfOutParams);
+extern krui_err  krui_learnSinglePatternFF(int pattern_no, 
+					   float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray, 
+					   int *NoOfOutParams);
+extern krui_err  krui_setClassDistribution(unsigned int *classDist);
+extern krui_err  krui_setClassInfo(char *name);
+extern krui_err  krui_useClassDistribution(bool use_it);
+extern char     *krui_getPrunFunc (void);
+extern char     *krui_getFFLearnFunc (void);
+extern krui_err  krui_setFFLearnFunc (char *FF_learning_func);
+extern krui_err  krui_setPrunFunc (char *pruning_func);
+extern krui_err  krui_showPattern(int mode);
+extern krui_err  krui_allocNewPatternSet(int *set_no);
+extern krui_err  krui_newPattern(void);
+extern krui_err  krui_setPatternNo(int pattern_no);
+extern krui_err  krui_getPatternNo(void);
+extern krui_err  krui_deletePattern(void);
+extern krui_err  krui_modifyPattern(void);
+extern void      krui_deleteAllPatterns(void);
+extern krui_err  krui_shufflePatterns(bool on_or_off);
+extern krui_err  krui_shuffleSubPatterns(bool on_or_off);
+extern int       krui_getNoOfPatterns(void);
+extern int       krui_getTotalNoOfSubPatterns(void);
+extern krui_err  krui_loadNewPatterns(char *filename, int *number);
+extern krui_err  krui_setCurrPatSet(int number);
+extern krui_err  krui_saveNewPatterns(char *filename, int number);
+extern krui_err  krui_deletePatSet(int number);
+extern krui_err  krui_GetPatInfo(pattern_set_info *set_info, 
+				 pattern_descriptor *pat_info);
+extern krui_err  krui_DefShowSubPat(int *insize, int *outsize, 
+				    int *inpos, int *outpos);
+extern krui_err  krui_DefTrainSubPat(int *insize, int *outsize,
+				     int *instep, int *outstep, 
+				     int *max_n_pos);
+extern krui_err  krui_AlignSubPat(int *inpos, int *outpos, int *no);
+extern krui_err  krui_GetShapeOfSubPattern(int *insize, int *outsize, 
+					   int *inpos, int *outpos, int n_pos);
+extern krui_err  krui_saveNet(char *filename, char *netname);
+extern krui_err  krui_loadNet(char *filename, char **netname);
+extern krui_err  krui_saveResultParam(char *filename, bool create, 
+				      int startpattern, int endpattern, 
+				      bool includeinput, bool includeoutput,
+				      float *Update_param_array,
+				      int NoOfUpdateParam);
+extern krui_err  krui_allocateUnits(int no_of_units);
+extern void      krui_deleteNet(void);
+extern bool      krui_getFirstSymbolTableEntry(char **symbol_name, 
+					       int *symbol_type);
+extern bool      krui_getNextSymbolTableEntry(char **symbol_name, 
+					      int *symbol_type);
+extern bool      krui_symbolSearch(char *symbol, int symbol_type);
+extern char     *krui_getVersion(void);
+extern void      krui_getNetInfo(int *no_of_sites, int *no_of_links, 
+				 int *no_of_STable_entries, 
+				 int *no_of_FTable_entries);
+extern void      krui_getMemoryManagerInfo(int *unit_bytes, int *site_bytes, 
+					   int *link_bytes, int *NTable_bytes, 
+					   int *STable_bytes,int *FTable_bytes);
+extern void      krui_getUnitDefaults(FlintType *act, FlintType *bias, int *st, 
+				      int *subnet_no, int *layer_no, 
+				      char **act_func, char **out_func);
+extern krui_err  krui_setUnitDefaults(FlintTypeParam act, FlintTypeParam bias, 
+				      int st, int subnet_no, int layer_no, 
+				      char *act_func, char *out_func);
+extern void      krui_resetNet(void);
+extern void      krui_setSeedNo(long int seed);
+extern int       krui_getNoOfInputUnits(void);
+extern int       krui_getNoOfOutputUnits(void);
+extern int       krui_getNoOfTTypeUnits(int UnitTType);
+extern int       krui_getNoOfSpecialInputUnits(void);
+extern int       krui_getNoOfSpecialOutputUnits(void);
+extern krui_err  krui_xyTransTable(int op, int *x, int *y, int z);
+extern krui_err  krui_getUnitCenters(int unit_no, int center_no, 
+				     struct PositionVector **unit_center);
+extern krui_err  krui_setUnitCenters(int unit_no, int center_no, 
+				     struct PositionVector *unit_center);
+extern char     *krui_error(int error_code);
+extern float     krui_NA_Error(int currentPattern, int error_unit, int error, 
+			       bool ave);
+
+extern float krui_getVariance (void);
+extern int krui_countLinks(void);
+
+#ifdef MASPAR_KERNEL
+
+extern krui_err  krui_MasPar( mode );
+extern krui_err  krui_getMasParStatus(void);
+extern krui_err  krui_MasParBenchmark( func_type, cycles, result );
+
+#endif
+
+extern krui_err  krui_setSpecialNetworkType(int net_type);
+extern int       krui_getSpecialNetworkType(void);
+extern int       krui_initInversion(void);
+extern void      krui_inv_forwardPass(struct UnitList *inputs);
+extern double    krui_inv_backwardPass(float learn, float delta_max, 
+				       int *err_units, float ratio,
+				       struct UnitList *inputs,
+				       struct UnitList *outputs);
+extern void      krui_kohonen_SetExtraParameter(int x);
+extern void      krui_spanning_tree(void);
+extern void      krui_cc_updatePosOfSpecialUnits(void);
+extern krui_err  krui_cc_deleteAllSpecialUnits(void);
+extern int       krui_getErrorCode(void);
+extern krui_err  krui_setErrorHandler(void(* error_Handler )(int));
+extern void      krui_execHandler(int error_code);
+
+
+/*
+#ifdef __MSDOS__
+
+#ifndef  KR_TYPES
+#undef  int
+#endif
+
+#endif
+*/
+
+
+
+
+
+#endif 
+
diff -Naur snort-2.3.3/src/kernel_snns/kr_ui.ph snort-2.3.3.new/src/kernel_snns/kr_ui.ph
--- snort-2.3.3/src/kernel_snns/kr_ui.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/kr_ui.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,320 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/kr_ui.ph,v $
+  SHORTNAME      : kr_ui.ph
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel User Interface Function Prototypes
+  NOTES          :
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 27.02.90
+ 
+  CHANGED BY     : Michael Vogt, Guenter Mamier, Christine Bagdi
+  RCS VERSION    : $Revision: 2.25 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:17 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+#ifndef _KR_UI_DEFINED_
+#define  _KR_UI_DEFINED_
+
+/* begin global definition section */
+
+
+#include "krui_typ.h"	/*  Interface function prototypes  */
+
+/*
+#ifdef __MSDOS__
+
+#ifndef  int
+#define  int long
+#endif
+
+#endif
+*/
+
+void (*krui_errorHandler)(int)=NULL;
+int krui_error_code;
+bool rpckernel=FALSE;
+
+int  krui_getNoOfUnits(void);
+int  krui_getFirstUnit(void);
+int  krui_getNextUnit(void);
+int  krui_getCurrentUnit(void);
+krui_err  krui_setCurrentUnit(int unit_no);
+char  *krui_getUnitName(int UnitNo);
+krui_err  krui_setUnitName(int unit_no, char *unit_name);
+int  krui_searchUnitName(char *unit_name);
+int  krui_searchNextUnitName(void);
+char  *krui_getUnitOutFuncName(int UnitNo);
+krui_err  krui_setUnitOutFunc(int unit_no, char *unitOutFuncName);
+char  *krui_getUnitActFuncName(int UnitNo);
+krui_err  krui_setUnitActFunc(int unit_no, char *unitActFuncName);
+char  *krui_getUnitFTypeName(int UnitNo);
+FlintType  krui_getUnitActivation(int UnitNo);
+krui_err  krui_setUnitActivation(int UnitNo, FlintTypeParam unit_activation);
+FlintType  krui_getUnitInitialActivation(int UnitNo);
+void  krui_setUnitInitialActivation(int UnitNo, FlintTypeParam unit_i_activation);
+FlintType  krui_getUnitOutput(int UnitNo);
+krui_err  krui_setUnitOutput(int unit_no, FlintTypeParam unit_output);
+FlintType  krui_getUnitBias(int UnitNo);
+void  krui_setUnitBias(int UnitNo, FlintTypeParam unit_bias);
+FlintType  krui_getUnitValueA(int UnitNo);
+void  krui_setUnitValueA(int UnitNo, FlintTypeParam unit_valueA);
+int  krui_getUnitSubnetNo(int UnitNo);
+void  krui_setUnitSubnetNo(int UnitNo, int subnet_no);
+unsigned short	krui_getUnitLayerNo(int UnitNo);
+void    krui_setUnitLayerNo(int UnitNo, int layer_no);
+void    krui_getUnitPosition(int UnitNo, struct PosType *position);
+void    krui_setUnitPosition(int UnitNo, struct PosType *position);
+int   krui_getUnitNoAtPosition(struct PosType *position, int subnet_no);
+int  krui_getUnitNoNearPosition(struct PosType *position, int subnet_no, int range, int gridWidth);
+int  krui_getUnitTType(int unit_no);
+krui_err  krui_setUnitTType(int unit_no, int UnitTType);
+krui_err  krui_freezeUnit(int unit_no);
+krui_err  krui_unfreezeUnit(int unit_no);
+bool  krui_isUnitFrozen(int unit_no);
+int  krui_getUnitInputType(int unit_no);
+int  krui_createDefaultUnit(void);
+int  krui_createUnit(char *unit_name, char *out_func_name, char *act_func_name, FlintTypeParam i_act, FlintTypeParam bias);
+krui_err  krui_deleteUnit(int unit_no);
+krui_err  krui_deleteUnitList(int no_of_units, int unit_list[]);
+int  krui_createFTypeUnit(char *Ftype_symbol);
+krui_err  krui_setUnitFType(int unit_no, char *Ftype_symbol);
+int   krui_copyUnit(int unit_no, int copy_mode);
+bool  krui_setFirstFTypeEntry(void);
+bool  krui_setNextFTypeEntry(void);
+bool  krui_setFTypeEntry(char *Ftype_symbol);
+char  *krui_getFTypeName(void);
+krui_err  krui_setFTypeName(char *Ftype_symbol);
+char  *krui_getFTypeActFuncName(void);
+krui_err  krui_setFTypeActFunc(char *act_func_name);
+krui_err   krui_setFTypeOutFunc(char *out_func_name);
+bool  krui_setFirstFTypeSite(void);
+bool  krui_setNextFTypeSite(void);
+char  *krui_getFTypeSiteName(void);
+krui_err  krui_setFTypeSiteName(char *FType_site_name);
+krui_err  krui_createFTypeEntry(char *Ftype_symbol, char *act_func_name, char *out_func_name, int no_of_sites, char **array_of_site_names);
+krui_err    krui_deleteFTypeEntry(char *Ftype_symbol);
+int  krui_getNoOfFunctions(void);
+void  krui_getFuncInfo(int func_no, char **func_name, int *func_type);
+bool  krui_isFunction(char *func_name, int func_type);
+bool  krui_getFuncParamInfo(char *func_name, int func_type, int *no_of_input_params, int *no_of_output_params);
+bool   krui_getFirstSiteTableEntry(char **site_name, char **site_func);
+bool  krui_getNextSiteTableEntry(char **site_name, char **site_func);
+char  *krui_getSiteTableFuncName(char *site_name);
+krui_err  krui_createSiteTableEntry(char *site_name, char *site_func);
+krui_err  krui_changeSiteTableEntry(char *old_site_name, char *new_site_name, char *new_site_func);
+krui_err  krui_deleteSiteTableEntry(char *site_name);
+bool  krui_setFirstSite(void);
+bool  krui_setNextSite(void);
+krui_err  krui_setSite(char *site_name);
+FlintType   krui_getSiteValue(void);
+char  *krui_getSiteName(void);
+krui_err  krui_setSiteName(char *site_name);
+char  *krui_getSiteFuncName(void);
+krui_err  krui_addSite(char *site_name);
+bool  krui_deleteSite(void);
+int  krui_getFirstPredUnit(FlintType *strength);
+int  krui_getNextPredUnit(FlintType *strength);
+int  krui_getFirstPredUnitAndData(FlintType *strength,float *val_a,float *val_b, float *val_c);
+int  krui_getNextPredUnitAndData(FlintType *strength,float *val_a,float *val_b, float *val_c);
+int  krui_getCurrentPredUnit(FlintType *strength);
+int  krui_getFirstSuccUnit(int source_unit_no, FlintType *weight);
+int  krui_getNextSuccUnit(FlintType *weight);
+bool  krui_areConnected(int source_unit_no, int target_unit_no);
+bool  krui_areConnectedWeight(int source_unit_no, int target_unit_no, FlintType *weight);
+bool  krui_isConnected(int source_unit_no);
+FlintType  krui_getLinkWeight(void);
+void  krui_setLinkWeight(FlintTypeParam weight);
+krui_err  krui_createLink(int source_unit_no, FlintTypeParam weight);
+struct Link*  krui_createLinkWithAdditionalParameters
+      (int source_unit_no, FlintTypeParam weight,float val_a,float val_b,float val_c);
+krui_err  krui_deleteLink(void);
+krui_err  krui_deleteAllInputLinks(void);
+krui_err  krui_deleteAllOutputLinks(void);
+
+void  krui_jogWeights(FlintTypeParam minus, FlintTypeParam plus);
+krui_err  krui_jogCorrWeights(FlintTypeParam minus, FlintTypeParam plus,
+				  FlintTypeParam mincorr);
+krui_err   krui_updateSingleUnit(int unit_no);
+char  *krui_getUpdateFunc(void);
+krui_err   krui_setUpdateFunc(char *update_func);
+krui_err krui_setRemapFunc(char *name, float *params);
+krui_err  krui_updateNet(float *parameterInArray, int NoOfInParams);
+char  *krui_getInitialisationFunc(void);
+krui_err   krui_setInitialisationFunc(char *initialisation_func);
+krui_err  krui_initializeNet(float *parameterInArray, int NoOfInParams);
+
+char  *krui_getLearnFunc(void);
+krui_err   krui_setLearnFunc(char *learning_func);
+krui_err krui_trainNetwork(NetLearnParameters *parameters);
+krui_err krui_getNetworkErrorArray(double **learnErrors,int **atEpoch,int *noOfErrors);
+krui_err krui_stopTraining(void);
+krui_err   krui_learnAllPatterns(float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams);
+krui_err   krui_testAllPatterns(float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams); /* joe */
+krui_err   krui_learnSinglePattern(int pattern_no, float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams);
+krui_err   krui_testSinglePattern(int pattern_no, float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams); /* joe */
+int krui_checkPruning ();
+krui_err   krui_learnAllPatternsFF(float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams);
+krui_err   krui_learnSinglePatternFF(int pattern_no, float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams);
+
+char *krui_getPrunFunc (void);
+krui_err krui_setPrunFunc (char *pruning_func);
+
+extern char *krui_getFFLearnFunc (void);
+extern krui_err krui_setFFLearnFunc (char *FF_learning_func);
+
+krui_err  krui_setClassDistribution(unsigned int *classDist);
+krui_err  krui_setClassInfo(char *name);
+krui_err  krui_useClassDistribution(bool use_it);
+krui_err  krui_showPattern(int mode);
+krui_err  krui_allocNewPatternSet(int *set_no);
+krui_err  krui_newPattern(void);
+krui_err  krui_setPatternNo(int pattern_no);
+krui_err  krui_getPatternNo(void);
+krui_err  krui_deletePattern(void);
+krui_err  krui_modifyPattern(void);
+void  krui_deleteAllPatterns(void);
+krui_err  krui_shufflePatterns(bool on_or_off);
+krui_err  krui_shuffleSubPatterns(bool on_or_off);
+int  krui_getNoOfPatterns(void);
+int  krui_getTotalNoOfSubPatterns(void);
+
+krui_err  krui_loadNewPatterns(char *filename, int *number);
+krui_err  krui_setCurrPatSet(int number);
+krui_err  krui_saveNewPatterns(char *filename, int number);
+krui_err  krui_deletePatSet(int number);
+krui_err  krui_GetPatInfo(pattern_set_info *set_info, 
+			  pattern_descriptor *pat_info);
+krui_err  krui_DefShowSubPat(int *insize, int *outsize, 
+			     int *inpos, int *outpos);
+krui_err  krui_DefTrainSubPat(int *insize, int *outsize,
+			      int *instep, int *outstep, int *max_n_pos);
+krui_err  krui_AlignSubPat(int *inpos, int *outpos, int *no);
+krui_err  krui_GetShapeOfSubPattern(int *insize, int *outsize, 
+				    int *inpos, int *outpos, int n_pos);
+
+krui_err  krui_saveNet(char *filename, char *netname);
+krui_err  krui_loadNet(char *filename, char **netname);
+krui_err  krui_saveResultParam(char *filename, bool create, 
+			       int startpattern, int endpattern, 
+			       bool includeinput, bool includeoutput,
+			       float *Update_param_array, int NoOfUpdateParam);
+krui_err  krui_allocateUnits(int no_of_units);
+void  krui_deleteNet(void);
+bool  krui_getFirstSymbolTableEntry(char **symbol_name, int *symbol_type);
+bool  krui_getNextSymbolTableEntry(char **symbol_name, int *symbol_type);
+bool  krui_symbolSearch(char *symbol, int symbol_type);
+char  *krui_getVersion(void);
+void  krui_getNetInfo(int *no_of_sites, int *no_of_links, int *no_of_STable_entries, int *no_of_FTable_entries);
+void  krui_getMemoryManagerInfo(int *unit_bytes, int *site_bytes, int *link_bytes, int *NTable_bytes, int *STable_bytes, int *FTable_bytes);
+void  krui_getUnitDefaults(FlintType *act, FlintType *bias, int *st, int *subnet_no, int *layer_no, char **act_func, char **out_func);
+krui_err  krui_setUnitDefaults(FlintTypeParam act, FlintTypeParam bias, int st, int subnet_no, int layer_no, char *act_func, char *out_func);
+void  krui_resetNet(void);
+void  krui_setSeedNo(long int seed);
+int  krui_getNoOfInputUnits(void);
+int  krui_getNoOfOutputUnits(void);
+int  krui_getNoOfTTypeUnits(int UnitTType);
+int  krui_getNoOfSpecialInputUnits(void);
+int  krui_getNoOfSpecialOutputUnits(void);
+
+
+
+krui_err  krui_xyTransTable(int op, int *x, int *y, int z);
+krui_err  krui_getUnitCenters(int unit_no, int center_no, struct PositionVector **unit_center);
+krui_err  krui_setUnitCenters(int unit_no, int center_no, struct PositionVector *unit_center);
+
+
+
+char  *krui_error(int error_code);
+
+/* for statistics
+ */
+float krui_getVariance (void);
+int krui_countLinks(void);
+
+/* for the network-analyzer tool
+*/
+float krui_NA_Error(int currentPattern, int error_unit, int error, bool ave);
+
+#ifdef MASPAR_KERNEL
+
+krui_err  krui_MasPar( mode );
+krui_err  krui_getMasParStatus(void);
+krui_err  krui_MasParBenchmark( func_type, cycles, result );
+
+#endif
+
+krui_err  krui_setSpecialNetworkType(int net_type);
+int  krui_getSpecialNetworkType(void);
+void krui_kohonen_SetExtraParameter(int x);
+void krui_spanning_tree(void);
+void krui_cc_updatePosOfSpecialUnits(void);
+krui_err krui_cc_deleteAllSpecialUnits(void);
+
+int krui_getErrorCode(void);
+krui_err krui_setErrorHandler(void(* error_Handler )(int));
+void krui_execHandler(int error_code);
+
+
+/*
+#ifdef __MSDOS__
+
+#ifndef  KR_TYPES
+#undef  int
+#endif
+
+#endif
+*/
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+static char  *krui_topo_err_msg(void);
+
+/*#################################################
+
+GROUP: Local Var's
+
+#################################################*/
+
+static int  UICurrentNameSearchUnitNo = 0;
+static struct Site  *UICurrentFtypeSite = NULL;
+static struct FtypeUnitStruct  *UICurrentFtypeEntry = NULL;
+static char  *UICurrentNameSearchUnitSymbolPtr = NULL;
+
+static bool dotraining; /* If True => train Network */
+static int noOfStoredErrors=0;
+static double storedLearnErrors[NO_OF_STORED_ERRORS+1];
+static int storedAtEpoch[NO_OF_STORED_ERRORS+1];
+
+/*#################################################
+
+GROUP: Macros
+
+#################################################*/
+
+/*  Check operation for compatibility with MasPar parallel 
+    network implementation
+*/
+#ifdef MASPAR_KERNEL
+
+#define  MASPAR_FF1_VALIDATE_OP \
+if (specialNetworkType == NET_TYPE_FF1)\
+  { KernelErrorCode = KRERR_MODE_FF1_INVALID_OP;\
+    return( KRERR_MODE_FF1_INVALID_OP ); }\
+
+#endif
+
+
+
+
+/* end private definition section */
+
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/krui_typ.h snort-2.3.3.new/src/kernel_snns/krui_typ.h
--- snort-2.3.3/src/kernel_snns/krui_typ.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/krui_typ.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1579 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/krui_typ.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+ 
+  PURPOSE        : SNNS-Kernel User Interface Function Prototypes
+  NOTES          : ANSI-C only
+ 
+  AUTHOR         : Niels Mache
+  DATE           : 27.02.90
+ 
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:20 $
+ 
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+ 
+******************************************************************************/
+
+
+/* -----------------------    THAT'S NEW:   -------------------------------
+
+
+Development History of the SNNS Kernel (reverse order):
+
+******************************************************************************
+
+22.07.92:
+   NEW FUNCTIONS:
+     A set of new activation/initialization/learning functions for make use of
+     Radial Basis Functions. Changes in:
+     trans_f.c
+     init_f.c
+     learn_f.c
+     func_tbl.c
+   NEW MODULES:
+     matrix.c
+     matrix.h
+      - general purpose matrix operations
+     
+*******************************************************************************
+
+
+*******************************************************************************
+
+22.05.92:
+   NEW FUNCTIONS:
+     krui_saveResult( ... )
+      - saves a result file. Depends on the current loaded net and patterns
+
+*******************************************************************************
+
+*******************************************************************************
+
+SNNS Kernel Version 2.1 with parallel kernel capability:
+
+1.01.92:
+   CHANGES:
+     krui_deleteLink(),
+     krui_deleteAllInputLinks(),
+     krui_deleteAllOutputLinks()
+       now returns and error code.
+
+     krui_getCurrentSuccUnit( ... )
+       has been removed from the interface.
+
+   NEW FUNCTIONS:
+     krui_setSpecialNetworkType( ... )
+      - sets the topologic type of the current network.
+
+     krui_getSpecialNetworkType()
+      - returns the special topologic type of the current network, if set.
+
+     krui_MasPar( ... )
+      - connects and disconnects the MasPar.
+
+     krui_getMasParStatus()
+      - returns the status of the MasPar.
+
+     krui_newVectorPatternPair( ... )
+      - creates a new pattern vector.
+
+     krui_getPatternArrays( ... )
+      - determines the addresses of the internal pattern arrays.
+
+     krui_allocatePatterns( ... )
+      - allocate pattern pairs.
+
+     krui_setNoOfPatterns( ... )
+      - set the number of available pattern pairs.
+
+
+*******************************************************************************
+
+SNNS Kernel Version 2.0:
+
+21.08.91:
+   NEW FUNCTIONS:
+     krui_searchUnitName( ... )
+       - searches for a unit with the given name
+     krui_searchNextUnitName()
+       - searches for the next unit with the given name
+     krui_testNet( ... )
+       - calculates the network error whith a given pattern
+     krui_getNoOfTTypeUnits( ... )
+       - returns the no. of units of the specified topologic type
+       (should now be used instead of "krui_getNoOfInputUnits" and
+	"krui_getNoOfOutputUnits")
+
+     krui_getFuncParamInfo( ... )
+       - returns the no. of input and output parameters of the given function
+
+
+   NEW FUNCTIONS for the 3D-Kernel:
+     krui_getXYTransTable( ... )
+       - returns the pointer of the XY-Translation Table
+
+     krui_getUnitCenters( ... )
+       - returns the 3D transform center of the specified unit and center number
+
+     krui_setUnitCenters( ... )
+       - sets the 3D transform center of the specified unit and center number
+
+
+*******************************************************************************
+
+SNNS Kernel Version 1.3:
+
+26.04.91:
+   CHANGES:
+      krui_showPattern( mode ) 
+      - has now only one parameter <mode> (the parameter <pattern_no> has left)
+        krui_showPattern(...) shows now the CURRENT pattern.
+        
+      - The pattern file format has been changed but the scanner is downward kompatible.
+        The new file format has now a SNNS-header with time stamp and is better readable.
+        Comments (beginning with a #) are also possible.
+
+   NEW FUNCTIONS:
+     krui_setPatternNo( ... )
+       - sets the current pattern for access
+     krui_deletePattern()
+       - deletes the current pattern
+     krui_modifyPattern()
+       - modifies the current pattern
+
+
+
+*******************************************************************************
+
+SNNS Kernel Version 1.2:
+
+18.03.91:
+   CHANGES:
+     krui_randomizeWeights( ... )  
+       - has been removed from the user interface
+     krui_updateNet( ... )
+       - parameters of krui_updateNet has changed
+
+   NEW FUNCTIONS:
+     krui_setInitialisationFunc( ... )
+       - sets the initialisation function (i.e. randomize weights)
+     krui_getInitialisationFunc()
+       - returns the current initialisation function
+     krui_initializeNet( ... )
+       - initializes the net with the current initialisation function
+     krui_setUpdateFunc( ... )
+       - sets the update function (i.e. serial propagation)
+     krui_getUpdateFunc()
+       - returns the current update function
+     krui_updateNet( ... )
+       - updates the network
+
+*******************************************************************************
+
+
+
+*******************************************************************************
+
+SNNS Kernel Version 1.1:
+
+19.12.90:
+   CHANGES:
+     krui_learnAllPatterns( ... ) and krui_learnSinglePattern( ... )
+     have parameter arrays now. The return type has changed to krui_err. 
+
+   NEW FUNCTIONS:
+     krui_getLearnFunc( ... )
+       - Returns the name of the current learning function
+     krui_setLearnFunc( ... )
+       - Changes the learning function
+
+        
+*******************************************************************************
+
+###############################################################################
+
+18.10.90  SNNS Kernel Version 1.0
+
+###############################################################################
+
+
+18.10.90:
+   NEW FUNCTIONS:
+     krui_getUnitNoNearPosition( ... )
+       - Returns the unit no. near the given position 
+
+
+04.10.90:
+   CHANGES:
+     krui_getUnitNoAtPosition( ... )  needs now another parameter <subnet_no>.
+
+
+25.09.90:
+   NEW FUNCTIONS:
+     krui_randomizeWeights( ... )
+       - Initializes connection weights with uniform distributed random values.
+
+     krui_jogWeights( ... )
+       - Add uniform distributed random values to connection weights.
+
+     krui_areConnected( ... )
+       - Determines a connection AND the attached site between two units
+         and returns the connection weight.
+
+
+05.06.90:
+   NEW FUNCTIONS:
+     krui_setSite( char    *site_name )
+       -  initializes the given site at the current unit.
+
+
+04.06.90:
+   All Symbols (Unit, Site, FType) will be spelling checked now.
+   Symbols must match ([A-Za-z]^[|, ]*).
+
+   krui_loadNet( ... )
+    - now admit user friendly free style format
+    - loads default presettings
+
+   krui_saveNet( ... )  now saves default presettings.
+
+   NEW FUNCTIONS:  krui_getUnitDefaults( ... ) and
+                   krui_setUnitDefaults( ... )
+
+                   - Determines and changes the default presettings.
+                   NOTE: Presettings may now be changed dynamically, i.e
+                         during creation of units.
+
+
+29.05.90:
+   NEW FUNCTIONS:
+      krui_getMemoryManagerInfo( ... )
+       - returns the number of ALLOCATED (not the number of USED) bytes
+         for the units, sites, name-table and site-table.
+
+      krui_getNetInfo( ... )
+       -  returns miscellanous information about the current network.
+
+      krui_getVersion()
+       -  returns the current version of the SNNS-Kernel.
+
+
+*******************************************************************************
+
+
+    For additional type definitions and constants see include file "glob_typ.h" !
+    For kernel user interface function prototypes use this file !
+*/
+
+
+
+/*#################################################
+
+GROUP: Unit Functions
+
+#################################################*/
+
+
+int  krui_getNoOfUnits( void );
+/*  Returns the number of units used by the network.
+*/
+
+int  krui_getFirstUnit( void );
+/*  Initializes the first available unit for access. If the unit has sites, the
+    first site will be set to the current site.
+    Returns the unit no. of the first unit or 0 if no units available.
+*/
+
+int  krui_getNextUnit( void );
+/*  Initializes the next available unit for access. If the unit has sites, the
+    first site will be set to the current site.
+    Returns the unit no. of the next unit or 0 if no more units available.
+*/
+
+int  krui_getCurrentUnit( void );
+     /*  Returns the no. of the current unit or 0 if no units available.
+     */
+
+krui_err    krui_setCurrentUnit( int  UnitNo );
+/*  Initializes a unit for access. If the unit has sites, the first site
+    will be set to the current site.
+    Returns error code if the given unit doesn't exist, 0 otherwise.
+*/
+
+
+char  *krui_getUnitName( int  UnitNo );
+/*  Returns the name of the unit. (NULL if not available).
+*/
+
+krui_err  krui_setUnitName( int  UnitNo, char * unit_name );
+/*  Sets the name of the unit <UnitNo>.
+    If the unit_name pointer is NULL, the unit's symbol will be deleted.
+    Function has no effect on the current unit.
+    Returns error code if memory allocation fails, 0 otherwise.
+*/
+
+int  krui_searchUnitName( char  *unit_name );
+/*  Searches for a unit with the given name.
+    Returns the first unit no. if a unit with the given name was found,
+    0 otherwise.
+
+    Returns error code if no units defined.
+*/
+
+int  krui_searchNextUnitName( void );
+/*  Searches for the next unit with the given name.
+    Returns the next unit no. if a unit with the given name was found,
+    0 otherwise.
+
+NOTE: Call krui_searchUnitName( unit_name ) before calling krui_searchNextUnitName().
+
+Returns error code if no units defined.
+*/
+
+
+
+char  *krui_getUnitOutFuncName( int  UnitNo );
+/*  Returns the output function name of the unit.
+    Do not use invalid unit numbers!
+*/
+
+krui_err   krui_setUnitOutFunc( int  UnitNo, char *  unitOutFuncName );
+/*  The unit's FType will be set to 0, i.e. the
+    unit's functionality type will be deleted.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+NOTE: Returns 0, if the function is a valid output function,
+      error code otherwise.
+*/
+
+char  *krui_getUnitActFuncName( int  UnitNo );
+/*  Returns the activation function name of the unit.
+    Do not use invalid unit numbers!
+*/
+
+krui_err  krui_setUnitActFunc( int  UnitNo, char *  unitActFuncName );
+/*  The unit's FType will be set to 0, i.e. the
+    unit's functionality type will be deleted.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+NOTE: Returns 0, if the function is a valid activation function,
+      error code otherwise.
+*/
+
+
+char  *krui_getUnitFTypeName( int UnitNo );
+/*  Returns the functionality type name of the unit.
+    Function has no effect on the current unit.
+    Returns NULL if unit has no FType.
+    Do not use invalid unit numbers!
+*/
+
+
+FlintType   krui_getUnitActivation( int  UnitNo );
+/*  Returns the activation value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+krui_err  krui_setUnitActivation(int  UnitNo, FlintTypeParam  unit_activation);
+/*  Sets the activation value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+FlintType  krui_getUnitInitialActivation( int  UnitNo );
+/*  Returns the initial activation value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+void  krui_setUnitInitialActivation( int  UnitNo, FlintTypeParam  unit_i_activation );
+/*  Sets the initial activation value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+FlintType  krui_getUnitOutput( int  UnitNo );
+/*  Returns the output value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+krui_err  krui_setUnitOutput( int  UnitNo, FlintTypeParam  unit_output );
+/*  Sets the output value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+
+FlintType  krui_getUnitBias( int  UnitNo );
+/*  Returns the bias value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+void  krui_setUnitBias( int  UnitNo, FlintTypeParam  unit_bias );
+/*  Sets the bias value of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+
+int   krui_getUnitSubnetNo( int UnitNo );
+/*  Returns the subnet number of the unit.
+    Function has no effect on the current unit.
+NOTE: The range of the subnet no. is -32736...+32735
+    Do not use invalid unit numbers!
+*/
+
+void  krui_setUnitSubnetNo( int UnitNo, int  subnet_no);
+/*  Sets the subnet number of the unit.
+    Function has no effect on the current unit.
+NOTE: The range of the subnet no. is -32736...+32735
+    Do not use invalid unit numbers!
+*/
+
+unsigned short  krui_getUnitLayerNo( int UnitNo );
+/*  Returns the layer number of the unit.
+    Function has no effect on the current unit.
+NOTE: Bit fields are 16 bit integers
+    Do not use invalid unit numbers!
+*/
+
+void  krui_setUnitLayerNo( int UnitNo, int layer_bitField );
+/*  Sets the layer number of the unit.
+    Function has no effect on the current unit.
+NOTE: Bit fields are 16 bit integers
+    Do not use invalid unit numbers!
+*/
+
+void  krui_getUnitPosition( int  UnitNo, struct PosType  *position );
+/*  Returns the position of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+
+NOTE: See include file glob_typ.h for PosType definition !
+*/
+
+void  krui_setUnitPosition( int  UnitNo, struct PosType  *position );
+/*  Sets the position of the unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+
+NOTE: See include file glob_typ.h for PosType definition !
+*/
+
+
+int  krui_getUnitNoAtPosition( struct PosType  *position, int subnet_no );
+/*  Returns the unit no. at the given position and the specified
+    subnet no or 0, if no unit exists at this position.
+    Function has no effect on the current unit.
+
+NOTE: This function is slow because it uses linear search to
+      find the unit with the given position.
+
+REMARK: getUnitNoAtPosition is for downward compatibility only.
+        Do not use this function in future applications.
+*/
+
+int  krui_getUnitNoNearPosition( struct PosType  *position, int subnet_no ,
+                                 int range, int gridWidth );
+/*  Returns the unit no. near the given position and the specified
+    subnet no or 0, if no unit exists at this position.
+    Function has no effect on the current unit.
+
+NOTE: This function is slow because it uses linear search to
+      find the unit with the given position.
+*/
+
+
+/*  Functions for the 3D-Kernel  */
+krui_err  krui_getUnitCenters( int unit_no, int center_no, struct PositionVector  * *unit_center );
+/*  Returns the 3D transform center of the specified unit and center number.
+    Function has no effect on the current unit.
+    Returns error number if unit or center no. is invalid
+*/
+
+krui_err  krui_setUnitCenters( int unit_no, int center_no, struct PositionVector  *unit_center );
+/*  sets the 3D transform center of the specified unit and center number
+    Function has no effect on the current unit.
+    Returns error number if unit or center no. is invalid
+*/
+
+krui_err  krui_xyTransTable(int op, int *x, int *y, int z);
+/*  Returns the x y coordinate of the given z-value.
+    Returns error code if the SNNS-Kernel isn't a 3D-Kernel.
+*/
+
+
+
+
+
+int  krui_getUnitTType( int  UnitNo );
+/*  Returns the topologic type, i.e. input, output, hidden
+    Function has no effect on the current unit.
+
+NOTE: See include file glob_typ.h for TType constants !
+
+    Do not use invalid unit numbers!
+*/
+
+krui_err  krui_setUnitTType( int  UnitNo, int  UnitTType );
+/*  Sets the topologic type of the unit.
+    Function has no effect on the current unit.
+
+NOTE: See include file glob_typ.h for TType constants !
+
+    Returns error code if topologic type or unit number is invalid.
+*/
+
+krui_err  krui_freezeUnit( int  UnitNo );
+/*  Freezes the output of a unit, i.e. the unit is disabled.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+krui_err  krui_unfreezeUnit( int  UnitNo );
+/*  Disabels a previosly freezed unit.
+    Function has no effect on the current unit.
+    Do not use invalid unit numbers!
+*/
+
+bool  krui_isUnitFrozen( int  UnitNo );
+/*  Returns true, if unit is frozen
+    Do not use invalid unit numbers!
+*/
+
+
+int  krui_getUnitInputType( int UnitNo );
+/*  Returns the input type of the unit:
+     NO_INPUTS    : if the unit has not inputs (at least not now)
+     SITES        : if the unit has one or more sites (and no direct input links !)
+     DIRECT_LINKS : if the unit has direct input links (and no sites !)
+
+    Function has no effect on the current unit.
+
+NOTE: See include file glob_typ.h for input type constants !
+*/
+
+/*  *************************************   */
+
+int  krui_createDefaultUnit( void );
+/*  Creates a unit with default properties:
+    1. default activation and output functions
+    2. default activation and bias
+    3. default position, subnet and layer number
+    4. no functionality type
+    5. no sites
+    6. no inputs and outputs
+    7. no unit_name
+
+    Returns an (negative) error code, if memory allocation fails or
+    invalid functions occured. Returns (positive) unit number otherwise.
+    Function has no effect on the current unit.
+
+NOTE: See file "kr_def.h" for more details about default presettings.
+*/
+
+int  krui_createUnit( char  *unit_name, char  *out_func_name, char  *act_func_name,
+                      FlintTypeParam  i_act,  FlintTypeParam  bias);
+/*  Creates a user defined unit.
+    Returns an (negative) error code, if memory allocation fails or
+    invalid functions occured. Returns (positive) unit number otherwise.
+    Function has no effect on the current unit.
+
+    Unit has additional default settings:
+    1. default position, subnet and layer number
+    2. no functionality type
+    3. no sites
+    4. no inputs and outputs
+
+*/
+
+
+krui_err  krui_deleteUnit( int UnitNo );
+/*  Deletes a unit from network. Removes all links to other
+    units. Returns error code if unit doesn't exist.
+*/
+
+int  krui_createFTypeUnit( char *  FType_name);
+/*  creates a unit with FType properties, but:
+    1. no inputs and outputs
+    2. default position, subnet and layer
+
+    Returns the unit number or (negative) error code if memory allocation
+    fails or functionality type isn't defined.
+    Function has no effect on the current unit.
+*/
+
+
+krui_err  krui_setUnitFType( int  UnitNo, char *  FTypeName );
+/*  Changes the properties of unit <UnitNo> to FType properties.
+
+    Returns an error code if
+     - FType name doesn't exist or
+     - unit doesn't exist or
+     - memory allocation fails
+     otherwise 0.
+
+    Function has no effect on the current unit.
+*/
+
+
+int  krui_copyUnit( int  UnitNo, int  copy_mode);
+/*  Copy a given unit, according to the copy mode
+        1. copy unit (with it sites, if available) and input/output links
+        2. copy unit (with it sites, if available) and input links
+        3. copy unit (with it sites, if available) and output links
+        4. copy unit (with it sites, if available) but no input/output links
+
+    Returns the unit number of the new unit or error message < 0 , if errors occured.
+    Function has no effect on the current unit.
+
+NOTE: Copying of output links is slow.
+      If return code < 0, an error occured.
+
+      See include file glob_typ.h for copy mode constants !
+
+*/
+
+
+/*#################################################
+
+GROUP: Functions for manipulation of the Unit-Functionality-List
+REMEMBER: The Unit-Functionality-List stores:
+            1. unit activation and output functions
+            2. if sites:  3. all site functions
+                          4. all site names
+
+
+#################################################*/
+
+bool  krui_setFirstFTypeEntry( void );
+/*  Initializes the first FType entry.
+    Returns true, if an entry is available
+*/
+bool  krui_setNextFTypeEntry( void );
+/*  Initializes the next FType entry.
+    Returns true, if an entry is available
+*/
+
+bool  krui_setFTypeEntry( char *Ftype_symbol );
+/*  Initializes the FType entry with the given name.
+    Returns true, if an entry with this name is available.
+*/
+
+char *krui_getFTypeName( void );
+/*  Returns the name of the current FType entry.
+NOTE: The FType name is definite and will never be
+      a NULL pointer.
+*/
+
+krui_err  krui_setFTypeName( char  *unitFType_name );
+/*  Sets the name of the current FType entry.
+    Returns error code if memory allocation fails or Ftype name
+    isn't definite, 0 otherwise.
+NOTE: The new FType name have to be definite and must not be
+      a NULL pointer.
+*/
+
+char  *krui_getFTypeActFuncName( void );
+/*  Returns the name of the activation function in the current
+    FType entry.
+*/
+
+krui_err  krui_setFTypeActFunc( char * act_func_name );
+/*  Sets the activation function in the current FType entry
+    returns 0, if the function is a valid activation function,
+    error code otherwise.
+    All units (in the existing network) of the current Ftype changes
+    their activation function.
+*/
+
+char  *krui_getFTypeOutFuncName( void );
+/*  Returns the name of the output function in the current
+    FType entry.
+*/
+
+krui_err  krui_setFTypeOutFunc( char * out_func_name );
+/*  Sets the output function in the current FType entry
+    Returns 0, if the function is a valid output function,
+    error code otherwise.
+    All units (in the existing network) of the current Ftype changes
+    their output function.
+*/
+
+/*  FType sites
+*/
+bool  krui_setFirstFTypeSite( void );
+/*  Initializes the first site of the current FType.
+    Returns FALSE, if no sites are available in the current
+    FType entry.
+*/
+
+bool  krui_setNextFTypeSite( void );
+/*  Initializes the next FType site.
+    Returns FALSE, if no more sites are available in the current
+    FType entry.
+*/
+
+char  *krui_getFTypeSiteName( void );
+/*  Returns the name of the current FType site (in the current
+    Ftype entry).
+*/
+
+krui_err  krui_setFTypeSiteName( char *  FType_site_name );
+/*  Sets the name and function of the current FType site (in the
+    current FType entry).
+    All sites (in the existing network) of the current Ftype and the
+    same (old) name changes their names and site functions.
+
+    Returns an error code if
+      - current Ftype site isn't defined
+      - site name does not exist in the site name table
+      0 otherwise.
+*/
+
+krui_err  krui_createFTypeEntry( char *  FType_symbol,
+                                 char *  act_func, char *  out_func,
+                                 int  no_of_sites, char * *array_of_site_names );
+
+/*  Create a new functionality type, needs a definite FType symbol,
+    the unit output and activation function
+    and the number of sites provided for this unit FType.
+    An additional array with N elements of pointers to site names
+    is required for the definition of the sites.
+
+    Returns error code if:
+     - memory allocation fails
+     - FType name isn't definite (symbol is used for another FType
+       or symbol is a NULL pointer)
+     - one or more site names are undefined
+
+     0 otherwise.
+
+NOTE: The number of Ftype entries and the number of sites per Ftype is
+      only limited by the size of system memory.
+*/
+
+krui_err  krui_deleteFTypeEntry( char  *FType_symbol );
+/*  Deletes the specified FType entry. If there exists units in the
+    network with this FType, all these units will lost their FType
+    but the functionality of the units will not be changed.
+    Returns error code if FType symbol dosn't exist, 0 otherwise.
+*/
+
+
+/*#################################################
+
+GROUP: Functions for reading of the function table
+       The function table holds the names, types and no. of parameters
+       of all functions (transfer, propagate, learning and initialisation
+       functions)
+
+#################################################*/
+
+int  krui_getNoOfFunctions( void );
+/*  Returns the number of available functions
+*/
+
+void  krui_getFuncInfo( int  func_no, char * *func_name, int  *func_type );
+/*  Returns the name of the function and the function type (Output,
+    Activation, Site).
+
+    NOTE: See include file glob_typ.h for function type constants !
+*/
+
+bool  krui_isFunction( char  *func_name, int  func_type );
+/*  Returns true if the given function name and type exists.
+
+    NOTE: See include file glob_typ.h for function type constants !
+*/
+
+bool  krui_getFuncParamInfo( char *func_name, int  func_type,
+                             int *no_of_input_params,
+                             int *no_of_output_params );
+
+/*  Returns the no. of input and output parameters of the given
+    function (only relevant for learning, update and initialisation
+    functions).
+
+    Returns TRUE if the given function exists, FALSE otherwise.
+*/
+
+/*#################################################
+
+GROUP: Site Table Functions
+
+#################################################*/
+
+bool  krui_getFirstSiteTableEntry( char * *site_name, char * *site_func );
+/*  Returns the first site name/function pair in the site table.
+    Returns FALSE and NULL, if not available.
+*/
+
+bool  krui_getNextSiteTableEntry( char * *site_name, char * *site_func );
+/*  Returns the next site name/function pair in the site table.
+    Returns FALSE and NULL, if not available.
+*/
+
+char  *krui_getSiteTableFuncName( char  *site_name );
+/*  Returns the name of the site function that is associated with
+    the site name.
+    If the site name do not exist, function returns NULL.
+*/
+
+krui_err  krui_createSiteTableEntry( char  *site_name, char  *site_func );
+/*  Creates a new site name and associate this name with a site
+    function.
+    Returns error code if:
+     - site name already exists or
+     - site function is invalid or
+     - memory allocation has failed
+    0 otherwise.
+*/
+
+krui_err  krui_changeSiteTableEntry( char  *old_site_name, char  *new_site_name, char  *new_site_func );
+/*  Changes the site function of a previously defined site name.
+    Returns error code if <old_site_name> or <new_site_func>
+    are not defined, 0 otherwise.
+
+NOTE: All sites in the network with the name <old_site_name>
+      changes their names and functions.
+*/
+
+krui_err  krui_deleteSiteTableEntry( char *site_name );
+/*  Removes the current site name entry from the site table.
+
+    Returns an error code if there exists sites in the network
+    with the given name, 0 otherwise.
+*/
+
+/*#################################################
+
+GROUP: Site Functions
+
+#################################################*/
+
+bool  krui_setFirstSite( void );
+/*  Initializes the first site at the current unit.
+    Returns false if no site available or if no sites permitted
+    at this unit.
+*/
+
+bool  krui_setNextSite( void );
+/*  Initializes the next site at the current unit.
+    Returns false if no more sites available.
+*/
+
+krui_err  krui_setSite( char    *site_name );
+/*  Initializes the given site at the current unit.
+    Returns error code if
+     - unit dosn't exist
+     - site name doesn't exist
+     - unit don't has sites
+     - unit don't has a site with this name
+    0 otherwise.
+*/
+
+
+FlintType  krui_getSiteValue( void );
+/*  Returns the actual value of the current site.
+*/
+
+char  *krui_getSiteName( void );
+/*  Returns the name of the current unit/site,
+    NULL if not available.
+*/
+
+krui_err  krui_setSiteName( char  *site_name );
+/*  Sets the name/function of the current unit/site.
+    Current Unit will loose the functionality type.
+    Returns error code if site name isn't defined.
+*/
+
+char  *krui_getSiteFuncName( void );
+/*  Returns the name of the current unit/site function.
+*/
+
+krui_err  krui_addSite( char *  site_name );
+/*  Adds a site at the current unit. If the unit has already sites, this new
+    site will be inserted above all other sites, i.e. the new created site will
+    be the first site at this unit.
+    If the unit has direct input links, i.e the unit has input links
+    but no sites, the creation of sites is not permitted (krui_addSite will
+    return an error code).
+    If there exists already a site with the given name, the creation of the
+    new site is prohibited and krui_addSite returns an error code.
+
+    krui_addSite has no effect on the current site. To change the current site
+    to this new site, call krui_setFirstSite().
+    The unit's FType will be deleted.
+
+    Returns error code if
+      - memory allocation fails or
+      - unit has direct input links or
+      - site name isn't defined or
+      - site with the given name exists already at this unit
+      0 otherwise.
+
+NOTE: The number of sites per unit is nearly unlimited (2^32).
+*/
+
+
+bool  krui_deleteSite( void );
+/*  Removes the current site at the current unit and removes all
+    links from predecessor units to this site.
+    krui_setFirstSite (krui_setNextSite) must be called at least once
+    before using this function.
+    The current site will be set to the next available site, if no more
+    sites available, krui_deleteSite returns 0 otherwise 1.
+    Returns an error code if ther was a problem.
+    The unit's FType will be set to 0, i.e. the unit's functionality
+    type will be deleted.
+
+NOTE: To delete all sites at a unit:
+        if ( krui_setFirstSite() )
+          while ( krui_deleteSite() > 0) { }
+*/
+
+
+/*#################################################
+
+GROUP: Link Functions
+
+#################################################*/
+
+int  krui_getFirstPredUnit( FlintType  *strength );
+/*  Returns the no. of first predecessor unit of the current unit/site
+    and the connection strenght.
+    Returns 0 if no predecessor unit available, i.e. if the current
+    unit and/or site has no inputs.
+
+NOTE: If a predecessor unit exists, the current link is set to the link
+      between the two units.
+*/
+
+int  krui_getNextPredUnit( FlintType   *strength );
+/*  Returns the no. of the next predecessor unit of the current
+    unit/site and the connection strenght.
+    Returns 0 if no more predecessor units exists.
+NOTE: If another predecessor unit exists, the current link is set to the link
+      between the two units.
+*/
+
+int  krui_getCurrentPredUnit( FlintType   *strength );
+/*  Returns the no. of the current predecessor unit (of the current
+    unit/site) and the connection strenght.
+    Returns 0 if no predecessor unit available, i.e. if the current unit
+    and/or site has no inputs.
+*/
+
+int  krui_getFirstSuccUnit( int  UnitNo, FlintType   *strength );
+/*  Returns the no. of the first successor unit of the unit <source_unit_no>
+    and the connection strenght.
+    Returns (negative) error code if unit doesn't exist.
+    Returns 0 if no successor unit available, i.e. if the given unit
+    has no output connection.
+
+IMPORTANT: If a successor unit exists, the current unit and site will be
+           set to this successor unit and the attached site.
+
+NOTE: This function is slow (Units are backward chained only).
+
+REMARK: getFirstSuccUnit is for downward compatibility only.
+        Do not use this function in future applications.
+*/
+
+
+int  krui_getNextSuccUnit( FlintType  *strength );
+/*  Returns the no. of the next successor unit and the connection strenght.
+
+IMPORTANT: If a successor unit exists, the current unit and site will be
+           set to this successor unit and the attached site.
+
+NOTE: This function is slow  (Units are backward chained only)
+
+REMARK: getNextSuccUnit is for downward compatibility only.
+        Do not use this function in future applications.
+*/
+
+
+extern bool  krui_areConnected(int source_unit_no, int target_unit_no);
+extern bool  krui_areConnectedWeight(int source_unit_no, int target_unit_no, FlintType *weight);
+/*  Returns true if there exists a connection between source unit <source_unit_no>
+    and target unit <target_unit_no>, otherwise false. If there exist a
+    connection between these units, krui_areConnected returns the connection
+    strength also.
+    Returns FALSE if unit doesn't exist.
+
+IMPORTANT: If there exist a connection, the current unit and site will be
+           set to the target unit and the attached site.
+
+NOTE: This function is slow (Units are backward chained only).
+*/
+
+bool krui_isConnected( int  source_unit_no );
+/*  True if there exists a connection between source unit <source_unit_no>
+    and the current unit/site, otherwise false.
+
+NOTE: If there exists a connection between the two units, the current link is set
+      to the link between the two units. (alter the link weight with krui_setLinkWeight)
+*/
+
+FlintType  krui_getLinkWeight( void );
+/*  Returns the link weight of the current link.
+*/
+
+void  krui_setLinkWeight( FlintTypeParam  strength );
+/*  Sets the link weight of the current link.
+*/
+
+krui_err  krui_createLink( int source_unit_no, FlintTypeParam  strength  );
+/*  Creates a link between source unit and the current unit/site.
+    Returns an error code:
+     - if memory allocation fails
+     - if source unit doesn't exist or
+     - if there exists already a connection between current unit/site and
+       the source unit
+    0 otherwise.
+    krui_createLink DO NOT set the current link.
+
+NOTE: If you want to create a link and its unknown if there exists already a
+      connection between the two units, use krui_createLink and test the return
+      code, instead of the sequence krui_isConnected and krui_createLink.
+*/
+
+krui_err  krui_deleteLink( void );
+/*  Deletes the current link.
+
+NOTE: To delete a link between the current unit/site and the source unit
+      <source_unit_no>, call krui_isConnected( source_unit_no ) and
+      krui_deleteLink().
+*/
+
+krui_err  krui_deleteAllInputLinks( void );
+/*  Deletes all input links at current unit/site.
+*/
+
+krui_err  krui_deleteAllOutputLinks( void );
+/*  Deletes all output links at current unit.
+NOTE: This function is slow.
+*/
+
+void  krui_jogWeights( FlintTypeParam  minus, FlintTypeParam  plus);
+/*  Add uniform distributed random values to connection weights.
+    <minus> must be less then <plus>.
+*/
+
+
+
+/*#################################################
+
+GROUP: Functions for network updating
+
+#################################################*/
+
+krui_err  krui_updateSingleUnit( int  UnitNo );
+/*  Updates a single unit. Returns error code if unit doesn't exist,
+    0 otherwise.
+
+NOTE: Updates also frozen Units.
+*/
+
+char  *krui_getUpdateFunc( void );
+/*  Returns the current update function. The default update function is
+    SerialOrder() (see also kr_def.h).
+*/
+
+krui_err  krui_setUpdateFunc( char  *update_func );
+/*  Changes the current update function.  Returns error code if update
+    function is invalid.
+*/
+
+krui_err  krui_updateNet( float *parameterArray, int  NoOfParams );
+/*  Updates the network according to update function:
+
+      To propagate a pattern thru the network the use of following
+      function calls is recommended:
+
+        krui_setPatternNo( pat_no );
+        krui_showPattern( OUTPUT_NOTHING );
+        krui_updateNet( parameterArray, NoOfParams );
+
+      See also krui_setSeedNo for initializing the pseudo
+      random generator.
+
+      Returns error code if an error occured, 0 othrwise.
+
+NOTE: The network should be feedforward in topological mode,
+      otherwise function will return a warning message.
+*/
+
+krui_err  krui_testNet( int  pattern_no, 
+                        float  *updateParameterArray, int  NoOfUpdateParams,
+                        float  *parameterInArray, int  NoOfInParams,
+                        float  * *parameterOutArray, int  *NoOfOutParams );
+/*  Calculates the network error whith the given pattern.
+    Uses the current update function to propagate the network.
+
+    UpdateParameterArray contains the parameters of the update function.
+    NoOfUpdateParams contains the number of input parameters of the update function.
+
+    parameterInArray[0] contains the max. devitation.
+    Set NoOfInParams to 1.
+
+    parameterOutArray[0] contains the error of the network/pattern,
+    parameterOutArray[1] contains the number of output units with a
+    higher error value than the given max. devitation.
+    NoOfOutParams will be set to 2.
+
+NOTE: Patterns must be loaded before calling this function.
+
+Returns error code if an error occured, 0 otherwise.
+*/
+
+
+/*#################################################
+
+GROUP: Functions for network initialisation
+
+#################################################*/
+
+char  *krui_getInitialisationFunc( void );
+/*  Returns the current initialisation function. The default initialisation function is
+    Randomize_Weights (see also kr_def.h).
+*/
+
+krui_err  krui_setInitialisationFunc( char  *init_func );
+/*  Changes the current initialisation function.  Returns error code if initialisation
+    function is invalid.
+*/
+
+krui_err  krui_initializeNet( float *parameterArray, int  NoOfParams );
+/*  Initializes the network
+*/
+
+
+/*#################################################
+
+GROUP: Learning Functions
+
+#################################################*/
+
+char  *krui_getLearnFunc( void );
+/*  Returns the name of the current learning function.
+*/
+
+krui_err  krui_setLearnFunc( char  *learning_func );
+/*  Changes the learning function. Returns a error code if the
+    given learning function is invalid.
+*/
+
+krui_err  krui_learnAllPatterns( float   *parameterInArray, int NoOfInParams,
+                                 float  * *parameterOutArray, int *NoOfOutParams );
+/*  Learn all pattern pairs using current learning method.
+    parameterInArray contains the learning
+    parameter(s). NoOfInParams stores the number of learning parameters.
+    parameterOutArray returns the results from the learning function.
+    this array is a static array defined in the learning function.
+    *NoOfOutParams points to a integer value that contains the number
+    of output parameters from the current learning function.
+    Returns an error code if memory allocation has failed or if
+    the parameters are invalid.
+
+    Returns error code of the learning function.
+REMEMBER:  The backpropagation learning function takes the learning
+           parameter from parameterInArray[ 0 ]. parameterOutArray[ 0 ]
+           returns the current net error.
+
+NOTE: Patterns must be loaded before calling this function.
+*/
+
+krui_err  krui_learnSinglePattern( int  pattern_no, float   *parameterInArray,
+                                   int NoOfInParams,
+                                   float  * *parameterOutArray, int *NoOfOutParams );
+/*  Same as krui_learnAllPatterns( ... ) but learns only the current
+    pattern pair.
+
+NOTE: Patterns must be loaded before calling this function.
+*/
+
+krui_err  krui_setPatternNo( int  patter_no );
+/*  Sets the current pattern.
+    Returns a error code if pattern number is invalid.
+
+NOTE: Patterns must be loaded before calling this function.
+*/
+
+krui_err  krui_deletePattern( void );
+/*  Deletes the current pattern.
+*/
+
+krui_err  krui_modifyPattern( void );
+/*  Modifies the current pattern.
+*/
+
+krui_err  krui_showPattern( int  mode );
+/*  According to the mode krui_showPattern stores the current
+    Pattern into the units activation (and/or output) values.
+    The modes are:
+      - OUTPUT_NOTHING
+         store input pattern into input units activations
+      - OUTPUT_ACT
+         store input pattern into input units activations and
+         store output pattern into output units activations
+      - OUTPUT_OUT
+         store input pattern into input units activations,
+         store output pattern into output units activations and
+         update output units output
+
+NOTE: See include file glob_typ.h for mode constants.
+*/
+
+krui_err  krui_newPattern( void );
+/*  Creates a new pattern pair.
+    A pattern pair can be created by modifying the activation
+    value of the input/output units.
+    Returns error code if memory is insufficent or no. of
+    input/output units is incompatible, 0 otherwise.
+
+NOTE: krui_newPattern switches pattern shuffeling off.
+      For shuffeling the new pattern pairs call
+        krui_newPattern(...)
+        krui_shufflePattern( TRUE )
+*/
+
+
+int  krui_getNoOfPatterns( void );
+/*  Returns the no. of available pattern pairs.
+*/
+
+
+void  krui_deleteAllPatterns( void );
+/*  Release previously defined patterns from memory.
+    Call krui_releasePatterns() if you want to create totally
+    new patterns with krui_newPattern().
+*/
+
+krui_err  krui_shufflePatterns( bool  on_or_off );
+/*  Shuffle pattern pairs by using pseudo random generator.
+    Returns error code if memory allocation fails.
+    Shuffeling of patterns is used by krui_learnAllPatterns(...).
+    krui_shufflePatterns( TRUE ) switches shuffeling of patterns
+    on, krui_shufflePatterns( FALSE ) switches shuffeling of
+    patterns off.
+    The default presetting is krui_shufflePatterns( FALSE ).
+
+NOTE:  See also krui_setSeedNo( seed )
+*/
+
+
+/*#################################################
+
+GROUP: I/O Functions
+
+#################################################*/
+
+krui_err  krui_loadNet( char  *filename, char  * *netname );
+/*  Load a network file and create a network.
+    Returns the name of the net or "UNTITLED" if unknown.
+    Returns error code if an error occured during
+    loading/memory allocation, or 0 otherwise.
+*/
+
+krui_err  krui_saveNet( char  *filename, char  *netname);
+/*  Save a network.
+    If netname is a NULL pointer, the net will get the name "UNTITLED"
+    Returns error code if an error occured, or 0 otherwise.
+*/
+
+/*#################################################
+
+GROUP: Functions for reading/searching the symbol table
+       The symbol table holds the names and types of all symbols
+       (unit and site symbols).
+
+#################################################*/
+
+bool  krui_getFirstSymbolTableEntry( char * *symbol_name, int  *symbol_type );
+/*  Returns the first symbol/symbol type entry in the
+    symbol table. Returns true if this entry is available,
+    false otherwise.
+*/
+
+bool  krui_getNextSymbolTableEntry( char * *symbol_name, int  *symbol_type );
+/*  Returns the next symbol/symbol type entry in the
+    symbol table. Returns true if another entry is available,
+    false otherwise.
+
+Example:  To get all symbols in the symbol table
+          if (krui_getFirstSymbolTableEntry( &symbol, &symtype))
+            do
+              {
+                .
+                .
+                .
+              }
+            while (krui_getNextSymbolTableEntry( &symbol, &symtype));
+*/
+
+
+bool  krui_symbolSearch( char * symbol, int  symbol_type);
+/*  Searches the symbol table for a given symbol and
+    symbol type (unit name symbol, site name symbol,
+    functionality unit name symbol)
+    Returns true, if the symbol exists.
+*/
+
+/*#################################################
+
+GROUP: Miscellanous
+
+#################################################*/
+
+
+char  *krui_getVersion( void );
+/*  Returns the current Version of the SNNS-Kernel.
+*/
+
+void  krui_getNetInfo( int  *no_of_sites, int  *no_of_links,
+                       int  *no_of_STable_entries, int  *no_of_FTable_entries );
+/*  Returns miscellanous information about the current network.
+*/
+
+void  krui_getUnitDefaults( FlintType  *act, FlintType  *bias, int  *st,
+                            int  *subnet_no, int  *layer_no,
+                            char * *act_func, char  * *out_func );
+/*  Returns Information about the unit default settings.
+    For more information about default settings see krui_createDefaultUnit() and
+    krui_createFTypeUnit( .. ).
+*/
+
+krui_err  krui_setUnitDefaults( FlintTypeParam  act, FlintTypeParam  bias, int  st,
+                                int  subnet_no, int  layer_no,
+                                char  *act_func, char  *out_func );
+/*  Changes the unit default settings.
+    For more information about default settings see krui_createDefaultUnit() and
+    krui_createFTypeUnit( .. ).
+
+    Returns error code if
+     - activation/output function is invalid
+     - Topologic type is invalid
+    0 otherwise.
+*/
+
+
+
+void  krui_setSeedNo( long seed );
+/*  Initialize the pseudo random generator.
+    0 as argument reinitializes the random generator.
+*/
+
+
+int  krui_getNoOfInputUnits( void );
+/*  Returns no. of input units
+*/
+
+int  krui_getNoOfOutputUnits( void );
+/*  returns no. of output units
+*/
+
+int  krui_getNoOfTTypeUnits( int  UnitTType );
+/*  returns the no. of units of the specified topologic type
+    (i.e. Input, Hidden, Output, Dual or Special units)
+*/
+
+void  krui_resetNet( void );
+/*  Reset the network by changeing the unit activation
+    to the initial activation value.
+*/
+char  *krui_error( int  error_code );
+/*  Returns an error message, depending on the error code.
+    If a function returns an error code use krui_error to
+    get the message.
+
+Available error messages are:
+
+"Invalid error code",
+"Insufficient memory",
+"Invalid unit number",
+"Invalid unit output function",
+"Invalid unit activation function",
+"Invalid site function",
+"Creation of sites isn't permitted because unit has direct input links",
+"Creation of a link isn't permitted because there exists already a link between these units",
+"Memory allocation failed during critical operation. Have lost some pointers, but consistency of the network is guaranteed",
+"Ftype name isn't definite",
+"Current Ftype entry isn't defined",
+"Invalid copy mode",
+"Current unit doesn't have sites",
+"Can't update unit because unit is frozen",
+"Redefinition of site name isn't permitted (site name already exists)",
+"Site name isn't defined",
+"This is not a 3D-Kernel",
+"This unit has already a site with this name",
+"Can't delete site table entry because site is in use",
+"Current Ftype site isn't defined",
+"Ftype symbol isn't defined",
+"Physical I/O error",
+"Creation of output file failed (line length limit exceeded)",
+"The network has not enough layers: ",
+"No Units defined",
+"Unexpected EOF",
+"Line length exceeded",
+"Incompatible file format",
+"Can't open file",
+"Syntax error at line",
+"Memory allocation error 1",
+"Topologic type invalid",
+"Symbol pattern invalid (must start with a letter)",
+"Current unit doesn't have a site with this name",
+"No hidden units defined",
+"Network contains cycle(s): ",
+"Network contains dead unit(s): ",
+"Pattern file contains not the same no. of input units as the network",
+"Pattern file contains not the same no. of output units as the network",
+"No. of input units have changed",
+"No. of output units have changed",
+"No input units defined",
+"No output units defined",
+"No patterns defined",
+"In-Core patterns incompatible with current network (remove In-Core patterns before loading a new network)",
+"Invalid pattern number",
+"Invalid learning function",
+"Invalid parameters",
+"Invalid update function",
+"Invalid initialisation function",
+"Derivation function of the activation function doesn't exist",
+"Input unit(s) with input connection(s) to other units: ",
+"Output unit(s) with output connection(s) to other units: ",
+"Invalid topological sorting mode",
+"Learning function doesn't support sites",
+"Sites are not supported",
+"This isn't a MasPar Kernel",
+"Connection(s) between unit(s) in non-neighbour layers are not supported: ",
+"The network has too much layers: ",
+"The network layers aren't fully connected",
+"This operation isn't allowed in the superscalar kernel mode",
+"Change of network type isn't possible in superscalar kernel mode",
+"No current link defined",
+"No current unit defined",
+"Current unit doesn't have any inputs",
+"Invalid parameter in topologic definition section",
+"Creation of link between these units isn't permitted",
+"MasPar don't respond",
+"This function isn't implemented yet",
+"Kernel isn't in parallel mode",
+"MasPar ran out of memory",
+"MasPar communication error",
+"MasPar ran out of processors",
+"Missing default function (check function table)",
+"MasPar kernel doesn't support multiple unit output functions",
+"MasPar kernel doesn't support multiple unit activation functions",
+"The depth of the network doesn't fit to the learning function"
+
+
+*/
+
+
+/*#################################################
+
+GROUP: Functions for memory management
+
+#################################################*/
+
+krui_err  krui_allocateUnits( int  number );
+/*  Allocates a given number of units, additional units
+    may allocated by calling this function again.
+    This function is called automatically if the user
+    construct more units than have been allocated before, but
+    it is recommended to use this function if a large amount
+    of units is needed (the UNIX System can manage system resources
+    much better, if the amount of memory used for the network is
+    approximately known before the network is created).
+
+    Returns error code if memory allocation fails, 0 otherwise.
+
+NOTE: If krui_create_unit has been called before using this
+      function, at least <UNIT_BLOCK> numbers of units have been
+      allocated.
+      See "kr_def.h" for more information about memory allocation
+      block sizes.
+*/
+
+void  krui_getMemoryManagerInfo( int  *unit_bytes, int  *site_bytes, int  *link_bytes,
+                                 int  *NTable_bytes, int  *STable_bytes, int  *FTable_bytes );
+/*  Returns the number of ALLOCATED (not the number of USED) bytes
+    for the units, sites, name-table and site-table.
+*/
+
+void  krui_deleteNet( void );
+/*  Delete network, names and unit types.
+    Frees all memory used for the network.
+
+NOTE: If krui_loadNet is called more then once,  krui_deleteNet will
+      be called by krui_loadNet, because the kernel have to free the
+      memory used for the old network.
+      It is recommended (but not neccessary) to call krui_deleteNet
+      before terminating  program.
+*/
+
+
+/* #############################################################
+ 
+  Functions for the extern kernels
+
+############################################################# */
+
+krui_err  krui_setSpecialNetworkType( int  net_type );
+/*  Sets the topologic type of the current network.
+    Returns an error if the topologic type of the current network  
+    doesn't fit to this type.
+    Topologic types are:
+      - NET_TYPE_GENERAL
+        general purpose network type with no limitations
+      - NET_TYPE_FF1
+        feedforward network with fully connected units in
+        neighbour layers
+*/
+
+int  krui_getSpecialNetworkType( void );
+/*  Returns the special topologic type of the current network, if set.
+*/
+
+int krui_initInversion(void);
+void  krui_inv_forwardPass(struct UnitList *inputs);
+double krui_inv_backwardPass(float learn, float delta_max, int *err_units, 
+			     float ratio, struct UnitList *inputs,
+			     struct UnitList *outputs);
+
+#ifdef MASPAR_KERNEL
+
+/* #############################################################
+ 
+  Functions for the parallel kernel
+
+############################################################# */
+
+krui_err  krui_MasPar( int  mode );
+/*  Connects and Disconnects the MasPar.
+    The mode switches are:  MASPAR_CONNECT, MASPAR_DISCONNECT and
+    MASPAR_NOT_AVAILABLE.
+*/
+
+
+krui_err  krui_getMasParStatus( void );
+/*  Returns the status of the MasPar.
+*/
+
+krui_err  krui_MasParBenchmark( int  func_type, int cycles, float  *result );
+/*  Perform benchmark tests
+*/
+
+#endif
+
diff -Naur snort-2.3.3/src/kernel_snns/learn_f.c snort-2.3.3.new/src/kernel_snns/learn_f.c
--- snort-2.3.3/src/kernel_snns/learn_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/learn_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,8832 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/learn_f.c,v $
+  SHORTNAME      : learn_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+	           - Backpropagation
+	           - Backpropagation with momentum term
+                   - Quickprop
+	           - Counterpropagation
+	           - BackPercolation
+                   - Backpropagation through time
+                   - Batch backpropagation through time
+                   - Quickprop through time
+		   - Kohonen (by Univ. of Tuebingen)
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.10.90
+
+  CHANGED BY     : Sven Doering, Michael Vogt, Martin Reczko ,Guenter Mamier
+  RCS VERSION    : $Revision: 2.46 $
+  LAST CHANGE    : $Date: 1998/05/20 09:35:23 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+#include <ctype.h>
+
+#include "kr_typ.h"		/* Kernel Types and Constants  */
+#include "kr_const.h"		/* Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"		/* Default Values  */
+
+#ifndef rand
+#include "random.h"	 /*  Randomize Library Function Prototypes  */
+#endif
+
+#include "kernel.h"		/* kernel function prototypes  */
+#include "kr_mac.h"		/* Kernel Macros   */
+#include "glob_typ.h"
+#include "kr_ui.h"
+#include "kr_art.h"
+#include "kr_art1.h"
+#include "kr_art2.h"
+#include "kr_amap.h"
+#include "krart_df.h"
+#include "kr_newpattern.h"
+#include "kr_JordElm.h"
+#include "prun_f.h"
+
+#ifdef PARAGON_KERNEL
+#include PARAGON_INCLUDE
+#include "kr_ipdef.h"
+#endif
+
+
+#include "learn_f.ph"
+
+
+
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : backpropagation learning algorithm
+
+  AUTHOR       : Niels Mache
+             
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetForward
+
+  PURPOSE  : forward pass for most of the learning algorithms
+  RETURNS  : 
+  NOTES    : topological forward propagation
+
+  UPDATE   : 05.11.1993
+******************************************************************************/
+void propagateNetForward(int pattern_no, int sub_pat_no)
+{
+    register struct Unit *unit_ptr;
+    register Patterns in_pat;
+    register TopoPtrArray topo_ptr;
+
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+    if(in_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return;
+    }
+
+    topo_ptr = topo_ptr_array;
+
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	
+	
+	/* topo_ptr points to a (topological sorted) unit
+	   stucture (input unit first)  */
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output 
+		= (*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    /* popagate hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	/* clear error values  */
+	unit_ptr->Aux.flint_no = 0.0;
+
+	/* calculate the activation value of the unit: call the activation
+	   function if needed  */
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /* popagate output units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	/* clear error values  */
+	unit_ptr->Aux.flint_no = 0.0;
+
+	/* calculate the activation value of the unit: call the activation
+	   function if needed  */
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackward2
+
+  PURPOSE  : backward pass of the backprop learning algorithm
+  RETURNS  : network error
+  NOTES    : network must be topologically sorted
+
+  UPDATE   : 07.02.1994 by Sven Doering 
+******************************************************************************/
+static float propagateNetBackward2(int pattern_no, int sub_pat_no, 
+				   float learn_parameter, float delta_max)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, eta, devit, learn_error;
+    register TopoPtrArray topo_ptr;
+    int size;
+
+    sum_error = 0.0;		/* reset network error  */
+    eta = learn_parameter;	/* store learn_parameter in CPU register  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+    out_pat += size;
+
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output; /* calc. devitation */
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	sum_error += devit * devit; /* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * (unit_ptr->act_deriv_func) (unit_ptr);
+	/* calc. the error for adjusting weights and bias of the pred.
+	   units  */
+	if (IS_SPECIAL_UNIT(unit_ptr))
+	    learn_error = 0.0;
+	else
+	    learn_error = eta * error;
+	/* adjust bias value  */
+	unit_ptr->bias += learn_error;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direkt links  */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) { /* adjust links and
+						   calc. errors of the
+						   predecessor units  */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    } else {		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		    /* adjust links and calc. errors of the predecessor units */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->weight += learn_error * link_ptr->to->Out.output;
+		}
+	    }
+    }
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	/* calc. the error of the (hidden) unit  */
+	error = (unit_ptr->act_deriv_func) (unit_ptr) * 
+	    unit_ptr->Aux.flint_no;
+	/* calc. the error for adjusting weights and bias of the pred.
+	   units  */
+	if (IS_SPECIAL_UNIT(unit_ptr)) 
+	    learn_error =0.0;
+	else
+	    learn_error = eta * error;
+	/* adjust bias value  */
+	unit_ptr->bias += learn_error;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direkt links	 */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust links and
+						   calc. sum of errors
+						   of the pred. units */
+		    if IS_HIDDEN_UNIT
+			(link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			    link_ptr->to->Aux.flint_no += 
+				link_ptr->weight * error;
+		    link_ptr->weight
+			+= learn_error * link_ptr->to->Out.output;
+		}
+	    } else {		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		    /* adjust links and calc sum of errors of the pred. units */
+		    if IS_HIDDEN_UNIT
+			(link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			    link_ptr->to->Aux.flint_no += 
+				link_ptr->weight * error;
+		    link_ptr->weight
+			+= learn_error * link_ptr->to->Out.output;
+		}
+	    }
+    }
+
+    return (sum_error);		/* return the error of the network */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_backprop
+
+  PURPOSE  : main routine for the backpropagation algorithm
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+
+  UPDATE   : 05.11.1993
+******************************************************************************/
+krui_err LEARN_backprop(int start_pattern, int end_pattern,
+			float *parameterInArray, int NoOfInParams,
+			float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error */
+    int             pattern_no, sub_pat_no, no_of_layers;
+
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    /* ####  have to be changed (must be 2)  #### */
+    if (NoOfInParams < 1) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) &&
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward(pattern_no,sub_pat_no);   /* Forward propagation */
+
+	/* Backward propagation  */
+	/* 1st parameter is the learning parameter 2nd parameter is the max.
+	   devitation between output pattern and the output of the output
+	   unit (delta max) */
+	NET_ERROR(OutParameter) +=
+	    propagateNetBackward2(pattern_no,sub_pat_no,
+				  LEARN_PARAM1(parameterInArray),
+				  LEARN_PARAM2(parameterInArray));
+    }
+
+    return (KernelErrorCode);
+}
+
+
+/*****************************************************************************
+  FUNCTION : TEST_backprop             joe
+
+  PURPOSE  : main routine for the test of MLPs
+  RETURNS  : kernel error code
+  NOTES    : Output Parameters:  1 : error of the network (sum of all cycles)
+
+
+  UPDATE   : 17.01.95
+******************************************************************************/
+krui_err TEST_backprop(int start_pattern, int end_pattern,
+			float *parameterInArray, int NoOfInParams,
+			float **parameterOutArray, int *NoOfOutParams)
+{
+
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error */
+    int             pattern_no, sub_pat_no, no_of_layers;
+
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NoOfInParams < 1) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) &&
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+    
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward(pattern_no,sub_pat_no);   /* Forward propagation */
+
+	NET_ERROR(OutParameter) +=
+	    testNetBackward2(pattern_no,sub_pat_no,
+				  LEARN_PARAM1(parameterInArray),
+				  LEARN_PARAM2(parameterInArray));
+
+    }
+
+    return (KernelErrorCode);
+}
+
+/*****************************************************************************
+  FUNCTION : testNetBackward2                        joe
+
+  PURPOSE  : calculates network error for MLPs
+  RETURNS  : network error
+  NOTES    : network must be topologically sorted 
+
+  UPDATE   : 19.02.95
+******************************************************************************/
+static float testNetBackward2(int pattern_no, int sub_pat_no, 
+				   float learn_parameter, float delta_max)
+{
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float sum_error, devit;
+    register TopoPtrArray topo_ptr;
+    int size;
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+    out_pat += size;
+
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output; /* calc. devitation */
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	sum_error += devit * devit; /* sum up the error of the network  */
+
+    }
+
+
+    return (sum_error);		/* return the error of the network */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackwardBatch
+
+  PURPOSE  : backward pass in batch mode for the backprop learning algorithm
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+float propagateNetBackwardBatch(int pattern_no, int sub_pat_no, float delta_max)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, devit;
+    register TopoPtrArray topo_ptr;
+    int size;
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no+1)*/
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+
+    out_pat += size;
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    /* no test for special units takes place because the final weight */
+    /* change is performed  by updateWeights */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output; /* calc. devitation */
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	sum_error += devit * devit; /* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * (unit_ptr->act_deriv_func) (unit_ptr);
+	/* calc. the error for adjusting weights and bias of the pred.
+	   units  */
+	/* adjust bias value  */
+	unit_ptr->value_a += error;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direkt links  */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust links and
+						   calc. sum of errors
+						   of pred. units  */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_a += error * link_ptr->to->Out.output;
+	    }
+	} else {
+	    /* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* adjust links and calc. sum of errors of pred. units */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_a += error * link_ptr->to->Out.output;
+	    }
+	}
+    }
+
+    /* calculate hidden units only  */
+    /* no test for special units takes place because the final weight */
+    /* change is performed  by updateWeights */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	/* calc. the error of the (hidden) unit  */
+	error = (unit_ptr->act_deriv_func) (unit_ptr) * 
+	    unit_ptr->Aux.flint_no;
+	/* calc. the error for adjusting weights and bias of the pred.
+	   units  */
+	/* adjust bias value  */
+	unit_ptr->value_a += error;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direkt links	 */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	
+		/* adjust links and calc sum of errors of the pred. units */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no += 
+			    link_ptr->weight * error;
+		link_ptr->value_a += error * link_ptr->to->Out.output;
+	    }
+	} else {
+	    /* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* adjust links and calc sum of errors of the pred. units */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no
+			    += link_ptr->weight * error;
+		link_ptr->value_a += error * link_ptr->to->Out.output;
+	    }
+	}
+    }
+
+    return (sum_error);		/* return the error of the network */
+}
+
+/*****************************************************************************
+  FUNCTION : propagateClassNetBackwardBatch
+
+  PURPOSE  : backward pass in batch mode for the backprop learning algorithm
+             only updates weights if units usr_flag info matches current
+	     pattern class (if classes are given)
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   : 31.03.98 Michael Vogt
+******************************************************************************/
+float propagateClassNetBackwardBatch(int pattern_no, int sub_pat_no, float delta_max)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, devit;
+    register TopoPtrArray topo_ptr;
+    int size;
+    int pattern_class;
+    unsigned long int class_flag;
+    const int maxclasses = 8 * sizeof(unsigned long int);
+    int adjust_this;
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no+1)*/
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+    pattern_class = kr_getSubPatClass(pattern_no,sub_pat_no);
+    if (pattern_class >= maxclasses)
+    {
+	fprintf(stderr, 
+		"propagateClassNetBackwardBatch: pattern class index %d out of range\n"
+		"pattern is trained as usual\n", pattern_class);
+	pattern_class = -1;
+    }
+    if (pattern_class >= 0)
+	class_flag = ((unsigned long int) 1) << pattern_class;
+
+#ifdef DEBUG
+    printf("maxclasses: %d, pattern_class: %d, class_flag: %lx\n",
+	  maxclasses, pattern_class, class_flag);
+#endif
+
+    out_pat += size;
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    /* no test for special units takes place because the final weight */
+    /* change is performed  by updateWeights */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output; /* calc. devitation */
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	adjust_this= (pattern_class == -1 || unit_ptr->usr_flags & class_flag);
+#ifdef DEBUG
+	printf("%s%s ", 
+	       adjust_this ? "+" : "-", 
+	       unit_ptr->unit_name ? unit_ptr->unit_name : "");
+#endif
+	sum_error += devit * devit; /* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * (unit_ptr->act_deriv_func) (unit_ptr);
+	/* calc. the error for adjusting weights and bias of the pred.
+	   units  */
+	if (adjust_this)
+	{
+	    /* adjust bias value  */
+	    unit_ptr->value_a += error;
+	    unit_ptr->value_b += 1.0;
+
+	    if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+		/* the unit has direkt links  */
+		FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust links and
+							   calc. sum of errors
+							   of pred. units  */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->value_a += error * link_ptr->to->Out.output;
+		    link_ptr->value_b += 1.0;
+		}
+	    } else {
+		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		    /* adjust links and calc. sum of errors of pred. units */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		    link_ptr->value_a += error * link_ptr->to->Out.output;
+		    link_ptr->value_b += 1.0;
+		}
+	    }
+	}
+    }
+
+    /* calculate hidden units only  */
+    /* no test for special units takes place because the final weight */
+    /* change is performed  by updateWeights */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	adjust_this= (pattern_class == -1 || unit_ptr->usr_flags & class_flag);
+#ifdef DEBUG
+	printf("%s%s ", 
+	       adjust_this ? "+" : "-", 
+	       unit_ptr->unit_name ? unit_ptr->unit_name : "");
+#endif
+	/* calc. the error of the (hidden) unit  */
+	error = (unit_ptr->act_deriv_func) (unit_ptr) * unit_ptr->Aux.flint_no;
+	/* calc. the error for adjusting weights and bias of the pred. units */
+	if (adjust_this)
+	{
+	    /* adjust bias value  */
+	    unit_ptr->value_a += error;
+	    unit_ptr->value_b += 1.0;
+
+	    if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+		/* the unit has direkt links	 */
+		FOR_ALL_LINKS(unit_ptr, link_ptr) {	
+		    /* adjust links and calc sum of errors of the pred. units */
+		    if (IS_HIDDEN_UNIT(link_ptr->to))
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		    link_ptr->value_a += error * link_ptr->to->Out.output;
+		    link_ptr->value_b += 1.0;
+		}
+	    } else {
+		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		    /* adjust links and calc sum of errors of the pred. units */
+		    if (IS_HIDDEN_UNIT(link_ptr->to))
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		    link_ptr->value_a += error * link_ptr->to->Out.output;
+		    link_ptr->value_b += 1.0;
+		}
+	    }
+	}
+    }
+
+#ifdef DEBUG
+    printf("\n");
+#endif
+    return (sum_error);		/* return the error of the network */
+}
+
+
+/*****************************************************************************
+  FUNCTION : clearDeltas
+
+  PURPOSE  : clears delta values for a new run of backprop batch
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err clearDeltas(void)
+{
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register FlintType fastnull = 0.0;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {	/* unit is in use  */
+	    unit_ptr->value_a = fastnull;
+
+	    if (flags & UFLAG_SITES) {	/* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    link_ptr->value_a = fastnull;
+	    } else {		/* unit has no sites   */
+		if (flags & UFLAG_DLINKS) { /* unit has direct links   */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			link_ptr->value_a = fastnull;
+		}
+	    }
+	}
+    }
+
+    return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : clearAllDeltas
+
+  PURPOSE  : clears all delta values for a new run of special batch schemes
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 31.03.98 by Michael Vogt
+******************************************************************************/
+krui_err clearAllDeltas(void)
+{
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register FlintType fastnull = 0.0;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {	/* unit is in use  */
+	    unit_ptr->value_a = fastnull;
+	    unit_ptr->value_b = fastnull;
+	    unit_ptr->value_c = fastnull;
+
+	    if (flags & UFLAG_SITES) {	/* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    {
+			link_ptr->value_a = fastnull;
+			link_ptr->value_b = fastnull;
+			link_ptr->value_c = fastnull;
+		    }
+	    } else if (flags & UFLAG_DLINKS) {
+		/* unit has direct links   */
+		FOR_ALL_LINKS(unit_ptr, link_ptr)
+		    {
+			link_ptr->value_a = fastnull;
+			link_ptr->value_b = fastnull;
+			link_ptr->value_c = fastnull;
+		    }
+	    }
+	}
+    }
+
+    return (KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : updateWeights
+
+  PURPOSE  : Update the weights after all patterns have been presented by 
+             backpropBatch 
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err updateWeights(float eta)
+{
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	if (!IS_SPECIAL_UNIT(unit_ptr)) {
+	    flags = unit_ptr->flags;
+
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use  */
+		unit_ptr->bias += unit_ptr->value_a * eta;
+
+		if (flags & UFLAG_SITES) {
+		    /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			link_ptr->weight += link_ptr->value_a * eta;
+		} else {
+		    /* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {	/* unit has direct links    */
+			FOR_ALL_LINKS(unit_ptr, link_ptr)
+			    link_ptr->weight += link_ptr->value_a * eta;
+		    }
+		}
+	    }
+	}
+    }
+    return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : updateNormalizedWeights
+
+  PURPOSE  : Update the weights after all patterns have been presented by 
+             a spezialized batch learning scheme, which places the number
+	     of weight changes in the value_b fields.
+  RETURNS  : kernel error code
+  NOTES    : This function should not be called with a normalized learning rate
+
+  UPDATE   : 31.03.98 Michael Vogt
+******************************************************************************/
+static krui_err updateNormalizedWeights(float eta)
+{
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register FlintType fastnull = 0.0;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	if (!IS_SPECIAL_UNIT(unit_ptr)) {
+	    flags = unit_ptr->flags;
+
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use */
+		if (unit_ptr->value_b > fastnull)
+		    unit_ptr->bias += 
+			unit_ptr->value_a * eta/unit_ptr->value_b;
+		if (flags & UFLAG_SITES) {
+		    /* unit has sites */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			{
+			    if (link_ptr->value_b > fastnull)
+				link_ptr->weight += 
+				    link_ptr->value_a * eta/link_ptr->value_b;
+			}
+		} else if (flags & UFLAG_DLINKS) {
+		    /* unit has direct links */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			{
+			    if (link_ptr->value_b > fastnull)
+				link_ptr->weight += 
+				    link_ptr->value_a * eta/link_ptr->value_b;
+			}
+		}
+	    }
+	}
+    }
+    return (KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropBatch
+
+  PURPOSE  : main routine for the batch version of the backpropagation 
+             algorithm
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err  LEARN_backpropBatch(int start_pattern, int end_pattern, 
+			      float *parameterInArray, int NoOfInParams, 
+			      float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             pattern_no, sub_pat_no, no_of_layers;
+    int             pattern_count;
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    /* ####  have to be changed (must be 2)  #### */
+    if (NoOfInParams < 1) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+    *NoOfOutParams = 1;	  /* One return value is available ( learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) && 
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+    clearDeltas();
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+    pattern_count = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+	pattern_count++;
+	propagateNetForward(pattern_no,sub_pat_no);  /* Forward propagation */
+
+	/* Backward propagation  */
+	/* 1st parameter is the learning parameter 2nd parameter is the max.
+	   devitation between output pattern and the output of the output
+	   unit (delta max) */
+	NET_ERROR(OutParameter) +=
+	    propagateNetBackwardBatch(pattern_no,sub_pat_no,
+				      LEARN_PARAM2(parameterInArray));
+    }
+
+    if (pattern_count > 0)
+	updateWeights(LEARN_PARAM1(parameterInArray)/pattern_count);
+
+
+    return (KernelErrorCode);
+}
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : backpropagation learning algorithm with momentum term
+
+  AUTHOR       : Niels Mache
+             
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : initializeBackpropMomentum
+
+  PURPOSE  : backprop-momentum initialisation
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err initializeBackpropMomentum(void)
+{
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {	/* unit is in use  */
+	    unit_ptr->value_a = (FlintType) 0;
+
+	    if (flags & UFLAG_SITES) {	/* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    link_ptr->value_b = (FlintType) 0;
+	    } else {		/* unit has no sites   */
+		if (flags & UFLAG_DLINKS) {	/* unit has direct links   */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			link_ptr->value_b = (FlintType) 0;
+		}
+	    }
+	}
+    }
+
+    return (KRERR_NO_ERROR);
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : Backprop_momentum_FSE
+  PURPOSE  : Backward error propagation (topological) of backpropagation 
+             learnig function with momentum term and flat spot elimination
+
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   : 07.02.1994 by Sven Doering
+******************************************************************************/
+static float Backprop_momentum_FSE(int pattern_no, int sub_pat_no, 
+				   float learn_parameter, 
+				   float mu, float FSE_term, float delta_max)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, eta, devit, learn_error, mu_help;
+    register TopoPtrArray topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;		/* reset network error  */
+    eta = learn_parameter;	/* store learn_parameter in CPU register  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+    out_pat += size;
+
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output;	/* calc. devitation */
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	sum_error += devit * devit;	/* sum up the error of the network  */
+	/* calc. error for output units	 */
+	error = devit * ((unit_ptr->act_deriv_func) (unit_ptr) + FSE_term);
+
+	/* calc. the error for adjusting weights and bias of the predecessor
+	   units  */
+	mu_help = mu;
+	learn_error = eta * error;
+	if(IS_SPECIAL_UNIT( unit_ptr )){
+	    learn_error = 0.0;
+	    mu = 0.0;
+	}
+	unit_ptr->value_a = learn_error + mu * unit_ptr->value_a;
+	/* adjust bias value  */
+	unit_ptr->bias += unit_ptr->value_a;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {	/* the unit has direkt links  */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust link weights and
+						   calc. sum of errors of the
+						   predecessor units  */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_b = learn_error * link_ptr->to->Out.output + 
+		                    mu * link_ptr->value_b;
+		link_ptr->weight += link_ptr->value_b;
+	    }
+	} else {		/* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* adjust links and calc. sum of errors of the pred. units */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+		link_ptr->value_b = learn_error * link_ptr->to->Out.output + 
+		                    mu * link_ptr->value_b;
+		link_ptr->weight += link_ptr->value_b;
+	    }
+	}
+	mu = mu_help;
+    }
+
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	/* calc. the error of the (hidden) unit  */
+	error = unit_ptr->Aux.flint_no * 
+	        ((unit_ptr->act_deriv_func) (unit_ptr) + FSE_term);
+
+	/* calc. the error for adjusting weights and bias of the pred. units */
+	mu_help = mu;
+	learn_error = eta * error;
+	if(IS_SPECIAL_UNIT( unit_ptr )){
+	    learn_error = 0.0;
+	    mu = 0.0;
+	}
+	unit_ptr->value_a = learn_error + mu * unit_ptr->value_a;
+	/* adjust bias value  */
+	unit_ptr->bias += unit_ptr->value_a;
+
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {	/* the unit has direkt links */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust link weights and
+						   calc. sum of errors of the
+						   predecessor units  */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+		    /* this link points to a hidden unit: sum up the error's
+		       from previos units  */
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		link_ptr->value_b = learn_error * link_ptr->to->Out.output + 
+		                    mu * link_ptr->value_b;
+		link_ptr->weight += link_ptr->value_b;
+	    }
+	} else {		/* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* adjust links and calc. sum of errors of the pred. units */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+		    /* this link points to a hidden unit: sum up the error's
+		       from previos units  */
+			link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		link_ptr->value_b = learn_error * link_ptr->to->Out.output + 
+		                    mu * link_ptr->value_b;
+		link_ptr->weight += link_ptr->value_b;
+	    }
+	}
+	mu = mu_help;
+    }
+
+    return (sum_error);		/* return the error of the network */
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropMomentum
+
+  PURPOSE  : main routine for backpropagation with momentum
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : momentum term
+				 3 : flat-spot-elimination value
+				 4 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_backpropMomentum(int start_pattern, int end_pattern, 
+				float *parameterInArray, int NoOfInParams, 
+				float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1];  /*OutParameter[0] stores the learning error*/
+    int          ret_code, pattern_no, sub_pat_no;
+
+
+    if (NoOfInParams < 1)	/* ####  have to be changed (must be 2)  #### */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);	/* an error has occured  */
+	if (ret_code < 2)
+	    return (KRERR_FEW_LAYERS);	/* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGICAL_FF);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   backprop now  */
+	ret_code = initializeBackpropMomentum();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward(pattern_no,sub_pat_no);	/* Forward propagation */
+
+	/* Backward propagation  */
+	/* 1st parameter is the learning parameter 2nd parameter is the
+	   momentum term 3rd parameter is the flat-spot-elimination value 4th
+	   parameter is the max. devitation between output pattern and the
+	   output of the output unit (delta max) */
+	NET_ERROR(OutParameter) +=
+	    Backprop_momentum_FSE(pattern_no,sub_pat_no,
+				  LEARN_PARAM1(parameterInArray),
+				  LEARN_PARAM2(parameterInArray),
+				  LEARN_PARAM3(parameterInArray),
+				  LEARN_PARAM4(parameterInArray));
+    }
+
+    return (ret_code);
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_backpropMomentum              joe
+
+  PURPOSE  : main routine for testing backpropagation with momentum
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : momentum term
+				 3 : flat-spot-elimination value
+				 4 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 20.01.95 by Joachim Danz
+******************************************************************************/
+krui_err TEST_backpropMomentum(int start_pattern, int end_pattern, 
+				float *parameterInArray, int NoOfInParams, 
+				float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1];  /*OutParameter[0] stores the learning error*/
+    int          ret_code, pattern_no, sub_pat_no;
+
+
+    if (NoOfInParams < 1)	/* ####  have to be changed (must be 2)  #### */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);	/* an error has occured  */
+	if (ret_code < 2)
+	    return (KRERR_FEW_LAYERS);	/* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGICAL_FF);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward(pattern_no,sub_pat_no);	/* Forward propagation */
+
+	/* Backward propagation  */
+	/* 1st parameter is the learning parameter 2nd parameter is the
+	   momentum term 3rd parameter is the flat-spot-elimination value 4th
+	   parameter is the max. devitation between output pattern and the
+	   output of the output unit (delta max) */
+	NET_ERROR(OutParameter) +=
+	    testNetBackward2(pattern_no,sub_pat_no,
+				  LEARN_PARAM1(parameterInArray),
+				   LEARN_PARAM4(parameterInArray));
+    }
+
+    return (ret_code);
+}
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : backpropagation learning algorithm with weight decay
+
+  AUTHOR       : Tobias Schreiner
+             
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : Backprop_weightdecay
+  PURPOSE  : Backward error propagation (topological) of backpropagation 
+             learnig function with weigth decay
+
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+static float Backprop_weightdecay (int pattern_no, int sub_pat_no, 
+				   float learn_parameter, 
+				   float wd_gamma, float min_weight,
+				   float delta_max)
+
+{
+
+    register Patterns out_pat;
+    register float error, sum_error, eta, devit, learn_error;
+    register TopoPtrArray topo_ptr;
+    int size;
+
+    /* reset network error  */
+    sum_error = 0.0;
+
+    /* store learn_parameter in CPU register  */
+    eta = learn_parameter;
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+/*    out_pat = out_patterns + (pattern_no + 1) * NoOfOutputPatterns;*/
+
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    if(out_pat == NULL)
+    {
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return(-1);
+    }
+    out_pat += size;
+
+    /* add 3 to no_of_topo_units because the topologic array contains */
+    /* 4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unitPtr = *--topo_ptr) != NULL)
+    {
+	/* update unitNo */
+	unitNo = unitPtr - unit_array;
+
+	/* calculate devitation */
+	devit = *(--out_pat) - unitPtr->Out.output;
+	if ((float) fabs (devit) <= delta_max)
+	    continue;
+
+	/* sum up the error of the network  */
+	sum_error += devit * devit;
+
+	/* calculate error for output units	 */
+	error = devit * (unitPtr->act_deriv_func) (unitPtr);
+
+	/* calculate the error for adjusting weights and bias of the */
+	/* predecessor units  */
+	if (IS_SPECIAL_UNIT(unitPtr))
+	    learn_error = 0.0;
+	else
+	    learn_error = eta * error;
+
+	/* adjust bias value  */
+	unitPtr->bias += learn_error - wd_gamma * unitPtr->bias;
+
+	/* initialize prevLinkPtr */
+	prevLinkPtr = NULL;
+
+	if UNIT_HAS_DIRECT_INPUTS (unitPtr)
+	    /* the unit has direkt links  */
+	    for (linkPtr = (struct Link *) unitPtr->sites;
+		 linkPtr != NULL;
+		 linkPtr = linkPtr ? linkPtr->next : linkPtr)
+	    {
+		/* calculate errors of the predecessor units  */
+		linkPtr->to->Aux.flint_no += linkPtr->weight * error;
+
+		/* adjust the link weights */
+		linkPtr->weight += 
+		    learn_error * linkPtr->to->Out.output
+			- wd_gamma * linkPtr->weight;
+
+		/* prune link if smaller than minimum */
+		if (fabs (linkPtr->weight) < min_weight)
+		    kr_deleteLink ();
+
+		/* adjust prevLinkPtr */
+		prevLinkPtr = linkPtr;
+	    }
+	else 
+	    /* the unit has sites  */
+	    for (sitePtr = unitPtr->sites;
+		 sitePtr != NULL;
+		 sitePtr = sitePtr ? sitePtr->next : sitePtr)
+		for (linkPtr = sitePtr->links;
+		     linkPtr != NULL;
+		     linkPtr = linkPtr ? linkPtr->next : linkPtr)
+		{	
+		    /* calculate errors of the predecessor units  */
+		    linkPtr->to->Aux.flint_no += linkPtr->weight * error;
+		    
+		    /* adjust the link weights */
+		    linkPtr->weight += 
+			learn_error * linkPtr->to->Out.output
+			    - wd_gamma * linkPtr->weight;
+		    
+		    /* prune link if smaller than minimum */
+		    if (fabs (linkPtr->weight) < min_weight)
+			kr_deleteLink ();
+		    
+		    /* adjust prevLinkPtr */
+		    prevLinkPtr = linkPtr;
+		}
+    }
+
+    /* calculate hidden units only  */
+    while ((unitPtr = *--topo_ptr) != NULL)
+    {
+	/* update unitNo */
+	unitNo = unitPtr - unit_array;
+
+	/* calculate the error of the (hidden) unit  */
+	error = (unitPtr->act_deriv_func) (unitPtr) * 
+	    unitPtr->Aux.flint_no;
+
+	/* calculate the error for adjusting weights and bias of the */
+	/* predecessor units  */
+	if (IS_SPECIAL_UNIT(unitPtr)) 
+	    learn_error = 0.0;
+	else
+	    learn_error = eta * error;
+
+	/* adjust bias value  */
+	unitPtr->bias += learn_error - wd_gamma * unitPtr->bias;
+
+	/* initialize prevLinkPtr */
+	prevLinkPtr = NULL;
+
+	if UNIT_HAS_DIRECT_INPUTS (unitPtr)
+	    /* the unit has direkt links  */
+	    for (linkPtr = (struct Link *) unitPtr->sites;
+		 linkPtr != NULL;
+		 linkPtr = linkPtr ? linkPtr->next : linkPtr)
+	    {
+		/* calculate errors of the predecessor units  */
+		if IS_HIDDEN_UNIT (linkPtr->to)
+		    /* this link points to a hidden unit: sum up the */
+		    /* error's from previos units  */
+		    linkPtr->to->Aux.flint_no += 
+			linkPtr->weight * error;
+
+		/* adjust link weights */
+		linkPtr->weight +=
+		    learn_error * linkPtr->to->Out.output
+			- wd_gamma * linkPtr->weight;
+
+		/* prune link if smaller than minimum */
+		if (fabs (linkPtr->weight) < min_weight)
+		    kr_deleteLink ();
+
+		/* adjust prevLinkPtr */
+		prevLinkPtr = linkPtr;
+	    }
+	else
+	    /* the unit has sites  */
+	    for (sitePtr = unitPtr->sites;
+		 sitePtr != NULL;
+		 sitePtr = sitePtr ? sitePtr->next : sitePtr)
+		for (linkPtr = sitePtr->links;
+		     linkPtr != NULL;
+		     linkPtr = linkPtr ? linkPtr->next : linkPtr)
+		{	
+		    /* calculate errors of the predecessor units  */
+		    if IS_HIDDEN_UNIT (linkPtr->to)
+			/* this link points to a hidden unit: sum up */
+			/* the error's from previos units  */
+			linkPtr->to->Aux.flint_no += 
+			    linkPtr->weight * error;
+
+		    /* adjust links */
+		    linkPtr->weight +=
+			learn_error * linkPtr->to->Out.output
+			    - wd_gamma * linkPtr->weight;
+		    
+		    /* prune link if smaller than minimum */
+		    if (fabs (linkPtr->weight) < min_weight)
+			kr_deleteLink ();
+		    
+		    /* adjust prevLinkPtr */
+		    prevLinkPtr = linkPtr;
+		}
+    }
+
+    return (sum_error);		/* return the error of the network */
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropWeightDecay
+
+  PURPOSE  : main routine for backpropagation with weight decay
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : parameter for weight decay
+				 3 : minimum weight (smaller weights
+				     will be pruned) 
+				 4 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+	     special flags are reset!
+
+  UPDATE   :
+******************************************************************************/
+krui_err LEARN_backpropWeightDecay (int start_pattern, int end_pattern, 
+		float *parameterInArray, int NoOfInParams, 
+		float **parameterOutArray, int *NoOfOutParams)
+
+{
+
+    static float OutParameter [1];  
+    /* OutParameter [0] stores the learning error */ 
+    int pattern_no, sub_pat_no, no_of_layers;
+
+    /* reset return code  */
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    /* assure four input parameters */
+    if (NoOfInParams < 4)
+    {
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    /* learning error is the only output parameter */
+    *NoOfOutParams = 1;
+    *parameterOutArray = OutParameter;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) 
+	/* Net has been modified or topologic array isn't initialized */
+    {	
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck ();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    return (KernelErrorCode);	/* an error has occured  */
+	if (no_of_layers < 2)
+	    /* the network has less then 2 layers */
+	{
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck () != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	kr_topoSort (TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) && 
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    /* reset network error value  */
+    NET_ERROR (OutParameter) = 0.0;
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no))
+    {
+	/* Forward propagation */
+	propagateNetForward(pattern_no,sub_pat_no);
+
+	/* Backward propagation with parameters according to header */
+	NET_ERROR(OutParameter) +=
+	    Backprop_weightdecay (pattern_no, sub_pat_no,
+				  LEARN_PARAM1 (parameterInArray),
+				  LEARN_PARAM2 (parameterInArray),
+				  LEARN_PARAM3 (parameterInArray),
+				  LEARN_PARAM4 (parameterInArray));
+    }
+
+    pr_checkDeadUnits();
+
+    return (KernelErrorCode);
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropChunk
+
+  PURPOSE  : main routine for the chunk-update version of the backpropagation 
+             algorithm
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+                                 3 : chunk size
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  LEARN_backpropChunk(int start_pattern, int end_pattern, 
+			      float *parameterInArray, int NoOfInParams, 
+			      float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             pattern_no, sub_pat_no, no_of_layers;
+    int             i = 0;
+    
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NoOfInParams < 3) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    *NoOfOutParams = 1;	  /* One return value is available ( learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    OutParameter[0] = 0.0;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) && 
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+    NET_ERROR(OutParameter) = 0.0; /* init error variable */
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* prepare for beginning of one chunk */
+    clearDeltas();
+
+    i = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+        propagateNetForward(pattern_no,sub_pat_no);  
+        NET_ERROR(OutParameter) +=
+            propagateNetBackwardBatch(pattern_no,sub_pat_no,
+                                      LEARN_PARAM2(parameterInArray));
+	
+	if( ++i >= (int)(LEARN_PARAM3(parameterInArray))){
+	    updateWeights(LEARN_PARAM1(parameterInArray)/i);
+	    clearDeltas();
+	    i = 0;
+	}
+    }
+
+    /* update the network weights */
+    if (i>0)
+    {
+	updateWeights(LEARN_PARAM1(parameterInArray)/i);
+    }
+
+    return (KernelErrorCode);
+    
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropJogChunk
+
+  PURPOSE  : main routine for the chunk-update version of the backpropagation 
+             algorithm with embedded weights jogging
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+                                 3 : chunk size
+                                 4 : lower jog value
+                                 5 : upper jog value
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+	     To be used within batchman scripts that apply automatically 
+	     decrease of absolute jog values.
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  LEARN_backpropJogChunk(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams, 
+				 float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             pattern_no, sub_pat_no, no_of_layers;
+    int             i = 0;
+    
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NoOfInParams < 3) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    *NoOfOutParams = 1;	  /* One return value is available ( learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    OutParameter[0] = 0.0;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) && 
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	NetModified = FALSE;
+    }
+
+    NET_ERROR(OutParameter) = 0.0; /* init error variable */
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* prepare for beginning of one chunk */
+    clearDeltas();
+
+    i = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	if (i==0 && 
+	    (LEARN_PARAM4(parameterInArray) != 0.0 || 
+	     LEARN_PARAM5(parameterInArray) != 0.0))
+	    kr_jogWeights(LEARN_PARAM4(parameterInArray), 
+			  LEARN_PARAM5(parameterInArray));
+
+        propagateNetForward(pattern_no,sub_pat_no);  
+        NET_ERROR(OutParameter) +=
+            propagateNetBackwardBatch(pattern_no,sub_pat_no,
+                                      LEARN_PARAM2(parameterInArray));
+	
+	if( ++i == (int)(LEARN_PARAM3(parameterInArray))){
+	    updateWeights(LEARN_PARAM1(parameterInArray)/i);
+	    clearDeltas();
+	    i = 0;
+	}
+    }
+
+    /* update the network weights */
+    if (i>0)
+    {
+	updateWeights(LEARN_PARAM1(parameterInArray)/i);
+    }
+
+    return (KernelErrorCode);
+    
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_backpropClassJogChunk
+
+  PURPOSE  : main routine for the chunk-update version of the backpropagation 
+             algorithm with embedded weights jogging
+	     only neurons with matching class information are trained:
+
+	     with x in {0, 1, 2, 3, ...}
+	     if unit name = "class+x[+x]*"
+	         only train, if current pattern class index is one of the given
+                 x values
+	     else if unit name = "class-x[-x]*"
+	         only train, if current pattern class index is different from
+                 all of the given x values
+	     else (for all other unit names and if no class information at all)
+                 train as usual
+
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+                                 3 : chunk size
+                                 4 : lower jog value
+                                 5 : upper jog value
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+	     To be used within batchman scripts that apply automatically 
+	     decrease of absolute jog values.
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  LEARN_backpropClassJogChunk(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams, 
+				 float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             pattern_no, sub_pat_no, no_of_layers;
+    int             i = 0;
+    unsigned long int class_flags;
+    unsigned long int class_add_flags;
+    char            delimiter;
+    char            *class_p;
+    char            class_str[9];
+    int             class_num;
+    const int       maxclasses = 8 * sizeof(unsigned long int);
+    struct Unit     *unit_ptr;
+
+    KernelErrorCode = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NoOfInParams < 3) {	/* Not enough input parameters	 */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    *NoOfOutParams = 1;	  /* One return value is available ( learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    OutParameter[0] = 0.0;
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	no_of_layers = kr_topoCheck();
+	if (KernelErrorCode != KRERR_NO_ERROR)
+	    /* an error has occured	 */
+	    return (KernelErrorCode);
+
+	if (no_of_layers < 2) {	/* the network has less then 2 layers  */
+	    KernelErrorCode = KRERR_FEW_LAYERS;
+	    return (KernelErrorCode);
+	}
+	/* count the no. of I/O units and check the patterns  */
+	if (kr_IOCheck() != KRERR_NO_ERROR)
+	    return (KernelErrorCode);
+
+	/* sort units by topology and by topologic type  */
+	(void) kr_topoSort(TOPOLOGICAL_FF);
+	if ((KernelErrorCode != KRERR_NO_ERROR) && 
+	    (KernelErrorCode != KRERR_DEAD_UNITS))
+	    return (KernelErrorCode);
+
+	/* set the usr_flags field of all units according to the class
+	   information given in the unit name:
+	   A bit set at position 2^n means to train this unit for class n */
+	FOR_ALL_UNITS(unit_ptr) {
+	    if (unit_ptr->unit_name &&
+		(strncmp(unit_ptr->unit_name, "class+", 6) == 0 ||
+		 strncmp(unit_ptr->unit_name, "class-", 6) == 0)
+		)
+	    {
+		delimiter = unit_ptr->unit_name[5];
+		if (delimiter == '+')
+		    class_flags = ((unsigned long int) 0); /* 00000000 */
+		else /* delimiter == '-' */
+		    class_flags = ~((unsigned long int) 0); /* 11111111 */
+		
+		class_p = &(unit_ptr->unit_name[5]);
+		while (*class_p != '\0')
+		{
+		    class_p++;
+		    class_str[0] = '\0';
+		    strncpy(class_str, class_p, 8);
+		    i = 0;
+		    while (i < 8 && isdigit(class_str[i]))
+			i++;
+		    if (i<8)
+			class_str[i] = '\0';
+		    class_num = atoi(class_str);
+		    if (class_num >= maxclasses)
+		    {
+			fprintf(stderr, 
+				"LEARN_backpropClassJogChunk: "
+				"units class information not handled\n"
+				"%d is >= %d (maxclasses)\n",
+				class_num, maxclasses);
+			class_add_flags = ((unsigned long int) 0);
+		    }
+		    else
+			class_add_flags = 
+			    ((unsigned long int) 1) << class_num;
+		    if (delimiter == '+')
+			class_flags |= class_add_flags;
+		    else
+			class_flags ^= class_add_flags;
+		    while (*class_p != '\0' && *class_p != delimiter)
+			class_p++;
+		}
+		unit_ptr->usr_flags = class_flags;
+	    }
+	    else
+		unit_ptr->usr_flags = ~((unsigned long int) 0); /* 11111111 */
+#ifdef DEBUG
+	    printf("%s: %lx  ", 
+		  unit_ptr->unit_name ? unit_ptr->unit_name : "",
+		  unit_ptr->usr_flags);
+#endif
+	}
+#ifdef DEBUG
+	printf("\n");
+#endif
+	NetModified = FALSE;
+    }
+
+    NET_ERROR(OutParameter) = 0.0; /* init error variable */
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* prepare for beginning of one chunk */
+    clearAllDeltas();
+
+    i = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	if (i==0 && 
+	    (LEARN_PARAM4(parameterInArray) != 0.0 || 
+	     LEARN_PARAM5(parameterInArray) != 0.0))
+	{
+#ifdef HAVE_LRAND48
+	    unsigned short lastseed[3];
+	    unsigned short *seedptr;
+
+	    /* read out current seed information and also use it */
+	    seedptr = seed48(lastseed);
+	    lastseed[0] = seedptr[0];
+	    lastseed[1] = seedptr[1];
+	    lastseed[2] = seedptr[2];
+	    seed48(lastseed);
+#endif
+	    kr_jogWeights(LEARN_PARAM4(parameterInArray), 
+			  LEARN_PARAM5(parameterInArray));
+#ifdef HAVE_LRAND48
+	    /* reset to previous random seed */
+	    seed48(lastseed);
+#endif
+	}
+
+        propagateNetForward(pattern_no,sub_pat_no);  
+        NET_ERROR(OutParameter) +=
+            propagateClassNetBackwardBatch(pattern_no,sub_pat_no,
+					   LEARN_PARAM2(parameterInArray));
+	
+	if( ++i >= (int)(LEARN_PARAM3(parameterInArray))){
+	    updateNormalizedWeights(LEARN_PARAM1(parameterInArray));
+	    clearAllDeltas();
+	    i = 0;
+	}
+    }
+
+    /* update the network weights */
+    if (i>0)
+    {
+	updateNormalizedWeights(LEARN_PARAM1(parameterInArray));
+    }
+
+    return (KernelErrorCode);
+    
+}
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : quickpropagation learning function
+
+  AUTHOR       : Peter Zimmerer
+             
+******************************************************************************
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : initializeQuickprop
+
+  PURPOSE  : initializes the quickprop learning
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err initializeQuickprop(void)
+{
+    register unsigned short flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {	/* unit is in use  */
+	    unit_ptr->value_a = unit_ptr->value_b =
+		unit_ptr->value_c = (FlintType) 0;
+
+	    if (flags & UFLAG_SITES) {	/* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    link_ptr->value_a = link_ptr->value_b = 
+			                link_ptr->value_c = (FlintType) 0;
+	    } else {		/* unit has no sites   */
+		if (flags & UFLAG_DLINKS) {	/* unit has direct links    */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			link_ptr->value_a = link_ptr->value_b = 
+			                    link_ptr->value_c = (FlintType) 0;
+		}
+	    }
+	}
+    }
+
+    return (KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackwardQuickprop
+
+  PURPOSE  : quickprop backward error propagation
+  RETURNS  : network error
+  NOTES    : quickprop backward error propagation
+             (topological) for quickprop with SIGMOID_PRIME_OFFSET
+	     batch-modus: without adaption of links and bias
+
+  UPDATE   : 05.11.1993 by Guenter Mamier
+******************************************************************************/
+static float propagateNetBackwardQuickprop(int pattern_no, int sub_pat_no, 
+					   float delta_max)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error,	/* error  */
+    sum_error,			/* sum of the error  */
+    devit;			/* deviation  */
+    TopoPtrArray    topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output;
+	/* = o * (1.0 - o) in [0.0,0.25], */
+	/* for asymmetric logistic function */
+
+	if ((float) fabs(devit) <= delta_max)
+	    continue;
+
+	sum_error += devit * devit; /* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * ((unit_ptr->act_deriv_func) (unit_ptr) +
+			 SIGMOID_PRIME_OFFSET);
+
+	unit_ptr->value_c += -error; /* calculate the bias slopes  */
+	/* learn bias like a weight  */
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direct links  */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* calculate the slopes */
+		link_ptr->value_c += -error * link_ptr->to->Out.output;
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	    }
+	} else {
+	    /* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* calculate the value_cs  */
+		link_ptr->value_c += -error * link_ptr->to->Out.output;
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	    }
+	}
+    }
+
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	error = ((unit_ptr->act_deriv_func) (unit_ptr) +
+		 SIGMOID_PRIME_OFFSET) * unit_ptr->Aux.flint_no;
+
+	unit_ptr->value_c += -error; /* calculate the bias slopes  */
+	/* learn bias like a weight  */
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {
+	    /* the unit has direct links  */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) { /* calculate the slopes  */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no += 
+			    link_ptr->weight * error;
+
+		link_ptr->value_c += -error * link_ptr->to->Out.output;
+	    }
+	} else {
+	    /* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {	
+		/* calculate the slopes  */
+		if IS_HIDDEN_UNIT
+		    (link_ptr->to)
+			/* this link points to a hidden unit: sum up the
+			   error's from previos units  */
+			link_ptr->to->Aux.flint_no += 
+			    link_ptr->weight * error;
+
+		link_ptr->value_c += -error * link_ptr->to->Out.output;
+	    }
+	}
+    }
+    return (sum_error);		/* return the error of the network  */
+}
+
+
+/*****************************************************************************
+  FUNCTION : MODI_quickprop
+
+  PURPOSE  : modifies the network at the end of each epoch
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void  MODI_quickprop(float learn_parameter, float max_factor, 
+			    float decay)
+ /* learning parameter */
+ /* maximal grow factor of weights */
+ /* decay factor */
+
+{
+    double          deltaw;	/* actual weight (bias) change */
+    float           shfac;	/* shrink factor */
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    TopoPtrArray    topo_ptr;
+    bool            hidden_units;
+
+
+    /* maximal grow factor of weights is max_factor  */
+    shfac = max_factor / (1.0 + max_factor);
+
+     topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+    hidden_units = TRUE;
+
+    /* calculate hidden and output units only  */
+    do {
+	if ((unit_ptr = *++topo_ptr) == NULL) {
+	    if (!hidden_units)
+		break;		/* end of topologic pointer array reached  */
+	    unit_ptr = *++topo_ptr;	/* skip NULL pointer  */
+	    hidden_units = FALSE;
+	}
+	if (IS_SPECIAL_UNIT(unit_ptr)) {
+	    unit_ptr->value_a = 
+	    unit_ptr->value_b = 
+	    unit_ptr->value_c = 0.0;
+	    if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {/* unit has direct links */
+		FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		    link_ptr->value_a = 
+		    link_ptr->value_b = 
+		    link_ptr->value_c = 0.0;
+		}
+	    } else {		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {
+		    link_ptr->value_a = 
+		    link_ptr->value_b = 
+		    link_ptr->value_c = 0.0;
+		}
+	    }
+	} else {
+	    deltaw = 0.0;	/* adjust bias like a weight  */
+	    if (unit_ptr->value_a > 0.0) { /* previous step was positive  */
+		if (unit_ptr->value_c < 0.0)
+		    /* same direction,i.e. slope, value_b have same sign  */
+		    deltaw += learn_parameter * (-unit_ptr->value_c);
+
+		if (unit_ptr->value_c <= shfac * unit_ptr->value_b)
+		    /* maximal positive step  */
+		    deltaw += max_factor * unit_ptr->value_a;
+		else
+		    /* littler positive step squared approximation  */
+		    deltaw += unit_ptr->value_c / 
+			      (unit_ptr->value_b - unit_ptr->value_c)
+			      * unit_ptr->value_a;
+	    } else if (unit_ptr->value_a < 0.0) {	/* previous step was
+							   negative  */
+		if (unit_ptr->value_c > 0.0)
+		    /* same direction,i.e. slope, prevslope have same sign  */
+		    deltaw += learn_parameter * (-unit_ptr->value_c);
+
+		if (unit_ptr->value_c >= shfac * unit_ptr->value_b)
+		    /* maximal negative step  */
+		    deltaw += max_factor * unit_ptr->value_a;
+		else
+		    /* littler negative step squared approximation */
+		    deltaw += unit_ptr->value_c / 
+			      (unit_ptr->value_b - unit_ptr->value_c)
+			      * unit_ptr->value_a;
+	    } else
+		/* previous step was 0.0  */
+		/* start of learning process with BP  */
+		deltaw += learn_parameter * (-unit_ptr->value_c);
+
+	    unit_ptr->bias += deltaw;	/* new bias */
+	    unit_ptr->value_a = deltaw;	/* bias change */
+	    unit_ptr->value_b = unit_ptr->value_c;	/* previous slope */
+	    unit_ptr->value_c = decay * unit_ptr->bias;	/* set new slope  */
+
+	    /* adjust links */
+	    if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {/* unit has direct links */
+		FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		    deltaw = 0.0;
+
+		    if (link_ptr->value_a > 0.0) { /* prev step was positive */
+			if (link_ptr->value_c < 0.0)
+			    /* same direction,i.e. slope, prevslope have same
+			       sign  */
+			    deltaw += learn_parameter * (-link_ptr->value_c);
+
+			if (link_ptr->value_c <= shfac * link_ptr->value_b)
+			    /* maximal positive step  */
+			    deltaw += max_factor * link_ptr->value_a;
+			else
+			    deltaw += link_ptr->value_c / 
+				      (link_ptr->value_b - link_ptr->value_c)
+				      * link_ptr->value_a;
+		    } else if (link_ptr->value_a < 0.0) {	
+			/* previous step was negative */
+			if (link_ptr->value_c > 0.0)
+			    /* same direction,i.e. slope, prevslope have same
+			       sign */
+			    deltaw += learn_parameter * (-link_ptr->value_c);
+
+			if (link_ptr->value_c >= shfac * link_ptr->value_b)
+			    /* maximal negative step  */
+			    deltaw += max_factor * link_ptr->value_a;
+			else
+			    deltaw += link_ptr->value_c / 
+				      (link_ptr->value_b - link_ptr->value_c)
+				      * link_ptr->value_a;
+		    } else	/* previous step was 0.0  */
+			/* start of learning process with BP  */
+			deltaw += learn_parameter * (-link_ptr->value_c);
+
+		    link_ptr->weight += deltaw;	/* new weight */
+		    link_ptr->value_a = deltaw;	/* weight change */
+		    link_ptr->value_b = link_ptr->value_c;  /* previous slope */
+		    /* set new slope  */
+		    link_ptr->value_c = decay * link_ptr->weight;
+		}		/* for links  */
+	    } else {		/* the unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {
+		    deltaw = 0.0;
+		    if (link_ptr->value_a > 0.0) {	/* previous step was
+							   positive  */
+			if (link_ptr->value_c < 0.0)
+			    /* same direction,i.e. slope, prevslope have same
+			       sign  */
+			    deltaw += learn_parameter * (-link_ptr->value_c);
+
+			if (link_ptr->value_c <= shfac * link_ptr->value_b)
+			    /* maximal positive step  */
+			    deltaw += max_factor * link_ptr->value_a;
+			else
+			    /* littler positive step squared approximation  */
+			    deltaw += link_ptr->value_c / 
+				      (link_ptr->value_b - link_ptr->value_c)
+				       * link_ptr->value_a;
+		    } else if (link_ptr->value_a < 0.0) {	
+			/* previous step was negative  */
+			if (link_ptr->value_c > 0.0)
+			    /* same direction,i.e. slope, prevslope have same
+			       sign  */
+			    deltaw += learn_parameter * (-link_ptr->value_c);
+
+			if (link_ptr->value_c >= shfac * link_ptr->value_b)
+			    /* maximal negative step  */
+			    deltaw += max_factor * link_ptr->value_a;
+			else
+			    deltaw += link_ptr->value_c / 
+				      (link_ptr->value_b - link_ptr->value_c)
+				      * link_ptr->value_a;
+		    } else	/* previous step was 0.0  */
+			/* start of learning process with BP  */
+			deltaw += learn_parameter * (-link_ptr->value_c);
+
+		    link_ptr->weight += deltaw;	/* new weight */
+		    link_ptr->value_a = deltaw;	/* weight change */
+		    link_ptr->value_b = link_ptr->value_c; /* previous slope */
+		    /* set new slope */
+		    link_ptr->value_c = decay * link_ptr->weight;
+		}
+	    }
+	}
+    }				/* for units  */
+    while (TRUE);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_quickprop
+
+  PURPOSE  : Quickprop learning function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : max factor (of the net after every epoch)
+                                 3 : decay
+                                 4 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_quickprop(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1]; /* OutParameter[0] stores the learning error*/
+    int          pattern_no, sub_pat_no, ret_code;
+
+
+    if (NoOfInParams < 1)	/* ###  have to be changed  (must be 3)  #### */
+	return (KRERR_PARAMETERS);	/* not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* one return value is available (the
+				   learning error) */
+
+    *parameterOutArray = OutParameter;	/* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);	/* an error has occured  */
+	if (ret_code < 2)
+	    return (KRERR_FEW_LAYERS);	/* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGICAL_FF);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   backprop now  */
+	ret_code = initializeQuickprop();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward(pattern_no,sub_pat_no);   /* Forward propagation */
+
+	/* backward propagation and summation of gradient  */
+	NET_ERROR(OutParameter) +=
+	    propagateNetBackwardQuickprop(pattern_no,sub_pat_no,
+					  LEARN_PARAM4(parameterInArray));
+    }
+
+    /* modificate links and bias  */
+    MODI_quickprop(LEARN_PARAM1(parameterInArray),
+		   LEARN_PARAM2(parameterInArray),
+		   LEARN_PARAM3(parameterInArray));
+
+    return (ret_code);
+}
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : Counterpropagation learning function
+
+******************************************************************************
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : initializeCPN
+
+  PURPOSE  : Counterpropagation initialisation
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err initializeCPN(void)
+{
+    register struct Unit *unit_ptr;
+
+
+    NoOfLearnedPatterns = 0;
+
+    /* set unit's bias to zero  */
+    FOR_ALL_UNITS(unit_ptr)
+	if ((unit_ptr->flags & UFLAG_IN_USE) == UFLAG_IN_USE)
+	/* unit is in use  */
+	unit_ptr->bias = (FlintType) 0;
+
+    return (KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : normalize_weight
+
+  PURPOSE  : Counterpropagation initialisation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void normalize_weight(struct Unit * winner_ptr, float sum)
+{
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register float  amount;
+
+
+    amount = 1.0 / sqrt(sum);
+
+    /* not necessary to see whether this is a special unit */
+
+    if (winner_ptr->flags & UFLAG_SITES)
+	/* the unit has sites */
+	FOR_ALL_SITES_AND_LINKS(winner_ptr, site_ptr, link_ptr)
+	    link_ptr->weight = link_ptr->weight * amount;
+    else
+	/* the unit has direct links */
+	FOR_ALL_LINKS(winner_ptr, link_ptr)
+	    link_ptr->weight = link_ptr->weight * amount;
+}
+
+
+/*****************************************************************************
+  FUNCTION : normalize_inputvector 
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void normalize_inputvector(float sum)
+{
+    register struct Unit *unit_ptr;
+    register float  amount;
+
+
+    amount = 1.0 / sqrt(sum);
+
+    FOR_ALL_UNITS(unit_ptr)
+	if (IS_INPUT_UNIT(unit_ptr) && UNIT_IN_USE(unit_ptr))
+	/* this is a input unit */
+	unit_ptr->Out.output = unit_ptr->Out.output * amount;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateNet_CPN
+
+  PURPOSE  : forward pass of counterprop
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static float propagateNet_CPN(int pattern_no, int sub_pat_no, float alpha,
+			      float beta, float threshold)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register struct Unit *winner_ptr;
+    register Patterns in_pat, out_pat;
+    float           maximum, sum_error, devit, learn_error, sum;
+    float           unit_ptr_net;
+    float           noOfPatterns_mul_NoHiddenUnits;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate the activation and the output values         */
+    /* of the input units (Input Layer)                       */
+
+    noOfPatterns_mul_NoHiddenUnits = (float) NoOfLearnedPatterns *
+	                             (float) NoOfHiddenUnits;
+
+    sum = 0.0;
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+
+    topo_ptr = topo_ptr_array;
+
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	
+	
+	/* topo_ptr points to the unit stuctures (sorted by: input-, hidden- 
+	   and output-units, separated with NULL pointers) */
+	sum += *in_pat * *in_pat;
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = 
+		(*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    if (sum != 0.0)
+	/* normalize the inputvector */
+	normalize_inputvector(sum);
+
+
+    /* propagate Kohonen Layer   */
+
+    /* calculate the activation and the output values         */
+    /* of the hidden units (Kohonen Layer)                    */
+
+
+    winner_ptr = NULL;
+    maximum = -1.0e30;		/* contains the maximum of the activations */
+
+    /* popagate hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	unit_ptr_net = 0.0;
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {	/* the unit has direct links */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr)
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	} else {		/* the unit has sites	 */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	}
+
+	if (unit_ptr->bias >= noOfPatterns_mul_NoHiddenUnits)
+	    unit_ptr_net -= threshold;
+
+	if (maximum < unit_ptr_net) {	/* determine winner unit  */
+	    winner_ptr = unit_ptr;
+	    maximum = unit_ptr_net;
+	}
+	/* reset output and activation of hidden units  */
+	unit_ptr->Out.output = unit_ptr->act = (FlintType) 0;
+    }
+
+
+    /* the competitive winner is chosen                */
+
+    winner_ptr->Out.output = winner_ptr->act = (FlintType) 1;
+    winner_ptr->bias++;
+
+
+
+    /* Training the Kohonen Layer                   
+       
+       Only the weights of links that go to the winning unit are adjusted, 
+       the others remain the same. The incoming weights to the competitive 
+       unit are adapted as follows:
+         
+       weight(new) = weight(old) + eta * (output - weight(old))  
+         
+       where eta is the learning constant (0<eta<=1.0)             
+       and output is the output of the input unit                  
+    */ 
+
+
+    if (!IS_SPECIAL_UNIT(winner_ptr)) {
+	sum = 0.0;
+	if (winner_ptr->flags & UFLAG_DLINKS) {	/* the winner unit has direct
+						   links  */
+	    FOR_ALL_LINKS(winner_ptr, link_ptr) {
+		devit = link_ptr->to->Out.output - link_ptr->weight;
+		learn_error = alpha * devit;
+		link_ptr->weight += learn_error;
+		/* this is needed for the normalization of the weight_vector */
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+	} else {		/* the winner unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(winner_ptr, site_ptr, link_ptr) {
+		devit = link_ptr->to->Out.output - link_ptr->weight;
+		learn_error = alpha * devit;
+		link_ptr->weight += learn_error;
+		/* this is needed for the normalization of the weight_vector */
+		sum += link_ptr->weight * link_ptr->weight;
+	    }
+	}
+	if (sum != 0.0)
+	    normalize_weight(winner_ptr, sum);
+    }
+
+
+    /* propagate Grossberg Layer                      */
+    /* Training the Grossberg Layer                   */
+    /* Adaptation of the Grossberg Layer weights is done by the    */
+    /* Widrow-Hoff rule:                                           */
+
+    /* weight(new) = weight(old) + beta * (target output - output) */
+
+    /* for all weights connected with the winning unit of the      */
+    /* Kohonen Layers                                              */
+
+
+    /* calculate address of the output pattern */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,NULL);
+
+
+    sum_error = 0.0;
+
+    /* popagate output units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+
+	/* calculate the activation and the output values         */
+	/* of the output units (Grossberg Layer)                  */
+
+	/* the activation function is the identity function (weighted sum)
+	   and identity output function */
+	unit_ptr->Out.output = unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	devit = *out_pat++ - unit_ptr->Out.output;    /* calculate devitation */
+	sum_error += devit * devit;
+	learn_error = beta * devit;
+
+	if (!IS_SPECIAL_UNIT(unit_ptr)) {
+	    if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)){ /* unit has direct links */
+		FOR_ALL_LINKS(unit_ptr, link_ptr)
+		    if (link_ptr->to == winner_ptr) {
+			/* link to the winning unit of the Kohonen Layer */
+			link_ptr->weight += learn_error;
+			break;
+		    }
+	    } else {		/* the unit has sites */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    if (link_ptr->to == winner_ptr) {
+			/* link to the winning unit of the Kohonen Layer */
+			link_ptr->weight += learn_error;
+			break;
+		    }
+	    }
+	}
+    }
+
+    return (sum_error);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_CPN
+
+  PURPOSE  : main function for counterpropagtion
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err  LEARN_CPN(int start_pattern, int end_pattern, 
+		    float *parameterInArray, int NoOfInParams, 
+		    float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+
+
+    if (NoOfInParams < 1)	/* have to be changed (must be 3) */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* one return value is available (the
+				   learning error) */
+    *parameterOutArray = OutParameter;	/* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* clear return code  */
+
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {	
+	/* Net has been modified  or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);	/* an error has occured  */
+	if (ret_code != 3)
+	    return (KRERR_FEW_LAYERS);	/* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   backprop now  */
+	ret_code = initializeCPN();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	NoOfLearnedPatterns++;
+	NET_ERROR(OutParameter) 
+	    += propagateNet_CPN(pattern_no,sub_pat_no,
+				LEARN_PARAM1(parameterInArray),
+				LEARN_PARAM2(parameterInArray),
+				LEARN_PARAM3(parameterInArray));
+    }
+
+    return (ret_code);
+}
+
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : Back-Percolation Learning Function
+
+  AUTHOR       : Artemis Hatzigeorgiou  Algorithm by Mark Jurik
+             
+******************************************************************************
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : propagateNetForward_perc
+
+  PURPOSE  : topological forward propagation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void propagateNetForward_perc(int pattern_no, int sub_pat_no)
+{
+    register struct Unit *unit_ptr;
+    register Patterns in_pat;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    topo_ptr = topo_ptr_array;
+
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture (input units
+						   first)  */
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = 
+		(*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    /* popagate hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	/* clear values  */
+	unit_ptr->Aux.flint_no = 0.0;
+	unit_ptr->value_a = 0.0;
+	unit_ptr->value_b = 0.000001;
+
+	/* calculate the activation value of the unit: call the activation
+	   function if needed  */
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /* popagate output units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	/* clear values  */
+	unit_ptr->Aux.flint_no = 0.0;
+	unit_ptr->value_a = 0.0;
+	unit_ptr->value_b = 0.000001;
+
+	/* calculate the activation value of the unit: call the activation
+	   function if needed  */
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackward_perc
+
+  PURPOSE  :topological backward propagation
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   : 07.02.1994 by Sven Doering
+******************************************************************************/
+static float propagateNetBackward_perc(int pattern_no, int sub_pat_no,
+				       float learn_parameter,
+				       float delta_max, float *perc_error)
+{
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, eta, devit;
+    register TopoPtrArray topo_ptr;
+    register float  norm, delta_sig_normaliser, message_weight;
+    register float  act_err, normalised_error, scaled_error, 
+                    delta_weight_normaliser;
+    register float  der = 0.0;
+    register float  tmp;	
+    register int    is_special;
+    int size;
+
+    sum_error = 0.0;		/* reset network error  */
+    eta = learn_parameter;	/* store learn_parameter in CPU register  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /* add 3 to no_of_topo_units because the topologic array contains 4 NULL
+       pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	devit = *(--out_pat) - unit_ptr->Out.output;	/* calc. devitation */
+
+	if (fabs(devit) > delta_max) {	/* calc. error for output units     */
+	    *perc_error += fabs(devit);
+	    error = -2.0 * devit * (unit_ptr->act_deriv_func) (unit_ptr);
+	    act_err = devit * eta;
+	    sum_error += devit * devit;	/* sum up the error of the network  */
+	} else {		/* set error of output units to zero	 */
+	    error = 0.0;
+	    act_err = 0.000001 * eta;
+	    continue;
+	}
+
+	/* calc. the error for adjusting weights and bias of the predecessor
+	   units  */
+
+	norm = 0.0;
+	delta_sig_normaliser = 0.000001;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {	/* adjust link weights and
+						   calc. sum of errors of the
+						   predecessor units  */
+	    if (IS_HIDDEN_UNIT(link_ptr->to))
+		norm += fabs(link_ptr->weight);
+	    delta_sig_normaliser += SQR(link_ptr->to->Out.output);
+	}
+	delta_weight_normaliser = delta_sig_normaliser + 1;
+	norm += delta_sig_normaliser;
+	is_special = IS_SPECIAL_UNIT(unit_ptr);
+	normalised_error = act_err / norm;
+	scaled_error = act_err / delta_weight_normaliser;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    tmp = link_ptr->weight * error;
+	    link_ptr->to->Aux.flint_no += tmp;
+
+	    message_weight = tmp * tmp;
+	    if (!is_special) {
+		link_ptr->to->value_a += link_ptr->weight * 
+		    normalised_error * message_weight;
+		link_ptr->to->value_b += message_weight;
+		link_ptr->weight += link_ptr->to->Out.output * scaled_error;
+	    }
+	}
+
+
+	/* adjust bias value  */
+	if (!is_special)
+	    unit_ptr->bias += scaled_error;
+    }
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	der = (unit_ptr->act_deriv_func) (unit_ptr);
+	error = der * unit_ptr->Aux.flint_no;
+	act_err = (unit_ptr->value_a / unit_ptr->value_b) * der;
+
+	/* calc. the error for adjusting weights and bias of the predecessor
+	   units  */
+
+	norm = 0.0;
+	delta_sig_normaliser = 0.000001;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    if (IS_HIDDEN_UNIT(link_ptr->to))
+		norm += fabs(link_ptr->weight);
+
+	    delta_sig_normaliser += SQR(link_ptr->to->Out.output);
+	}
+	delta_weight_normaliser = delta_sig_normaliser + 1;
+	norm += delta_sig_normaliser;
+	is_special = IS_SPECIAL_UNIT(unit_ptr);
+	normalised_error = act_err / norm;
+	scaled_error = act_err / delta_weight_normaliser;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    tmp = link_ptr->weight * error;
+	    link_ptr->to->Aux.flint_no += tmp;
+
+	    message_weight = tmp * tmp;
+
+	    if (!is_special) {
+		link_ptr->to->value_a += link_ptr->weight * 
+		    normalised_error * message_weight;
+		link_ptr->to->value_b += message_weight;
+		link_ptr->weight += link_ptr->to->Out.output * scaled_error;
+	    }
+	}
+
+
+	/* adjust bias value  */
+	if (!is_special)
+	    unit_ptr->bias += scaled_error;
+    }
+
+    return (sum_error);		/* return the error of the network */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_perc
+
+  PURPOSE  : main function for backpercolation
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : learning parameter
+                                 2 : delta max
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_perc(int start_pattern, int end_pattern, 
+	            float *parameterInArray, int NoOfInParams, 
+	            float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+    float           p_error, l_error;
+    register struct Unit *unit_ptr;
+
+    if (NoOfInParams < 1)	        /* have to be changed (must be 2)  */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		        /* One return value is available (the
+				           learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* check the topology of the network  */
+	FOR_ALL_UNITS(unit_ptr)
+	    if UNIT_HAS_SITES
+	    (unit_ptr)
+		return (KRERR_SITES_NO_SUPPORT);
+
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);	/* an error has occured  */
+	if (ret_code < 2)
+	    return (KRERR_FEW_LAYERS);	/* the network has less then 2 layers */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGICAL_FF);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   backprop now  */
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+	parameterInArray[4] = 1.0;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+    p_error = 0.0;
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	propagateNetForward_perc(pattern_no,sub_pat_no);  /* Forward pass */
+
+	/* Backward propagation  */
+	/* 1st parameter is the learning parameter 2nd parameter is the max.
+	   devitation between output pattern and the output of the output
+	   unit (delta max) */
+
+	NET_ERROR(OutParameter) +=
+	    propagateNetBackward_perc(pattern_no,sub_pat_no,
+				      LEARN_PARAM1(parameterInArray),
+				      LEARN_PARAM3(parameterInArray), &p_error);
+    }
+
+    p_error = p_error / (kr_TotalNoOfSubPatPairs()* NoOfOutputUnits);
+
+    if (p_error < LEARN_PARAM2(parameterInArray)) {
+	p_error = (parameterInArray[4] + p_error) / 2;
+	l_error = exp((parameterInArray[4] - p_error) / 
+		      (parameterInArray[4] + p_error));
+	if (l_error <= 0.5)
+	    l_error = 0.5;
+	else if (l_error >= 1.05)
+	    l_error = 1.05;
+	parameterInArray[0] = parameterInArray[0] * l_error;
+    }
+    parameterInArray[4] = p_error;
+
+    return (ret_code);
+}
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP  : Radial Basis Functions Learning
+
+  AUTHOR : Michael Vogt
+  Notes  : Use of special entries in links and units with RBFs:
+
+           for Units in hidden layer:
+	   Unit value_a: |X - L|^2  == norm^2 == square of euclidean distance 
+	                  between all links and all input units to this unit.
+	   Unit value_b: delta_BIAS == sum of all deltas to BIAS during learning
+	   Unit value_c: Backpropagated weighted sum of errors in output layer
+
+	   for Units in output layer:
+	   Unit value_a: error (y_learn - y_net) during learning current pattern
+	   Unit value_b: delta_BIAS == sum of all deltas to BIAS during learning
+
+	   for links between input and hidden layer:
+	   Link value_b: delta for this link during learning (link treated as 
+	                 vector)
+	   Link value_a: Momentum term for this link (last change)
+
+	   for links between hidden and output layer:
+	   Link value_b: delta for weight of this link during learning.
+	   Link value_a: Momentum term for this link (last change)
+ 
+	   for links between input and output layer:
+	   Link value_b: delta for weight of this link during learning.
+	   Link value_a: Momentum term for this link (last change)
+             
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : RbfLearnClean
+
+  PURPOSE  : Clean all deltas, so that learning can start.
+  RETURNS  : kernel error code
+  NOTES    : Called every time LEARN_RBF is called to be sure that there is 
+             no stuff inside the value_b fields of links and units
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err RbfLearnClean(void)
+{
+    register struct Unit *unit_ptr;
+    register struct Link *link_ptr;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	unit_ptr->value_b = 0.0;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    link_ptr->value_b = 0.0;
+	}
+    }
+
+    return KRERR_NO_ERROR;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : RbfLearnForward
+
+  PURPOSE  : Forward propagation of current pattern. Calculation of different
+             value_a fields. value_c of hidden units is set to 0.0
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err  RbfLearnForward(int pattern_no, int sub_pat_no)
+{
+    register struct Unit *unit_ptr;
+    register Patterns current_in_pattern;
+    register Patterns current_out_pattern;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate index of current input pattern in Pattern array:	 */
+    current_in_pattern = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    /* activate input units with current patterns and calculate	 */
+    /* their output value:						 */
+
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *(++topo_ptr)) != NULL) {
+	/* go through all input units, set activation and calculate */
+	/* output:							 */
+
+	unit_ptr->act = *current_in_pattern++;
+	unit_ptr->Out.output = unit_ptr->out_func == OUT_IDENTITY
+	    ? unit_ptr->act
+	    : (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /* activate hidden units, by calling the activation function	 */
+    /* (has to be a RBF activation function which places norm ^ 2	 */
+    /* into value_a of the unit: see trans_f.c: RbfUnitGetNormsqr). */
+    /* The output function is supposed to be OUT_IDENTITY !		 */
+    /* (so the output function is never called !)			 */
+
+    while ((unit_ptr = *(++topo_ptr)) != NULL) {
+	unit_ptr->act = unit_ptr->Out.output =
+	    (*unit_ptr->act_func) (unit_ptr);
+
+	unit_ptr->value_c = 0.0;
+    }
+
+    /* activate output units. Again, the output function is supposed */
+    /* to be OUT_IDENTITY. The calculated output is compared to the */
+    /* current pattern, the error (difference) is calculated and    */
+    /* stored in value_a of the current output unit.		 */
+
+    current_out_pattern = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,NULL);
+
+    while ((unit_ptr = *(++topo_ptr)) != NULL) {
+	unit_ptr->act = unit_ptr->Out.output =
+	    (*unit_ptr->act_func) (unit_ptr);
+	unit_ptr->value_a = *current_out_pattern++ - unit_ptr->act;
+    }
+
+    return KRERR_NO_ERROR;
+}
+
+
+#define	RBF_LEARN_CENTER	0x1
+#define RBF_LEARN_BIAS		0x2
+#define RBF_LEARN_WEIGHT	0x4
+#define RBF_LEARN_PAIN		0x8
+
+/*****************************************************************************
+  FUNCTION : RbfLearnAdjustDelta
+
+  PURPOSE  : Adjusting of all deltas (value_b fields) by using the current 
+             input pattern (activation of input units) and the stored error 
+	     of the output units (value_a). value_c of hidden units is used 
+	     too!
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+float RbfLearnAdjustDelta(float para_center, float para_bias, 
+			  float para_weight, float para_pain, 
+			  float para_momentum, float para_delta_max, 
+			  int learn_mask)
+{
+    register struct Unit *curr_unit;	/* current unit		 */
+    register struct Link *curr_link;	/* current link		 */
+    register struct Unit *source_unit;	/* input unit to link	 */
+    register TopoPtrArray topo_ptr;
+    register float  center_delta;	/* delta of centers	 */
+    register float  w_error;	        /* weighted error of 	 */
+                                        /* output unit		 */
+    register float  w2_error;           /* w_error for special u.*/
+    register float  learn_error;
+
+    /* start with last unit in output layer:			 */
+    topo_ptr = topo_ptr_array + no_of_topo_units + 3;
+
+    learn_error = 0.0;
+
+    /* work on the output layer and all links leading to it:	 */
+
+    while ((curr_unit = *(--topo_ptr)) != NULL) {
+	/* go on with next unit if |error| <= delta_max		 */
+	if ((float) fabs(curr_unit->value_a) <= para_delta_max)
+	    continue;
+
+	/* error, weighted by the deviation of the activation:	 */
+	w2_error = w_error = (curr_unit->value_a) *
+	    (*curr_unit->act_deriv_func) (curr_unit);
+
+	/* sum up the learning error:				 */
+	learn_error += (curr_unit->value_a) * (curr_unit->value_a);
+
+	if (learn_mask & RBF_LEARN_WEIGHT) {
+	    /* sum up all deltas for change of bias:		 */
+
+#ifdef RBF_INCR_LEARNING
+	    if (IS_SPECIAL_UNIT(curr_unit)
+		w_error = 0.0;
+	    curr_unit->bias += para_weight * w_error;
+#else
+	    curr_unit->value_b += w_error;
+#endif
+	}
+	if (learn_mask) {
+	    FOR_ALL_LINKS(curr_unit, curr_link) {
+		source_unit = curr_link->to;
+
+		/* sum up deltas for change of link weight:	 */
+
+#ifdef RBF_INCR_LEARNING
+		curr_link->weight += para_weight * w_error *
+		    source_unit->Out.output;
+#else
+		curr_link->value_b += w_error * source_unit->Out.output;
+#endif
+
+		/* if comming from hidden unit: sum up delta for change */
+		/* of bias of hidden unit:			        */
+		if (IS_HIDDEN_UNIT(source_unit))
+		    source_unit->value_c += w2_error * curr_link->weight;
+	    }
+	}
+    }
+
+    /* work on the hidden layer and all links leading to it:	 */
+
+    if (learn_mask & (RBF_LEARN_CENTER | RBF_LEARN_BIAS)) {
+	while ((curr_unit = *(--topo_ptr)) != NULL) {
+	    /* now calculate delta for weights of links (centers of the */
+	    /* RBF function)						 */
+	    curr_unit->Aux.int_no = 2;	/* derivated to norm ^2 */
+	    center_delta = curr_unit->value_c *
+		(*curr_unit->act_deriv_func) (curr_unit);
+
+	    if (learn_mask & RBF_LEARN_CENTER) {
+#ifdef RBF_INCR_LEARNING
+		if (IS_SPECIAL_UNIT(curr_unit))
+		    center_delta = 0.0;
+#endif
+		FOR_ALL_LINKS(curr_unit, curr_link) {
+
+#ifdef RBF_INCR_LEARNING
+		    curr_link->weight += para_center * center_delta *
+			((curr_link->to->Out.output) - (curr_link->weight));
+#else
+		    curr_link->value_b += center_delta *
+			((curr_link->to->Out.output) - (curr_link->weight));
+#endif
+		}
+	    }
+	    /* calculate delta for bias (parameter of RBF function):	 */
+	    curr_unit->Aux.int_no = 3;	/* derivation to bias!  */
+
+#ifdef RBF_INCR_LEARNING
+	    if (!IS_SPECIAL_UNIT(curr_unit))
+		curr_unit->bias += para_bias * curr_unit->value_c *
+		    (*curr_unit->act_deriv_func) (curr_unit);
+#else
+	    curr_unit->value_b += curr_unit->value_c *
+		(*curr_unit->act_deriv_func) (curr_unit);
+#endif
+	}
+    }
+    return learn_error;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : RbfLearnAdjustWeights
+
+  PURPOSE  : Adjusting of all learnable parameters, depending on collected 
+             deltas and on actual learning parameters.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+void RbfLearnAdjustWeights(float para_center, float para_bias, 
+			   float para_weight, float para_momentum)
+{
+    register struct Unit *curr_unit;	/* current unit		 */
+    register struct Link *curr_link;	/* current link		 */
+    register TopoPtrArray topo_ptr;
+
+#ifdef RBF_DELTA_PROT
+    static int      step = 0;	/* current learning step */
+    char            filename[20];	/* Name of prot file	 */
+    FILE           *protfile;	/* filepointer		 */
+
+#endif
+
+#ifdef RBF_DELTA_PROT
+    step++;
+    sprintf(filename, "rbf_%04d.prot", step);
+    protfile = fopen(filename, "w");
+    if (protfile == NULL)
+	fprintf(stderr, "RbfLearnAdjustWeights: Can't open protfile\n");
+#endif
+
+    /* start with last unit in output layer:			 */
+    topo_ptr = topo_ptr_array + no_of_topo_units + 3;
+
+#ifdef RBF_DELTA_PROT
+    fprintf(protfile, "%s\t\t\n", "h -> o");
+#endif
+
+    while ((curr_unit = *(--topo_ptr)) != NULL) {
+	if (!IS_SPECIAL_UNIT(curr_unit)) {
+	    /* adjust bias of output unit:                       */
+	    curr_unit->bias += para_weight * (curr_unit->value_b);
+
+#ifdef RBF_DELTA_PROT
+	    fprintf(protfile, "%13s:\t\n", curr_unit->unit_name);
+#endif
+
+	    /* adjust weights of links leading to this unit:	 */
+	    FOR_ALL_LINKS(curr_unit, curr_link) {
+
+#ifdef RBF_DELTA_PROT
+		fprintf(protfile, "%-10.2e\t\n",
+			para_weight * (curr_link->value_b));
+#endif
+
+		curr_link->weight +=
+		    (curr_link->value_a = para_weight * (curr_link->value_b)
+		     + para_momentum * curr_link->value_a);
+	    }
+	}
+    }
+
+    /* now adjust weights of hidden layer:			 */
+
+#ifdef RBF_DELTA_PROT
+    fprintf(protfile, "%s\t\t\n", "i -> h");
+#endif
+
+    while ((curr_unit = *(--topo_ptr)) != NULL) {
+	if (!IS_SPECIAL_UNIT(curr_unit)) {
+	    /* adjust bias of hidden unit (parameter of RBF function):	 */
+	    curr_unit->bias += para_bias * (curr_unit->value_b);
+	    if (curr_unit->bias <= 0.0)
+		fprintf(stderr, "Hidden unit bias %f !\n", curr_unit->bias);
+
+#ifdef RBF_DELTA_PROT
+	    fprintf(protfile, "%13s:\t\n", curr_unit->unit_name);
+#endif
+
+	    /* adjust weights of links (centers of RBF functions):	 */
+	    FOR_ALL_LINKS(curr_unit, curr_link) {
+
+#ifdef RBF_DELTA_PROT
+		fprintf(protfile, "%-10.2e\t\n",
+			para_center * (curr_link->value_b));
+#endif
+
+		curr_link->weight +=
+		    (curr_link->value_a = para_center * (curr_link->value_b)
+		     + para_momentum * curr_link->value_a);
+	    }
+	}
+    }
+
+#ifdef RBF_DELTA_PROT
+    fclose(protfile);
+#endif
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : RbfTopoCheck
+
+  PURPOSE  : Topological Check for Radial Basis Functions.
+             Also the number of output units is compared to the patterns.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err RbfTopoCheck(void)
+{
+    krui_err        ret_code;	/* error return code		 */
+
+    /* Net has been modified or topologic array isn't		 */
+    /* initialized. check the topology of the network.		 */
+    ret_code = kr_topoCheck();
+    if (ret_code < KRERR_NO_ERROR)
+	return (ret_code);	/* an error has occured */
+    if (ret_code < 2)
+	return (KRERR_NET_DEPTH);	/* the network has less */
+    /* then 2 layers	 */
+
+    /* count the no. of I/O units and check the patterns	 */
+    ret_code = kr_IOCheck();
+    if (ret_code < KRERR_NO_ERROR)
+	return (ret_code);
+
+    /* sort units by topology and by topologic type		 */
+    ret_code = kr_topoSort(TOPOLOGICAL_FF);
+
+    return ret_code;
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_RBF
+
+  PURPOSE  : Learning function for RBF (GRBF) called from kernel.
+  RETURNS  : kernel error code
+  NOTES    : Use of Learning Parameters:
+             LEARN_PARAM1: learning parameter for adjusting centers (links 
+	                   between input and hidden layer, treated as vectors)
+             LEARN_PARAM2: learning parameter for adjusting RBF-parameter 
+	                   (BIAS of units in hidden layer)
+             LEARN_PARAM3: learning parameter for adjusting weights (all links
+	                   to output layer + bias of output units)
+	     LEARN_PARAM4: maximum difference between output value and teaching
+                           input which is treated as error 0.0 (delta_max)
+             LEARN_PARAM5: factor for momentum term
+
+  UPDATE   : 06.11.1993 by Guenter Mamier 
+******************************************************************************/
+krui_err LEARN_RBF(int start_pattern, int end_pattern, 
+		   float *parameterInArray, int NoOfInParams, 
+		   float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores	 */
+                                        /* the learning error   	 */
+    int             ret_code, pattern_no, sub_pat_no, learn_mask;
+    float           para_bias, para_center, para_weight, para_pain, 
+                    para_momentum,para_delta_max;
+
+    register struct Unit *unit_ptr;
+    register struct Link *link_ptr;
+
+#ifdef RBF_LEARN_PROT
+    static int      schritt = 1;
+    int             fehler_zaehler = 0;
+    float           temp_fehler;
+    FILE           *protfile;
+
+#endif
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);/* No Units defined		 */
+    if (NoOfInParams < 1)	/* has to be changed (must be 4) */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available */
+                                /* (the learning error)		 */
+    *parameterOutArray = OutParameter;	/* set the reference to */
+    /* the output parameter */
+
+    ret_code = KRERR_NO_ERROR;	/* default return code		 */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)) {
+	ret_code = RbfTopoCheck();
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {
+	fprintf(stderr, "Initialization RBF_Weights should be called!\n");
+	/* initialize fields for momentum term */
+	FOR_ALL_UNITS(unit_ptr) {
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		link_ptr->value_a = 0.0;
+	    }
+	}
+    }
+    NET_ERROR(OutParameter) = 0.0;
+    para_center = -LEARN_PARAM1(parameterInArray);
+    para_bias = LEARN_PARAM2(parameterInArray);
+    para_weight = LEARN_PARAM3(parameterInArray);
+    para_momentum = LEARN_PARAM5(parameterInArray);
+    para_delta_max = LEARN_PARAM4(parameterInArray);
+    para_pain = 0.0;		/* not used now	*/
+
+    /* set learn mask in condition of the learning parameters:	 */
+    learn_mask = 0;
+    if (para_center != 0.0)
+	learn_mask |= RBF_LEARN_CENTER;
+    if (para_bias != 0.0)
+	learn_mask |= RBF_LEARN_BIAS;
+    if (para_weight != 0.0)
+	learn_mask |= RBF_LEARN_WEIGHT;
+    if (para_pain != 0.0)
+	learn_mask |= RBF_LEARN_PAIN;
+
+#ifndef RBF_INCR_LEARNING
+    ret_code = RbfLearnClean();
+    if (ret_code != KRERR_NO_ERROR)
+	return ret_code;
+#endif
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	RbfLearnForward(pattern_no,sub_pat_no);	/* forward propagation	 */
+
+	/* backward propagation 					 */
+
+#ifdef RBF_LEARN_PROT
+	temp_fehler = RbfLearnAdjustDelta(para_center,
+			   para_bias, para_weight, para_pain, para_momentum,
+					  para_delta_max, learn_mask);
+	NET_ERROR(OutParameter) += temp_fehler;
+	if (temp_fehler > 0.0)
+	    fehler_zaehler++;
+#else
+	NET_ERROR(OutParameter) += RbfLearnAdjustDelta(para_center,
+			   para_bias, para_weight, para_pain, para_momentum,
+						para_delta_max, learn_mask);
+#endif
+    }
+
+#ifndef RBF_INCR_LEARNING
+    RbfLearnAdjustWeights(para_center, para_bias, para_weight,
+			  para_momentum);
+#endif
+
+#ifdef RBF_LEARN_PROT
+    protfile = fopen("rbf_learn_prot_file", "a");
+    if (schritt == 1) {
+	fprintf(protfile, "# Neues Lernprotokoll: \n");
+    }
+    fprintf(protfile, "%d %f %d\n", schritt, NET_ERROR(OutParameter),
+	    fehler_zaehler);
+    fclose(protfile);
+    schritt++;
+#endif
+
+    return (ret_code);
+}
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP  (Radial Basis Functions) Dynamic Decay Adjustment (DDA) Learning
+  
+  AUTHORS Michael R. Berthold (Michael.Berthold@informatik.uni-karlsruhe.de) and 
+          Markus J. Weihrauch (Markus.Weihrauch@informatik.uni-karlsruhe.de)
+  NOTES Use of special entries in links and units with RBFs
+        for units in hidden layer:
+          unit.value_a == |X - L|^2  = norm^2 = summed squares of euclidian
+            distances between all links and input units of this unit.
+        for units in output layer:
+          unit.value_a == <desired activation> - <actual activation>
+	Use of the following global variables
+	  KernelErrorCode, NoOfInputUnits, NoOfHiddenUnits, NoOfOutputUnits,
+	  NetModified, TopoSortID, topo_ptr_array
+	Uses the following global MACROS
+	  MAXINT, KRERR_...
+	Output units *must* have "Act_Identity" and RBF (==hidden) units *must*
+	  have "Act_RBF_Gaussian" as activation function. 
+	All output functions must be "Out_Identity".
+
+******************************************************************************
+******************************************************************************/
+
+/* The RBFs act. fct. is exp(-distance^2/sigma^2). Sigma == 1/sqrt(bias) */
+#define RBF_MIN_SIGMA 1e-10 
+#define RBF_MAX_SIGMA 1e10 
+
+/* This is the maximal number of units displayed in the graphical display */
+#define DEF_MAX_UNITS_DISPLAYED 20
+
+#define RBF_GET_UNIT_NO( unit_ptr ) ( (unit_ptr) - unit_array ) 
+
+#define RBF_ERROR_CHECK( x ) \
+  KernelErrorCode = ( x ); \
+  if ( KernelErrorCode < KRERR_NO_ERROR && \
+       KernelErrorCode != KRERR_DEAD_UNITS ) return KernelErrorCode; 
+
+/* Factor for the calculation of the inverse RBF activation function */
+#define RBF_INV ( -1.0 * log(theta_neg) )
+
+#define RBF_SQR( x ) ( (x) * (x) )
+#define RBF_MIN( x, y ) ( (x) < (y) ? (x) : (y) )
+#define RBF_MAX( x, y ) ( (x) > (y) ? (x) : (y) )
+
+/*****************************************************************************
+  FUNCTION : LEARN_RBF_DDA
+
+  PURPOSE  : Learning function for RBFs called from kernel.
+  RETURNS  : An kernel error code and OutParameter[0] == Mean Square Error 
+             (MSE is not very meaningful in classification tasks)
+  NOTES    : LEARN_PARAM1: 
+               theta_pos, minimum activation of correct RBF (default 0.4)
+             LEARN_PARAM2: 
+	       theta_neg, maximum activation of competing RBFs (default 0.2)
+	     LEARN_PARAM3: 
+	       #units per line/column in display (default 20)
+
+  UPDATE   : 8 May 1995 by mb
+******************************************************************************/
+
+krui_err LEARN_RBF_DDA(int start_pattern, int end_pattern, 
+		       float  *parameterInArray,  int  NoOfInParams, 
+		       float **parameterOutArray, int *NoOfOutParams)
+{
+  static float OutParameter[1];
+  float        theta_pos           =       LEARN_PARAM1(parameterInArray),
+               theta_neg           =       LEARN_PARAM2(parameterInArray);
+  int          max_units_displayed = (int )LEARN_PARAM3(parameterInArray),
+               pattern_no, sub_pat_no,
+               xmin_in,  ymin_in, xmin_out, ymin_out,
+               xmax_in,  ymax_in, xmax_out, ymax_out;
+  struct Unit  *input_unit_ptr, *hidden_unit_ptr, *output_unit_ptr; 
+  struct Link  *link_ptr;
+  TopoPtrArray topo_ptr;
+  Patterns     out_pat_ptr;
+
+
+  /* Treat parameters */
+
+  if  ( theta_pos == 0.0 ) theta_pos = 0.4;
+
+  if  ( theta_neg == 0.0 ) theta_neg = 0.2;
+
+  if ( theta_pos <= 0.0 || theta_pos > 1.0 ) return DDA_PARAM_ONE; 
+
+  if ( theta_neg <= 0.0 || theta_neg > 1.0 ) return DDA_PARAM_TWO; 
+
+  if ( max_units_displayed == 0 ) max_units_displayed = DEF_MAX_UNITS_DISPLAYED;
+
+  if ( max_units_displayed <= 0 ) return DDA_PARAM_THREE; 
+
+
+  /*  If net has been modified or topologic array isn't initialized:
+      Check the topology of the network  */    
+
+  if ( NetModified || (TopoSortID != TOPOLOGICAL_FF) )
+    {
+      int no_of_layers = kr_topoCheck(); 
+      RBF_ERROR_CHECK( no_of_layers );
+
+      if ( no_of_layers < 1 ) return KRERR_FEW_LAYERS;
+      if ( no_of_layers > 3 ) return KRERR_MUCH_LAYERS; 
+
+      /*  count the no. of I/O units and check the patterns  */
+      RBF_ERROR_CHECK( kr_IOCheck () );
+
+      /*  sort units by topology and by topologic type  */
+      RBF_ERROR_CHECK( kr_topoSort( TOPOLOGICAL_FF ) );
+
+      NetModified = FALSE;
+    } 
+
+
+  /* Check the topology and find min+max positions */
+
+  /* NULL before first  unit */
+  topo_ptr = topo_ptr_array;
+  xmin_in = ymin_in =  MAXINT;
+  xmax_in = ymax_in = -MAXINT;
+
+  while ( (input_unit_ptr = * ++topo_ptr ) != NULL)
+    {
+      if ( !IS_INPUT_UNIT(input_unit_ptr) ) return KRERR_TOPOLOGY; 
+      
+      if ( UNIT_HAS_INPUTS(input_unit_ptr) || 
+	  UNIT_HAS_SITES(input_unit_ptr) )
+	{ 
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(input_unit_ptr) );
+	  return KRERR_UNEXPECTED_SITES; 
+	}
+
+#if 0
+      if ( strcmp( krui_getUnitActFuncName( RBF_GET_UNIT_NO(input_unit_ptr) ),
+		   "Act_Identity" ) )
+	return DDA_INPUT_ACT_FUNC;
+
+      if ( input_unit_ptr->out_func != OUT_IDENTITY )
+	{ 
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(input_unit_ptr) );
+	  return KRERR_OUT_FUNC; 
+	}
+#endif
+
+      input_unit_ptr->bias = 0.0;
+
+      xmin_in = RBF_MIN( xmin_in, input_unit_ptr->unit_pos.x );
+      ymin_in = RBF_MIN( ymin_in, input_unit_ptr->unit_pos.y );
+      xmax_in = RBF_MAX( xmax_in, input_unit_ptr->unit_pos.x );
+      ymax_in = RBF_MAX( ymax_in, input_unit_ptr->unit_pos.y );
+    } 
+
+  /* topo_ptr points now to the NULL before first hidden (RBF) unit */
+
+  while ( (hidden_unit_ptr = * ++topo_ptr ) != NULL)
+    {
+      int no_input_units = 0;
+
+      if ( UNIT_HAS_SITES(hidden_unit_ptr) )
+	{ 
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(hidden_unit_ptr) );
+	  return KRERR_UNEXPECTED_SITES; 
+	}
+      
+      if ( hidden_unit_ptr->out_func != OUT_IDENTITY )
+	{ 
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(hidden_unit_ptr) );
+	  return KRERR_OUT_FUNC; 
+	}
+      
+      if ( strcmp( krui_getUnitActFuncName( RBF_GET_UNIT_NO(hidden_unit_ptr) ),
+		   "Act_RBF_Gaussian" ) )
+	return DDA_HIDDEN_ACT_FUNC;
+
+      FOR_ALL_LINKS( hidden_unit_ptr, link_ptr ) 
+	{
+	  if ( !IS_INPUT_UNIT(link_ptr->to) ) return KRERR_TOPOLOGY; 
+	  
+	  no_input_units++;
+	}
+
+      if ( no_input_units != NoOfInputUnits ||
+	  !IS_HIDDEN_UNIT(hidden_unit_ptr) ||
+	  !UNIT_HAS_DIRECT_INPUTS(hidden_unit_ptr) || 
+	  hidden_unit_ptr->sites == NULL ) return KRERR_TOPOLOGY; 
+    } 
+
+  /* topo_ptr points now to the NULL before first output unit */
+
+  xmin_out = ymin_out =  MAXINT;
+  xmax_out = ymax_out = -MAXINT;
+
+  while ( (output_unit_ptr = * ++topo_ptr ) != NULL)
+    {
+      if ( UNIT_HAS_SITES(output_unit_ptr) )
+	{ 
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(output_unit_ptr) );
+	  return KRERR_UNEXPECTED_SITES; 
+	}
+
+#if 0
+      if ( output_unit_ptr->out_func != OUT_IDENTITY )
+	{
+	  krui_setCurrentUnit( RBF_GET_UNIT_NO(output_unit_ptr) );
+	  return KRERR_OUT_FUNC; 
+	}
+
+      if ( strcmp( krui_getUnitActFuncName( RBF_GET_UNIT_NO(output_unit_ptr) ),
+		   "Act_Identity" ) )
+	return DDA_OUTPUT_ACT_FUNC;
+#endif
+      if ( strcmp( krui_getUnitActFuncName( RBF_GET_UNIT_NO(output_unit_ptr) ),
+		   "Act_Identity" ) )
+        {
+	  RBF_ERROR_CHECK( krui_setUnitActFunc ( RBF_GET_UNIT_NO(output_unit_ptr), "Act_Identity" ) );
+        }
+
+      if ( output_unit_ptr->out_func != OUT_IDENTITY )
+        output_unit_ptr->out_func = OUT_IDENTITY; 
+
+      output_unit_ptr->bias = 0.0;
+
+      xmin_out = RBF_MIN( xmin_out, output_unit_ptr->unit_pos.x );
+      ymin_out = RBF_MIN( ymin_out, output_unit_ptr->unit_pos.y );
+      xmax_out = RBF_MAX( xmax_out, output_unit_ptr->unit_pos.x );
+      ymax_out = RBF_MAX( ymax_out, output_unit_ptr->unit_pos.y );
+
+      /* Set the weights of all links from RBFs to output to zero */
+      FOR_ALL_LINKS( output_unit_ptr, link_ptr ) 
+	{
+	  if ( start_pattern != end_pattern ) link_ptr->weight = 0.0;
+
+	  if ( !IS_HIDDEN_UNIT(link_ptr->to) ) return DDA_SHORTCUTS; 
+	}
+
+      /* If it's an empty net no connections are allowed */
+      if ( !IS_OUTPUT_UNIT(output_unit_ptr) ||
+	  (NoOfHiddenUnits == 0 && output_unit_ptr->sites != NULL ))
+	return KRERR_TOPOLOGY; 
+    } 
+
+
+  /* The big MAIN Loop:
+     Loop through patterns from pattern no. start_pattern to end_pattern */
+
+  /* compute the necessary sub patterns */
+  RBF_ERROR_CHECK( kr_initSubPatternOrder ( start_pattern, end_pattern ) );
+ 
+  while( kr_getSubPatternByOrder ( &pattern_no, &sub_pat_no ) )
+    {
+      int      correct_output_unit_no;
+      struct   Link *max_to_out_link_ptr;
+      struct   Unit *max_rbf_ptr, *correct_output_unit_ptr;
+
+      /* forward propagation */
+      RbfLearnForward ( pattern_no, sub_pat_no );
+
+      /* Find correct output neuron */
+
+      out_pat_ptr = kr_getSubPatData ( pattern_no, sub_pat_no, OUTPUT, NULL );
+
+      topo_ptr = topo_ptr_array + 2 + NoOfInputUnits  + NoOfHiddenUnits;
+      correct_output_unit_ptr = NULL;
+
+      while( (output_unit_ptr = * ++topo_ptr) != NULL )
+	if ( *out_pat_ptr++ > 0.0 )
+	  if ( correct_output_unit_ptr == NULL )
+	    correct_output_unit_ptr = output_unit_ptr;
+	  else
+	    return DDA_DESIRED_CLASS; 
+      
+      /* Is there a desired class ? */
+      max_rbf_ptr = NULL;
+      
+      if ( correct_output_unit_ptr != NULL )
+	{
+	  correct_output_unit_no = RBF_GET_UNIT_NO ( correct_output_unit_ptr );
+	  
+	  /* Find nearest RBF (having highest activation) of correct class */
+	  
+	  FOR_ALL_LINKS( correct_output_unit_ptr, link_ptr)
+	    if ( link_ptr->to->act >= theta_pos )
+	      if ( max_rbf_ptr != NULL )
+		{
+		  if ( link_ptr->to->act > max_rbf_ptr->act ) 
+		    max_rbf_ptr = link_ptr->to; 
+		}
+	      else 
+		max_rbf_ptr = link_ptr->to; 
+	}
+      
+      /* Shrink competing RBFs */
+      
+      topo_ptr = topo_ptr_array + 2 + NoOfInputUnits + NoOfHiddenUnits;
+      
+      while ( ( output_unit_ptr = * ++topo_ptr ) != NULL )
+	/* Only competing classes */
+	if ( output_unit_ptr != correct_output_unit_ptr )
+	  FOR_ALL_LINKS( output_unit_ptr, link_ptr )
+	    /* Only competing RBFs with a too big activation */
+	    if ( link_ptr->to->act > theta_neg )
+	      { 
+		/* Shrink! */
+		if ( link_ptr->to->bias < 1.0/RBF_SQR( RBF_MIN_SIGMA ) )
+		  {
+		    if ( link_ptr->to->value_a/RBF_INV > RBF_SQR( RBF_MIN_SIGMA ) )
+		      link_ptr->to->bias = RBF_INV/link_ptr->to->value_a;
+		    else 
+		      link_ptr->to->bias = 1.0/RBF_SQR( RBF_MIN_SIGMA );
+		  }
+#ifdef RBF_DEBUG
+		else
+		  fprintf(stderr,"\nRBF-DDA WARNING: Sigma too small (competing)!\n");
+#endif
+	      }
+      /* End Shrink competing RBFs */
+
+      /* If there is a desired class: is the actual input pattern already covered 
+	 by an RBF of the correct class? */
+      
+      if ( correct_output_unit_ptr != NULL )
+	if ( max_rbf_ptr != NULL) 
+	  {
+	    /* increase weight of link from nearest RBF 
+	       to correct output neuron */
+	    
+	    /* Find link from RBF with max. act. to the correct output unit */
+	    max_to_out_link_ptr = 
+	      (struct Link *) correct_output_unit_ptr->sites;
+	    
+	    FOR_ALL_LINKS ( correct_output_unit_ptr, link_ptr )
+	      if ( link_ptr->to == max_rbf_ptr ) 
+		max_to_out_link_ptr = link_ptr;
+	    
+	    /* Increase the weight of this link */
+	    max_to_out_link_ptr->weight += 1.0;
+	  } /* end if covered or no desired class */
+      
+	else 
+	  /* Not covered:
+	     No RBF near enough or no RBF at all yet ... commit new RBF */
+	  {
+	    struct Unit *new_rbf_ptr;
+	    int new_rbf_no = kr_makeDefaultUnit();
+	    
+	    NetModified = TRUE;
+	    RBF_ERROR_CHECK( new_rbf_no );
+	    RBF_ERROR_CHECK( kr_unitSetTType ( new_rbf_no, HIDDEN ) );
+	    RBF_ERROR_CHECK( krui_setUnitActFunc ( new_rbf_no, "Act_RBF_Gaussian" ) );
+	    new_rbf_ptr = kr_getUnitPtr ( new_rbf_no );
+	    RBF_ERROR_CHECK( KernelErrorCode );
+	    new_rbf_ptr->i_act      = 0.0;
+	    new_rbf_ptr->bias       = 1.0/RBF_SQR( RBF_MAX_SIGMA );
+	    new_rbf_ptr->out_func   = OUT_IDENTITY; 
+	    
+	    /* Set  weight of links from inputs to new RBF (=center of RBF) */
+	    
+	    RBF_ERROR_CHECK( krui_setCurrentUnit ( new_rbf_no ) );
+	    
+	    /* Scan input units and create links */
+	    topo_ptr = topo_ptr_array;
+	    
+	    while ( (input_unit_ptr = * ++topo_ptr ) != NULL)
+	      RBF_ERROR_CHECK
+		( krui_createLink ( RBF_GET_UNIT_NO ( input_unit_ptr ), 
+				   input_unit_ptr->act ) );  
+	    
+	    /* Make link from correct output unit to the RBF having max. act. */
+	    
+	    RBF_ERROR_CHECK( kr_setCurrUnit ( correct_output_unit_no ) );
+	    RBF_ERROR_CHECK( krui_createLink ( new_rbf_no, 1.0 ) );
+	    
+	    /*  sort units by topology and by topologic type  */
+	    RBF_ERROR_CHECK( kr_topoSort ( TOPOLOGICAL_FF ) );
+	    
+	    /* Shrink new RBF */
+	    
+	    /* Scan all competing RBFs */
+	    
+	    new_rbf_ptr = kr_getUnitPtr ( new_rbf_no );
+	    topo_ptr = topo_ptr_array + 2 + NoOfInputUnits + NoOfHiddenUnits;
+	    
+	    while ( (output_unit_ptr = * ++topo_ptr ) != NULL)
+	      /* Only competing RBFs! */
+	      if ( output_unit_ptr != correct_output_unit_ptr )
+		FOR_ALL_LINKS( output_unit_ptr, link_ptr )
+		  {
+		    float sqr_distance = 0.0;
+		    struct Link *link_ptr1, *link_ptr2;
+		    
+		    /* Compute Euclidian distance of the center of the new RBF 
+		       to the center of a competing RBFs */
+		    
+		    link_ptr1 = (struct Link *) new_rbf_ptr->sites;
+		    link_ptr2 = (struct Link *) link_ptr->to->sites;
+		    
+		    while ( link_ptr1 != NULL)
+		      {
+			float diff;
+			
+			/* Find corresponding link so that link_ptr1 and 
+			   link_ptr2 start at the same unit. */
+			
+			if ( link_ptr1->to != link_ptr2->to )
+			  {
+			    link_ptr1 = (struct Link *) new_rbf_ptr->sites;		      
+			    while ( link_ptr1->to != link_ptr2->to )
+			      if ( link_ptr1 != NULL )
+				link_ptr1 = link_ptr1->next;
+			      else
+				return KRERR_NP_DOES_NOT_FIT; 
+			  }
+			
+			/* Compute distance of the two centers */
+			
+			diff = ( link_ptr1->weight - link_ptr2->weight );
+			sqr_distance += diff*diff;
+			if ( link_ptr1->to != link_ptr2->to ) 
+			  return DDA_CONN_POINTER;
+			
+			link_ptr1 = link_ptr1->next;
+			link_ptr2 = link_ptr2->next;
+		      }
+		    
+		    /* Activation greater than theta_neg? Sigma too big ? */
+		    
+		    if ( RBF_INV/new_rbf_ptr->bias > sqr_distance )
+		      /* Shrink! */
+		      if ( new_rbf_ptr->bias < 1.0/RBF_SQR( RBF_MIN_SIGMA ) )
+	  	        {
+			  if ( sqr_distance/RBF_INV > RBF_SQR( RBF_MIN_SIGMA ) )
+			    new_rbf_ptr->bias = RBF_INV / sqr_distance;
+			  else 
+			    new_rbf_ptr->bias = 1.0/RBF_SQR( RBF_MIN_SIGMA );
+		        }
+#ifdef RBF_DEBUG
+		      else
+		        fprintf( stderr, "\nRBF-DDA WARNING: Sigma too small (new)!\n" );
+#endif
+		  }
+	    
+	  } /* end else not covered/new rbf */
+      
+    } /* end while kr_getSubPatternByOrder (Main Loop) */
+  
+  
+  /* Set positions of units on display */
+  {
+    int i = 0;
+    
+    /* Direction of data flow: From left to right */
+    if ( xmax_in < xmin_out )
+      {
+	topo_ptr = topo_ptr_array + 1 + NoOfInputUnits;
+
+	while ( (hidden_unit_ptr = * ++topo_ptr ) != NULL)
+	  {
+	    hidden_unit_ptr->unit_pos.x = xmax_in + 4 + i / max_units_displayed;
+	    hidden_unit_ptr->unit_pos.y = RBF_MIN ( ymin_in, ymin_out) + 
+	      i % max_units_displayed;
+	    i++;
+	  } 
+
+	while ( (output_unit_ptr = * ++topo_ptr ) != NULL)
+	  output_unit_ptr->unit_pos.x += 
+	    xmax_in + 8 + (NoOfHiddenUnits - 1) / max_units_displayed - xmin_out;
+      }
+
+    /* right to left */
+    else if ( xmin_in > xmax_out &&  !( ymax_in < ymin_out ) )
+      {
+	topo_ptr = topo_ptr_array;
+
+	while ( (input_unit_ptr = * ++topo_ptr ) != NULL)
+	  input_unit_ptr->unit_pos.x +=  
+	    xmax_out + 8 + (NoOfHiddenUnits - 1) / max_units_displayed - xmin_in ;
+
+	while ( (hidden_unit_ptr = * ++topo_ptr ) != NULL)
+	  {
+	    hidden_unit_ptr->unit_pos.x = xmax_out + 4 + 
+	      ( NoOfHiddenUnits - 1 - i ) / max_units_displayed;
+	    hidden_unit_ptr->unit_pos.y =  RBF_MIN ( ymin_in, ymin_out) + 
+	      i % max_units_displayed;
+	    i++;
+	  } 
+      }
+
+    /* downwards to upwards */
+    else if ( ymin_in > ymax_out )
+      {
+	topo_ptr = topo_ptr_array;
+
+	while ( (input_unit_ptr = * ++topo_ptr ) != NULL)
+	  input_unit_ptr->unit_pos.y += 
+	    ymax_out + 8 + (NoOfHiddenUnits - 1) / max_units_displayed - ymin_in;
+
+	while ( (hidden_unit_ptr = * ++topo_ptr ) != NULL)
+	  {
+	    hidden_unit_ptr->unit_pos.x =  RBF_MIN ( xmin_in, xmin_out) + 
+	      i % max_units_displayed;
+	    hidden_unit_ptr->unit_pos.y = ymax_out + 4 + 
+	      ( NoOfHiddenUnits - 1 - i ) / max_units_displayed;
+	    i++;
+	  } 
+      }
+
+    /* Default case: upwards to downwards */
+    else
+      {
+	topo_ptr = topo_ptr_array + 1 + NoOfInputUnits;
+
+	while ( (hidden_unit_ptr = * ++topo_ptr ) != NULL)
+	  {
+	    hidden_unit_ptr->unit_pos.x =  RBF_MIN ( xmin_in, xmin_out) + 
+	      i % max_units_displayed;
+	    hidden_unit_ptr->unit_pos.y = ymax_in + 4 + i / max_units_displayed;
+	    i++;
+	  } 
+
+	while ( (output_unit_ptr = * ++topo_ptr ) != NULL)
+	  output_unit_ptr->unit_pos.y += 
+	    ymax_in + 8 + (NoOfHiddenUnits - 1) / max_units_displayed - ymin_out;
+      }
+
+  } /* end Set positions of units ... */
+
+
+  /* Compute Error == # misclassified patterns */
+
+  *NoOfOutParams = 1; /*  One return value: OutParameter[0] == learning error */
+  *parameterOutArray = OutParameter;  /*  set the output parameter reference  */
+    
+  /* reset network error value  */
+  OutParameter[0] = 0.0;  
+    
+  /* compute the necessary sub patterns */
+  RBF_ERROR_CHECK( kr_initSubPatternOrder ( start_pattern, end_pattern ) );
+    
+  while( kr_getSubPatternByOrder ( &pattern_no, &sub_pat_no ) )
+    {
+      /* forward propagation */
+      RbfLearnForward ( pattern_no, sub_pat_no );
+
+      topo_ptr = topo_ptr_array + 2 + NoOfInputUnits  + NoOfHiddenUnits;
+
+      while( (output_unit_ptr = * ++topo_ptr) != NULL )
+	OutParameter[0] +=  RBF_SQR( output_unit_ptr->value_a );
+    }
+  
+  return ( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+
+ GROUP        : RPROP learning function, V1.1
+
+  AUTHOR       : Martin Riedmiller, ILKD, University of Karlsruhe
+  Notes        : RPROP parameters are the initial update value (default 0.1) 
+                 and the maximal update value (default 50.0). The defaults 
+		 are assumed if the parameters are set to 0.0. It may be 
+		 helpfull to limit the second paream to 0.01.
+
+		V1.1 supports weight decay (third parameter)
+
+		V1.0 in SNNSv3.0 according to descritption in IEEE ICNN '93
+		V1.1 in SNNSv3.3 according to technical report (Riedmiller 1994)
+	       		  -no backtracking in case of jump over minimum
+		        new features:
+        	          -weight decay included
+	       		  -'weights-fixed' removed
+
+*******************************************************************************
+******************************************************************************/
+
+#define RPROP_ETAPLUS 1.2
+#define RPROP_ETAMINUS 0.5
+#define RPROP_MINEPS 1e-6
+#define RPROP_MAXEPS 2.0
+#define RPROP_DEFAULT_UPDATE_VALUE 0.001
+#define SUM_SQUARE_ERROR          0
+#define CROSS_ENTROPY_ERROR       1
+#define MULTIPLE_CROSS_ERROR      2
+
+
+/*****************************************************************************
+  FUNCTION : initializeRprop
+
+  PURPOSE  : Rprop initialisation:
+  RETURNS  : kernel error code
+  NOTES    : ->value_c : Sum (dEdw)
+             ->value_b : dw(t-1)
+             ->value_a : update_value
+
+  UPDATE   : 09.05.1994 by Guenter Mamier
+******************************************************************************/
+static krui_err initializeRprop(float update_val)
+{
+    register unsigned short flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+  FOR_ALL_UNITS( unit_ptr ){
+	flags = unit_ptr->flags;
+
+      if ( (flags & UFLAG_IN_USE) == UFLAG_IN_USE){ /*  unit is in use  */
+	    unit_ptr->value_b = unit_ptr->value_c = (FlintType) 0;
+	  unit_ptr->value_a = (FlintType)update_val;
+
+	  if (flags & UFLAG_SITES){ /*  unit has sites  */
+	      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		    link_ptr->value_b = link_ptr->value_c = (FlintType) 0;
+		  link_ptr->value_a = (FlintType)update_val;
+		}
+
+	  } else{		/*  unit has no sites   */
+		if (flags & UFLAG_DLINKS) {	/* unit has direct links   */
+		  FOR_ALL_LINKS( unit_ptr, link_ptr ){
+			link_ptr->value_b = link_ptr->value_c = (FlintType) 0;
+		      link_ptr->value_a = (FlintType)update_val;
+		    }
+		}
+	    }
+	}
+    }
+
+  return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : computeDevite
+
+  PURPOSE  : one function to compute the error
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static int computeDevite(float *devit, float *sum_error,
+                         float target, float output, int errorType )
+{
+    int ret = 0;
+    float sum1,sum2,sum3,sum4;
+
+
+    switch(errorType){
+    
+    case MULTIPLE_CROSS_ERROR:
+	(*devit) = output-target;
+	if (output > 0.0)
+	    sum1 = target * log (output);
+	else
+	    sum1 = 0.0;
+	if (target > 0.0)
+	    sum2 = target * log (target);
+	else
+	    sum2 = 0.0;
+	*sum_error -= (sum1 - sum2);
+	break;
+
+    case CROSS_ENTROPY_ERROR:
+	(*devit) = target-output;
+	if (output > 0.0)
+	    sum1 = target * log (output);
+	else
+	    sum1 = 0.0;
+	if (target > 0.0)
+	    sum2 = target * log (target);
+	else
+	    sum2 = 0.0;
+	if ( (1 - output) > 0.0)
+	    sum3 = (1 - target) * log (1 - output);
+	else
+	    sum3 = 0.0;
+	if ((1 - target) > 0.0)
+	    sum4 = ( 1- target) * log ( 1 - target);
+	else
+	    sum4 = 0.0;
+    
+	*sum_error -= (sum1 - sum2 + sum3 - sum4);    
+	break;
+    
+    case SUM_SQUARE_ERROR:
+    default:
+	(*devit) = target-output;
+	*sum_error += (*devit) * (*devit);
+	break;
+    }
+    return ret;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : computeAlpha
+
+  PURPOSE  : one function to compute the alpha value
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static float computeAlpha(void)
+{
+    int i=0,s,t;
+    float Alpha = 0.0, sum = 0.0,weightVal;
+
+    for( s = krui_getFirstUnit(); s != 0; s = krui_getNextUnit() ) {
+	if (krui_getUnitTType( s ) != INPUT){
+	    weightVal = krui_getUnitBias(s);
+	    weightVal = krui_getUnitBias(s);
+	    sum += weightVal * weightVal;     /* add biases */
+	    i++;
+	}
+      
+	for( t=krui_getFirstSuccUnit(s,&weightVal); t != 0; 
+	     t = krui_getNextSuccUnit(&weightVal) ){
+	    i++;
+	    sum += weightVal * weightVal;     /* add weights */
+        }
+          
+	/* getNextUnit will get the succ of the current Unit */
+	krui_setCurrentUnit( s ); 
+    }
+    if (sum > 0.0)
+	Alpha = i / sum;
+    return Alpha;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetForwardRprop
+
+  PURPOSE  : forward pass for Rprop with different error functions
+  RETURNS  : 
+  NOTES    : topological forward propagation
+
+  UPDATE   : 
+******************************************************************************/
+static void propagateNetForwardMAP(int pattern_no, int sub_pat_no, 
+				   int errorType)
+{
+    register struct Unit *unit_ptr;
+    register Patterns in_pat;
+    register TopoPtrArray topo_ptr;
+    float sum_act = 0.0;
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+    if(in_pat == NULL){
+        KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+        return;
+    }
+
+    topo_ptr = topo_ptr_array;
+
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    while ((unit_ptr = *++topo_ptr) != NULL) {  
+        
+        /* topo_ptr points to a (topological sorted) unit
+           stucture (input unit first)  */
+        if (unit_ptr->out_func == OUT_IDENTITY)
+            /* identity output function: there is no need to call the output
+               function  */
+            unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+        else
+            /* no identity output function: calculate unit's output also  */
+            unit_ptr->Out.output 
+                = (*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    /* popagate hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {  /* topo_ptr points to a
+                                                   (topological sorted) unit
+                                                   stucture */
+        /* clear error values  */
+        unit_ptr->Aux.flint_no = 0.0;
+
+        /* calculate the activation value of the unit: call the activation
+           function if needed  */
+        unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+        if (unit_ptr->out_func == OUT_IDENTITY)
+            /* identity output function: there is no need to call the output
+               function  */
+            unit_ptr->Out.output = unit_ptr->act;
+        else
+            /* no identity output function: calculate unit's output also  */
+            unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /* popagate output units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {  /* topo_ptr points to a
+                                                   (topological sorted) unit
+                                                   stucture */
+        /* clear error values  */
+        unit_ptr->Aux.flint_no = 0.0;
+
+        /* calculate the activation value of the unit: call the activation
+           function if needed  */
+        unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+        sum_act += unit_ptr->act;
+        if (unit_ptr->out_func == OUT_IDENTITY)
+            /* identity output function: there is no need to call the output
+               function  */
+            unit_ptr->Out.output = unit_ptr->act;
+        else
+            /* no identity output function: calculate unit's output also  */
+            unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+    if (errorType == MULTIPLE_CROSS_ERROR){
+      /* normalize activations of output units  */
+      while ((unit_ptr = *--topo_ptr) != NULL) {        /* topo_ptr points to a
+                                                   (topological sorted) unit
+                                                   stucture */
+        /* normalize activation */
+        if (sum_act > 0.0)
+          unit_ptr->act /= sum_act; /* / (sum_act + unit_ptr->act);*/
+        
+        if (unit_ptr->out_func == OUT_IDENTITY)
+          /* identity output function: there is no need to call the output
+             function  */
+          unit_ptr->Out.output = unit_ptr->act;
+        else
+          /* no identity output function: calculate unit's output also  */
+          unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+      }
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackwardRprop
+
+  PURPOSE  : Pure Backpropagation of gradient without weight-update
+  RETURNS  : network error
+  NOTES    : sum(dE/dw) -> value_c.
+
+  UPDATE   : 09.05.1994 by Guenter Mamier
+******************************************************************************/
+static float propagateNetBackwardRprop(int pattern_no, int sub_pat_no)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error,	/* error  */
+                    sum_error,	/* sum of the error  */
+                    devit;	/* deviation  */
+    TopoPtrArray    topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /*  add 3 to no_of_topo_units because the topologic array contains
+	4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+	devit = *(--out_pat) - unit_ptr->Out.output;
+	/*= o * (1.0 - o) in [0.0,0.25],*/
+	/*for asymmetric logistic function*/
+
+	sum_error += devit * devit;	/* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * ((unit_ptr->act_deriv_func) ( unit_ptr ));
+
+	unit_ptr->value_c += - error /* *1 */; /* calculate the bias slopes */
+	/* learn bias like a weight  */
+	if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+	    /*  the unit has direct links  */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr ){
+		/*	calculate the slopes  */
+		link_ptr->value_c += - error * link_ptr->to->Out.output;
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	    }
+	}else{	
+	    /*  the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		/* calculate the value_cs  */
+		link_ptr->value_c += - error * link_ptr->to->Out.output;
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	    }
+	}
+    }
+
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+	error = ((unit_ptr->act_deriv_func)(unit_ptr)) * unit_ptr->Aux.flint_no;
+
+	unit_ptr->value_c += - error /* * 1 */; /* calculate the bias slopes  */
+	/* learn bias like a weight  */
+	if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){ /* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr ){ /* calculate the slopes  */
+		if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+		    /*  this link points to a hidden unit: 
+			sum up the error's from previos units  */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		link_ptr->value_c += - error * link_ptr->to->Out.output;
+	    }
+	}else {		/*  the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+		/* calculate the slopes  */
+		if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+		    /*  this link points to a hidden unit: 
+			sum up the error's from previos units  */
+		    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+		link_ptr->value_c += - error * link_ptr->to->Out.output;
+	    }
+	}
+    }
+    return( sum_error );	/*  return the error of the network  */
+}
+
+
+/*****************************************************************************
+  FUNCTION : propagateNetBackwardMAP
+
+  PURPOSE  : Backward phase for RPROP with weight decay
+  RETURNS  : network error
+  NOTES    : sum(dE/dw) -> value_c.
+
+  UPDATE   : 09.05.1994 by Guenter Mamier
+******************************************************************************/
+static float propagateNetBackwardMAP(int pattern_no, int sub_pat_no, 
+				     int errorType)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    float  error,       /* error  */
+                    sum_error,  /* sum of the error  */
+                    devit;      /* deviation  */
+    TopoPtrArray    topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;            /* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /*  add 3 to no_of_topo_units because the topologic array contains
+        4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+        computeDevite(&devit,&sum_error,*(--out_pat), unit_ptr->Out.output, 
+		      errorType);
+
+        /* calc. error for output units  */
+        error = devit;
+        if (errorType == SUM_SQUARE_ERROR)
+          error *= ((unit_ptr->act_deriv_func) ( unit_ptr ));
+
+        
+        unit_ptr->value_c += - error /* *1 */; /* calculate the bias slopes */
+        /* learn bias like a weight  */
+        if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+            /*  the unit has direct links  */
+            FOR_ALL_LINKS( unit_ptr, link_ptr ){
+                /*      calculate the slopes  */
+                link_ptr->value_c += - error * link_ptr->to->Out.output;
+                link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+            }
+        }else{  
+            /*  the unit has sites  */
+            FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+                /* calculate the value_cs  */
+                link_ptr->value_c += - error * link_ptr->to->Out.output;
+                link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+            }
+        }
+    }
+
+
+    /* calculate hidden units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+        error = ((unit_ptr->act_deriv_func)(unit_ptr)) * unit_ptr->Aux.flint_no;
+
+        unit_ptr->value_c += - error /* * 1 */; /* calculate the bias slopes  */
+        /* learn bias like a weight  */
+        if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){ /* the unit has direct links */
+            FOR_ALL_LINKS( unit_ptr, link_ptr ){ /* calculate the slopes  */
+                if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+                    /*  this link points to a hidden unit: 
+                        sum up the error's from previos units  */
+                    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+                link_ptr->value_c += - error * link_ptr->to->Out.output;
+            }
+        }else {         /*  the unit has sites  */
+            FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+                /* calculate the slopes  */
+                if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+                    /*  this link points to a hidden unit: 
+                        sum up the error's from previos units  */
+                    link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+
+                link_ptr->value_c += - error * link_ptr->to->Out.output;
+            }
+        }
+    }
+    return( sum_error );        /*  return the error of the network  */
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : MODI_rprop
+
+  PURPOSE  : modifies network after each epoch
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 09.05.1994 by Guenter Mamier
+******************************************************************************/
+static void MODI_rprop(float maxeps, float weight_decay)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    TopoPtrArray    topo_ptr;
+    bool            hidden_units;
+    float           direction;
+
+
+    topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+    hidden_units = TRUE;
+
+    /* calculate hidden and output units only  */
+    do {
+	if ((unit_ptr = *++topo_ptr) == NULL) {
+	  if (!hidden_units) break; /* end of topologic pointer array reached */
+	    unit_ptr = *++topo_ptr;	/* skip NULL pointer  */
+	    hidden_units = FALSE;
+	}
+
+      unit_ptr->value_c += weight_decay * unit_ptr->bias;
+	direction = unit_ptr->value_b * unit_ptr->value_c;
+      if (direction < 0.0){	/*  same direction : dw * dEdw < 0  */
+	  unit_ptr->value_a *= RPROP_ETAPLUS;	/* adapt update_value*/
+	  if (unit_ptr->value_a > maxeps) unit_ptr->value_a = maxeps; 
+	    if (unit_ptr->value_c < 0.0)
+		unit_ptr->value_b = unit_ptr->value_a;
+	    else
+	      unit_ptr->value_b = - (unit_ptr->value_a);
+      }else
+	  if (direction > 0.0){	/*  direction changed  */
+	      unit_ptr->value_b = 0; /* reset for restarting adaptation 
+					in next step */
+	      unit_ptr->value_a *= RPROP_ETAMINUS; /* adapt update_value*/
+	    if (unit_ptr->value_a < RPROP_MINEPS)
+		unit_ptr->value_a = RPROP_MINEPS;
+	} else {
+	    /* start of RPROP learning process */
+	    if (unit_ptr->value_c < 0.0)
+		unit_ptr->value_b = unit_ptr->value_a;
+	    else if (unit_ptr->value_c > 0.0)
+		  unit_ptr->value_b = - (unit_ptr->value_a);
+
+	    /* else no action if  derivative was zero */
+
+	}
+
+      if(!IS_SPECIAL_UNIT(unit_ptr))
+	  unit_ptr->bias += unit_ptr->value_b; /* compute new bias*/
+      unit_ptr->value_c = 0.0;	/* reset */
+
+      /*adjust links*/
+      if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )) { /*  the unit has direct links */
+	  FOR_ALL_LINKS( unit_ptr, link_ptr ){
+	      link_ptr->value_c += weight_decay * link_ptr->weight;	
+		direction = link_ptr->value_b * link_ptr->value_c;
+		if (direction < 0.0) {	/* same direction : dw * dEdw < 0  */
+		  link_ptr->value_a *= RPROP_ETAPLUS;	/* adapt update_value*/
+		  if (link_ptr->value_a > maxeps) link_ptr->value_a = maxeps; 
+		    if (link_ptr->value_c < 0.0)
+			link_ptr->value_b = link_ptr->value_a;
+		    else
+		      link_ptr->value_b = - (link_ptr->value_a);
+	      } else
+		  if (direction > 0.0) { /*  direction changed  */
+		      link_ptr->value_b = 0; /* reset for restarting adaptation
+						in next step */
+		      link_ptr->value_a *= RPROP_ETAMINUS;/*adapt update_value*/
+		      if( link_ptr->value_a < RPROP_MINEPS)
+			link_ptr->value_a = RPROP_MINEPS;
+		} else {
+		    /* start of RPROP learning process  */
+		    if (link_ptr->value_c < 0.0)
+			link_ptr->value_b = link_ptr->value_a;
+		    else if (link_ptr->value_c > 0.0)
+			  link_ptr->value_b = - (link_ptr->value_a);
+
+		    /* else no action if  derivative was zero */
+
+		}
+	      if(!IS_SPECIAL_UNIT(unit_ptr))
+		  link_ptr->weight += link_ptr->value_b;/* compute new weight*/
+		link_ptr->value_c = 0.0;	        /* reset */
+
+	    }
+	} else {		/* the unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+	      link_ptr->value_c += weight_decay * link_ptr->weight;
+	      direction = link_ptr->value_b * link_ptr->value_c;
+	      if (direction < 0.0){ /*  same direction : dw * dEdw <! 0  */
+		    link_ptr->value_a *= RPROP_ETAPLUS;	/* adapt update_value */
+		  if (link_ptr->value_a > maxeps) link_ptr->value_a = maxeps; 
+		    if (link_ptr->value_c < 0.0)
+			link_ptr->value_b = link_ptr->value_a;
+		    else
+		      link_ptr->value_b = - (link_ptr->value_a);
+	      } else
+		  if (direction > 0.0) { /*  direction changed  */
+		    link_ptr->value_b = 0;	/* reset for restarting
+						   adaptation in next step */
+		      link_ptr->value_a *= RPROP_ETAMINUS;/*adapt update_value*/
+		      if(link_ptr->value_a < RPROP_MINEPS)
+			link_ptr->value_a = RPROP_MINEPS;
+		  }else {
+		    /* start of RPROP learning process */
+		    if (link_ptr->value_c < 0.0)
+			link_ptr->value_b = link_ptr->value_a;
+		    else if (link_ptr->value_c > 0.0)
+			  link_ptr->value_b = - (link_ptr->value_a);
+
+		    /* else no action if  derivative was zero */
+
+		}
+
+	      if(!IS_SPECIAL_UNIT(unit_ptr))
+		  link_ptr->weight += link_ptr->value_b; /*compute new weight*/
+		link_ptr->value_c = 0.0;	/* reset */
+	    }
+	}
+    }				/* for units  */
+  while( TRUE );
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_rprop
+
+  PURPOSE  : RPROP learning function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : initial update value
+                                 2 : maxeps;
+                                 3 : exponent weight decay
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 09.05.1994 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_rprop(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1]; /*OutParameter[0] stores the*/
+    /*learning error*/
+    int    pattern_no, sub_pat_no, ret_code;
+    float  maxeps, update_value, wd;
+
+
+    if (NoOfUnits == 0)
+	return( KRERR_NO_UNITS ); /*  No Units defined  */
+
+    if (NoOfInParams < 3)
+	return( KRERR_PARAMETERS ); /*  not enough input parameters  */
+
+    /* DEFAULTS: */
+
+    if (( update_value = LEARN_PARAM1( parameterInArray )) == 0.0) 
+	update_value = RPROP_DEFAULT_UPDATE_VALUE;
+    if ((maxeps = LEARN_PARAM2( parameterInArray )) == 0.0) 
+	maxeps = RPROP_MAXEPS;
+    if (update_value > maxeps) update_value = maxeps;
+
+    wd = LEARN_PARAM3( parameterInArray );
+    if (wd != 0.0)
+	wd = (float) pow(10.0, (double)(- wd));
+
+
+
+
+    *NoOfOutParams = 1;		/* one return value */
+
+    *parameterOutArray = OutParameter;	/* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)){
+	/* Net has been modified  or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return( ret_code ); /*  an error has occured  */
+	if (ret_code < 2)
+	    return( KRERR_NET_DEPTH ); /*the network has less than 2 layers  */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort( TOPOLOGICAL_FF );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+
+    }
+
+    if (NetModified || NetInitialize || LearnFuncHasChanged){
+	/*  Net has been modified or initialized, initialize RPROP */
+	ret_code = initializeRprop(update_value);
+	if (ret_code != KRERR_NO_ERROR)  return( ret_code );
+    }
+    NetModified = FALSE;
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+	propagateNetForward(pattern_no,sub_pat_no);   /* forward propagation  */
+
+	/* backward propagation and summation of gradient  */
+	NET_ERROR(OutParameter) 
+	    += propagateNetBackwardRprop(pattern_no,sub_pat_no);
+    }
+
+    /*  modify links and bias  */
+    MODI_rprop(maxeps, wd); 
+    return( ret_code );
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_RpropMAP
+
+  PURPOSE  : RPROP learning function with adaptive weight decay
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : maxeps
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 
+******************************************************************************/
+krui_err LEARN_RpropMAP(int start_pattern, int end_pattern, 
+                     float *parameterInArray, int NoOfInParams, 
+                     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1]; /*OutParameter[0] stores the*/
+    /*learning error*/
+    static int counter=0;
+    int    pattern_no, sub_pat_no, ret_code,errorType=0,updateEpoch=20;
+    float  maxeps, update_value;
+    float  alpha, beta, lambda; 
+    
+    
+    if (NoOfUnits == 0)
+        return( KRERR_NO_UNITS ); /*  No Units defined  */
+
+    if (NoOfInParams < 1)
+        return( KRERR_PARAMETERS ); /*  not enough input parameters  */
+
+    /* DEFAULTS: */
+
+    if ((maxeps = LEARN_PARAM1( parameterInArray )) == 0.0) 
+        maxeps = RPROP_MAXEPS;
+    update_value = RPROP_DEFAULT_UPDATE_VALUE;
+    if (update_value > maxeps) update_value = maxeps;
+
+    
+    if (( update_value = LEARN_PARAM1( parameterInArray )) == 0.0) 
+        update_value = RPROP_DEFAULT_UPDATE_VALUE;
+    if ((maxeps = LEARN_PARAM2( parameterInArray )) == 0.0) 
+        maxeps = RPROP_MAXEPS;
+    if (update_value > maxeps) update_value = maxeps;
+    if (!(( lambda = LEARN_PARAM3( parameterInArray )) == 0.0))
+        lambda = (float) pow(10,(double)(- lambda));
+
+    updateEpoch = (int) LEARN_PARAM4( parameterInArray );
+    errorType = (int) LEARN_PARAM5( parameterInArray );
+
+    *NoOfOutParams = 1;         /* one return value */
+
+    *parameterOutArray = OutParameter;  /* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;  /* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)){
+        /* Net has been modified  or topologic array isn't initialized */
+        /* check the topology of the network  */
+        ret_code = kr_topoCheck();
+        if (ret_code < KRERR_NO_ERROR)
+            return( ret_code ); /*  an error has occured  */
+        if (ret_code < 2)
+            return( KRERR_NET_DEPTH ); /*the network has less than 2 layers  */
+
+        /* count the no. of I/O units and check the patterns  */
+        ret_code = kr_IOCheck();
+        if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+        /* sort units by topology and by topologic type  */
+        ret_code = kr_topoSort( TOPOLOGICAL_FF );
+        if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+            return( ret_code );
+        counter = 0;
+    }
+
+    if (NetModified || NetInitialize || LearnFuncHasChanged){
+        /*  Net has been modified or initialized, initialize RPROP */
+        ret_code = initializeRprop(update_value);
+        if (ret_code != KRERR_NO_ERROR)  return( ret_code );
+        counter = 0;
+    }
+    NetModified = FALSE;
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+        return (KernelErrorCode);
+
+    NET_ERROR(OutParameter) = 0.0;      /* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+        propagateNetForwardMAP(pattern_no,sub_pat_no,errorType);  
+
+        /* backward propagation and summation of gradient  */
+        NET_ERROR(OutParameter) 
+            += propagateNetBackwardMAP(pattern_no,sub_pat_no, errorType);
+    }
+    counter++;
+    if (updateEpoch && (counter % updateEpoch == 0) ){
+      /* compute bayes hyperparameter */
+      alpha = computeAlpha();
+      beta  = krui_getNoOfPatterns() / NET_ERROR(OutParameter);
+      if (beta ==  0.0)
+         lambda = 0.0; /* should never happen */
+        else
+          lambda = alpha / beta;
+
+      fprintf(stderr,"Epoch %d, beta:  %.4f alpha: %.4f lambda: %.4f \n",
+              counter, beta, alpha, lambda);
+    }
+    /*  modify links and bias  */
+    MODI_rprop(maxeps, lambda); 
+    return( ret_code );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : TEST_rprop
+
+  PURPOSE  : RPROP testing function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : initial update value
+                                 2 : maxeps;
+                                 3 : exponent weight decay
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 03.03.95 Joachim Danz
+******************************************************************************/
+krui_err TEST_rprop(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1]; /*OutParameter[0] stores the*/
+    /*learning error*/
+    int    pattern_no, sub_pat_no, ret_code;
+
+    if (NoOfUnits == 0)
+	return( KRERR_NO_UNITS ); /*  No Units defined  */
+
+    if (NoOfInParams < 3)
+	return( KRERR_PARAMETERS ); /*  not enough input parameters  */
+
+
+
+    *NoOfOutParams = 1;		/* one return value */
+
+    *parameterOutArray = OutParameter;	/* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)){
+	/* Net has been modified  or topologic array isn't initialized */
+	/* check the topology of the network  */
+	ret_code = kr_topoCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return( ret_code ); /*  an error has occured  */
+	if (ret_code < 2)
+	    return( KRERR_NET_DEPTH ); /*the network has less than 2 layers  */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort( TOPOLOGICAL_FF );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+	propagateNetForward(pattern_no,sub_pat_no);   /* forward propagation  */
+
+	/* backward propagation and summation of gradient  */
+	NET_ERROR(OutParameter) 
+	    += testNetBackwardRprop(pattern_no,sub_pat_no);
+    }
+
+    return( ret_code );
+}
+
+
+/*****************************************************************************
+  FUNCTION : testNetBackwardRprop
+
+  PURPOSE  : Calculation of Error
+  RETURNS  : network error
+  NOTES    : sum(dE/dw) -> value_c.
+
+  UPDATE   : 03.03.1995 by Joachim Danz
+******************************************************************************/
+static float testNetBackwardRprop(int pattern_no, int sub_pat_no)
+{
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error,	/* error  */
+                    sum_error,	/* sum of the error  */
+                    devit;	/* deviation  */
+    TopoPtrArray    topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /*  add 3 to no_of_topo_units because the topologic array contains
+	4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+	devit = *(--out_pat) - unit_ptr->Out.output;
+	/*= o * (1.0 - o) in [0.0,0.25],*/
+	/*for asymmetric logistic function*/
+
+	sum_error += devit * devit;	/* sum up the error of the network  */
+
+	/* calc. error for output units	 */
+	error = devit * ((unit_ptr->act_deriv_func) ( unit_ptr ));
+
+    }
+
+    return( sum_error );	/*  return the error of the network  */
+}
+
+
+/*****************************************************************************
+  FUNCTION : testNetBackwardMAP
+
+  PURPOSE  : Calculation of Error
+  RETURNS  : network error
+  NOTES    : sum(dE/dw) -> value_c.
+
+  UPDATE   : 03.03.1997 by Thomas Ragg
+******************************************************************************/
+static float testNetBackwardMAP(int pattern_no, int sub_pat_no, int errorType)
+{
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    float           sum_error,  /* sum of the error  */
+                    devit;      /* deviation  */
+    TopoPtrArray    topo_ptr;
+    int size;
+
+
+    sum_error = 0.0;            /* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+    /*  add 3 to no_of_topo_units because the topologic array contains
+        4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL){
+	computeDevite(&devit, &sum_error, *(--out_pat), unit_ptr->Out.output,
+		      errorType);
+    }
+    return( sum_error );        /*  return the error of the network  */
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : TEST_MAP
+
+  PURPOSE  : RPROP_MAP testing function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : initial update value
+                                 2 : maxeps;
+                                 3 : exponent weight decay
+                                 4 : #epochs update hyperparameter
+                                 5 : error function type
+
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 03.10.97 Thomas Ragg
+******************************************************************************/
+krui_err TEST_MAP(int start_pattern, int end_pattern, 
+                     float *parameterInArray, int NoOfInParams, 
+                     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter[1]; /*OutParameter[0] stores the*/
+    /*learning error*/
+    int    pattern_no, sub_pat_no, ret_code;
+    int errorType;
+
+    if (NoOfUnits == 0)
+        return( KRERR_NO_UNITS ); /*  No Units defined  */
+
+    if (NoOfInParams < 3)
+        return( KRERR_PARAMETERS ); /*  not enough input parameters  */
+
+    errorType = (int) LEARN_PARAM5( parameterInArray );
+    
+    *NoOfOutParams = 1;         /* one return value */
+
+    *parameterOutArray = OutParameter;  /* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;  /* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)){
+        /* Net has been modified  or topologic array isn't initialized */
+        /* check the topology of the network  */
+        ret_code = kr_topoCheck();
+        if (ret_code < KRERR_NO_ERROR)
+            return( ret_code ); /*  an error has occured  */
+        if (ret_code < 2)
+            return( KRERR_NET_DEPTH ); /*the network has less than 2 layers  */
+
+        /* count the no. of I/O units and check the patterns  */
+        ret_code = kr_IOCheck();
+        if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+        /* sort units by topology and by topologic type  */
+        ret_code = kr_topoSort( TOPOLOGICAL_FF );
+        if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+            return( ret_code );
+
+        NetModified = FALSE;
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+        return (KernelErrorCode);
+
+    NET_ERROR(OutParameter) = 0.0;      /* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+        propagateNetForwardMAP(pattern_no,sub_pat_no,errorType);
+
+        /* backward propagation and summation of gradient  */
+        NET_ERROR(OutParameter) 
+          += testNetBackwardMAP(pattern_no,sub_pat_no,errorType);
+    }
+
+    return( ret_code );
+}
+
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : ART 1 learning function
+
+  AUTHOR       : Kai-Uwe Herrmann
+             
+******************************************************************************
+******************************************************************************/
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_ART1
+
+  PURPOSE  : ART 1 learning function.
+  RETURNS  : kernel error code
+  NOTES    : 1 input-parameter  :  1. vigilance parameter RHO
+
+             output-parameters  :  numbers of classified patterns,
+                                   separator -1,
+                                   numbers of not classifiable patterns
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err  LEARN_ART1(int start_pattern, int end_pattern,
+		     float parameterInArray[], int NoOfInParams,
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    int             pattern_no, sub_pat_no;	/* Contains actual */
+						/* pattern number */
+    int             start, end;
+    int             i,n;
+    struct Unit    *winner_ptr;	/* recognition unit which is the winner of
+				   w.t.a  */
+    TopoPtrArray    topo_layer[6];	/* topo_layer[0] : *first input unit
+					   topo_layer[1] : *first comp. unit
+					   topo_layer[2] : *first rec.  unit
+					   topo_layer[3] : *first delay unit
+					   topo_layer[4] : *first local reset
+					   unit topo_layer[5] : *first
+					   special unit (classified_unit) */
+    TopoPtrArray    topo_ptr;
+    FlintType       beta;
+    float           rho;
+
+
+    /* Check number of incoming parameters */
+
+    if (NoOfInParams < 1) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }				/* if */
+    /* rho is the vigilance parameter   */
+    rho = parameterInArray[0];
+
+
+    /* Check interval for vigilance parameter and constant value L */
+
+    if ((rho < 0.0) || (rho > 1.0)) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }				/* if */
+    /* Check if network has been modified or learning func has been changed */
+    if (NetModified || LearnFuncHasChanged || (TopoSortID != ART1_TOPO_TYPE)) {
+	(void) kr_topoSort(ART1_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	}			/* if */
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }				/* if */
+    /* set initial activation values */
+    ret_code = kra1_init_i_act(rho);
+
+    if (ret_code != KRERR_NO_ERROR) {
+	return (ret_code);
+    }				/* if */
+    /* beta is another learning parameter of the network which is determined
+       when initializing the network. It is there written to the bias field
+       of the structure of each unit. Now we will read this value. */
+    beta = (unit_array + 1)->bias;
+
+    if (beta <= 0.0) {
+	topo_msg.error_code = KRERR_PARAM_BETA;
+	topo_msg.src_error_unit = 0;
+	topo_msg.dest_error_unit = 1;
+	return (topo_msg.error_code);
+    }				/* if */
+    /* # of output parameters is 0  */
+    *NoOfOutParams = 0;
+    *parameterOutArray = NULL;
+
+
+    /* get pointers to first elements of each layer in topo_ptr_array */
+
+    topo_ptr = topo_ptr_array + 1;
+
+    for (i = 0; i <= 5; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+
+    }				/* for */
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* Search phase */
+    start = kr_AbsPosOfFirstSubPat(start_pattern);
+    end   = kr_AbsPosOfFirstSubPat(end_pattern);
+    end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+    for(n=start; n<=end; n++){
+
+	kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+    
+	/* initialize the unit activations of the whole net */
+
+	ret_code = krart_reset_activations();
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}			/* if */
+	/* put pattern into input units */
+	ret_code = put_ART1_in_pattern(pattern_no, sub_pat_no, topo_layer[0]);
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}			/* if */
+	/* repeat synchronous propagation and look for winner until pattern
+	   is classified or network tells us, that pattern is not
+	   classifiable */
+	do {
+	    /* 1 propagation step (all units push their information onto
+	       their output and calculate their new activation. */
+
+	    krart_prop_synch();
+
+	    /* look for the recognition unit with the highest activation
+	       returns a NULL pointer if all recognition units have
+	       activation 0.0 */
+	    winner_ptr = krart_get_winner(topo_layer[2], 1.0);
+
+	} while (!(ART1_CLASSIFIED) && !(ART1_NOT_CLASSIFIABLE));
+
+
+	/* training phase */
+
+	if (ART1_CLASSIFIED) {
+
+	    /* Train network i.e. adjust weights between comparison layer and
+	       winner_unit and vice versa */
+
+	    ret_code = adjust_ART1_weights(beta, topo_layer[1],
+					   topo_layer[3], winner_ptr);
+
+	    if (ret_code != KRERR_NO_ERROR) {
+		return (ret_code);
+	    }/* if */
+	}/* if */
+    }/* for */
+
+
+    return (ret_code);
+
+}/* LEARN_ART1 */
+
+
+
+
+/*****************************************************************************
+  FUNCTION : put_ART1_in_pattern
+
+  PURPOSE  : pushes a new pattern into the input units of the network
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err put_ART1_in_pattern(int pattern_no, int sub_pat_no, 
+				    TopoPtrArray topo_inp_ptr)
+{
+    int             ret_code = KRERR_NO_ERROR;
+    register Patterns in_pat;
+    struct Unit    *unit_ptr;
+    TopoPtrArray    topo_ptr = topo_inp_ptr;
+
+    /* calculate startadress of actual pattern   */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    while ((unit_ptr = *topo_ptr++) != NULL) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->act = unit_ptr->Out.output = *in_pat++;
+	} else {
+	    unit_ptr->act = *in_pat++;
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}/* if */
+    }/* while */
+
+    return (ret_code);
+
+}/* put_ART1_in_pattern */
+
+
+
+/*****************************************************************************
+  FUNCTION : adjust_ART1_weights
+
+  PURPOSE  : training function for ART1 networks
+  RETURNS  : kernel error code
+  NOTES    : Parameters:  
+             beta         constant value beta > 0.0
+
+             comp_ptr     points to pointer to first comparison unit
+
+             delay_ptr    points to pointer to first unit in the delay layer. 
+	                  The t(j,i) links are not between recognition layer 
+			  and comparison layer but between the respective 
+			  delay unit of the recogniton unit and the comparison 
+			  layer. So first we have to look for the corresponding
+			  delay unit of the winning unit before training these 
+			  weights.
+
+             winner_ptr   points to winning unit of the recognition layer.
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err adjust_ART1_weights(double beta, TopoPtrArray comp_ptr,
+				    TopoPtrArray delay_ptr,
+				    struct Unit * winner_ptr)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    TopoPtrArray    topo_ptr = NULL;
+    struct Unit    *unit_ptr_comp = NULL, *unit_ptr_delay = NULL;
+    struct Link    *link_ptr = NULL;
+    bool            found_delay_unit = FALSE;
+    FlintType       sum_ck = 0.0;
+
+
+    /* get corresponding unit of the winning unit in the delay layer */
+
+    topo_ptr = delay_ptr;
+
+    while ((!found_delay_unit) && (*topo_ptr != NULL)) {
+
+	unit_ptr_delay = *topo_ptr++;
+
+	if (((struct Link *) unit_ptr_delay->sites)->to == winner_ptr) {
+	    found_delay_unit = TRUE;
+	}/* if */
+    }/* while */
+
+    if (!found_delay_unit) {
+
+	/* There was no delay unit found corresponding to the winning
+	   recognition unit */
+
+	ret_code = KRERR_TOPOLOGY;
+	return (ret_code);
+
+    }/* if */
+    /* Adjust weights between winning unit (delay-layer) and comparison layer
+       (t(j,i) link values)
+    
+    t(j,i) = c(i)   where j is the number of the winning neuron in the delay
+       layer and i ist the number of a comparison unit. */
+    topo_ptr = comp_ptr;
+
+    while ((unit_ptr_comp = *topo_ptr++) != NULL) {
+
+	sum_ck += unit_ptr_comp->act;	/* sum up activatons of comparison
+					   layer. sum_ck is needed for b(i,j) */
+
+	FOR_ALL_LINKS(unit_ptr_comp, link_ptr) {
+
+	    if (link_ptr->to == unit_ptr_delay) {
+		link_ptr->weight = ART1_ADJUST_LINK_DEL_CMP(unit_ptr_comp);
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+
+    }/* while */
+
+
+    /* Adjust weights between comparison layer and winning unit (recognition
+       layer) (b(i,j) link values)
+    
+       b(i,j) = c(i) / (beta + sum(k)(c(k)))
+    
+       where j is the number of the winning neuron in the recognition layer, i
+       ist the number of a comparison unit and k runs over all comparison
+       units. (sum(k)(c(k))) = sum_ck. 
+    */
+
+
+    FOR_ALL_LINKS(winner_ptr, link_ptr) {
+
+	if (link_ptr->to->lln == ART1_CMP_LAY) {
+	    link_ptr->weight = (FlintType)ART1_ADJUST_LINK_CMP_REC(link_ptr->to,
+								   beta,sum_ck);
+	}/* if */
+    }/* FOR_ALL_LINKS */
+
+
+    return (ret_code);
+}/* adjust_ART1_weights () */
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : ART2 learning function
+
+  AUTHOR       : Kai-Uwe Herrmann
+
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_ART2
+
+  PURPOSE  : ART2 learning function.
+  RETURNS  : kernel error code
+  NOTES    : Parameters: 
+                    6 input-parameter  :  1. vigilance parameter RHO
+                                          2. Parameter a
+                                          3. Parameter b
+                                          4. Parameter c
+                                          5. Parameter e
+                                          6. Parameter THETA
+
+                    output-parameters  :  none
+
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_ART2(int start_pattern, int end_pattern,
+		    float parameterInArray[], int NoOfInParams,
+		    float **parameterOutArray, int *NoOfOutParams)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    int             pattern_no, sub_pat_no; /* Contains actual pattern number */
+    int             i,n;
+    int             start, end;
+    struct Unit    *winner_ptr;	/* recognition unit which is the winner of
+				   w.t.a */
+    TopoPtrArray    topo_layer[12];	/* topo_layer[0] : *first input unit
+					   topo_layer[1] : *first w unit
+					   topo_layer[2] : *first x unit
+					   topo_layer[3] : *first u unit
+					   topo_layer[4] : *first v unit
+					   topo_layer[5] : *first p unit
+					   topo_layer[6] : *first q unit
+					   topo_layer[7] : *first r unit
+					   topo_layer[8] : *first rec.  unit
+					   topo_layer[10] : *first local
+					   reset unit */
+    TopoPtrArray    topo_ptr;
+    FlintType       rho, param_a, param_b, param_c, param_d, theta;
+
+
+    /* Check number of incoming parameters */
+
+    if (NoOfInParams < 5) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }/* if */
+    rho = parameterInArray[0];
+    param_a = parameterInArray[1];
+    param_b = parameterInArray[2];
+    param_c = parameterInArray[3];
+    theta = parameterInArray[4];
+
+
+    /* Check if network has been modified or learning func has been changed */
+
+    if (NetModified || LearnFuncHasChanged || (TopoSortID != ART2_TOPO_TYPE)) {
+	(void) kr_topoSort(ART2_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	}/* if */
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }/* if */
+    /* Read out value of parameter d from bias field of any unit. The value
+       has been written into the bias field by the init-function */
+    param_d = (*(topo_ptr_array + 1))->bias;
+
+
+    /* Check values of the parameters */
+
+    if ((rho < 0.0) || (rho > 1.0) ||
+	(param_a <= 0.0) || (param_b <= 0.0) ||
+	((param_c * param_d) / (1 - param_d) > 1.0) ||
+	(theta < 0.0) || (theta > 1.0)
+	) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }/* if */
+    ret_code = kra2_set_params(rho, param_a, param_b, param_c, param_d, theta);
+
+    if (ret_code != KRERR_NO_ERROR) {
+	return (ret_code);
+    }/* if */
+    ret_code = kra2_init_propagate();
+
+    if (ret_code != KRERR_NO_ERROR) {
+	return (ret_code);
+    }/* if */
+    /* get pointers to first elements of each layer in topo_ptr_array */
+    topo_ptr = topo_ptr_array + 1;
+
+    for (i = 0; i <= 9; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+
+    }/* for */
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* Search phase */
+    start = kr_AbsPosOfFirstSubPat(start_pattern);
+    end   = kr_AbsPosOfFirstSubPat(end_pattern);
+    end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+    for(n=start; n<=end; n++){
+
+	kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+	/* initialize the unit activations of the whole net */
+
+	ret_code = krart_reset_activations();
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}/* if */
+	/* put pattern into input units */
+	ret_code = put_ART2_in_pattern(pattern_no, sub_pat_no,
+				       topo_layer[ART2_INP_LAY-1]);
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}/* if */
+
+	/* initialize of ART2 Simulator for new pattern */
+	kra2_init_pattern();
+
+	/* repeat synchronous propagation and look for winner until pattern
+	   is classified or network tells us, that pattern is not
+	   classifiable */
+
+	do {
+
+	    /* compute vector norms */
+	    kra2_compute_norms();
+
+	    /* save old activation values of f1-units */
+	    kra2_save_for_stability_check();
+
+	    /* 1 propagation step (all units push their information onto
+	       their output and calculate their new activation. */
+	    krart_prop_synch();
+
+	    /* look for the recognition unit with the highest activation
+	       returns a NULL pointer if all recognition units have
+	       activation 0.0 */
+	    winner_ptr = krart_get_winner(topo_layer[ART2_REC_LAY-1], param_d);
+
+	    /* Check if F1-Layer is stable */
+	    kra2_check_f1_stability();
+
+	    /* Check Reset */
+	    kra2_checkReset();
+
+	} while (!(ART2_CLASSIFIED) && !(ART2_NOT_CLASSIFIABLE));
+
+
+	/* training phase */
+
+	if (ART2_CLASSIFIED) {
+
+	    /* Train network i.e. adjust weights between comparison layer and
+	       winner_unit and vice versa */
+	    ret_code = adjust_ART2_weights(param_d, topo_layer[ART2_P_LAY - 1],
+					   winner_ptr);
+
+	    if (ret_code != KRERR_NO_ERROR) {
+		return (ret_code);
+	    }/* if */
+	}/* if */
+    }/* for */
+
+    return (ret_code);
+
+}/* LEARN_ART2 */
+
+
+
+/*****************************************************************************
+  FUNCTION : krui_err put_ART2_in_pattern
+
+  PURPOSE  : pushes a new pattern into the input units of the network
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err put_ART2_in_pattern(int pattern_no, int sub_pat_no,
+				    TopoPtrArray topo_inp_ptr)
+{
+    int               ret_code = KRERR_NO_ERROR;
+    register Patterns in_pat;
+    struct Unit       *unit_ptr;
+    TopoPtrArray      topo_ptr = topo_inp_ptr;
+
+    /* calculate startadress of actual pattern */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    while ((unit_ptr = *topo_ptr++) != NULL) {
+
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->act = unit_ptr->Out.output = *in_pat++;
+	} else {
+	    unit_ptr->act = *in_pat++;
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}/* if */
+
+    }/* while */
+
+    return (ret_code);
+
+}/* put_ART2_in_pattern */
+
+
+
+/*****************************************************************************
+  FUNCTION : adjust_ART2_weights
+
+  PURPOSE  : training function for ART2 networks
+  RETURNS  : kernel error code
+  NOTES    : Parameters:  
+             param_d     constant value 0 < param_d < 1
+
+             p_ptr       points to pointer to first comparison unit
+
+             delay_ptr   points to pointer to first unit in the delay layer. 
+	                 The z(j,i) links are not between recognition layer 
+			 and comparison layer but between the respective delay 
+			 unit of the recogniton unit and the comparison layer.
+			 So first we have to look for the corresponding delay 
+			 unit of the winning unit before training these weights.
+
+             winner_ptr  points to winning unit of the recognition layer.
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err adjust_ART2_weights(double param_d, TopoPtrArray p_ptr,
+				    struct Unit * winner_ptr)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    TopoPtrArray    topo_ptr = NULL;
+    struct Unit    *unit_ptr_p = NULL;
+    struct Link    *link_ptr = NULL, *link_ptr_u = NULL;
+
+    /* Adjust weights between winning unit and p layer (z(J,i) link values)
+    
+       (d/dt) z(J,i) = z(J,i) + d * (1-d) * [ u(i)/(1-d) - z(J,i) ]
+    
+       for (d/dt) -> 0:        z(J,i) = u(i)/(1-d) 
+    */
+
+    topo_ptr = p_ptr;
+
+    while ((unit_ptr_p = *topo_ptr++) != NULL) {
+	FOR_ALL_LINKS(unit_ptr_p, link_ptr) {
+	    if (link_ptr->to == winner_ptr) {
+
+		/* lookin' for corresponding u unit */
+		FOR_ALL_LINKS(unit_ptr_p, link_ptr_u) {
+		    if (link_ptr_u->to->lln == ART2_U_LAY) {
+			link_ptr->weight =
+			    ART2_ADJUST_LINK_REC_P(link_ptr_u->to, param_d);
+			break;
+		    }/* if */
+		}/* FOR_ALL_LINKS */
+
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+
+    /* Adjust weights between p layer and winning unit (recognition layer)
+       (z(i,j) link values)
+    
+       (d/dt) z(i,J) = d * (1-d) * [ u(i)/(1-d) - z(i,J) ]
+    
+       where J is the number of the winning neuron in the recognition layer, i
+       ist the number of a p unit
+    
+       for (d/dt) -> 0:   z(i,J) = u(i)/(1-d)
+    
+    */
+
+
+    FOR_ALL_LINKS(winner_ptr, link_ptr) {
+	if (link_ptr->to->lln == ART2_P_LAY) {
+
+	    /* lookin' for corresponding u unit */
+	    FOR_ALL_LINKS(link_ptr->to, link_ptr_u) {
+		if (link_ptr_u->to->lln == ART2_U_LAY) {
+		    link_ptr->weight =
+			ART2_ADJUST_LINK_P_REC(link_ptr_u->to, param_d);
+
+		    break;
+		}/* if */
+	    }/* FOR_ALL_LINKS */
+	}/* if */
+    }/* FOR_ALL_LINKS */
+
+
+    return (ret_code);
+
+}/* adjust_ART2_weights () */
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : ARTMAP learning function
+
+  AUTHOR       : Kai-Uwe Herrmann
+
+******************************************************************************
+******************************************************************************/
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_ARTMAP
+
+  PURPOSE  : ARTMAP learning function.
+  RETURNS  : kernel error code
+  NOTES    : Parameters:      
+                    3 input-parameter  :  1. vigilance parameter RHOa
+                                          2. vigilance parameter RHOb
+                                          3. vigilance parameter RHO
+
+                    output-parameters  :  none
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_ARTMAP(int start_pattern, int end_pattern,
+		      float parameterInArray[], int NoOfInParams,
+		      float **parameterOutArray, int *NoOfOutParams)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    int             pattern_no, sub_pat_no; /* Contains actual pattern number */
+    int             i,n;
+    struct Unit    *winner_ptr_a;	/* recognition unit which is the
+					   winner of w.t.a ARTa */
+    struct Unit    *winner_ptr_b;	/* recognition unit which is the
+					   winner of w.t.a ARTb */
+    struct Unit    *unit_ptr;
+    TopoPtrArray    topo_layer[14];	/* topo_layer[0] : *first input unit
+					   ARTa topo_layer[1] : *first comp.
+					   unit ARTa topo_layer[2] : *first
+					   rec.  unit ARTa topo_layer[3] :
+					   *first delay unit ARTa
+					   topo_layer[4] : *first local reset
+					   unit ARTa topo_layer[5] : *first
+					   special unit ARTa
+					   (classified_unit) topo_layer[6] :
+					   *first input unit ARTb
+					   topo_layer[7] : *first comp. unit
+					   ARTb topo_layer[8] : *first rec.
+					   unit ARTb topo_layer[9] : *first
+					   delay unit ARTb topo_layer[10]:
+					   *first local reset unit ARTb
+					   topo_layer[11]: *first special
+					   unit ARTb (classified_unit)
+					   topo_layer[12]: *first map unit
+					   topo_layer[13]: *first special map
+					   unit */
+
+    TopoPtrArray    topo_ptr;
+    FlintType       beta_a;
+    FlintType       beta_b;
+    float           rho_a;
+    float           rho_b;
+    float           rho;
+    int             start, end;
+
+
+    /* Check number of incoming parameters */
+
+    if (NoOfInParams < 3) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }/* if */
+    /* rho is the vigilance parameter */
+    rho_a = parameterInArray[0];
+    rho_b = parameterInArray[1];
+    rho = parameterInArray[2];
+
+
+    /* Check interval in which vigilance parameter and constant value L have
+       to be */
+
+    if ((rho_a < 0.0) || (rho_a > 1.0) || (rho_b < 0.0) ||
+	(rho_b > 1.0) || (rho < 0.0) || (rho > 1.0)
+	) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }/* if */
+    /* Check if network has been modified or learning func has been changed */
+    if (NetModified || LearnFuncHasChanged || (TopoSortID != ARTMAP_TOPO_TYPE)){
+	(void) kr_topoSort(ARTMAP_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	}/* if */
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }/* if */
+
+    /* set initial activation values */
+    ret_code = kram_init_i_act(rho_a, rho_b, rho);
+
+    if (ret_code != KRERR_NO_ERROR) {
+	return (ret_code);
+    }/* if */
+    /* beta_a, beta_b are other learning parameters of the network which are
+       determined when initializing the network. They are there written to
+       the bias field of the structure of each unit of the corresponding ART
+       1 network. Now we will read these values. */
+
+    /* find an ARTa unit and get ARTa beta value */
+    for (unit_ptr=unit_array+1; unit_ptr->lln != ARTMAP_INPa_LAY; unit_ptr++);
+    beta_a = unit_ptr->bias;
+
+    /* find an ARTb unit and get ARTb beta value */
+    for (unit_ptr=unit_array+1; unit_ptr->lln != ARTMAP_INPb_LAY; unit_ptr++);
+    beta_b = unit_ptr->bias;
+
+    if ((beta_a <= 0.0) || (beta_b <= 0.0)) {
+	topo_msg.error_code = KRERR_PARAM_BETA;
+	topo_msg.src_error_unit = 0;
+	topo_msg.dest_error_unit = 1;
+	return (topo_msg.error_code);
+    }/* if */
+
+    /* # of output parameters is 0 */
+    *NoOfOutParams = 0;
+    *parameterOutArray = NULL;
+
+
+    /* get pointers to first elements of each layer in topo_ptr_array */
+
+    topo_ptr = topo_ptr_array + 1;
+
+    for (i = 0; i <= 13; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+
+    }/* for */
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* Search phase */
+    start = kr_AbsPosOfFirstSubPat(start_pattern);
+    end   = kr_AbsPosOfFirstSubPat(end_pattern);
+    end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+    for(n=start; n<=end; n++){
+
+	kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+	/* initialize the unit activations of the whole net */
+	ret_code = krart_reset_activations();
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}/* if */
+
+	/* put pattern into input units */
+	ret_code = 
+	    put_ARTMAP_in_pattern(pattern_no, sub_pat_no, topo_layer[0], 
+				  topo_layer[6]);
+	if (ret_code != KRERR_NO_ERROR) {
+	    return (ret_code);
+	}/* if */
+	/* repeat synchronous propagation and look for winner until pattern
+	   is classified or network tells us, that pattern is not
+	   classifiable */
+	do {
+
+	    /* 1 propagation step (all units push their information onto
+	       their output and calculate their new activation. */
+
+	    krart_prop_synch();
+
+	    /* look for the recognition unit with the highest activation
+	       returns a NULL pointer if all recognition units have
+	       activation 0.0 */
+	    winner_ptr_a = krart_get_winner(topo_layer[2], 1.0);
+	    winner_ptr_b = krart_get_winner(topo_layer[8], 1.0);
+
+	} while (!(ARTMAP_CLASSIFIED) && !(ARTMAP_NOT_CLASSIFIABLE));
+
+
+	/* training phase */
+
+	if (ARTMAP_CLASSIFIED) {
+
+	    /* Train network i.e. adjust weights between comparison layer and
+	       winner_unit and vice versa of both, ARTa and ARTb. Further
+	       adjust weights between ARTa delay and map field layer. */
+
+	    ret_code = adjust_ARTMAP_weights(beta_a, beta_b,
+					     topo_layer[1], topo_layer[7],
+					     topo_layer[3], topo_layer[9],
+					     topo_layer[12],
+					     winner_ptr_a, winner_ptr_b);
+
+	    if (ret_code != KRERR_NO_ERROR) {
+		return (ret_code);
+	    }/* if */
+	} else {
+
+	    /* we're doing nothing */
+
+	}/* if */
+
+    }/* for */
+
+    return (ret_code);
+
+}/* LEARN_ARTMAP */
+
+
+
+/*****************************************************************************
+  FUNCTION : put_ARTMAP_in_pattern
+
+  PURPOSE  : pushes a new pattern into the input units of the network
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err put_ARTMAP_in_pattern(int pattern_no, int sub_pat_no,
+				      TopoPtrArray topo_inpa_ptr,
+				      TopoPtrArray topo_inpb_ptr)
+{
+    int               ret_code = KRERR_NO_ERROR;
+    register Patterns in_pat;
+    struct Unit       *unit_ptr;
+    TopoPtrArray      topo_ptr_a = topo_inpa_ptr;
+    TopoPtrArray      topo_ptr_b = topo_inpb_ptr;
+
+
+    /* calculate startadress of actual pattern */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    while ((unit_ptr = *topo_ptr_a++) != NULL) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->act = unit_ptr->Out.output = *in_pat++;
+	} else {
+	    unit_ptr->act = *in_pat++;
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}/* if */
+    }/* while */
+
+    while ((unit_ptr = *topo_ptr_b++) != NULL) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->act = unit_ptr->Out.output = *in_pat++;
+	} else {
+	    unit_ptr->act = *in_pat++;
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}/* if */
+    }/* while */
+
+
+    return (ret_code);
+
+}/* put_ARTMAP_in_pattern */
+
+
+
+
+/*****************************************************************************
+  FUNCTION : adjust_ARTMAP_weights
+
+  PURPOSE  : training function for ARTMAP networks
+  RETURNS  : kernel error code
+  NOTES    : Parameters:  
+             beta_a         constant value beta of ARTa > 0.0
+             beta_b         constant value beta of ARTb > 0.0
+
+             compa_ptr      points to pointer to 1st comparison unit of ARTa
+             compb_ptr      points to pointer to 1st comparison unit of ARTb
+
+             dela_ptr       points to pointer to first unit in the delay layer.
+	                    The t(j,i) links are not between recognition layer
+			    and comparison layer but between the respective 
+			    delay unit of the recogniton unit and the 
+			    comparison layer. So first we have to look for the 
+			    corresponding delay unit of the winning unit before
+			    training these weights.
+             delb_ptr       points to pointer to first unit in the delay layer.
+	                    The t(j,i) links are not between recognition layer 
+			    and comparison layer but between the respective 
+			    delay unit of the recogniton unit and the 
+			    comparison layer. So first we have to look for the 
+			    corresponding delay unit of the winning unit before
+			    training these weights.
+
+             map_ptr        points to pointer to first unit in the map layer
+
+             winner_ptr_a   points to winning unit of the recognition layer of 
+	                    ARTa.
+             winner_ptr_b   points to winning unit of the recognition layer of 
+	                    ARTb.
+
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err adjust_ARTMAP_weights(double beta_a, double beta_b,
+				      TopoPtrArray compa_ptr,
+				      TopoPtrArray compb_ptr,
+				      TopoPtrArray dela_ptr,
+				      TopoPtrArray delb_ptr,
+				      TopoPtrArray map_ptr,
+				      struct Unit * winner_ptr_a,
+				      struct Unit * winner_ptr_b)
+{
+    krui_err        ret_code = KRERR_NO_ERROR;
+    TopoPtrArray    topo_ptr = NULL;
+    struct Unit    *unit_ptr_compa = NULL, *unit_ptr_compb = NULL, 
+                   *unit_ptr_dela = NULL, *unit_ptr_delb = NULL, 
+                   *unit_ptr_map = NULL;
+
+    struct Link    *link_ptr = NULL;
+
+    bool            found_dela_unit = FALSE;
+    bool            found_delb_unit = FALSE;
+
+    FlintType       sum_ck = 0.0;
+
+
+    if ((winner_ptr_a == NULL) || (winner_ptr_b == NULL)) {
+	/* We are using ARTMAP in a non-learning mode, wo we are not allowed
+	   to adjust weights now. Weights may just be adjusted, if we have an
+	   input in ARTa and ARTb each of which brings out a winner in the
+	   respective F2-Layer */
+	return (ret_code);
+    }/* if */
+    /* get corresponding unit of the winning unit of ARTa in the delay layer */
+    topo_ptr = dela_ptr;
+
+    while ((!found_dela_unit) && (*topo_ptr != NULL)) {
+	unit_ptr_dela = *topo_ptr++;
+	FOR_ALL_LINKS(unit_ptr_dela, link_ptr) {
+	    if (link_ptr->to == winner_ptr_a) {
+		found_dela_unit = TRUE;
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+    /* get corresponding unit of the winning unit of ARTb in the delay layer */
+
+    topo_ptr = delb_ptr;
+    while ((!found_delb_unit) && (*topo_ptr != NULL)) {
+	unit_ptr_delb = *topo_ptr++;
+	FOR_ALL_LINKS(unit_ptr_delb, link_ptr) {
+	    if (link_ptr->to == winner_ptr_b) {
+		found_delb_unit = TRUE;
+		break;
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+    if ((!found_dela_unit) || (!found_delb_unit)) {
+
+	/* There was no delay unit found corresponding to the winning
+	   recognition unit in ARTa or ARTb */
+
+	ret_code = KRERR_TOPOLOGY;
+	return (ret_code);
+
+    }/* if */
+    /********* ADJUST WEIGHTS *********/
+    /* Adjust weights between winning unit (delay-layer) and comparison layer
+       (t(j,i) link values) -> ARTa
+    
+       t(j,i) = c(i)   where j is the number of the winning neuron in the delay
+       layer and i ist the number of a comparison unit. 
+    */
+
+    topo_ptr = compa_ptr;
+    while ((unit_ptr_compa = *topo_ptr++) != NULL) {
+	sum_ck += unit_ptr_compa->act;	/* sum up activatons of comparison
+					   layer. sum_ck is needed for b(i,j) */
+	FOR_ALL_LINKS(unit_ptr_compa, link_ptr) {
+	    if (link_ptr->to == unit_ptr_dela) {
+		link_ptr->weight = ART1_ADJUST_LINK_DEL_CMP(unit_ptr_compa);
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+    /* Adjust weights between comparison layer and winning unit (recognition
+       layer) -> ARTa
+    
+       b(i,j) = c(i) / (beta + sum(k)(c(k)))
+    
+       where j is the number of the winning neuron in the recognition layer, i
+       ist the number of a comparison unit and k runs over all comparison
+       units. (sum(k)(c(k))) = sum_ck. 
+    */
+
+    FOR_ALL_LINKS(winner_ptr_a, link_ptr) {
+	if (link_ptr->to->lln == ARTMAP_CMPa_LAY) {
+	    link_ptr->weight = (FlintType)ART1_ADJUST_LINK_CMP_REC(link_ptr->to,
+								   beta_a,
+								   sum_ck);
+	}/* if */
+    }/* FOR_ALL_LINKS */
+
+
+    /* Adjust weights between winning unit (delay-layer) and comparison layer
+       (t(j,i) link values) -> ARTb
+    
+       t(j,i) = c(i)   where j is the number of the winning neuron in the delay
+       layer and i ist the number of a comparison unit. 
+    */
+
+    topo_ptr = compb_ptr;
+    sum_ck = 0.0;
+    while ((unit_ptr_compb = *topo_ptr++) != NULL) {
+	sum_ck += unit_ptr_compb->act;	/* sum up activatons of comparison
+					   layer. sum_ck is needed for b(i,j) */
+	FOR_ALL_LINKS(unit_ptr_compb, link_ptr) {
+	    if (link_ptr->to == unit_ptr_delb) {
+		link_ptr->weight = ART1_ADJUST_LINK_DEL_CMP(unit_ptr_compb);
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+    /* Adjust weights between comparison layer and winning unit (recognition
+       layer) (b(i,j) link values)
+    
+       b(i,j) = c(i) / (beta + sum(k)(c(k)))
+    
+       where j is the number of the winning neuron in the recognition layer, i
+       ist the number of a comparison unit and k runs over all comparison
+       units. (sum(k)(c(k))) = sum_ck. 
+    */
+
+    FOR_ALL_LINKS(winner_ptr_b, link_ptr) {
+	if (link_ptr->to->lln == ARTMAP_CMPb_LAY) {
+	    link_ptr->weight = (FlintType)ART1_ADJUST_LINK_CMP_REC(link_ptr->to,
+								   beta_b,
+								   sum_ck);
+	}/* if */
+    }/* FOR_ALL_LINKS */
+
+
+    /* Adjust weights between delay units of ARTa and map units
+    
+       w(i,j) = map(j) where j is the number of a neuron in the map layer i is
+       the number of the winning neuron in the dela layer 
+    */
+
+    topo_ptr = map_ptr;
+    while ((unit_ptr_map = *topo_ptr++) != NULL) {
+	FOR_ALL_LINKS(unit_ptr_map, link_ptr) {
+	    if (link_ptr->to == unit_ptr_dela) {
+		/* Same as adjustment between delay and comparison layer */
+		link_ptr->weight = ART1_ADJUST_LINK_DEL_CMP(unit_ptr_map);
+	    }/* if */
+	}/* FOR_ALL_LINKS */
+    }/* while */
+
+    return (ret_code);
+
+}/* adjust_ARTMAP_weights () */
+
+
+
+/*****************************************************************************
+ *****************************************************************************
+
+  GROUP        : backpropagation through time learning functions
+
+  AUTHOR       : Martin Reczko
+  NOTES        : Implemented are Truncated backpropagation through time with 
+                 online-update (BPTT), Truncated backpropagation through time 
+                 with batch-update (BBPTT) and truncated quickprop through 
+		 time (QPTT) learning functions
+
+******************************************************************************
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : BPTT_clear_deltaw
+
+  PURPOSE  : BPTT weight change reset
+  RETURNS  : kernel error code
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err BPTT_clear_deltaw(void)
+{
+    register struct Unit *unit_ptr;
+    struct Link    *link_ptr;
+
+
+    FOR_ALL_UNITS(unit_ptr) {
+
+	/* reset old weight changes (_a), old gradients (_b) and gradient
+	   accumulators (_c) */
+	unit_ptr->value_a = 0.0;
+	unit_ptr->value_b = 0.0;
+	unit_ptr->value_c = 0.0;
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    link_ptr->value_a = 0.0;
+	    link_ptr->value_b = 0.0;
+	    link_ptr->value_c = 0.0;
+	}
+    }
+    return (KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : initializeBPTT 
+
+  PURPOSE  : BPTT network activity reset 
+  RETURNS  : kernel error code
+  NOTES    : BPTT data structures: unit:
+             unit_ptr->olddelta : delta values, after finished calculation 
+	                          for 1 time step
+             unit_ptr->newdelta : accumulators for new delta values
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static krui_err initializeBPTT(void)
+{
+    register struct Unit *unit_ptr;
+    int             i;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	/* clear netact-copies */
+	for (i = 0; i < MAX_BPTT_BACKSTEP; i++)
+	    unit_ptr->actbuf[i] = 0.0;
+    }
+    return (KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : BPTT_propagateNetForward
+
+  PURPOSE  : topological forward propagation (backprop thru time)
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void BPTT_propagateNetForward(int pattern_no, int sub_pat_no, int nhist)
+{
+    register struct Unit *unit_ptr;
+    register Patterns in_pat;
+    register TopoPtrArray topo_ptr;
+    TopoPtrArray    first_hidden_ptr;
+    int             i, done_hidden;
+    int             all_zero_input = 1;	/* flag to reset net-copies */
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    topo_ptr = topo_ptr_array;
+
+    /* ACTIVATE INPUT LAYER */
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    /* topo_ptr points to a (topological sorted) unit stucture (input units
+       first)  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+
+	/* apply input pattern */
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* there is no need to call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = 
+		(*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+	if (fabs(unit_ptr->act) > 0.000001)
+	    all_zero_input = 0;	/* no reset-input */
+
+	/* BPTT: shift the actbuf for this input buffer one step back in time */
+	for (i = nhist; i > 0; i--) {
+	    unit_ptr->actbuf[i] = unit_ptr->actbuf[i - 1];
+	}
+
+	/* the new input pattern moves into the second time-layer with index 1,
+	   since activations for this pattern are calculated in time-layer 0 */
+	unit_ptr->actbuf[1] = unit_ptr->act;
+
+    }
+
+    /* An all-zero input pattern resets all network activities */
+    if (all_zero_input) {
+	initializeBPTT();    /* reset all netact-copies at start of sequences */
+    }
+
+    /* INPUT LAYER DONE */
+
+    /* store first hidden unit pointer */
+    first_hidden_ptr = topo_ptr;
+
+    /* shift all actbufs for non-input units one step back in time, make most
+       recent activity visible in unit_ptr->Out.output for subsequent calls
+       to act_func */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* hidden layer */
+	for (i = nhist; i > 0; i--)
+	    unit_ptr->actbuf[i] = unit_ptr->actbuf[i - 1];
+	unit_ptr->Out.output = unit_ptr->actbuf[1];
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* output layer */
+	for (i = nhist; i > 0; i--)
+	    unit_ptr->actbuf[i] = unit_ptr->actbuf[i - 1];
+	unit_ptr->Out.output = unit_ptr->actbuf[1];
+    }
+
+
+    /* calculate new activities for hidden and output units */
+    /* point to first hidden unit */
+    topo_ptr = first_hidden_ptr;
+    done_hidden = 0;
+    while (((unit_ptr = *++topo_ptr) != NULL) || (done_hidden == 0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	} else {
+	    /* calc actbuf[0] using actbuf[1], don't update Out.output while
+	       updating units, wait until all units are processed  */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+	    unit_ptr->actbuf[0] = unit_ptr->act;
+	}
+
+    /* set Out.output */
+    topo_ptr = first_hidden_ptr;
+    done_hidden = 0;
+    while (((unit_ptr = *++topo_ptr) != NULL) || (done_hidden == 0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	} else {
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		/* identity output function: there is no need to call the
+		   output function  */
+		unit_ptr->Out.output = unit_ptr->act;
+	    else
+		/* no identity output function: calculate unit's output also  */
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}
+}
+
+
+/*****************************************************************************
+  FUNCTION : initOldDeltas
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    : BPTT starts at the first time-layer (actbuf[0]).
+             The deltas for this layer are calculated for the output units by
+	     comparison with the target values. All other deltas for hidden 
+	     units are zero. The deltas are propagated to the second time-layer
+	     (actbuf[1]) into oldelta
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static float initOldDeltas(int pattern_no, int sub_pat_no)
+{
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register float  error, sum_error, devit, delta, tmp;
+    register TopoPtrArray topo_ptr;
+    TopoPtrArray    first_hidden_ptr;
+    int             all_correct = 1;	/* flag, wether all bits in the
+					   pattern are correct */
+    int size;
+
+    /* Initdelta, Step 1: clear all olddeltas (accumulate delta in olddelta) */
+
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* input units */
+	unit_ptr->olddelta = 0.0;
+    }
+
+    /* store first hidden unit pointer */
+    first_hidden_ptr = topo_ptr;
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* hidden units */
+	unit_ptr->olddelta = 0.0;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* output units */
+	unit_ptr->olddelta = 0.0;
+    }
+
+    sum_error = 0.0;		/* reset network error  */
+
+    /* calculate address of the output pattern (with number pattern_no + 1)  */
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+
+
+    /* last output unit: add 3 to no_of_topo_units because the topologic
+       array contains 4 NULL pointers  */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    /* LOOP FOR ALL OUTPUT UNITS */
+    /* calculate olddelta for output units  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	tmp = unit_ptr->Out.output;
+	devit = *(--out_pat);
+
+	/* count correct bits using threshold of 0.5 */
+	if (devit > 0.5) {
+	    if (tmp > 0.5)
+		NoOfLearnedPatterns++;
+	    else
+		all_correct = 0;
+	} else {
+	    if (tmp <= 0.5)
+		NoOfLearnedPatterns++;
+	    else
+		all_correct = 0;
+	}
+
+	devit = devit - tmp;	/* calc. devitation (target_j - output_j) */
+	error = devit * devit;
+	sum_error += error;
+
+	/* BPTT uses sum_j ( o_j - t_j )^2 as error function => -2.0 * ... */
+	delta = -2.0 * devit * ((unit_ptr->act_deriv_func) (unit_ptr));
+
+	/* Initdelta, Step 2: upstream propagation of gradients for backprop */
+	FOR_ALL_LINKS(unit_ptr, link_ptr) {
+	    tmp = delta * link_ptr->weight;
+	    link_ptr->to->olddelta += tmp;	/* accumulate delta */
+	    /* accumulate weight gradient */
+	    link_ptr->value_c += link_ptr->to->actbuf[1] * delta;	
+	}
+
+	/* accumulate bias gradient */
+	unit_ptr->value_c += delta;
+    }/* output units done */
+
+    /* Initdelta, Step 3:  clear newdelta */
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* input units */
+	unit_ptr->newdelta = 0.0;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* hidden units */
+	unit_ptr->newdelta = 0.0;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* output units */
+	unit_ptr->newdelta = 0.0;
+    }
+
+    return (sum_error);
+}
+
+
+/*****************************************************************************
+  FUNCTION : oneStepBackprop
+
+  PURPOSE  : calc weight changes between consecutive time steps 
+  RETURNS  : network error
+  NOTES    : heart of BPTT
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static float oneStepBackprop(int backstep, int pattern_no, int sub_pat_no, 
+			     int nhist)
+{
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    double          delta, sum_error;
+    register TopoPtrArray topo_ptr;
+    int             done_hidden, nextlayer;
+    float           tmp;
+
+    /* CHECK FOR START OF BACKPROP AT THE LAST TIME LAYER */
+    if (backstep == 0) {
+	sum_error = initOldDeltas(pattern_no,sub_pat_no);
+	return (sum_error);	/* start case */
+    } else			/* at least for time layer 0, old deltas are
+				   known */
+	sum_error = 0.0;
+
+    /* index of next layer (used frequently!) */
+    nextlayer = backstep + 1;
+
+    /* point to seperator after last input unit */
+    topo_ptr = topo_ptr_array;	/* + (NoOfInputUnits + 1); */
+    while ((unit_ptr = *++topo_ptr) != NULL);
+    done_hidden = 0;
+
+    /* DO BACKPROP FOR ALL NON-INPUT-UNITS */
+    while (((unit_ptr = *++topo_ptr) != NULL) || (done_hidden == 0))
+	if (unit_ptr == NULL) {	/* skip NULL seperator between hidden and
+				   output units */
+	    done_hidden = 1;
+	} else {		/* delta =  f'(net[backstep]) * olddelta */
+	    /* copy actbuf[backstep] to act to enable call to act_deriv_func
+	       (overhead: better definition of activation functions required) */
+	    unit_ptr->act = unit_ptr->actbuf[backstep];
+	    delta = ((unit_ptr->act_deriv_func)(unit_ptr)) * unit_ptr->olddelta;
+
+	    /* propagate gradients upstream */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		tmp = delta * link_ptr->weight;
+		link_ptr->to->newdelta += tmp;	/* accumulate delta */
+		/* accumulate weight gradient */
+		link_ptr->value_c += link_ptr->to->actbuf[nextlayer] * delta;
+	    }
+
+	    /* accumulate bias gradient */
+	    unit_ptr->value_c += delta;
+	}
+
+    /* copy newdeltas to olddeltas, clear newdeltas */
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* input units */
+	unit_ptr->olddelta = unit_ptr->newdelta;
+	unit_ptr->newdelta = 0.0;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* hidden units */
+	unit_ptr->olddelta = unit_ptr->newdelta;
+	unit_ptr->newdelta = 0.0;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* output units */
+	unit_ptr->olddelta = unit_ptr->newdelta;
+	unit_ptr->newdelta = 0.0;
+    }
+
+    return (sum_error);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : BPTTadapt 
+
+  PURPOSE  : adapt all weights after BPTT using steepest descent with momentum
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static void BPTTadapt(float step_size, float bptt_momentum)
+{
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register TopoPtrArray topo_ptr;
+    int             done_hidden = 0;
+    float           delta;
+
+    /* point to seperator after last input unit */
+    topo_ptr = topo_ptr_array + (NoOfInputUnits + 1);
+
+    /* for each non-input unit: add weight changes to old weights */
+    while (((unit_ptr = *++topo_ptr) != NULL) || (done_hidden == 0)) {
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	} else {
+	    delta = step_size * (-unit_ptr->value_c) + 
+		bptt_momentum * unit_ptr->value_a;
+	    if (!IS_SPECIAL_UNIT(unit_ptr))
+		unit_ptr->bias += delta;
+	    unit_ptr->value_a = delta;
+	    unit_ptr->value_c = 0.0;
+	    /* set act to last activity, since it was scrambled by bptt */
+	    unit_ptr->act = unit_ptr->Out.output;
+	    FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		delta = step_size * (-link_ptr->value_c) + 
+		    bptt_momentum * link_ptr->value_a;
+		link_ptr->value_a = delta;
+		link_ptr->value_c = 0.0;
+	    }
+	    if (!IS_SPECIAL_UNIT(unit_ptr))
+		FOR_ALL_LINKS(unit_ptr, link_ptr) {
+		    link_ptr->weight += link_ptr->value_a;
+		}
+	}
+    }
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : BPTT_propagateNetBackward
+
+  PURPOSE  : BPTT-main: accumulate weight changes backward thru time
+  RETURNS  : network error
+  NOTES    :
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+static float BPTT_propagateNetBackward(int pattern_no, int sub_pat_no,int nhist)
+{
+    float           error = 0.0;
+    float           dummy;
+    int             backstep;
+
+    /* go nhist steps back thru time */
+    for (backstep = 0; backstep < nhist; backstep++)
+	if (backstep == 0) {
+	    /* start at output, pattern-error is calculated first */
+	    error = oneStepBackprop(backstep, pattern_no, sub_pat_no, nhist);
+	} else {
+	    dummy = oneStepBackprop(backstep, pattern_no, sub_pat_no, nhist);
+	}
+    return (error);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_BPTT
+
+  PURPOSE  : Backpropagation through time learning function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : step_size
+                                 2 : momentum
+				 3 : nhist
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_BPTT(int start_pattern, int end_pattern, 
+		    float *parameterInArray, int NoOfInParams, 
+		    float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no, patterns;
+    int             nhist;	/* number of steps back in time */
+    register struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);        /* No Units defined	 */
+    if (NoOfInParams < 1)	        /* has to be ... snns habit ? */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by ''topologic type'', criterion is visibility
+	   (input,hidden,output), not topology */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	/* sites are not supported, check absence */
+	FOR_ALL_UNITS(unit_ptr)
+	    if UNIT_HAS_SITES
+	    (unit_ptr)
+		return (KRERR_SITES_NO_SUPPORT);
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, clear weight
+						   changes */
+	ret_code = BPTT_clear_deltaw();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    NoOfLearnedPatterns = 0;	/* correct bits using threshold of 0.5 */
+    nhist = LEARN_PARAM3(parameterInArray);
+    if (nhist > MAX_BPTT_BACKSTEP)
+	return (KRERR_NET_DEPTH);	/* actbuf and learning functions
+					   support only MAX_BPTT_BACKSTEP net
+					   copies */
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    patterns = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	/* FORWARD-BPTT */
+	/* 1st parameter is the pattern number 2nd parameter is the number of
+	   steps back in time */
+	BPTT_propagateNetForward(pattern_no,sub_pat_no,nhist); /*Forward pass */
+
+	/* Backward propagation  */
+	NET_ERROR(OutParameter) 
+	    += BPTT_propagateNetBackward(pattern_no, sub_pat_no, nhist);
+
+	/* online version: adapt net after each pattern has been
+	   backpropagated through time and weight changes have accumulated
+	   through time */
+	BPTTadapt(LEARN_PARAM1(parameterInArray), 
+		  LEARN_PARAM2(parameterInArray));
+
+	patterns++;
+    }
+    return (ret_code);
+}
+
+
+/*****************************************************************************
+  FUNCTION : TEST_BPTT
+
+  PURPOSE  : Backpropagation through time validation function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : step_size
+                                 2 : momentum
+				 3 : nhist
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+ AUTHOR    : 02.06.1995, Martin Reczko
+******************************************************************************/
+krui_err TEST_BPTT(int start_pattern, int end_pattern, 
+		    float *parameterInArray, int NoOfInParams, 
+		    float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no, patterns;
+    int             nhist;	/* number of steps back in time */
+    register struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);        /* No Units defined	 */
+    if (NoOfInParams < 1)	        /* has to be ... snns habit ? */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by ''topologic type'', criterion is visibility
+	   (input,hidden,output), not topology */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	/* sites are not supported, check absence */
+	FOR_ALL_UNITS(unit_ptr)
+	    if UNIT_HAS_SITES
+	    (unit_ptr)
+		return (KRERR_SITES_NO_SUPPORT);
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, clear weight
+						   changes */
+	ret_code = BPTT_clear_deltaw();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    NoOfLearnedPatterns = 0;	/* correct bits using threshold of 0.5 */
+    nhist = 1;
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern); 
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    patterns = 0;
+
+    while (kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)) {
+
+	/* FORWARD-BPTT */
+	/* 1st parameter is the pattern number 2nd parameter is the number of
+	   steps back in time */
+	BPTT_propagateNetForward(pattern_no,sub_pat_no,nhist); /*Forward pass*/
+    
+	/* Backward propagation  */
+	NET_ERROR(OutParameter) 
+	    += BPTT_propagateNetBackward(pattern_no, sub_pat_no, nhist);
+  
+    }
+printf("%d bits correct\n",    NoOfLearnedPatterns);fflush(stdout); 
+    return (ret_code);
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_BBPTT
+
+  PURPOSE  : Batch backpropagation through time learning function (BBPTT)
+  RETURNS  : 
+  NOTES    : Input Parameters:   1 : step_size
+                                 2 : momentum
+				 3 : nhist
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err LEARN_BBPTT(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no, patterns;
+    int             nhist;	/* number of steps back in time */
+    register struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);        /* No Units defined	 */
+    if (NoOfInParams < 1)     	        /* has to be ... snns habit ? */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by ''topologic type'', criterion is visibility
+	   (input,hidden,output), not topology */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	/* sites are not supported, check absence */
+	FOR_ALL_UNITS(unit_ptr)
+	    if UNIT_HAS_SITES
+	    (unit_ptr)
+		return (KRERR_SITES_NO_SUPPORT);
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, clear weight
+						   changes */
+	ret_code = BPTT_clear_deltaw();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    NoOfLearnedPatterns = 0;	/* correct bits using threshold of 0.5 */
+    nhist = LEARN_PARAM3(parameterInArray);
+    if (nhist > MAX_BPTT_BACKSTEP)
+	return (KRERR_NET_DEPTH);	/* actbuf and learning functions
+					   support only MAX_BPTT_BACKSTEP net
+					   copies */
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    patterns = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	/* FORWARD-BPTT */
+	/* 1st parameter is the pattern number 2nd parameter is the number of
+	   steps back in time */
+	BPTT_propagateNetForward(pattern_no,sub_pat_no,nhist); /*Forward pass */
+
+	/* Backward propagation  */
+	NET_ERROR(OutParameter) 
+	    += BPTT_propagateNetBackward(pattern_no, sub_pat_no, nhist);
+	patterns++;
+    }
+
+    /* batch version */
+    BPTTadapt(LEARN_PARAM1(parameterInArray) / patterns, 
+	      LEARN_PARAM2(parameterInArray));
+
+    return (ret_code);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_QPTT
+
+  PURPOSE  : Quickprop through time learning function
+  RETURNS  : kernel error code
+  NOTES    : Input Parameters:   1 : step_size
+                                 2 : maximum step growth
+				 3 : decay factor
+				 4 : nhist
+             Output Parameters:  1 : error of the network (sum of all cycles)
+
+  UPDATE   : 06.11.1993 by Guenter Mamier
+******************************************************************************/
+krui_err  LEARN_QPTT(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no, patterns;
+    int             nhist;	/* number of steps back in time */
+    register struct Unit *unit_ptr;
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);/* No Units defined	 */
+    if (NoOfInParams < 1)	/* snns habit ? */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				   learning error)  */
+    *parameterOutArray = OutParameter;	/* set the output parameter reference */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by ''topologic type'', criterion is visibility
+	   (input,hidden,output), not topology */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	/* sites are not supported, check absence */
+	FOR_ALL_UNITS(unit_ptr)
+	    if UNIT_HAS_SITES
+	    (unit_ptr)
+		return (KRERR_SITES_NO_SUPPORT);
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, clear weight
+						   changes */
+	ret_code = BPTT_clear_deltaw();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+
+    NoOfLearnedPatterns = 0;	/* correct bits using threshold of 0.5 */
+    nhist = LEARN_PARAM4(parameterInArray);
+    if (nhist > MAX_BPTT_BACKSTEP)
+	return (KRERR_NET_DEPTH);	/* actbuf and learning functions
+					   support only MAX_BPTT_BACKSTEP net
+					   copies */
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    patterns = 0;
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	/* FORWARD-BPTT */
+	/* 1st parameter is the pattern number 2nd parameter is the number of
+	   steps back in time */
+	BPTT_propagateNetForward(pattern_no,sub_pat_no,nhist); /*Forward pass */
+
+	/* Backward propagation  */
+	NET_ERROR(OutParameter)
+	    += BPTT_propagateNetBackward(pattern_no, sub_pat_no, nhist);
+
+	patterns++;
+    }
+    MODI_quickprop(LEARN_PARAM1(parameterInArray) / patterns,
+		   LEARN_PARAM2(parameterInArray),
+		   LEARN_PARAM3(parameterInArray));
+
+    return (ret_code);
+}
+
+
+/*****************************************************************************
+
+  GROUP        : kohonen_learning
+
+  PURPOSE      : learning algorithm for Kohonen Feature Map
+  AUTHOR       : Marc Seemann
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : propagateNet_kohonen
+
+  PURPOSE  : Propagate and train a pattern
+  NOTES    :
+  UPDATE   : 07.02 1994 by Sven Doering
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+static float propagateNet_kohonen(int pattern_no, int sub_pat_no, float height,
+				  float radius, int sizehor)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    register struct Unit *winner_ptr;
+    register Patterns in_pat;
+    register int    NoOfCompounds, sizever, verwin, horwin, hor, ver, helpver,
+    helphor, range;
+    float           maximum, sum_error, deviat, learn_error, sum;
+    float           unit_ptr_net;
+    register TopoPtrArray topo_ptr;
+    float           adapt;
+    int             winner, current_no;
+
+
+    /* calculate the activation and the output values         */
+    /* of the input units (Input Layer)                       */
+
+    NoOfCompounds = NoOfInputUnits;
+    sizever = NoOfHiddenUnits / sizehor;
+
+    sum = 0.0;
+
+    /* calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+    topo_ptr = topo_ptr_array;
+
+    /* copy pattern into input unit's activation and calculate output of the
+       input units */
+    while ((unit_ptr = *++topo_ptr) != NULL) { /* topo_ptr points to the
+						  unit stuctures (sorted by:
+						  input-, hidden- and
+						  output-units, separated
+						  with NULL pointers) */
+	sum += *in_pat * *in_pat;
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /* identity output function: there is no need to call the output
+	       function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /* no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = 
+		(*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    if (sum != 0.0)
+	/* normalize the inputvector */
+	normalize_inputvector(sum);
+
+    /* propagate Kohonen Layer  */
+
+    /* calculate the activation and the output values */
+    /* of the cmpetitive units (hidden layer) */
+
+    /* winner is determined using the dot product */
+
+
+    winner_ptr = NULL;
+    maximum = -1.0e30;		/* contains the maximum of the activations */
+    current_no = 0;
+
+    /* propagate hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL) {	/* topo_ptr points to a
+						   (topological sorted) unit
+						   stucture */
+	unit_ptr_net = 0.0;
+	if (UNIT_HAS_DIRECT_INPUTS(unit_ptr)) {	/* the unit has direct links */
+	    FOR_ALL_LINKS(unit_ptr, link_ptr)
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	} else {		/* the unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	}
+
+	if (maximum < unit_ptr_net) {	/* determine winner unit  */
+	    winner_ptr = unit_ptr;
+	    maximum = unit_ptr_net;
+	    winner = current_no;
+	}
+	current_no++;
+	/* reset output and activation of hidden units  */
+	unit_ptr->Out.output = unit_ptr->act = (FlintType) 0;
+    }
+
+    /* the competitive winner is chosen */
+
+    winner_ptr->Out.output = winner_ptr->act = (FlintType) 1;
+    winner_ptr->bias++;
+    winner_ptr->value_a = (FlintType) (pattern_no + 1);
+
+    /* store number of according pattern in winner unit */
+
+    horwin = winner % sizehor;
+    verwin = winner / sizehor;
+
+
+    /***************************************************************/
+    /* Train  the  SOM                                             */
+
+    /* Only the weights of links that go to the winner and its     */
+    /* neighbourhood are adjusted, the others remain the same.     */
+    /* The incoming weights to the competitive units are adapted   */
+    /* as follows:                                                 */
+
+    /* weight(new) = weight(old) + adapt * (output - weight(old))  */
+
+    /* where adapt is the learning rate (0 < adapt <= 1.0)         */
+    /* and output is the value of the input unit vector            */
+
+    /***************************************************************/
+
+
+    for (ver = 0; ver < sizever; ver++)
+	for (hor = 0; hor < sizehor; hor++)
+	    if ((hor < radius + horwin) &&
+		(hor > horwin - radius) &&
+		(ver < radius + verwin) &&
+		(ver > verwin - radius)) {
+		helpver = (float) ((ver - verwin) * (ver - verwin));
+		helphor = (float) ((hor - horwin) * (hor - horwin));
+		adapt = height * exp(-(helpver + helphor) / 
+				     (float) (radius * radius));
+
+		sum = 0.0;
+		range = ver * sizehor + hor + 1 + NoOfCompounds;
+
+		/* get unit pointer of unit in adaptation range */
+		unit_ptr = kr_getUnitPtr(range);
+		
+		if(!IS_SPECIAL_UNIT(unit_ptr)){
+		    if (unit_ptr->flags & UFLAG_DLINKS) { /* the unit has  */
+							  /* direct links  */
+			FOR_ALL_LINKS(unit_ptr, link_ptr) {
+			    deviat=link_ptr->to->Out.output - link_ptr->weight;
+			    learn_error = adapt * deviat;
+			    link_ptr->weight += learn_error;
+			    /* this is needed for the normalization of the
+			       weight_vector */
+			    sum += link_ptr->weight * link_ptr->weight;
+			}
+		    } else {	/* the winner unit has sites  */
+			FOR_ALL_SITES_AND_LINKS(winner_ptr,site_ptr,link_ptr) {
+			    deviat=link_ptr->to->Out.output - link_ptr->weight;
+			    learn_error = adapt * deviat;
+			    link_ptr->weight += learn_error;
+			    /* this is needed for the normalization of the
+			       weight_vector */
+			    sum += link_ptr->weight * link_ptr->weight;
+			}
+		    }
+		    if (sum != 0.0)
+			normalize_weight(unit_ptr, sum);
+		}
+	    }
+    sum_error = 0.0;		/* 0.0 is chosen arbitrarily and serves no
+				   purpose */
+    return (sum_error);
+}
+
+
+/*****************************************************************************
+  FUNCTION : initializeKohonenLearning
+
+  PURPOSE  : initialize the SOM
+  NOTES    :
+  UPDATE   : 19.08.1993
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+static krui_err initializeKohonenLearning(void)
+{
+    register unsigned short flags;
+    register struct Unit *unit_ptr;
+
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE)	/* unit is in use  */
+	    unit_ptr->value_a = unit_ptr->bias = (FlintType) 0.0;
+    }
+    return (KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_kohonen
+
+  PURPOSE  :  incorporates the body of the kohonen learning algorithm
+  NOTES    :  the parameterInArray must contain 4 parameter
+                      1) initial adaptation height
+                      2) initial adaptation radius
+       	              3) multiplication factor for height
+                      4) multiplication factor for radius
+           	      5) horizontal size of the competitive (hidden) layer
+
+  UPDATE   : july 15 1994
+******************************************************************************/
+krui_err LEARN_kohonen(int start_pattern, int end_pattern,
+		       float parameterInArray[], int NoOfInParams,
+		       float **parameterOutArray, int *NoOfOutParams)
+{
+    static float    OutParameter[1];	/* OutParameter[0] stores the
+					   learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);/* No Units defined    */
+    if (NoOfInParams < 5)	/* see Note  */
+	return (KRERR_PARAMETERS);	/* Not enough input parameters  */
+
+    *NoOfOutParams = 1;		/* one return value is available (the
+				   learning error) */
+    *parameterOutArray = OutParameter;	/* set output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* clear return code  */
+
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code == KRERR_NO_OUTPUT_UNITS)
+	    ret_code = KRERR_NO_ERROR;
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+	if (ret_code == KRERR_NO_OUTPUT_UNITS)
+	    ret_code = KRERR_NO_ERROR;
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   kohonen now  */
+	ret_code = initializeKohonenLearning();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    if ((int) LEARN_PARAM5(parameterInArray) == 0) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+    if ((LEARN_PARAM3(parameterInArray) > 1.0) ||
+	(LEARN_PARAM3(parameterInArray) < 0.0)) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+    if ((LEARN_PARAM4(parameterInArray) > 1.0) ||
+	(LEARN_PARAM4(parameterInArray) < 0.0)) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    NET_ERROR(OutParameter) = 0.0;	/* reset network error value  */
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	NoOfLearnedPatterns++;
+	NET_ERROR(OutParameter) +=
+	    propagateNet_kohonen(pattern_no,sub_pat_no,
+				 LEARN_PARAM1(parameterInArray),
+				 LEARN_PARAM2(parameterInArray),
+				 (int) LEARN_PARAM5(parameterInArray));
+
+	LEARN_PARAM1(parameterInArray) *= LEARN_PARAM3(parameterInArray);
+	LEARN_PARAM2(parameterInArray) *= LEARN_PARAM4(parameterInArray);
+
+    }
+    return (ret_code);
+}
+
+
+/*****************************************************************************
+  FUNCTION : spanning_tree
+
+  PURPOSE  : calculate the spanning tree of the kohonen feature map
+  NOTES    : evaluating the learn function doesn't affect the net itself
+
+  UPDATE   : july 13 1993
+******************************************************************************/
+krui_err  spanning_tree(void)
+{
+    register TopoPtrArray topo_ptr;
+    register struct Unit *unit_ptr;
+    int             ret_code, n, pattern_no, sub_pat_no;
+
+
+    if (NoOfUnits == 0)
+	return (KRERR_NO_UNITS);/* No Units defined    */
+
+    ret_code = KRERR_NO_ERROR;	/* clear return code  */
+
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)) {	
+	/* Net has been modified or topologic array isn't initialized */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code == KRERR_NO_OUTPUT_UNITS)
+	    ret_code = KRERR_NO_ERROR;
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+	if (ret_code == KRERR_NO_OUTPUT_UNITS)
+	    ret_code = KRERR_NO_ERROR;
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified or
+						   initialized, initialize
+						   kohonen now  */
+	ret_code = initializeKohonenLearning();
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+    }
+    topo_ptr = topo_ptr_array;
+
+    while ((unit_ptr = *++topo_ptr) != NULL);
+    /* topo_ptr points to the units' stucture (sorted by: input-, hidden- and
+       output-units, separated by NULL pointers) */
+
+    while ((unit_ptr = *++topo_ptr) != NULL)
+	/* topo_ptr points to hidden_units */
+	unit_ptr->value_a = 0;	/* the unit next to a pattern stores the
+				   number of that pattern in value_a, at the
+				   beginning initialized to 0 */
+
+
+    n = 0;
+    while(kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n++)){
+
+	/* To calculate the winning unit we call the  propagateNet_kohonen
+	   function, and treat the map as 1-dimensional array */
+	propagateNet_kohonen(pattern_no, sub_pat_no, 0.0, 0.0, 1);
+    }
+
+    return (ret_code);
+
+}/* spanning_tree */
+
+
+
+
+/*****************************************************************************
+
+  GROUP        : JORDAN / ELMAN networks 
+
+  PURPOSE      : learning functions for JORDAN / ELMAN networks
+  AUTHOR       : Tobias Soyez
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : update_je_context_units
+
+  PURPOSE  : synchronous update of context units
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void update_je_context_units (int pattern_no, int sub_pat_no,
+				     float use_real_value_percent) 
+
+{
+    register TopoPtrArray   topo_ptr, topo_ptr_context ;
+    register struct Unit   *unit_ptr ;
+    register Patterns       out_pat  ;
+    int size;
+
+
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+    
+    topo_ptr_context = topo_ptr_array + (no_of_topo_units + 3) ;
+
+
+    /* ----  store real output ---- */
+ 
+    if (use_real_value_percent > 1.0)
+	use_real_value_percent = 1.0;
+    else
+	if (use_real_value_percent < 0.0)
+	    use_real_value_percent = 0.0;
+
+    topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *--topo_ptr) != NULL)
+    {
+      unit_ptr->actbuf[0]  = unit_ptr->Out.output ;
+      unit_ptr->Out.output = (1.0 - use_real_value_percent) * *--out_pat +
+	                     use_real_value_percent * unit_ptr->Out.output;
+    }
+    
+
+    /* ----  calculate new activation of context units ---- */
+
+   topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *++topo_ptr) != NULL)
+    {
+      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+
+      if (unit_ptr->out_func == OUT_IDENTITY)
+        unit_ptr->Out.output = unit_ptr->act ;
+      else
+        unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+    /* ----  restore real output  ---- */
+
+    topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *--topo_ptr) != NULL)
+    {
+      unit_ptr->Out.output = unit_ptr->actbuf[0] ;
+    }
+}
+
+
+/*****************************************************************************
+  FUNCTION : reset_je_context_units
+
+  PURPOSE  : resets the context units 
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void reset_je_context_units (void)
+
+{
+  register TopoPtrArray   topo_ptr ;
+  register struct Unit   *unit_ptr ;
+
+ 
+  topo_ptr = topo_ptr_array + (no_of_topo_units + 3) ;
+  
+  while ((unit_ptr = *++topo_ptr) != NULL)
+  {
+    unit_ptr->act = unit_ptr->i_act ;
+
+    if (unit_ptr->out_func == OUT_IDENTITY)
+      unit_ptr->Out.output = unit_ptr->act ;
+    else
+      unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+  }
+}
+
+
+/*****************************************************************************
+  FUNCTION : check_je_network
+
+  PURPOSE  : checks the topology of a partial recurrent network
+             (i.e. JORDAN and ELMAN networks)
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+static krui_err check_je_network (void) 
+
+{
+    /*  check the topology of the network  */
+    (void) kr_topoCheckJE () ;
+    if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+
+    /*	count the no. of I/O units and check the patterns  */
+    if (kr_IOCheck() != KRERR_NO_ERROR) return (KernelErrorCode) ;
+
+    /*	sort units by topology and by topologic type  */
+    (void) kr_topoSort (TOPOLOGICAL_JE) ;
+
+    if ((KernelErrorCode != KRERR_NO_ERROR) && 
+        (KernelErrorCode != KRERR_DEAD_UNITS))
+      return (KernelErrorCode) ;
+
+    NetModified = FALSE;
+    return (KRERR_NO_ERROR) ;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_JE_Backprop
+
+  PURPOSE  : backpropagation learning function for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. learning parameter
+                                   2. delta max
+				   3. influence of real output
+				      (= 0 -> only teacher force)
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err  LEARN_JE_Backprop (int     start_pattern    , int  end_pattern ,
+                             float  *parameterInArray , int  NoOfInParams, 
+                             float **parameterOutArray, int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        n, pattern_no,sub_pat_no ;
+  int           start, end;
+
+
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (NoOfInParams < 3) return (KRERR_PARAMETERS) ;
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  reset_je_context_units () ;
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    start = kr_AbsPosOfFirstSubPat(start_pattern);
+    end   = kr_AbsPosOfFirstSubPat(end_pattern);
+    end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+    for(n=start; n<=end; n++){
+
+	kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+	propagateNetForward (pattern_no,sub_pat_no) ;	
+	NET_ERROR (OutParameter) +=
+	    propagateNetBackward2 (pattern_no,sub_pat_no, 
+				   LEARN_PARAM1 (parameterInArray), 
+				   LEARN_PARAM2 (parameterInArray)) ;
+	update_je_context_units (pattern_no,sub_pat_no, 
+				 LEARN_PARAM3(parameterInArray)) ;
+    }
+
+  return (KernelErrorCode) ;
+}
+
+
+/*****************************************************************************
+  FUNCTION : TEST_JE_Backprop
+
+  PURPOSE  : backpropagation learning function for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. learning parameter
+                                   2. delta max
+				   3. influence of real output
+				      (= 0 -> only teacher force)
+				      has no meaning for validation
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err  TEST_JE_Backprop (int     start_pattern    , int  end_pattern ,
+                             float  *parameterInArray , int  NoOfInParams, 
+                             float **parameterOutArray, int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        n, pattern_no,sub_pat_no ;
+  int           start, end;
+
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (NoOfInParams < 3) return (KRERR_PARAMETERS) ;
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  reset_je_context_units () ;
+
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    start = kr_AbsPosOfFirstSubPat(start_pattern);
+    end   = kr_AbsPosOfFirstSubPat(end_pattern);
+    end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+    for(n=start; n<=end; n++){
+
+	kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+	propagateNetForward (pattern_no,sub_pat_no) ;	
+	NET_ERROR (OutParameter) +=
+	    testNetBackward2 (pattern_no,sub_pat_no, 
+				   LEARN_PARAM1 (parameterInArray),
+				   LEARN_PARAM2 (parameterInArray)) ;
+	test_update_je_context_units (pattern_no,sub_pat_no) ; 
+    }
+
+  return (KernelErrorCode) ;
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_JE_BackpropMomentum
+
+  PURPOSE  : test network with momentum term learning funcyion
+             for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   4. delta max
+                                   5. influence of real output
+				      (= 0 -> only teacher force)
+				      has no meaning for validation
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err TEST_JE_BackpropMomentum(int start_pattern, int end_pattern,
+				   float *parameterInArray, int NoOfInParams, 
+				   float **parameterOutArray, 
+				   int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        n, pattern_no,sub_pat_no ;
+  int           start, end;
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (NoOfInParams < 5) return (KRERR_PARAMETERS) ;
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  reset_je_context_units () ;
+
+
+  /* compute the necessary sub patterns */
+
+  KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+      return (KernelErrorCode);
+  
+  start = kr_AbsPosOfFirstSubPat(start_pattern);
+  end   = kr_AbsPosOfFirstSubPat(end_pattern);
+  end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+  for(n=start; n<=end; n++){
+
+      kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+      propagateNetForward (pattern_no,sub_pat_no) ;	
+      NET_ERROR (OutParameter) +=
+	  testNetBackward2  (pattern_no,sub_pat_no,
+				 LEARN_PARAM1( parameterInArray ),
+				 LEARN_PARAM4( parameterInArray )) ;
+      test_update_je_context_units (pattern_no, sub_pat_no) ;
+  }
+
+  return (KernelErrorCode) ;
+}
+
+/*****************************************************************************
+  FUNCTION : test_update_je_context_units           joe
+
+  PURPOSE  : synchronous update of context units
+  NOTES    :
+
+  UPDATE   : 03.03.95
+******************************************************************************/
+
+static void test_update_je_context_units (int pattern_no, int sub_pat_no) 
+
+{
+    register TopoPtrArray   topo_ptr, topo_ptr_context ;
+    register struct Unit   *unit_ptr ;
+    register Patterns       out_pat  ;
+    int size;
+
+
+    out_pat = kr_getSubPatData(pattern_no,sub_pat_no,OUTPUT,&size);
+    out_pat += size;
+    
+    topo_ptr_context = topo_ptr_array + (no_of_topo_units + 3) ;
+
+
+    /* ----  store real output                        ---- */
+ 
+    topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *--topo_ptr) != NULL)
+    {
+      unit_ptr->actbuf[0]  = unit_ptr->Out.output ;
+      unit_ptr->Out.output = *--out_pat ; 
+    }
+    
+
+    /* ----  calculate new activation of context units ---- */
+
+   topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *++topo_ptr) != NULL)
+    {
+      unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+
+      if (unit_ptr->out_func == OUT_IDENTITY)
+        unit_ptr->Out.output = unit_ptr->act ;
+      else
+        unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+    /* ----  restore real output  ---- */
+
+    topo_ptr = topo_ptr_context ;
+
+    while ((unit_ptr = *--topo_ptr) != NULL)
+    {
+      unit_ptr->Out.output = unit_ptr->actbuf[0] ;
+    }
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_JE_BackpropMomentum
+
+  PURPOSE  : backpropagation with momentum term learning funcyion
+             for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. learning parameter
+                                   2. momentum factor
+                                   3. flat spot elimination
+                                   4. delta max
+				   5. influence of real output
+				      (= 0 -> only teacher force)
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err LEARN_JE_BackpropMomentum(int start_pattern, int end_pattern,
+				   float *parameterInArray, int NoOfInParams, 
+				   float **parameterOutArray, 
+				   int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        n, pattern_no,sub_pat_no ;
+  int           start, end;
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (NoOfInParams < 5) return (KRERR_PARAMETERS) ;
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  if (NetInitialize || LearnFuncHasChanged)
+  {  /*  Net has been modified or initialized, initialize backprop now  */
+    KernelErrorCode = initializeBackpropMomentum () ;
+    if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  reset_je_context_units () ;
+
+
+  /* compute the necessary sub patterns */
+
+  KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+      return (KernelErrorCode);
+  
+  start = kr_AbsPosOfFirstSubPat(start_pattern);
+  end   = kr_AbsPosOfFirstSubPat(end_pattern);
+  end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+  for(n=start; n<=end; n++){
+
+      kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+      propagateNetForward (pattern_no,sub_pat_no) ;	
+      NET_ERROR (OutParameter) +=
+	  Backprop_momentum_FSE (pattern_no,sub_pat_no,
+				 LEARN_PARAM1( parameterInArray ),
+				 LEARN_PARAM2( parameterInArray ),
+				 LEARN_PARAM3( parameterInArray ),
+				 LEARN_PARAM4( parameterInArray )) ;
+      update_je_context_units (pattern_no, sub_pat_no,
+			       LEARN_PARAM5(parameterInArray)) ;
+  }
+
+  return (KernelErrorCode) ;
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_JE_Quickprop
+
+  PURPOSE  : quickprop learning function for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. learning parameter
+                                   2. max. growth factor
+                                   3. weight decay
+                                   4. delta max
+				   5. influence of real output
+				      (= 0 -> only teacher force)
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err  LEARN_JE_Quickprop (int     start_pattern    , int  end_pattern ,
+                              float  *parameterInArray , int  NoOfInParams, 
+                              float **parameterOutArray, int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        n,pattern_no,sub_pat_no ;
+  int           start, end;
+
+  KernelErrorCode = KRERR_NO_ERROR;  /*  reset return code  */
+
+  if (NoOfInParams < 5) return (KRERR_PARAMETERS) ;
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  if (NetInitialize || LearnFuncHasChanged)
+  { 
+    /*  Net has been modified or initialized, initialize quickprop now  */
+    KernelErrorCode = initializeQuickprop () ;
+    if (KernelErrorCode != KRERR_NO_ERROR)  return (KernelErrorCode) ;
+  }
+
+
+  reset_je_context_units () ;
+
+
+
+  /* compute the necessary sub patterns */
+
+  KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+    return (KernelErrorCode);
+
+  start = kr_AbsPosOfFirstSubPat(start_pattern);
+  end   = kr_AbsPosOfFirstSubPat(end_pattern);
+  end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+  for(n=start; n<=end; n++){
+
+      kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+      propagateNetForward (pattern_no,sub_pat_no) ;	
+      NET_ERROR(OutParameter) +=
+	  propagateNetBackwardQuickprop (pattern_no,sub_pat_no,
+					 LEARN_PARAM4 (parameterInArray)) ;
+      update_je_context_units (pattern_no,sub_pat_no,
+			       LEARN_PARAM5(parameterInArray)) ;
+  }
+
+  MODI_quickprop (LEARN_PARAM1 (parameterInArray),
+                  LEARN_PARAM2 (parameterInArray),
+                  LEARN_PARAM3 (parameterInArray)) ;
+
+  return (KernelErrorCode) ;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_JE_Rprop
+
+  PURPOSE  : rprop learning function for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. delta 0
+                                   2. delta max
+				   3. ????????
+				   4. influence of real output
+				      (= 0 -> only teacher force)
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   :
+******************************************************************************/
+krui_err  LEARN_JE_Rprop    (int     start_pattern    , int  end_pattern ,
+                             float  *parameterInArray , int  NoOfInParams, 
+                             float **parameterOutArray, int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        pattern_no,sub_pat_no ;
+  int           n, ret_code, blocksize ;
+  float         maxeps, wd, update_value ;
+  int           start, end;
+
+
+  if (NoOfInParams < 4) return (KRERR_PARAMETERS) ;
+
+  if (( update_value = LEARN_PARAM1 (parameterInArray)) == 0.0) 
+    update_value = RPROP_DEFAULT_UPDATE_VALUE;
+  if ((maxeps = LEARN_PARAM2 (parameterInArray)) == 0.0) 
+    maxeps = RPROP_MAXEPS;
+  if (!(( wd = LEARN_PARAM3( parameterInArray )) == 0.0))
+      wd = (float) pow(10,(double)(- wd));
+  if (update_value > maxeps) update_value = maxeps;
+
+
+  KernelErrorCode = ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  if (NetInitialize || LearnFuncHasChanged)
+  {  /*  Net has been modified or initialized, initialize RPROP */
+    ret_code = initializeRprop (update_value) ;
+    if (ret_code != KRERR_NO_ERROR)  return (ret_code) ;
+  }
+
+  /* DEFAULTS: */
+  if ((blocksize = LEARN_PARAM3 (parameterInArray)) == 0)
+    blocksize = end_pattern;
+
+  reset_je_context_units () ;
+
+
+  /* compute the necessary sub patterns */
+
+  KernelErrorCode = kr_initSubPatternOrder(start_pattern,blocksize);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+      return (KernelErrorCode);
+
+  start = kr_AbsPosOfFirstSubPat(start_pattern);
+  end   = kr_AbsPosOfFirstSubPat(end_pattern);
+  end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+  for(n=start; n<=end; n++){
+
+      kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+      propagateNetForward (pattern_no,sub_pat_no) ;	
+      NET_ERROR (OutParameter) +=
+	  propagateNetBackwardRprop (pattern_no,sub_pat_no) ;
+      update_je_context_units (pattern_no,sub_pat_no,
+			       LEARN_PARAM4(parameterInArray)) ;
+  }
+  MODI_rprop (maxeps,wd) ;
+  return (KernelErrorCode) ;
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_JE_Rprop
+
+  PURPOSE  : rprop testing function for JORDAN / ELMAN networks
+  NOTES    : input parameters  :   1. delta 0
+                                   2. delta max
+				   3. ??????????
+				   4. influence of real output
+				      (= 0 -> only teacher force)
+				      has no meaning for validation
+             output parameters :   1. error of the network (sum of all cycles)
+             return value      :   kernel error code
+  UPDATE   : 03.03.95 Joachim Danz
+******************************************************************************/
+krui_err  TEST_JE_Rprop    (int     start_pattern    , int  end_pattern ,
+			    float  *parameterInArray , int  NoOfInParams, 
+			    float **parameterOutArray, int *NoOfOutParams)
+
+{
+  static float  OutParameter[1] ; /* OutParameter[0] stores the */
+                                  /* learning error             */
+  int	        pattern_no,sub_pat_no ;
+  int           n, ret_code, blocksize ;
+  int           start, end;
+
+
+  if (NoOfInParams < 4) return (KRERR_PARAMETERS) ;
+
+  KernelErrorCode = ret_code = KRERR_NO_ERROR;  /*  reset return code  */
+
+
+  *NoOfOutParams     = 1            ; /* one return value is available      */
+                                      /* (the learning error)               */
+  *parameterOutArray = OutParameter ; /* set the output parameter reference */ 
+  NET_ERROR (OutParameter) = 0.0    ; /* reset network error value          */
+
+
+  /* DEFAULTS: */
+  if ((blocksize = LEARN_PARAM3 (parameterInArray)) == 0)
+    blocksize = end_pattern;
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_JE))
+  {
+     KernelErrorCode = check_je_network () ;
+     if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode) ;
+  }
+
+  reset_je_context_units () ;
+
+
+  /* compute the necessary sub patterns */
+
+  KernelErrorCode = kr_initSubPatternOrder(start_pattern,blocksize);
+  if(KernelErrorCode != KRERR_NO_ERROR)
+      return (KernelErrorCode);
+
+  start = kr_AbsPosOfFirstSubPat(start_pattern);
+  end   = kr_AbsPosOfFirstSubPat(end_pattern);
+  end  += kr_NoOfSubPatPairs(end_pattern) - 1;
+
+  for(n=start; n<=end; n++){
+
+      kr_getSubPatternByNo(&pattern_no,&sub_pat_no,n);
+
+      propagateNetForward (pattern_no,sub_pat_no) ;	
+      NET_ERROR (OutParameter) +=
+	  testNetBackwardRprop (pattern_no,sub_pat_no) ;
+      test_update_je_context_units (pattern_no,sub_pat_no) ;
+  }
+  return (KernelErrorCode) ;
+}
+
+
+
+/*****************************************************************************
+
+  GROUP        : Functions for autoassoziative memory networks
+
+  PURPOSE      : Implement autoassoziative memory networks, including learning 
+                 functions for Rummelhart & McClelland's Delta Rule and Hebbian
+		 learning
+  AUTHOR       : Jamie DeCoster
+
+******************************************************************************/
+
+/*****************************************************************************
+  FUNCTION : RM_propagate
+
+  PURPOSE  : forward propagation for Rummelhart & McClelland's Delta Rule
+  NOTES    : 
+
+  UPDATE   : 17.02.1994
+******************************************************************************/
+static void RM_propagate (int pattern_no, int sub_pat_no, float prop_step)
+{
+
+    int t;
+    register struct Unit   *unit_ptr;
+    register Patterns      in_pat;
+    register TopoPtrArray  topo_ptr;
+
+
+    /*  calculate startaddress for input pattern array  */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+    if(in_pat == NULL){
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return;
+    }
+    
+    topo_ptr = topo_ptr_array;
+
+    /*  copy pattern into input unit's activation and calculate output of the 
+	input units */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+
+	/*  topo_ptr points to a (topological sorted) unit stucture  */
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = 
+		(*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+    }
+
+    for (t=0; t < prop_step; ++t){ 
+
+	FOR_ALL_UNITS( unit_ptr )
+	    if UNIT_IN_USE( unit_ptr ){
+
+		/* update unit activations first  */
+		if ( !IS_INPUT_UNIT( unit_ptr)) 
+		    /*  unit isn't an input unit and is in use and enabled  */
+		    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+		/* update unit outputs  */
+		if (unit_ptr->out_func == OUT_IDENTITY)
+		    /*  identity output function: don't call output function  */
+		    unit_ptr->Out.output = unit_ptr->act;
+		else
+		    /*  calculate unit's output also  */
+		    unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+    }
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : RM_learn
+
+  PURPOSE  : backward propagation for Rummelhart & McClelland's Delta Rule
+  NOTES    : 
+
+  UPDATE   : 11.02.1994
+******************************************************************************/
+static void RM_learn(float learn_parameter)
+{
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register struct Unit *unit_ptr;
+    float ex_in, in_in, error, eta;
+
+    eta = learn_parameter;
+
+    FOR_ALL_UNITS (unit_ptr)
+	if (!IS_INPUT_UNIT (unit_ptr)){
+	    /* World units don't learn so their inputs are not examined */
+
+	    in_in = 0;
+
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+		if (IS_INPUT_UNIT (link_ptr->to))
+		    /* Determine the input from the world unit */
+		    ex_in = link_ptr->to->act * link_ptr->weight;
+		else
+		    /* Determine the input from the network */
+		    in_in += link_ptr->to->act * link_ptr->weight; 
+
+	    /* Error defined as the difference between the world input and 
+	       the input from the net */ 
+	    error = ex_in - in_in; 
+ 
+	    /* Modify the weights */ 
+	    if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)){
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_INPUT_UNIT (link_ptr->to))  
+			/* The link between a world unit and its corresponding 
+			   learning unit is always 1 */
+			link_ptr->weight += link_ptr->to->act * eta * error;
+	    }else{
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_INPUT_UNIT (link_ptr->to))
+			link_ptr->weight += link_ptr->to->act * eta * error;
+	    }
+	}
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_RM_delta 
+
+  PURPOSE  : McClelland & Rumelhart's learning rule
+                      Input parameter:   1: learning parameter
+		                         2: no. of propagation steps
+		      Output parameter:  1:  Learning error
+  NOTES    : 
+
+  UPDATE   : 11.02.1994
+******************************************************************************/
+krui_err LEARN_RM_delta (int start_pattern, int end_pattern,
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams)
+{
+
+    static float OutParameter [1];
+    int pattern_no,sub_pat_no;
+    float Learn_p;
+    float prop_step;
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    /* Checking for learning parameter */
+    if (NoOfInParams < 2){  
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    Learn_p = LEARN_PARAM1 (parameterInArray);
+    prop_step = LEARN_PARAM2 (parameterInArray);
+    if (prop_step == 0){  
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    *NoOfOutParams = 1; /* Out Parameter = Learning error */
+    *parameterOutArray = OutParameter;
+
+    (void) kr_topoSort (TOPOLOGIC_TYPE);
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+
+    /* reset network error value  */
+    NET_ERROR (OutParameter) = 0.0;
+
+    /* Determine order of pattern presentation */
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+
+	/* Propagate the pattern through the network */
+	RM_propagate (pattern_no,sub_pat_no,prop_step);        
+
+	/* Update links */ 
+	RM_learn (Learn_p);
+
+	/* Compute network error */ 
+	NET_ERROR (OutParameter) += Hebb_error(prop_step); 
+    }
+
+    return (KernelErrorCode);
+} 
+
+
+/*****************************************************************************
+  FUNCTION : Hebb_error
+
+  PURPOSE  : Compute the error of the network for the Hebbian learning rule
+  NOTES    : 
+
+  UPDATE   : 09.03.1994
+******************************************************************************/
+static float Hebb_error(int NoOfTimes)
+{
+
+    struct Unit *unit_ptr;
+    struct Link *link_ptr;
+    float error, sum_error, ex_in;
+    int t;
+
+
+    /* update unit activations first  */
+    for(t=0; t < NoOfTimes; ++t){ 
+	FOR_ALL_UNITS( unit_ptr )
+	    if ( !IS_INPUT_UNIT( unit_ptr)) 
+		if UNIT_IN_USE( unit_ptr )
+		    /*  unit isn't an input unit and is in use and enabled  */
+		    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	/* update unit outputs */
+	FOR_ALL_UNITS( unit_ptr )
+	    if UNIT_IN_USE( unit_ptr )
+		if (unit_ptr->out_func == OUT_IDENTITY)
+		    /* there is no need to call the output function  */
+		    unit_ptr->Out.output = unit_ptr->act;
+		else
+		    /* calculate unit's output also  */
+		    unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+    }
+
+
+    /* calculate the error defined as the difference between the internal
+       and external inputs */
+
+    sum_error = 0.0;
+
+    FOR_ALL_UNITS (unit_ptr){
+	FOR_ALL_LINKS (unit_ptr, link_ptr)
+	    if (IS_INPUT_UNIT (link_ptr->to)){
+		ex_in = link_ptr->to->act;
+		error = ex_in - unit_ptr->act;
+		sum_error += error * error;
+	    }
+    }
+    return (sum_error);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_Hebb 
+
+  PURPOSE  : Hebbian learning rule
+                      Input parameter:   1: learning parameter
+		                         2: Maximum absolute weight strength
+		      Output parameter:  1: Network error
+  NOTES    : 
+
+  UPDATE   : 09.03.1994
+******************************************************************************/
+krui_err LEARN_HEBB (int start_pattern, int end_pattern,
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams)
+{
+    static float OutParameter [1];
+    int pattern_no, sub_pat_no;
+    int NoOfTimes;
+    float Learn_p, Weight_MAX;
+    register struct Unit *unit_ptr;
+    register struct Link *link_ptr;
+    register struct Site *site_ptr;
+    register Patterns in_pat;
+    register TopoPtrArray topo_ptr;
+
+
+    KernelErrorCode = KRERR_NO_ERROR;
+
+    if (NoOfInParams < 3){  /* Checking for learning parameter */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+
+    *NoOfOutParams = 1;  /* Out Parameter = Learning error */
+    *parameterOutArray = OutParameter;
+
+    Learn_p    = LEARN_PARAM1 (parameterInArray);
+    Weight_MAX = LEARN_PARAM2 (parameterInArray);
+    NoOfTimes  = (int)LEARN_PARAM3 (parameterInArray);
+
+    if (NoOfTimes == 0){  /* Checking for learning parameter */
+	KernelErrorCode = KRERR_PARAMETERS;
+	return (KernelErrorCode);
+    }
+    
+    kr_topoSort (TOPOLOGIC_TYPE);
+
+    /* compute the necessary sub patterns */
+
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+        return (KernelErrorCode);
+
+
+    /* reset network error value  */
+    NET_ERROR (OutParameter) = 0.0;
+
+    /* Determine order of pattern presentation */
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+  
+	/* calculate startaddress for input pattern array */
+    in_pat = kr_getSubPatData(pattern_no,sub_pat_no,INPUT,NULL);
+
+	topo_ptr = topo_ptr_array;
+
+	/* copy pattern into input units  and calculate their output */
+	while ((unit_ptr = *++topo_ptr) != NULL){
+	    /* topo_ptr points to a unit structure (input units first) */
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		/* identity output function */
+		unit_ptr->Out.output = unit_ptr->act = *in_pat++;
+	    else
+		/* calculate unit's output */
+		unit_ptr->Out.output = 
+		    (*unit_ptr->out_func) (unit_ptr->act = *in_pat++);
+	}
+
+	/* copy pattern from the world units to the learning units */
+	FOR_ALL_UNITS (unit_ptr)
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+		if (IS_INPUT_UNIT (link_ptr->to))
+		    unit_ptr->act = link_ptr->to->act;
+
+	/* Network has the same structure as the RM_delta autoassociative 
+	   network. Here we update the learning unit links. */
+	FOR_ALL_UNITS (unit_ptr)
+	    if (!IS_INPUT_UNIT (unit_ptr)){
+
+		/* Update the links */
+		if (UNIT_HAS_DIRECT_INPUTS (unit_ptr)){
+		    FOR_ALL_LINKS (unit_ptr, link_ptr)
+			if (!IS_INPUT_UNIT (link_ptr->to)){
+			    /* Only change learning links */
+			    link_ptr->weight += 
+				Learn_p * unit_ptr->act * (link_ptr->to->act);
+			    if (link_ptr->weight > Weight_MAX)
+				link_ptr->weight = Weight_MAX;
+			    if (link_ptr->weight < -Weight_MAX)
+				link_ptr->weight = -Weight_MAX;
+			}
+		}else{
+		    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+			if (!IS_INPUT_UNIT (link_ptr->to)){
+			    link_ptr->weight += 
+				Learn_p * unit_ptr->act * (link_ptr->to->act);
+			    if (link_ptr->weight > Weight_MAX)
+				link_ptr->weight = Weight_MAX;
+			    if (link_ptr->weight < -Weight_MAX)
+				link_ptr->weight = -Weight_MAX;
+			}
+		}
+	    }
+
+	NET_ERROR (OutParameter) += Hebb_error (NoOfTimes); 
+    }
+    return (KernelErrorCode);
+}
+
diff -Naur snort-2.3.3/src/kernel_snns/learn_f.h snort-2.3.3.new/src/kernel_snns/learn_f.h
--- snort-2.3.3/src/kernel_snns/learn_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/learn_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,208 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/learn_f.h,v $
+  SHORTNAME      : learn_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+	           - Backpropagation
+	           - Backpropagation with momentum term
+                   - Quickprop
+	           - Counterpropagation
+	           - BackPercolation
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.10.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.16 $
+  LAST CHANGE    : $Date: 1998/04/08 09:26:45 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _LEARN_F_DEFINED_
+#define  _LEARN_F_DEFINED_
+
+extern krui_err LEARN_HEBB (int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams, 
+			    float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_RM_delta(int start_pattern, int end_pattern,
+			       float parameterInArray[], int NoOfInParams,
+			       float * *parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_ART1(int start_pattern, int end_pattern,
+			   float parameterInArray[], int NoOfInParams,
+			   float * *parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_ART2(int start_pattern, int end_pattern,
+			   float parameterInArray[], int NoOfInParams,
+			   float * *parameterOutArray, int *NoOfOutParams );
+
+extern krui_err LEARN_ARTMAP(int start_pattern, int end_pattern,
+			     float parameterInArray[], int NoOfInParams,
+			     float * *parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_kohonen(int start_pattern, int end_pattern,
+			      float parameterInArray[], int NoOfInParams,
+			      float * *parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_backprop(int start_pattern, int end_pattern, 
+			       float *parameterInArray, int NoOfInParams, 
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_backpropBatch(int start_pattern, int end_pattern, 
+				    float *parameterInArray, int NoOfInParams,
+				    float **parameterOutArray, 
+				    int *NoOfOutParams);
+
+extern krui_err LEARN_backpropMomentum(int start_pattern, int end_pattern, 
+				       float *parameterInArray, 
+				       int NoOfInParams, 
+				       float **parameterOutArray, 
+				       int *NoOfOutParams);
+
+extern krui_err LEARN_backpropWeightDecay (int start_pattern, 
+					   int end_pattern, 
+					   float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray,
+					   int *NoOfOutParams); 
+
+extern krui_err  LEARN_backpropChunk(int start_pattern, int end_pattern, 
+				     float *parameterInArray, int NoOfInParams,
+				     float **parameterOutArray, 
+				     int *NoOfOutParams);
+
+extern krui_err  LEARN_backpropJogChunk(int start_pattern, int end_pattern, 
+					float *parameterInArray, int NoOfInParams,
+					float **parameterOutArray, 
+					int *NoOfOutParams);
+
+extern krui_err  LEARN_backpropClassJogChunk(int start_pattern, int end_pattern, 
+					     float *parameterInArray, int NoOfInParams,
+					     float **parameterOutArray, 
+					     int *NoOfOutParams);
+
+extern krui_err LEARN_quickprop(int start_pattern, int end_pattern, 
+				float *parameterInArray, int NoOfInParams, 
+				float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_CPN(int start_pattern, int end_pattern, 
+			  float *parameterInArray, int NoOfInParams, 
+			  float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_perc(int start_pattern, int end_pattern, 
+			   float *parameterInArray, int NoOfInParams, 
+			   float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err RbfLearnClean(void);
+
+extern krui_err RbfLearnForward(int pattern_no, int sub_pat_no);
+
+extern float RbfLearnAdjustDelta(float para_center, float para_bias, 
+				 float para_weight, float para_pain, 
+				 float para_momentum, float para_delta_max, 
+				 int learn_mask);
+
+extern void RbfLearnAdjustWeights(float para_center, float para_bias, 
+				  float para_weight, float para_momentum);
+
+extern krui_err RbfTopoCheck(void);
+
+extern krui_err LEARN_RBF(int start_pattern, int end_pattern, 
+			   float *parameterInArray, int NoOfInParams, 
+			   float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_RBF_DDA(int start_pattern, int end_pattern, 
+		   float  *parameterInArray,  int  NoOfInParams, 
+		   float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_rprop(int start_pattern, int end_pattern, 
+			    float *parameterInArray, int NoOfInParams, 
+			    float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_RpropMAP(int start_pattern, int end_pattern, 
+			       float *parameterInArray, int NoOfInParams, 
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_BPTT(int start_pattern, int end_pattern, 
+			   float *parameterInArray, int NoOfInParams, 
+			   float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_BBPTT(int start_pattern, int end_pattern, 
+			    float *parameterInArray, int NoOfInParams, 
+			    float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_QPTT(int start_pattern, int end_pattern, 
+			   float *parameterInArray, int NoOfInParams, 
+			   float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err LEARN_JE_Backprop(int start_pattern, int end_pattern,
+				  float *parameterInArray, int NoOfInParams,
+				  float **parameterOutArray,int *NoOfOutParams);
+
+extern krui_err LEARN_JE_BackpropMomentum(int start_pattern, int end_pattern,
+					  float *parameterInArray,
+					  int NoOfInParams,
+					  float **parameterOutArray,
+					  int *NoOfOutParams);
+
+extern krui_err LEARN_JE_Quickprop(int start_pattern, int end_pattern,
+				   float *parameterInArray, int NoOfInParams,
+				   float **parameterOutArray, 
+				   int *NoOfOutParams);
+
+extern krui_err LEARN_JE_Rprop(int start_pattern, int end_pattern,
+			       float  *parameterInArray, int NoOfInParams,
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err spanning_tree(void);
+
+extern void propagateNetForward(int pattern_no, int sub_pat_no);
+
+extern float propagateNetBackwardBatch(int pattern_no, int sub_pat_no,
+				       float delta_max,
+				       Patterns alternative_out_pat, 
+				       int alternative_size);
+
+extern krui_err clearDeltas(void);
+extern krui_err clearAllDeltas(void);
+
+extern krui_err TEST_backprop(int start_pattern, int end_pattern, 
+			       float *parameterInArray, int NoOfInParams, 
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err TEST_backpropMomentum(int start_pattern, int end_pattern, 
+			       float *parameterInArray, int NoOfInParams, 
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err TEST_JE_Backprop(int start_pattern, int end_pattern,
+				  float *parameterInArray, int NoOfInParams,
+				  float **parameterOutArray,int *NoOfOutParams);
+
+extern krui_err TEST_JE_BackpropMomentum(int start_pattern, int end_pattern,
+				  float *parameterInArray, int NoOfInParams,
+				  float **parameterOutArray,int *NoOfOutParams);
+
+extern krui_err TEST_rprop(int start_pattern, int end_pattern, 
+			    float *parameterInArray, int NoOfInParams, 
+			    float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err TEST_MAP(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err TEST_JE_Rprop(int start_pattern, int end_pattern,
+			       float  *parameterInArray, int NoOfInParams,
+			       float **parameterOutArray, int *NoOfOutParams);
+
+extern krui_err TEST_BPTT(int start_pattern, int end_pattern, 
+			   float *parameterInArray, int NoOfInParams, 
+			   float **parameterOutArray, int *NoOfOutParams);
+
+#endif 
+
+
diff -Naur snort-2.3.3/src/kernel_snns/learn_f.ph snort-2.3.3.new/src/kernel_snns/learn_f.ph
--- snort-2.3.3/src/kernel_snns/learn_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/learn_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,342 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/learn_f.ph,v $
+  SHORTNAME      : learn_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+	           - Backpropagation
+	           - Backpropagation with momentum term
+                   - Quickprop
+	           - Counterpropagation
+	           - BackPercolation
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.10.90
+
+  CHANGED BY     : Sven Doering, Michael Vogt (Martin Reczko), Guenter Mamier
+  RCS VERSION    : $Revision: 2.19 $
+  LAST CHANGE    : $Date: 1998/04/08 09:26:46 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _LEARN_F_DEFINED_
+#define  _LEARN_F_DEFINED_
+
+/* begin global definition section */
+krui_err LEARN_HEBB (int start_pattern, int end_pattern,
+                     float *parameterInArray, int NoOfInParams, 
+                     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err LEARN_RM_delta (int start_pattern, int end_pattern,
+			 float parameterInArray[], int NoOfInParams,
+			 float * *parameterOutArray, int *NoOfOutParams	);
+
+krui_err  LEARN_ART1(int start_pattern, int end_pattern,
+		     float parameterInArray[], int NoOfInParams,
+		     float * *parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_ART2(int start_pattern, int end_pattern, 
+		     float parameterInArray[], int NoOfInParams,
+		     float * *parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_ARTMAP(int start_pattern, int end_pattern,
+		       float parameterInArray[], int NoOfInParams,
+		       float * *parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_kohonen(int start_pattern, int end_pattern,
+			float parameterInArray[], int NoOfInParams,
+			float * *parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_backprop(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_backpropBatch(int start_pattern, int end_pattern, 
+			      float *parameterInArray, int NoOfInParams, 
+			      float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_backpropMomentum(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams, 
+				 float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_backpropWeigthDecay(int start_pattern, int end_pattern, 
+				    float *parameterInArray, int NoOfInParams, 
+				    float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_backpropChunk(int start_pattern, int end_pattern, 
+			      float *parameterInArray, int NoOfInParams,
+			      float **parameterOutArray, 
+			      int *NoOfOutParams);
+
+krui_err  LEARN_backpropJogChunk(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams,
+				 float **parameterOutArray, 
+				 int *NoOfOutParams);
+
+krui_err  LEARN_backpropClassJogChunk(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams,
+				 float **parameterOutArray, 
+				 int *NoOfOutParams);
+
+krui_err LEARN_quickprop(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_CPN(int start_pattern, int end_pattern, 
+		    float *parameterInArray, int NoOfInParams, 
+		    float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_perc(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  RbfLearnClean(void);
+
+krui_err  RbfLearnForward(int pattern_no, int sub_pat_no);
+
+float RbfLearnAdjustDelta(float para_center, float para_bias, 
+			  float para_weight, float para_pain, 
+			  float para_momentum, float para_delta_max, 
+			  int learn_mask);
+
+void RbfLearnAdjustWeights(float para_center, float para_bias, 
+			   float para_weight, float para_momentum);
+
+krui_err RbfTopoCheck(void);
+
+krui_err  LEARN_RBF(int start_pattern, int end_pattern, 
+		    float *parameterInArray, int NoOfInParams, 
+		    float **parameterOutArray, int *NoOfOutParams);
+
+krui_err LEARN_RBF_DDA(int start_pattern, int end_pattern, 
+		   float  *parameterInArray,  int  NoOfInParams, 
+		   float **parameterOutArray, int *NoOfOutParams);
+
+krui_err LEARN_rprop(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err LEARN_RpropMAP(int start_pattern, int end_pattern, 
+                     float *parameterInArray, int NoOfInParams, 
+                     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_BPTT(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_BBPTT(int start_pattern, int end_pattern, 
+		      float *parameterInArray, int NoOfInParams, 
+		      float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_QPTT(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_JE_Backprop(int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams,
+			    float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err LEARN_JE_BackpropMomentum(int start_pattern, int end_pattern,
+				   float *parameterInArray, int NoOfInParams,
+				   float **parameterOutArray, 
+				   int *NoOfOutParams);
+
+krui_err  LEARN_JE_Quickprop(int start_pattern, int end_pattern,
+			     float *parameterInArray, int NoOfInParams,
+			     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  LEARN_JE_Rprop(int start_pattern, int end_pattern,
+			 float *parameterInArray, int NoOfInParams,
+			 float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err  spanning_tree(void);
+
+void propagateNetForward(int pattern_no, int sub_pat_no);
+
+float propagateNetBackwardBatch(int pattern_no, int sub_pat_no,float delta_max);
+float propagateClassNetBackwardBatch(int pattern_no, int sub_pat_no,float delta_max);
+
+krui_err clearDeltas(void);
+krui_err clearAllDeltas(void);
+
+krui_err  TEST_backprop(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  TEST_backpropMomentum(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+
+krui_err TEST_rprop(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err TEST_MAP(int start_pattern, int end_pattern, 
+                     float *parameterInArray, int NoOfInParams, 
+                     float **parameterOutArray, int *NoOfOutParams);
+
+krui_err  TEST_JE_Backprop(int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams,
+			    float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err  TEST_JE_BackpropMomentum(int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams,
+			    float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err  TEST_JE_Rprop(int start_pattern, int end_pattern,
+			 float *parameterInArray, int NoOfInParams,
+			 float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err  TEST_BPTT(int start_pattern, int end_pattern, 
+		     float *parameterInArray, int NoOfInParams, 
+		     float **parameterOutArray, int *NoOfOutParams);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+
+static	float testNetBackward2(int pattern_no, int sub_pat_no, 
+				    float learn_parameter, float delta_max);
+
+static void test_update_je_context_units(int pattern_no, int sub_pat_no) ; 
+
+static float testNetBackwardRprop(int pattern_no, int sub_pat_no);
+
+#define  NET_ERROR( param )      param[ 0 ]  /* returns the net error   */
+#define  LEARN_PARAM1( param )   param[ 0 ]  /* contains 1st learning param  */
+#define  LEARN_PARAM2( param )   param[ 1 ]  /* contains 2nd learning param  */
+#define  LEARN_PARAM3( param )   param[ 2 ]  /* contains 3rd learning param  */
+#define  LEARN_PARAM4( param )   param[ 3 ]  /* contains 4th learning param  */
+#define  LEARN_PARAM5( param )   param[ 4 ]  /* contains 5th learning param  */
+
+#define  SIGMOID_PRIME_OFFSET    0.1         /* for modified sigmoid function */
+#define SQR(x)  (x) * (x)
+
+static int  NoOfLearnedPatterns;
+
+static float Hebb_error(int NoOfTimes);
+
+static void RM_propagate(int pattern_no, int sub_pat_no, float prop_step);
+
+static void RM_learn(float learn_parameter);
+
+static krui_err put_ART1_in_pattern(int pattern_no, int sub_pat_no, 
+				    TopoPtrArray topo_inp_ptr);
+
+static krui_err adjust_ART1_weights(double beta, TopoPtrArray  comp_ptr,
+				    TopoPtrArray delay_ptr,
+				    struct Unit   *winner_ptr);
+
+static krui_err put_ART2_in_pattern(int pattern_no, int sub_pat_no,
+				    TopoPtrArray topo_inp_ptr);
+
+static krui_err adjust_ART2_weights(double param_d, TopoPtrArray  p_ptr,
+				    struct Unit *winner_ptr);
+
+static krui_err put_ARTMAP_in_pattern(int pattern_no, int sub_pat_no,
+				      TopoPtrArray topo_inpa_ptr,
+				      TopoPtrArray topo_inpb_ptr);
+
+static krui_err adjust_ARTMAP_weights(double beta_a, double beta_b,
+				      TopoPtrArray compa_ptr,
+				      TopoPtrArray  compb_ptr,
+				      TopoPtrArray  dela_ptr,
+				      TopoPtrArray  delb_ptr,
+				      TopoPtrArray  map_ptr,
+				      struct Unit *winner_ptr_a,
+				      struct Unit *winner_ptr_b);
+
+static	float propagateNetBackward2(int pattern_no, int sub_pat_no, 
+				    float learn_parameter, float delta_max);
+
+static krui_err updateWeights(float eta);
+static krui_err updateNormalizedWeights(float eta);
+
+static krui_err initializeBackpropMomentum(void);
+
+static	float Backprop_momentum_FSE(int pattern_no, int sub_pat_no, 
+				    float learn_parameter, float mu, 
+				    float FSE_term, float delta_max);
+
+static float Backprop_weightdecay (int pattern_no, int sub_pat_no, 
+				   float learn_parameter, 
+				   float wd_gamma, float min_weight,
+				   float delta_max);
+
+static krui_err initializeQuickprop(void);
+
+static float  propagateNetBackwardQuickprop(int pattern_no, int sub_pat_no,
+					    float delta_max);
+
+static void MODI_quickprop(float learn_parameter, float max_factor, 
+			   float decay);
+
+static krui_err  initializeCPN(void);
+
+static void normalize_weight(struct Unit *winner_ptr, float sum);
+
+static void normalize_inputvector(float sum);
+
+static float propagateNet_CPN(int pattern_no, int sub_pat_no,
+			      float alpha, float beta, float threshold);
+
+static	void  propagateNetForward_perc(int pattern_no, int sub_pat_no);
+
+static	float propagateNetBackward_perc(int pattern_no, int sub_pat_no,
+					float learn_parameter, float delta_max,
+					float *perc_error);
+
+static int computeDevite(float *devit, float *sum_error,
+                         float target, float output, int errorType );
+
+static float computeAlpha(void);
+
+static void MODI_rprop(float maxeps, float weight_decay);
+
+static krui_err initializeRprop(float update_val);
+
+static void propagateNetForwardMAP(int pattern_no, int sub_pat_no, 
+				   int errorType);
+
+static float propagateNetBackwardRprop(int pattern_no, int sub_pat_no);
+
+static float propagateNetBackwardMAP(int pattern_no, int sub_pat_no, 
+				     int errorType);
+
+static float testNetBackwardMAP(int pattern_no, int sub_pat_no, int errorType);
+
+static krui_err BPTT_clear_deltaw(void);
+
+static krui_err initializeBPTT(void);
+
+static void BPTT_propagateNetForward(int pattern_no, int sub_pat_no, int nhist);
+
+static float initOldDeltas(int pattern_no, int sub_pat_no );
+
+static float oneStepBackprop(int backstep, int pattern_no, int sub_pat_no, 
+			     int nhist);
+
+static void BPTTadapt(float step_size, float bptt_momentum);
+
+static float BPTT_propagateNetBackward(int pattern_no, int sub_pat_no, 
+				       int nhist);
+
+static float propagateNet_kohonen(int pattern_no, int sub_pat_no, float height,
+				  float width, int sizehor);
+
+static krui_err initializeKohonenLearning(void);
+
+static void update_je_context_units(int pattern_no, int sub_pat_no,
+				    float use_real_value_percent) ; 
+
+static void reset_je_context_units(void) ;
+
+static krui_err check_je_network(void) ;
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/lrand48.c snort-2.3.3.new/src/kernel_snns/lrand48.c
--- snort-2.3.3/src/kernel_snns/lrand48.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/lrand48.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,41 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/lrand48.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : lrand48 functions
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 2.3.98
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.2 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:49 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#if ! defined(HAVE_LRAND48) || HAVE_LRAND48 == 0
+#include <stdlib.h>
+
+long lrand48(void)
+{
+    return (long) random();
+}
+
+void srand48(long seedval)
+{
+    srandom(seedval);
+}
+
+double drand48(void)
+{
+    return((double) (random() & 0x7fffffff)
+	   / (double) 0x7fffffff);
+}
+
+#endif /* ! HAVE_LRAND48 */
diff -Naur snort-2.3.3/src/kernel_snns/lrand48.h snort-2.3.3.new/src/kernel_snns/lrand48.h
--- snort-2.3.3/src/kernel_snns/lrand48.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/lrand48.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,30 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/lrand48.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : lrand48 functions
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 2.3.98
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.2 $
+  LAST CHANGE    : $Date: 1998/03/03 17:54:29 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#if ! defined(HAVE_LRAND48) || HAVE_LRAND48 == 0
+#ifndef _LRAND48_DEFINED_
+#define _LRAND48_DEFINED_
+
+extern long lrand48(void);
+extern void srand48(long seedval);
+extern double drand48(void);
+
+#endif /* _LRAND48_DEFINED_ */
+#endif /* ! HAVE_LRAND48 */
diff -Naur snort-2.3.3/src/kernel_snns/Makefile snort-2.3.3.new/src/kernel_snns/Makefile
--- snort-2.3.3/src/kernel_snns/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/Makefile	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,188 @@
+#*****************************************************************************
+# FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/Makefile,v $
+# SHORTNAME      : Makefile
+# SNNS VERSION   : 4.2
+#
+# PURPOSE        : Makefile for kernel make
+# NOTES          : Do not change Makefiles manually
+#
+# AUTHOR         : Michael Vogt
+# DATE           : 27.02.98
+#
+# CHANGED BY     : 
+# RCS VERSION    : $Revision: 2.13 $
+# LAST CHANGE    : $Date: 1998/03/18 15:24:16 $
+#
+#   Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+#   Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+#
+#*****************************************************************************
+
+# Read all global definitions, common for all source Makefiles
+
+include Makefile.def
+
+# Final compiler definitions
+
+# Define final C-preprocessor options for the kernel
+# Additional definitions like -I... and -D... go here
+CPPFLAGS           = -I. $(ENZOFLAGS)
+
+# Here you may change the default C-compiler flags as set in
+# ../../Makefile.def (not recommended)
+# CFLAGS           = -g -O
+
+# Source files
+
+KERNELSOURCES_YACC = kr_pat_parse_bison.y
+KERNELSOURCES_LEX  = kr_pat_scan.l
+KERNELSOURCES_C    = kernel.c \
+                     kr_io.c \
+                     kr_mem.c \
+                     kr_ui.c \
+                     kr_inversion.c \
+                     art_ui.c \
+                     kr_art.c \
+                     kr_art1.c \
+                     kr_art2.c \
+                     kr_amap.c \
+		     kr_pat_parse.c \
+                     kr_newpattern.c\
+                     kr_JordElm.c
+
+USR_FUNC_SOURCES_C = func_tbl.c \
+                     init_f.c \
+                     kr_td.c \
+                     kr_funcs.c \
+                     learn_f.c \
+                     prun_f.c \
+                     tbl_func.c \
+                     trans_f.c \
+                     update_f.c \
+                     remap_f.c \
+                     matrix.c \
+                     arttr_f.c \
+                     cc_learn.c \
+                     cc_prune.c \
+                     cc_modify.c \
+                     cc_glob.c \
+                     cc_display.c \
+                     tacoma_learn.c \
+                     dlvq_learn.c \
+                     stochastic_learn_f.c \
+		     scaled_conj_grad.c
+
+UTILITY_SOURCES_C  = make_tbl.c \
+                     calc_err.c
+
+# Modul files
+
+MODULES            = $(KERNELSOURCES_C) \
+                     $(KERNELSOURCES_LEX) \
+                     $(USR_FUNC_SOURCES_C) \
+                     $(UTILITY_SOURCES_C)
+
+# Object files
+
+KERNELOBJECTS	   = $(KERNELSOURCES_LEX:.l=.o) \
+                     $(KERNELSOURCES_C:.c=.o)
+USR_FUNC_OBJECTS   = $(USR_FUNC_SOURCES_C:.c=.o)
+UTILITY_OBJECTS    = $(UTILITY_SOURCES_C:.c=.o)
+
+# Libraries
+
+LIBKERNEL	   = libkernel.a
+LIBFUNCS	   = libfunc.a
+
+# Targets
+
+all: $(LIBKERNEL) $(LIBFUNCS)
+
+$(KERNELBINDIR):
+	-mkdir $(KERNELBINDIR)
+
+install: all $(KERNELBINDIR)
+	@echo "nothing to install"
+
+install-strip:
+	$(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' install
+
+uninstall:
+	@echo "nothing to uninstall"
+
+mostlyclean:
+	rm -f $(KERNELOBJECTS) $(USR_FUNC_OBJECTS) $(SUBSTOBJECTS)
+
+clean: mostlyclean
+	rm -f $(LIBKERNEL) $(LIBFUNCS)
+
+distclean: clean
+	rm -f *~ *% *.bak
+
+maintainer-clean: distclean
+	@echo "This command deletes files that may need special tools to rebuild."
+	@echo "You need to have flex to rebuild a scanner."
+	@echo "You need to have bison to rebuild a parser."
+	rm -f kr_pat_scan.c kr_pat_parse.c y.tab.h
+
+depend:
+	-$(MAKEDEPEND) -- $(CPPFLAGS) -- -w3 -f- $(MODULES) | \
+	grep -v ': */' > kernel.ddt
+
+# Building of libraries
+
+$(LIBKERNEL): $(KERNELOBJECTS)
+	$(AR) $(ARFLAGS) $(LIBKERNEL) $(KERNELOBJECTS)
+	@echo ""
+	@echo "Ignore possible error messages for the following command:"
+	-$(RANLIB) $(LIBKERNEL)
+	@echo "END OF COMMANDS THAT MAY FAIL"
+	@echo ""
+
+$(LIBFUNCS): $(USR_FUNC_OBJECTS) $(SUBSTOBJECTS)
+	$(AR) $(ARFLAGS) $(LIBFUNCS) $(USR_FUNC_OBJECTS) $(SUBSTOBJECTS)
+	@echo ""
+	@echo "Ignore possible error messages for the following command:"
+	-$(RANLIB) $(LIBFUNCS)
+	@echo "END OF COMMANDS THAT MAY FAIL"
+	@echo ""
+
+# Parser and Scanner generation
+
+kr_pat_scan.c: kr_pat_scan.l
+	@echo ""
+	@echo "You need to have flex to rebuild a scanner."
+	@echo "If the following commands fail you will either have to"
+	@echo "install flex and rerun 'configure' in $(SNNSDIR)" 
+	@echo "or to 'touch' the unchanged file kr_pat_scan.c from the SNNS distribution."
+	-$(FLEX) kr_pat_scan.l
+	-mv kr_pat_scan.c kr_pat_scan.c.bak
+	-mv lex.yy.c kr_pat_scan.c
+	@echo "END OF COMMANDS THAT MAY FAIL"
+	@echo ""
+
+kr_pat_parse.c y.tab.h: kr_pat_parse_bison.y
+	@echo ""
+	@echo "You need to have bison to rebuild a parser."
+	@echo "If the following commands fail you will either have to"
+	@echo "install bison and rerun 'configure' in $(SNNSDIR),"
+	@echo "or to 'touch' the original files kr_pat_parse.c and y.tab.h"
+	@echo "from the SNNS distribution."
+	@echo "Also read the notes about 'bison' versions in Readme.install."
+	-mv kr_pat_parse.c kr_pat_parse.c.bak
+	-mv y.tab.h y.tab.h.bak
+	-$(BISON) $(BISONFLAGS) pp kr_pat_parse_bison.y
+	-mv y.tab.c kr_pat_parse.c
+	@echo "END OF COMMANDS THAT MAY FAIL"
+	@echo ""
+
+# Dependencies
+
+$(KERNELOBJECTS): Makefile Makefile.def
+$(USR_FUNC_OBJECTS): Makefile Makefile.def
+
+include kernel.ddt
+
+#*****************************************************************************
+# End of kernel Makefile
+#*****************************************************************************
diff -Naur snort-2.3.3/src/kernel_snns/Makefile.def snort-2.3.3.new/src/kernel_snns/Makefile.def
--- snort-2.3.3/src/kernel_snns/Makefile.def	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/Makefile.def	2008-02-18 00:44:23.000000000 -0300
@@ -0,0 +1,122 @@
+# Generated automatically from Makefile.din by configure.
+#*****************************************************************************
+# FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/configuration/Makefile.din,v $
+# SHORTNAME      : Makefile.defs.in
+# SNNS VERSION   : 4.2
+#
+# PURPOSE        : input file to create Makefile.defs by configure
+# NOTES          : Do not change Makefiles manually
+#
+# AUTHOR         : Michael Vogt
+# DATE           : 27.02.98
+#
+# CHANGED BY     : 
+# RCS VERSION    : $Revision: 2.2 $
+# LAST CHANGE    : $Date: 1998/03/18 15:24:12 $
+#
+#   Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+#   Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+#
+#*****************************************************************************
+
+#*****************************************************************************
+# BEGIN OF USER CUSTOMIZABLE AREA
+#*****************************************************************************
+
+# Use the command 'bison --version' to get information about your bison.
+# If you are using bison 1.22 or later, your BISONFLAGS should look like this:
+# BISONFLAGS       = -y -t -d -p
+# For bison version before 1.22, use these BISONFLAGS:
+# BISONFLAGS       = -y -t -d +a
+
+BISONFLAGS         = -y -t -d +a # REPORT_IF_BUG
+
+# This is the archiver program used to build libraries
+AR                 = ar # REPORT_IF_BUG
+
+# These are the flags for the archiver program 
+ARFLAGS 	   = rc # REPORT_IF_BUG
+
+#*****************************************************************************
+# END OF USER CUSTOMIZABLE AREA
+# Don't change any of the following setings. They are all set by running 
+# 'configure' in the main SNNS directory. Check possible variations with
+# 'configure --help' and read the file Readme.install.
+#*****************************************************************************
+
+#*****************************************************************************
+# BEGIN OF AREA UNDER CONTROL OF CONFIGURE
+# Please read Readme.install before you even think about changing any of
+# the following definitions manually!
+#*****************************************************************************
+
+# Here are the automatically created options to run the C compiler
+# To influence this value, set the enviroment variable CFLAGS before
+# running 'configure'
+CFLAGS             = -g -O2 # REPORT_IF_BUG
+CXXFLAGS           = -g -O2 # REPORT_IF_BUG
+
+# SNNS installation directories
+
+CANONICAL_HOST     = i686-pc-linux-gnu # REPORT_IF_BUG
+INSTALLDIR         = ./
+SNNSDIR            = ./
+KERNELBINEXT       = /kernel
+TOOLSBINEXT        = /tools
+XGUIBINEXT         = /xgui
+HOSTBINEXT         = /i686-pc-linux-gnu
+
+KERNELBINDIR       = $(INSTALLDIR)$(KERNELBINEXT)/bin$(HOSTBINEXT)
+KERNELSRCDIR       = kernel/sources
+TOOLSBINDIR        = $(INSTALLDIR)$(TOOLSBINEXT)/bin$(HOSTBINEXT)
+TOOLSSRCDIR        = tools/sources
+XGUIBINDIR         = $(INSTALLDIR)$(XGUIBINEXT)/bin$(HOSTBINEXT)
+XGUISRCDIR         = xgui/sources
+XGUIICONSDIR       = xgui/iconsXgui
+MANDIR             = $(INSTALLDIR)/man
+MAN1DIR            = $(MANDIR)/man1
+MANSRCDIR          = man
+
+# Tools covered by configure
+
+FLEX               = flex # REPORT_IF_BUG
+BISON              = bison # REPORT_IF_BUG
+CC                 = gcc # REPORT_IF_BUG
+CXX                = c++ # REPORT_IF_BUG
+INSTALL            = /usr/bin/install -c # REPORT_IF_BUG
+INSTALL_DATA       = ${INSTALL} -m 644
+INSTALL_PROGRAM    = ${INSTALL}
+RANLIB             = ranlib # REPORT_IF_BUG
+MAKEDEPEND         = makedepend
+
+# C-Preprocessor, C-Compiler, and linker configuration
+
+# Define library and include paths for the X system if headers and
+# libraries can not be found in standard places
+X_CFLAGS           =  # REPORT_IF_BUG
+X_LIBS             =  # REPORT_IF_BUG
+
+# Any extra libraries needed to be linked after all X libraries
+X_EXTRA_LIBS       =  # REPORT_IF_BUG
+
+# Any extra libraries needed to be linked before -lX11
+X_PRE_LIBS         =  # REPORT_IF_BUG
+
+# Library needed for flex scanner
+LEXLIB             = -lfl # REPORT_IF_BUG
+
+# Preprocessor flags to prepare SNNS for ENZO
+ENZOFLAGS          =  # REPORT_IF_BUG
+
+# Substitutions for some function implementations
+SUBSTOBJECTS       =   # REPORT_IF_BUG
+
+# Redefinition of implicit make rules
+.SUFFIXES:
+.SUFFIXES: .c .o
+.c.o:
+	$(CC) $(CPPFLAGS) $(CFLAGS) -c $<
+
+#*****************************************************************************
+# End of common Makefile.defs
+#*****************************************************************************
diff -Naur snort-2.3.3/src/kernel_snns/make_tbl.c snort-2.3.3.new/src/kernel_snns/make_tbl.c
--- snort-2.3.3/src/kernel_snns/make_tbl.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/make_tbl.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,151 @@
+/*     $State: Exp $ $Locker:  $  */
+
+/**********************************************************************
+FILE   : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/make_tbl.c,v $
+PURPOSE: SNNS-Kernel Tool: Calculates the lookup tables for table lookup
+	 transfer functions
+NOTES  : 
+AUTHOR : Niels Mache
+DATE   : 06.12.91
+VERSION : $Revision: 2.5 $  $Date: 1998/03/03 14:08:50 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+**********************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <math.h>
+
+
+#define NEWLINE_INSERT	10
+#define PRECISION  7
+
+
+
+/*  user defined parameters
+*/
+#define NO_OF_APPROX 1000
+#define MIN_APPROX_X -12.0
+#define MAX_APPROX_X  12.0
+#define MINUS_INFINITE_BORDER  -13.0
+#define PLUS_INFINITE_BORDER	13.0
+#define MINUS_INFINITE_FUNC_VALUE  0.0
+#define PLUS_INFINITE_FUNC_VALUE   1.0
+
+
+#define ERR_MINUS_INFINITE_BORDER  -100.0
+#define ERR_PLUS_INFINITE_BORDER    100.0
+#define ERROR 7.425010618e-05
+/*
+#define INDEX_OFFSET (NO_OF_APPROX / 2)
+#define SCALE_FACTOR (NO_OF_APPROX / (MAX_APPROX_X - MIN_APPROX_X))
+#define MIN_INDEX ((int) (MINUS_ININITE_BORDER * SCALE_FACTOR) + INDEX_OFFSET)
+#define MAX_INDEX ((int) (PLUS_ININITE_BORDER * SCALE_FACTOR) + INDEX_OFFSET)
+*/
+
+/*  Sigmoid Function
+*/
+double	f( x )
+double	x;
+{
+  return( 1.0 / (1.0 + exp( -x )));
+}
+
+
+void  calc_m_and_b( x1, x2, m, b )
+double	x1, x2;
+double	*m, *b;
+{
+  double  y1, y2;
+
+  y1 = f( x1 );
+  y2 = f( x2 );
+
+  *m = (y2 - y1) / (x2 - x1);
+  *b = y1 - *m * x1;
+}
+
+
+int  main()
+{
+  double  x, m, b, step, scale;
+  int  i, nl_cycle;
+  int  index_offset, min_index, max_index;
+
+
+  index_offset = NO_OF_APPROX / 2;
+  step = (MAX_APPROX_X - MIN_APPROX_X) / (double) NO_OF_APPROX;
+  scale = (double) NO_OF_APPROX / (MAX_APPROX_X - MIN_APPROX_X);
+  min_index = (int) (MINUS_INFINITE_BORDER * scale) + index_offset;
+  max_index = (int) (PLUS_INFINITE_BORDER * scale) + index_offset;
+
+  fprintf( stdout, "/*\nNo. of Approx.: %d\nMin. x: %g\nMax. x: %g\n",
+	   NO_OF_APPROX, MIN_APPROX_X, MAX_APPROX_X );
+  fprintf( stdout, "Minus inf. border: %g\nPlus inf. border : %g\n",
+	   MINUS_INFINITE_BORDER, PLUS_INFINITE_BORDER );
+  fprintf( stdout, "Error in [%+g,%+g]: %g\n*/\n\n",
+	   ERR_MINUS_INFINITE_BORDER, ERR_PLUS_INFINITE_BORDER, ERROR );
+
+  fprintf( stdout, "#define NO_OF_APPROX %d\n#define INDEX_OFFSET %d\n",
+	   NO_OF_APPROX, index_offset );
+  fprintf( stdout, "#define MINUS_INFINITE_FUNC_VALUE %#.10g\n#define PLUS_INFINITE_FUNC_VALUE %#.10g\n",
+	   MINUS_INFINITE_FUNC_VALUE, PLUS_INFINITE_FUNC_VALUE );
+  fprintf( stdout, "#define SCALE_FACTOR %#.10g\n#define MIN_INDEX %d\n#define MAX_INDEX %d\n\n",
+	   scale, min_index, max_index );
+
+
+  fprintf( stdout, "static float m[] = {\n" );
+
+  calc_m_and_b( MINUS_INFINITE_BORDER, MIN_APPROX_X, &m, &b );
+  fprintf( stdout, "%.8g,  /*  minus infinite border  */\n", m );
+
+  x = MIN_APPROX_X;
+  nl_cycle = 0;
+  for (i = 0; i < NO_OF_APPROX - 1; i++)
+    {
+    calc_m_and_b( x, x + step, &m, &b );
+
+    if ((++nl_cycle % NEWLINE_INSERT) == 0)
+      fprintf( stdout, "%.8g,\n", m );
+    else
+      fprintf( stdout, "%.8g, ", m );
+
+    x += step;
+    }
+
+  calc_m_and_b( MAX_APPROX_X, PLUS_INFINITE_BORDER, &m, &b );
+  if ((nl_cycle % NEWLINE_INSERT) == 0)
+    fprintf( stdout, "%.8g  };  /*  plus infinite border  */\n\n", m );
+  else
+    fprintf( stdout, "\n%.8g  };  /*  plus infinite border  */\n\n", m );
+
+
+  fprintf( stdout, "static float b[] = {\n" );
+
+  calc_m_and_b( MINUS_INFINITE_BORDER, MIN_APPROX_X, &m, &b );
+  fprintf( stdout, "%.8g,  /*  minus infinite border  */\n", b );
+
+  x = MIN_APPROX_X;
+  nl_cycle = 0;
+  for (i = 0; i < NO_OF_APPROX - 1; i++)
+    {
+    calc_m_and_b( x, x + step, &m, &b );
+
+    if ((++nl_cycle % NEWLINE_INSERT) == 0)
+      fprintf( stdout, "%.8g,\n", b );
+    else
+      fprintf( stdout, "%.8g, ", b );
+
+    x += step;
+    }
+
+  calc_m_and_b( MAX_APPROX_X, PLUS_INFINITE_BORDER, &m, &b );
+  if ((nl_cycle % NEWLINE_INSERT) == 0)
+    fprintf( stdout, "%.8g  };  /*  plus infinite border  */\n", b );
+  else
+    fprintf( stdout, "\n%.8g  };  /*  plus infinite border  */\n", b );
+
+  exit( 0 );
+}
diff -Naur snort-2.3.3/src/kernel_snns/matrix.c snort-2.3.3.new/src/kernel_snns/matrix.c
--- snort-2.3.3/src/kernel_snns/matrix.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/matrix.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,683 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/matrix.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel standard matrix operations
+  NOTES          :
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.02.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/03/16 13:33:58 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+/************************************************************************/
+/* included headers:							*/
+/************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include "matrix.ph"
+#include "glob_typ.h"
+
+
+/************************************************************************/
+/* functions:								*/
+/************************************************************************/
+
+/************************************************************************/
+/* function RbfAllocMatrix:						*/
+/* allocate matrix m with r rows and c columns				*/
+/* returns 0 if impossible, 1 otherwise					*/
+/************************************************************************/
+
+int	RbfAllocMatrix(int r, int c, RbfFloatMatrix *m)
+{
+	int	rc;			/* return code			*/
+	int	i;			/* index variable		*/
+
+	m -> field = (float *) malloc(r * c * sizeof(float));
+	m -> r_pt = (float **) malloc(r * sizeof(float *));
+	if (m -> field == (float *) NULL ||
+	    m -> r_pt == (float **) NULL)
+	{
+		/* malloc was impossible, return 0 (reports error)	*/
+		rc = 0;
+	}
+	else
+	{
+		/* malloc successfull, initialize matrix:		*/
+		rc = 1;
+		m -> rows = r;
+		m -> columns = c;
+		for (i = 0; i<r; i++)
+			(m -> r_pt)[i] = &(m -> field)[i * c];
+	}
+
+	return rc;			/* report status		*/
+}
+
+/************************************************************************/
+/* function RbfFreeMatrix:						*/
+/* deallocate matrix m							*/
+/************************************************************************/
+
+void	RbfFreeMatrix(RbfFloatMatrix *m)
+{
+	free(m -> field);
+	free(m -> r_pt);
+	m -> rows = 0;
+	m -> columns = 0;
+}
+
+/************************************************************************/
+/* function RbfClearMatrix:						*/
+/* set all elements of matrix m to value c				*/
+/************************************************************************/
+
+void RbfClearMatrix(RbfFloatMatrix *m, double c)
+{
+	int	count;
+	float	*ptoelement;
+
+	ptoelement = m -> field;
+	count = (m -> rows)*(m -> columns);
+
+	while(count--)
+	{
+		*ptoelement++ = c;
+	}
+}
+
+/************************************************************************/
+/* function RbfSquareOfNorm:						*/
+/*                                      				*/
+/************************************************************************/
+
+float RbfSquareOfNorm(RbfFloatMatrix *m)
+{
+  int	i, j;
+  float norm = 0.0;
+
+  for (i = m->rows -1 ; i>=0; i--)
+    {
+      for (j = m->columns -1 ; j>=0; j--)
+	norm += RbfMatrixGetValue(m, i ,j )*RbfMatrixGetValue(m, i, j);
+    };
+  return norm ;
+}
+
+/************************************************************************/
+/* function RbfIdempotentMatrix:	                                */
+/* CAUTION: m must be a square matrix      		      		*/
+/* set all elements of matrix m to value 0, the diagonal to 1  		*/
+/************************************************************************/
+
+void RbfIdempotentMatrix(RbfFloatMatrix *m)
+{
+register int     i,j;
+
+for (i = m->rows -1 ; i>=0; i--)
+  {
+    for (j = m->columns -1 ; j>=0; j--)
+      RbfMatrixSetValue(m,  i, j, 0);
+    RbfMatrixSetValue(m, i, i, 1);
+  };
+
+}
+
+/************************************************************************/
+/* function RbfMulScalarMatrix:	                                */
+/* set all elements of matrix m to their value multiplied with a      	*/
+/************************************************************************/
+
+void RbfMulScalarMatrix(RbfFloatMatrix *m, float a)
+{
+register int     i,j;
+
+for (i = m->rows -1 ; i>=0; i--)
+  {
+    for (j = m->columns -1 ; j>=0; j--)
+      RbfMatrixSetValue(m, i, j, a * RbfMatrixGetValue(m, i, j) );
+  };
+
+}
+
+/************************************************************************/
+/* function RbfSetMatrix:						*/
+/* set m1 to m2 (m1 = m2). m1 must be allocated with the same		*/
+/* dimensions as m2							*/
+/************************************************************************/
+
+void RbfSetMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2)
+{
+	int	count;
+	float	*ptofrom;
+	float	*ptoto;
+
+#ifdef	DEBUG_MODE
+	if (m1 -> rows != m2 -> rows ||
+	    m1 -> columns != m2 -> columns)
+	{
+		ErrMess("RbfSetMatrix: incompatible matrixes.\n");
+	}
+#endif
+
+	count = (m2 -> rows)*(m2 -> columns);
+	ptofrom = m2 -> field;
+	ptoto = m1 -> field;
+
+	while(count--)
+	{
+		*ptoto++ = *ptofrom++;
+	}
+}
+
+/************************************************************************/
+/* function RbfTranspMatrix:						*/
+/* set m1 to m2 transposed (m1 = m2T)					*/
+/* number of rows of m1 must be equal to number of columns of m2.	*/
+/* number of columns of m1 must be equal to number of rows of m2.	*/
+/************************************************************************/
+
+void	RbfTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2)
+{
+	
+	int		r;
+	int		c;
+
+#ifdef	DEBUG_MODE
+	if (m1 -> rows != m2 -> columns ||
+	    m1 -> columns != m2 -> rows)
+		ErrMess("RbfTranspMatrix: incompatible matrixes.\n"); 
+#endif
+
+	/* make m1 to become m2 transposed				*/
+
+	for (r = 0; r < m2 -> rows; r++)
+	    for (c = 0; c < m2 -> columns; c++)
+		RbfMatrixSetValue(m1, c, r, RbfMatrixGetValue(m2, r, c));
+}
+
+#ifdef RBF_MATRIX_LUDCOMP
+
+/************************************************************************/
+/* function RbfLUDcmp:							*/
+/* builds the LU Decomposition of matrix m and stores it into m 	*/
+/* the permutation of rows is stored in vector <index> to use with	*/
+/* the function RbfLUBksb for solving linear equations.			*/
+/* (Algorithm taken from 'Numerical Recipts')				*/
+/* returns 1 if succesfull, 0 if singular matrix, negative if kernel	*/
+/* error								*/
+/************************************************************************/
+
+static int RbfLUDcmp(RbfFloatMatrix *m, int *indx)
+{
+	register float		sum;
+	register float		dum;
+	register float		big;
+	register int		i, j, k, imax;
+	register float		temp;
+	register float		*vv;
+
+	if ((vv = (float *) malloc(m -> rows * sizeof(float))) == NULL)
+	{
+	    ErrMess("RbfLUDcmp: impossible to allocate helpmatrix.\n");
+	    return KRERR_INSUFFICIENT_MEM;
+	}
+
+	for (i = 0; i < m -> rows; i++)
+	{
+	    big = 0.0;
+	    for (j = 0; j < m -> rows; j++)
+	    {
+		if ((temp = fabs(RbfMatrixGetValue(m, i, j))) > big)
+		    big = temp;
+	    }
+	    if (big == 0.0)
+	    {
+		free(vv);
+		return 0;
+	    }
+	    vv[i] = 1.0/big;
+	}
+	for (j = 0; j < m -> rows; j++)
+	{
+	    for (i = 0; i < j; i++)
+	    {
+		sum = RbfMatrixGetValue(m, i, j);
+		for (k = 0; k < i; k++)
+		    sum -= RbfMatrixGetValue(m, i, k) *
+			   RbfMatrixGetValue(m, k, j);
+		RbfMatrixSetValue(m, i, j, sum);
+	    }
+	    big = 0.0;
+	    for (i = j; i < m -> rows; i++)
+	    {
+		sum = RbfMatrixGetValue(m, i, j);
+		for (k = 0; k < j; k++)
+		    sum -= RbfMatrixGetValue(m, i, k) *
+			   RbfMatrixGetValue(m, k, j);
+		RbfMatrixSetValue(m, i, j, sum);
+		if ((dum = vv[i] * fabs(sum)) >= big)
+		{
+		    big = dum;
+		    imax = i;
+		}
+	    }
+	    if (j != imax)
+	    {
+		for (k = 0; k < m -> rows; k++)
+		{
+		    dum = RbfMatrixGetValue(m, imax, k);
+		    RbfMatrixSetValue(m, imax, k, 
+			RbfMatrixGetValue(m, j, k));
+		    RbfMatrixSetValue(m, j, k, dum);
+		}
+		dum = vv[imax];
+		vv[imax] = vv[j];
+		vv[j] = dum;
+	    }
+	    indx[j] = imax;
+	    if (RbfMatrixGetValue(m, j, j) == 0.0)
+	    {
+		fprintf(stderr,"RbfLUDcmp: seems to be a singular matrix\n");
+		free(vv);
+		return 0;
+	    }
+	    if (j != (m -> rows - 1))
+	    {
+		dum = 1.0/RbfMatrixGetValue(m, j, j);
+		for (i = j+1; i < m -> rows; i++)
+		    RbfMatrixSetValue(m, i, j,
+			RbfMatrixGetValue(m, i, j) * dum);
+	    }
+	}
+	free(vv);
+	return 1;
+}
+
+/************************************************************************/
+/* function RbfLUBksb							*/
+/* solves the linear equation LU*x = b, where LU is placed in m using   */
+/* the algorithm RbfLUDcmp. b is replaced by the solution x.		*/
+/************************************************************************/
+
+static void RbfLUBksb(RbfFloatMatrix *m, int *indx, float *b)
+{
+	register float	sum;
+	register int	i, ii=0, ip, j;
+
+	for (i = 0; i < m -> rows; i++)
+	{
+	    ip = indx[i];
+	    sum = b[ip];
+	    b[ip] = b[i];
+	    if (ii)
+	    {
+		for (j = ii-1; j < i; j++)
+		    sum -= RbfMatrixGetValue(m, i, j) * b[j];
+	    }
+	    else if (sum != 0.0)
+		ii = i+1;
+	    b[i] = sum;
+	}
+	for (i = (m -> rows - 1); i >= 0; i--)
+	{
+	    sum = b[i];
+	    for (j = i+1; j < m -> rows; j++)
+		sum -= RbfMatrixGetValue(m, i, j) * b[j];
+	    b[i] = sum / RbfMatrixGetValue(m, i, i);
+	}
+	
+}
+
+/************************************************************************/
+/* function RbfInvMatrix:						*/
+/* set m to inverse of m (m = m^-1).					*/
+/* returns 0 if impossible, 1 otherwise, negative if kernel error	*/
+/* This function makes use of the Gauss-Jordan algorithm, which devides */
+/* the matrix m into two triangular matrixes m = l*r. m needs to be not */
+/* singulary! (Algorithm taken from "Numerical Recipts")		*/
+/************************************************************************/
+
+int	RbfInvMatrix(RbfFloatMatrix *m)
+{
+	register 	int	i, j;
+	register	int	*indx;
+	register	float	*b;
+	register	int	tmp_err;
+	RbfFloatMatrix	help;
+
+#ifdef	DEBUG_MODE
+	if (m -> rows != m -> columns)
+	    ErrMess("RbfInvMatrix: matrix not of form N x N.\n");
+#endif
+
+	if (!RbfAllocMatrix(m -> rows, m -> rows, &help) ||
+	    (indx = (int *) malloc(m -> rows * sizeof(int))) == NULL ||
+	    (b = (float *) malloc(m -> rows * sizeof(float))) == NULL)
+	{
+	    ErrMess("RbfInvMatrix: impossible to allocate helpmatrix.\n");
+	    return KRERR_INSUFFICIENT_MEM;
+	}
+
+	RbfSetMatrix(&help, m);
+	if ((tmp_err = RbfLUDcmp(&help, indx)) != 1)
+	{
+	    free(b);
+	    free(indx);
+	    RbfFreeMatrix(&help);
+	    return tmp_err;
+	}
+
+	for (j = 0; j < m -> rows; j++)
+	{
+	    for (i = 0; i < m -> rows; i++)
+		b[i] = 0.0;
+	    b[j] = 1.0;
+	    RbfLUBksb(&help, indx, b);
+	    for (i = 0; i < m -> rows; i++)
+		RbfMatrixSetValue(m, i, j, b[i]);
+	}
+
+	free(b);
+	free(indx);
+	RbfFreeMatrix(&help);
+
+	return 1;
+}
+
+#else
+
+/************************************************************************/
+/* function RbfInvMatrix:						*/
+/* set m to inverse of m (m = m^-1).					*/
+/* returns 0 if impossible, 1 otherwise, negative if kernel error	*/
+/* This function makes use of the Gauss-Jordan algorithm, which devides */
+/* the matrix m into two triangular matrixes m = l*r. m needs to be not */
+/* singulary! (Algorithm taken from "Stoer: Numerische Mathematik 1")	*/
+/************************************************************************/
+
+int	RbfInvMatrix(m)
+RbfFloatMatrix	*m;
+{
+	RbfFloatMatrix	help;
+	int		i, j, r, k, n;
+	float		max, hr, hi;
+
+#ifdef	DEBUG_MODE
+	if (m -> rows != m -> columns)
+	    ErrMess("RbfInvMatrix: matrix not of form N x N.\n");
+#endif
+
+	n = m -> rows;			/* n = dimension of matrix	*/
+
+	/* allocate helpmatrix: 0. row: field p[N] of algorithm		*/
+	/*			1. row: field hv[N] of algorithm	*/
+
+	if (!RbfAllocMatrix(2, n, &help))
+	{
+	    ErrMess("RbfInvMatrix: impossible to allocate helpmatrix.\n");
+	    return KRERR_INSUFFICIENT_MEM;
+	}
+
+	/* initialize permutation field:				*/
+ 
+	for (j = 0; j < n; j++)
+	    RbfMatrixSetValue(&help, 0, j, (float) j);
+
+	/* invert matrix:						*/
+	/* notation in comments: m[r,c] means element at row r column c */
+
+	for (j = 0; j < n; j++)
+	{
+	    /* looking for pivot:					*/
+	    /* find row r, where r >= j and m[r,j] is maximal		*/
+
+	    max = fabs(RbfMatrixGetValue(m, j, j));
+	    r = j;
+	    for (i = j+1; i < n; i++)
+	    {
+		hi = fabs(RbfMatrixGetValue(m, j, i));
+		if (hi > max)
+		{
+		    max = hi;
+		    r = i;
+		}
+	    }
+
+	    /* test if matrix is singulary:				*/
+	    /* if true, then return directly and report errorcode	*/
+
+	    if (max == 0.0)
+	    {
+		RbfFreeMatrix(&help);
+		return 0;
+	    }
+
+	    /* if r != j (r > j) then switch row r with row j and mark	*/
+	    /* this in helpmatrix:					*/
+
+	    if (r > j)
+	    {
+		for (k = 0; k < n; k++)
+		{
+		    hr = RbfMatrixGetValue(m, j, k);
+		    RbfMatrixSetValue(m, j, k, RbfMatrixGetValue(m, r, k));
+		    RbfMatrixSetValue(m, r, k, hr);
+		}
+		hi = RbfMatrixGetValue(&help, 0, j);
+		RbfMatrixSetValue(&help, 0, j, RbfMatrixGetValue(&help, 0, r));
+		RbfMatrixSetValue(&help, 0, r, hi);
+	    }
+
+	    /* do the transformation:					*/
+
+	    hr = 1.0 / RbfMatrixGetValue(m, j, j);
+	    for (i = 0; i < n; i++)
+	    {
+		RbfMatrixSetValue(m, i, j, hr * RbfMatrixGetValue(m, i, j));
+	    }
+	    RbfMatrixSetValue(m, j, j, hr);
+	    for (k = 0; k < n; k++)
+		if (k != j)
+		{
+		    for (i = 0; i < n; i++)
+			if (i != j)
+			{
+				RbfMatrixSetValue(m, i, k,
+				    RbfMatrixGetValue(m, i, k) -
+				    RbfMatrixGetValue(m, i, j) *
+				    RbfMatrixGetValue(m, j, k));
+			}
+		    RbfMatrixSetValue(m, j, k, 
+			-hr * RbfMatrixGetValue(m, j, k));
+		}
+	}
+
+	/* now switch back the columns:					*/
+
+	for (i = 0; i < n; i++)
+	{
+	    for (k = 0; k < n; k++)
+		RbfMatrixSetValue(&help, 1, 
+		    (int) RbfMatrixGetValue(&help, 0, k),
+		    RbfMatrixGetValue(m, i, k));
+	    for (k = 0; k < n; k++)
+		RbfMatrixSetValue(m, i, k,
+		    RbfMatrixGetValue(&help, 1, k));
+	}
+
+	/* report success:						*/
+
+	RbfFreeMatrix(&help);
+	return 1;
+}
+
+#endif
+
+/************************************************************************/
+/* function RbfMulTranspMatrix:						*/
+/* set m1 to m2*m2T. number of rows of m2 must be equal to number of    */
+/* rows and columns of m1.                                              */
+/************************************************************************/
+
+void	RbfMulTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2)
+{
+    int	dest_c;
+    int	dest_r;
+    int	count;
+    register float scalar_product;
+
+#ifdef	DEBUG_MODE
+	if (m2 -> rows != m1 -> rows ||
+	    m2 -> rows != m1 -> columns)
+	{
+		ErrMess("RbfMulTranspMatrix: incompatible matrixes.\n");
+	}
+#endif
+
+    /* notice that m2*m2T is a symmetric matrix!                        */
+
+    for (dest_r = 0; dest_r < m1 -> rows; dest_r++)
+    {
+	for (dest_c = dest_r; dest_c < m1 -> rows; dest_c++)
+	{
+	    scalar_product = 0.0;
+	    for (count = 0; count < m2 -> columns; count++)
+	    {
+		scalar_product += RbfMatrixGetValue(m2, dest_r, count) *
+			          RbfMatrixGetValue(m2, dest_c, count);
+	    }
+	    RbfMatrixSetValue(m1, dest_r, dest_c, scalar_product);
+	    if (dest_r != dest_c)
+		RbfMatrixSetValue(m1, dest_c, dest_r, scalar_product);
+	}
+    }
+}
+
+/************************************************************************/
+/* function RbfMulMatrix:						*/
+/* set m1 to m2*m3. number of columns of m2 must be equal to number of  */
+/* rows of m3. m1 must be allocated with r = number of rows of m2 and   */
+/* c = number of columns of m3.						*/
+/************************************************************************/
+
+void	RbfMulMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3)
+{
+	int	dest_c;
+	int	dest_r;
+	int	count;
+
+#ifdef	DEBUG_MODE
+	if (m1 -> rows != m2 -> rows ||
+	    m1 -> columns != m3 -> columns ||
+	    m2 -> columns != m3 -> rows)
+	{
+		ErrMess("RbfMulMatrix: incompatible matrixes.\n");
+	}
+#endif
+
+	/* This seems to be a strange way to multiply two matrices but  */
+	/* it prevents the swapper from trashing:                       */
+
+	RbfClearMatrix(m1, 0.0);
+
+	for (dest_r = 0; dest_r < m1 -> rows; dest_r++)
+	{
+	    for (count = 0; count < m2 -> columns; count++)
+	    {
+		for (dest_c = 0; dest_c < m1 -> columns; dest_c++)
+		    RbfMatrixSetValue(m1, dest_r, dest_c,
+			    RbfMatrixGetValue(m2, dest_r, count) *
+			    RbfMatrixGetValue(m3, count, dest_c) +
+			    RbfMatrixGetValue(m1, dest_r, dest_c));
+	    }
+	}
+}
+
+/************************************************************************/
+/* set m1 to m2+m3. number of columns of m1, m2 and m3 must be equal.	*/
+/* number of rows of m1, m2 and m3 must be equal.			*/
+/************************************************************************/
+
+void	RbfAddMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3)
+{
+	int	dest_c;
+	int	dest_r;
+
+#ifdef	DEBUG_MODE
+	if (!(m1 -> rows == m2 -> rows &&
+	      m2 -> rows == m3 -> rows) ||
+	    !(m1 -> columns == m2 -> columns &&
+	      m2 -> columns == m3 -> columns)
+	   )
+	{
+		ErrMess("RbfAddMatrix: incompatible matrixes.\n");
+	}
+#endif
+
+	for (dest_r = 0; dest_r < m1 -> rows; dest_r++)
+	    for (dest_c = 0; dest_c < m1 -> columns; dest_c++)
+		RbfMatrixSetValue(m1, dest_r, dest_c,
+		    RbfMatrixGetValue(m2, dest_r, dest_c) +
+		    RbfMatrixGetValue(m3, dest_r, dest_c));
+}
+
+/************************************************************************/
+/* function RbfPrintMatrix:						*/
+/* print out matrix m to stream (file) s				*/
+/************************************************************************/
+
+void	RbfPrintMatrix(RbfFloatMatrix *m, FILE *s)
+{
+	int	r;
+	int	c;
+
+	for (r = 0; r < m -> rows; r++)
+	{
+		for (c = 0; c < m -> columns; c++)
+			fprintf(s, "%.4e ",RbfMatrixGetValue(m, r, c));
+		fprintf(s,"\n");
+	}
+}
+
+/************************************************************************/
+/* function ErrMess:                                                    */
+/* print message to stderr			                        */
+/************************************************************************/
+
+void    ErrMess(char *message)
+{
+        fprintf(stderr, "%s", message);
+}
+
+/************************************************************************/
+/* end of file								*/
+/************************************************************************/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/matrix.h snort-2.3.3.new/src/kernel_snns/matrix.h
--- snort-2.3.3/src/kernel_snns/matrix.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/matrix.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,159 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/matrix.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel standard matrix operations
+  NOTES          :
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.02.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:28 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef	_RBF_MATRIX_DEFINED_
+#define _RBF_MATRIX_DEFINED_
+
+
+/************************************************************************/
+/* type definitions:							*/
+/************************************************************************/
+
+typedef struct
+{
+	int	rows;		/* number of rows			*/
+	int	columns;	/* number of columns			*/
+	float	*field;		/* matrix organized as list		*/
+	float	**r_pt;		/* array of references to rows		*/
+} RbfFloatMatrix;
+
+/************************************************************************/
+/* allocate matrix m with r rows and c columns				*/
+/* returns 0 if impossible, 1 otherwise					*/
+/************************************************************************/
+
+extern int	RbfAllocMatrix(int r, int c, RbfFloatMatrix *m);
+
+/************************************************************************/
+/* deallocate matrix m							*/
+/************************************************************************/
+
+extern void	RbfFreeMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* set all elements of matrix m to value c				*/
+/************************************************************************/
+
+extern void	RbfClearMatrix(RbfFloatMatrix *m, double c);
+
+/************************************************************************/
+/* returns the square norm of  matrix m            		     	*/
+/************************************************************************/
+
+extern float	RbfSquareOfNorm(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* sets m to the idempotent matrix           				*/
+/************************************************************************/
+
+extern void	RbfIdempotentMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* multiplies matrix m with a constant factor  				*/
+/************************************************************************/
+
+extern void	RbfMulScalarMatrix(RbfFloatMatrix *m, float a);
+
+/************************************************************************/
+/* set m1 to m2 (m1 = m2). m1 must be allocated with the same		*/
+/* dimensions as m2							*/
+/************************************************************************/
+
+extern void	RbfSetMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m1 to m2 transposed (m1 = m2T)					*/
+/* number of rows of m1 must be equal to number of columns of m2.	*/
+/* number of columns of m1 must be equal to number of rows of m2.	*/
+/************************************************************************/
+
+extern void	RbfTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m to inverse of m (m = m^-1).					*/
+/* returns 0 if impossible, 1 otherwise, negative if kernel error	*/
+/************************************************************************/
+
+extern int	RbfInvMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* function RbfMulTranspMatrix:						*/
+/* set m1 to m2*m2T. number of rows of m2 must be equal to number of    */
+/* rows and columns of m1.                                              */
+/************************************************************************/
+
+extern void	RbfMulTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m1 to m2*m3. number of columns of m2 must be equal to number of  */
+/* rows of m3. m1 must be allocated with r = number of rows of m2 and   */
+/* c = number of columns of m3.						*/
+/************************************************************************/
+
+extern void	RbfMulMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3); 
+
+/************************************************************************/
+/* set m1 to m2+m3. number of columns of m1, m2 and m3 must be equal.	*/
+/* number of rows of m1, m2 and m3 must be equal.			*/
+/************************************************************************/
+
+extern void	RbfAddMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3); 
+
+/************************************************************************/
+/* print out matrix m to stream (file) s				*/
+/************************************************************************/
+
+extern void	RbfPrintMatrix(RbfFloatMatrix *m, FILE *s);
+
+/************************************************************************/
+/* print message to stderr			                        */
+/************************************************************************/
+
+extern void    ErrMess(char *message);
+
+/************************************************************************/
+/* macro definitions							*/
+/************************************************************************/
+
+/************************************************************************/
+/* set element at row r and column c in matrix referenced by m to the   */
+/* value of v. r goes from 0 to rows -1, c goes from 0 to columns -1    */
+/************************************************************************/
+
+#define	RbfMatrixSetValue(m, r, c, v)	((m)->r_pt)[r][c] = v
+
+/************************************************************************/
+/* get value of element at row r and column c in matrix referenced by m.*/
+/* r goes from 0 to rows -1, c goes from 0 to columns -1		*/
+/************************************************************************/
+
+#define RbfMatrixGetValue(m, r, c)	(((m) -> r_pt)[r][c])
+
+
+
+#endif
+
+
+
+
+
+
+
+/* 141 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/matrix.ph snort-2.3.3.new/src/kernel_snns/matrix.ph
--- snort-2.3.3/src/kernel_snns/matrix.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/matrix.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,165 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/matrix.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel standard matrix operations
+  NOTES          :
+
+  AUTHOR         : Michael Vogt
+  DATE           : 10.02.92
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:29 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#ifndef	_RBF_MATRIX_DEFINED_
+#define _RBF_MATRIX_DEFINED_
+
+/* begin global definition section */
+
+/************************************************************************/
+/* type definitions:							*/
+/************************************************************************/
+
+typedef struct
+{
+	int	rows;		/* number of rows			*/
+	int	columns;	/* number of columns			*/
+	float	*field;		/* matrix organized as list		*/
+	float	**r_pt;		/* array of references to rows		*/
+} RbfFloatMatrix;
+
+/************************************************************************/
+/* allocate matrix m with r rows and c columns				*/
+/* returns 0 if impossible, 1 otherwise					*/
+/************************************************************************/
+
+int	RbfAllocMatrix(int r, int c, RbfFloatMatrix *m);
+
+/************************************************************************/
+/* deallocate matrix m							*/
+/************************************************************************/
+
+void	RbfFreeMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* set all elements of matrix m to value c				*/
+/************************************************************************/
+
+void	RbfClearMatrix(RbfFloatMatrix *m, double c);
+
+/************************************************************************/
+/* returns the square norm of  matrix m            		     	*/
+/************************************************************************/
+
+float	RbfSquareOfNorm(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* sets m to the idempotent matrix           				*/
+/************************************************************************/
+
+void	RbfIdempotentMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* multiplies matrix m with a constant factor  				*/
+/************************************************************************/
+
+void	RbfMulScalarMatrix(RbfFloatMatrix *m, float a);
+
+
+/************************************************************************/
+/* set m1 to m2 (m1 = m2). m1 must be allocated with the same		*/
+/* dimensions as m2							*/
+/************************************************************************/
+
+void	RbfSetMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m1 to m2 transposed (m1 = m2T)					*/
+/* number of rows of m1 must be equal to number of columns of m2.	*/
+/* number of columns of m1 must be equal to number of rows of m2.	*/
+/************************************************************************/
+
+void	RbfTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m to inverse of m (m = m^-1).					*/
+/* returns 0 if impossible, 1 otherwise, negative if kernel error	*/
+/************************************************************************/
+
+int	RbfInvMatrix(RbfFloatMatrix *m);
+
+/************************************************************************/
+/* function RbfMulTranspMatrix:						*/
+/* set m1 to m2*m2T. number of rows of m2 must be equal to number of    */
+/* rows and columns of m1.                                              */
+/************************************************************************/
+
+void	RbfMulTranspMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2);
+
+/************************************************************************/
+/* set m1 to m2*m3. number of columns of m2 must be equal to number of  */
+/* rows of m3. m1 must be allocated with r = number of rows of m2 and   */
+/* c = number of columns of m3.						*/
+/************************************************************************/
+
+void	RbfMulMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3); 
+
+/************************************************************************/
+/* set m1 to m2+m3. number of columns of m1, m2 and m3 must be equal.	*/
+/* number of rows of m1, m2 and m3 must be equal.			*/
+/************************************************************************/
+
+void	RbfAddMatrix(RbfFloatMatrix *m1, RbfFloatMatrix *m2, RbfFloatMatrix *m3); 
+
+/************************************************************************/
+/* print out matrix m to stream (file) s				*/
+/************************************************************************/
+
+void	RbfPrintMatrix(RbfFloatMatrix *m, FILE *s);
+
+/************************************************************************/
+/* print message to stderr			                        */
+/************************************************************************/
+
+void    ErrMess(char *message);
+
+/************************************************************************/
+/* macro definitions							*/
+/************************************************************************/
+
+/************************************************************************/
+/* set element at row r and column c in matrix referenced by m to the   */
+/* value of v. r goes from 0 to rows -1, c goes from 0 to columns -1    */
+/************************************************************************/
+
+#define	RbfMatrixSetValue(m, r, c, v)	((m)->r_pt)[r][c] = v
+
+/************************************************************************/
+/* get value of element at row r and column c in matrix referenced by m.*/
+/* r goes from 0 to rows -1, c goes from 0 to columns -1		*/
+/************************************************************************/
+
+#define RbfMatrixGetValue(m, r, c)	(((m) -> r_pt)[r][c])
+
+/* end global definition section */
+
+/* begin private definition section */
+
+#define RBF_MATRIX_LUDCOMP	1
+
+/* end private definition section */
+
+#endif
+
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/memcmp.c snort-2.3.3.new/src/kernel_snns/memcmp.c
--- snort-2.3.3/src/kernel_snns/memcmp.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/memcmp.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,37 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/memcmp.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : memcmp function
+  NOTES          : 
+
+  AUTHOR         : Michael Vogt
+  DATE           : 2.3.98
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.3 $
+  LAST CHANGE    : $Date: 1998/03/03 17:54:30 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <string.h>
+
+int memcmp(const void *s1, const void *s2, size_t n)
+{
+    unsigned const char *p1 = s1;
+    unsigned const char *p2 = s2;
+
+    while (n>0 && *p1 == *p2)
+    {
+	p1++;
+	p2++;
+	n--;
+    }
+
+    return (n>0) ? ((*p1 < *p2) ? -1 : 1) : 0;
+}
diff -Naur snort-2.3.3/src/kernel_snns/prun_f.c snort-2.3.3.new/src/kernel_snns/prun_f.c
--- snort-2.3.3/src/kernel_snns/prun_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/prun_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1702 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/prun_f.c,v $
+  SHORTNAME      : prun_f.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : learning functions with pruning algorithms
+  NOTES          :
+
+  AUTHOR         : Tobias Schreiner
+  DATE           : 13.3.94
+
+  CHANGED BY     : Jochen Biedermann, 07.07.94
+                   Thomas Gern, 07.09.95
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/03/13 16:24:01 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"		/* Kernel Types and Constants  */
+#include "kr_const.h"		/* Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"		/* Default Values  */
+#include "kernel.h"		/* kernel function prototypes  */
+#include "kr_mac.h"		/* Kernel Macros   */
+#include "glob_typ.h"
+#include "kr_funcs.h"
+#include "kr_newpattern.h"
+#include "matrix.h"
+#include "learn_f.h"
+
+#include "prun_f.ph"
+
+
+/*****************************************************************************
+
+  GROUP: General Functions
+
+******************************************************************************/
+
+
+
+/*****************************************************************************
+  FUNCTION : pr_setInputPruning
+  PURPOSE  : updates input pruning flag
+
+  RETURNS  : void
+  NOTES    : 
+  UPDATE   :
+******************************************************************************/
+
+void pr_setInputPruning (int value)
+{
+    pr_inputPruning = value;
+}
+
+/*****************************************************************************
+  FUNCTION : pr_setHiddenPruning
+  PURPOSE  : updates hidden pruning flag
+
+  RETURNS  : void
+  NOTES    : 
+  UPDATE   :
+******************************************************************************/
+
+void pr_setHiddenPruning (int value)
+{
+    pr_hiddenPruning = value;
+}
+
+/*****************************************************************************
+  FUNCTION : pr_updateNoLinks
+  PURPOSE  : updates values for one connection
+
+  RETURNS  : void
+  NOTES    : called by pr_checkDeadUnits
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_updateNoOfLinks (struct Unit *unit_ptr, struct Link *link_ptr)
+
+{
+
+    if (!IS_SPECIAL_UNIT (link_ptr->to))
+    {
+	/* increment number of outgoing links for source unit */
+	link_ptr->to->value_a++;
+
+	/* increment number of incoming links for target unit */
+	unit_ptr->value_b++;
+    }
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_checkDeadUnits
+  PURPOSE  : deletes/disables dead units in the network
+
+  RETURNS  : void
+  NOTES    : 
+
+  UPDATE   :
+******************************************************************************/
+
+void pr_checkDeadUnits (void)
+
+{
+
+    struct Unit *unit_ptr, *unit_ptr2;
+    struct Site *site_ptr, *site_ptr2;
+    struct Link *link_ptr, *link_ptr2;
+    int unit_deleted;
+
+    FOR_ALL_UNITS (unit_ptr)
+	/* reset special flags */
+	unit_ptr->flags &= ~UFLAG_TTYP_SPEC;
+
+    do
+    {
+        unit_deleted = FALSE;
+
+        /* initialize units */
+        FOR_ALL_UNITS (unit_ptr)
+        {
+	    unit_ptr->value_a = 0; /* outgoing links */
+	    unit_ptr->value_b = 0; /* incoming links */
+        }
+
+        /* count links for each unit */
+        FOR_ALL_UNITS (unit_ptr)
+            if (! IS_SPECIAL_UNIT (unit_ptr))
+                if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+                    FOR_ALL_LINKS (unit_ptr, link_ptr)
+                        /* calculate number of in- and outgoing links */
+                        pr_updateNoOfLinks (unit_ptr, link_ptr);
+                else
+                    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+                        /* calculate number of in- and outgoing links */
+                        pr_updateNoOfLinks (unit_ptr, link_ptr);
+
+        /* delete dead units */
+        FOR_ALL_UNITS (unit_ptr)
+            if (! IS_SPECIAL_UNIT (unit_ptr)
+                && ((IS_INPUT_UNIT (unit_ptr) && pr_inputPruning) || 
+                    (IS_HIDDEN_UNIT (unit_ptr) && pr_hiddenPruning))) 
+            {
+		if (IS_INPUT_UNIT (unit_ptr) && (unit_ptr->value_a == 0))
+                {
+                    /* no outgoing links, disable unit */
+                    unit_ptr->flags |= UFLAG_TTYP_SPEC;
+                    unit_deleted = TRUE;
+                    NetModified = TRUE;
+                }
+
+                if (IS_HIDDEN_UNIT (unit_ptr) &&
+		    ((unit_ptr->value_a == 0) ||
+		     (unit_ptr->value_b == 0)))
+                {
+		    if (unit_ptr->value_b == 0)
+                        /* add output to successors' biases */
+                    {
+                        FOR_ALL_UNITS (unit_ptr2)
+                            if (UNIT_HAS_DIRECT_INPUTS (unit_ptr2))
+                                FOR_ALL_LINKS (unit_ptr2, link_ptr2)
+                                {
+                                    if (link_ptr2->to == unit_ptr)
+                                        unit_ptr2->bias +=   
+                                            (*unit_ptr->act_func) (unit_ptr) 
+						* link_ptr2->weight;
+                                }
+                            else
+                                FOR_ALL_SITES_AND_LINKS
+                                    (unit_ptr2, site_ptr2, link_ptr2)
+					if (link_ptr2->to == unit_ptr)
+					    unit_ptr2->bias +=   
+						(*unit_ptr->act_func) (unit_ptr) 
+						    * link_ptr2->weight;
+                        unit_ptr->bias = 0;
+                        unit_ptr->Out.output = 0;
+                        unit_ptr->act = 0;
+                    }
+
+		    /* delete unit */
+		    kr_removeUnit (unit_ptr);
+		    kr_forceUnitGC ();
+                    unit_deleted = TRUE;
+                    NetModified = TRUE;
+                }
+
+
+		if (IS_OUTPUT_UNIT (unit_ptr) && (unit_ptr->value_b == 0))
+                {
+                    /* unit has no incoming links, disable it */
+                    unit_ptr->flags |= UFLAG_TTYP_SPEC;
+                    unit_deleted = TRUE;
+                    NetModified = TRUE;
+                }
+            }
+    }
+    while (unit_deleted);
+
+}
+
+/*****************************************************************************
+  FUNCTION : pr_calcMeanDeviation
+  PURPOSE  : calculates the mean deviation for each output unit
+
+  RETURNS  : sum error of the net or negative value, if error occurs
+  NOTES    : result is placed value_a
+
+  UPDATE   :
+******************************************************************************/
+
+krui_err pr_calcMeanDeviation (int pattern, float *sum_error)
+
+{
+
+    register struct Unit *unit_ptr;
+    register TopoPtrArray topo_ptr;
+    register Patterns out_pat;
+    int size, pattern_no, sub_pat_no, no_of_patterns;
+    
+    /* initialize sum error */
+    *sum_error = 0.0;
+
+    /* initialize value_a of each unit */
+    FOR_ALL_UNITS (unit_ptr)
+	unit_ptr->value_a = 0;
+
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)
+	/* all patterns */
+	KernelErrorCode = kr_initSubPatternOrder
+	    (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else
+	/* single pattern */
+	KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    /* calculate total number of subpatterns */
+    no_of_patterns = kr_TotalNoOfSubPatPairs ();
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no))
+    {
+	/* calculate address of the output pattern */
+	out_pat = kr_getSubPatData (pattern_no, sub_pat_no, OUTPUT, &size);
+	out_pat += size;
+	
+	/* propagate pattern through net */
+	propagateNetForward (pattern_no, sub_pat_no);
+
+	/* calculate deviation for output units */
+	for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	     unit_ptr = *(topo_ptr--); unit_ptr != NULL;
+	     unit_ptr = *(topo_ptr--))
+	    unit_ptr->value_a += (float) fabs (*(--out_pat) - unit_ptr->Out.output);
+    }
+    
+    /* divide values by total number of pattern */
+    for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	 unit_ptr = *(topo_ptr--); unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+    {
+	*sum_error += unit_ptr->value_a;
+	unit_ptr->value_a /= no_of_patterns;
+    }
+
+    return (KernelErrorCode);
+
+}
+
+
+/*****************************************************************************
+
+  GROUP: Magnitude based pruning
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_mag_processLink
+
+  PURPOSE  : processes one link for Mag
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_mag_processLink (struct Unit *unit_ptr, struct Link *link_ptr)
+
+{
+
+    if ((pr_candidateLink == NULL) ||
+	(abs (link_ptr->weight) < pr_candidateSaliency))
+	/* found first or least important link so far */
+    {
+	pr_candidateTargetUnit = unit_ptr;
+	pr_candidateLink = link_ptr;
+	pr_candidateSaliency = abs (link_ptr->weight);
+    }
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : PRUNE_Mag
+
+  PURPOSE  : performs magnitude based pruning
+             sets global variables 'pr_candidateTargetUnit' and
+	     'pr_candidateLink'
+	     to the smallest weight in the network,
+	     no deletion
+  RETURNS  :
+  NOTES    : 'pr_candidateTargetUnit' and 'pr_candidateLink' must be set to
+             NULL before calling this function
+
+  UPDATES  :
+*****************************************************************************/
+
+krui_err PRUNE_Mag (int pattern)
+
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+
+    FOR_ALL_UNITS (unit_ptr)
+	/* process links to all units */
+	if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+	    /* unit has direct inputs */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+		pr_mag_processLink (unit_ptr, link_ptr);
+	else
+	    /* unit has sites */
+	    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		pr_mag_processLink (unit_ptr, link_ptr);
+
+    return (KernelErrorCode);
+
+}
+
+
+/*****************************************************************************
+
+  GROUP: Optimal Brain Damage
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_obd_processLink
+
+  PURPOSE  : processes one link for OBD
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obd_processLink (struct Unit *unit_ptr, struct Link *link_ptr,
+				float delta, float delta2)
+
+{
+
+    float bp_delta2;
+
+    /* calculate saliency of link */
+    bp_delta2 = delta2 * link_ptr->weight * link_ptr->weight;
+    link_ptr->value_a +=
+	bp_delta2 * link_ptr->to->Out.output * link_ptr->to->Out.output;
+
+    /* propagate initial values back */
+    link_ptr->to->value_a += delta * link_ptr->weight;
+    link_ptr->to->value_b += bp_delta2;
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obd_checkLink
+
+  PURPOSE  : check saliency of one link for OBD
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obd_checkLink (struct Unit *unit_ptr, struct Link *link_ptr)
+
+{
+
+    /* check, if saliency smallest so far */
+    if ((pr_candidateLink == NULL) || 
+	(link_ptr->value_a < pr_candidateSaliency))
+    {
+	pr_candidateTargetUnit = unit_ptr;
+	pr_candidateLink = link_ptr;
+	pr_candidateSaliency = link_ptr->value_a;
+    }
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : PRUNE_OBD
+
+  PURPOSE  : performs pruning according to Optimal Brain Damage,
+             sets global variables 'pr_candidateTargetUnit' and
+	     'pr_candidateLink',
+	     no deletion
+  RETURNS  :
+  NOTES    : 'pr_candidateTargetUnit' and 'pr_candidateLink' must be set to
+             NULL before calling this function
+
+  UPDATE   :
+******************************************************************************/
+
+krui_err PRUNE_OBD (int pattern)
+
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray topo_ptr;
+    register Patterns out_pat;
+    register float deriv, delta, delta2, devit;
+    int size, pattern_no, sub_pat_no;
+
+    /* reset auxiliary variables in unit array */
+    FOR_ALL_UNITS (unit_ptr)
+    {
+	unit_ptr->value_a = 0.0;
+	unit_ptr->value_b = 0.0;
+
+	if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+	    /* unit has direct inputs */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+		link_ptr->value_a = 0.0;
+	else
+	    /* unit has sites */
+	    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		link_ptr->value_a = 0.0;
+    }
+
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)
+	/* all patterns */
+	KernelErrorCode = kr_initSubPatternOrder
+	    (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else
+	/* single pattern */
+	KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no))
+    {
+	/* propagate input pattern through net */
+	propagateNetForward (pattern_no, sub_pat_no);
+
+	/* calculate address of the output pattern */
+	out_pat = kr_getSubPatData (pattern_no, sub_pat_no, OUTPUT, &size);
+	out_pat += size;
+
+	/* calculate all output units */
+	for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	     unit_ptr = *(topo_ptr--); unit_ptr != NULL;
+	     unit_ptr = *(topo_ptr--))
+	{
+	    devit = (unit_ptr->Out.output - *(--out_pat));
+	    deriv = (unit_ptr->act_deriv_func) (unit_ptr);
+
+	    delta = deriv * devit;
+	    delta2 = devit * (unit_ptr->act_2_deriv_func) (unit_ptr)
+		+ deriv * deriv;
+	    
+	    /* process all links to that unit */
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    pr_obd_processLink (unit_ptr, link_ptr, delta, delta2);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    pr_obd_processLink (unit_ptr, link_ptr, delta, delta2);
+	}
+	
+	/* calculate all hidden units */
+	for (unit_ptr = *(topo_ptr--);
+	     (unit_ptr != NULL);
+	     unit_ptr = *(topo_ptr--))
+	{
+	    /* calculate deltas for unit */
+	    deriv = (unit_ptr->act_deriv_func) (unit_ptr);
+	    delta = deriv * unit_ptr->value_a;
+	    delta2 =
+		unit_ptr->value_a * (unit_ptr->act_2_deriv_func) (unit_ptr)
+		    + unit_ptr->value_b * deriv * deriv;
+	    
+	    /* process all links to that unit */
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    pr_obd_processLink (unit_ptr, link_ptr, delta, delta2);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    pr_obd_processLink (unit_ptr, link_ptr, delta, delta2);
+	}
+    }
+
+    /* measure least saliency */
+    FOR_ALL_UNITS (unit_ptr)
+	/* check all links to that unit */
+	if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+	    /* unit has direct inputs */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+		pr_obd_checkLink (unit_ptr, link_ptr);
+	else
+	    /* unit has sites */
+	    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		pr_obd_checkLink (unit_ptr, link_ptr);
+
+    return (KernelErrorCode);
+
+}
+
+
+/*****************************************************************************
+
+  GROUP: Optimal Brain Surgeon
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_setInitParameter
+
+  PURPOSE  : set init parameter for obs
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+void pr_obs_setInitParameter (float param)
+
+{
+
+    pr_obs_initParameter = param;
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_countLinks
+
+  PURPOSE  : count links, result in global variable 'pr_noOfLinks'
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obs_countLinks ()
+
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+
+    /* initialize global variable */
+    pr_noOfLinks = 0;
+
+    FOR_ALL_UNITS (unit_ptr)
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		{
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_noOfLinks++;
+		}
+	    else
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_noOfLinks++;
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_calculateDerivative
+
+  PURPOSE  : calculate the derivative for one link and propagate
+             derivative information back
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obs_calculateDerivative (struct Link *link_ptr,
+					float help, int weight_no)
+
+{
+
+    RbfMatrixSetValue
+	(&pr_derivVector, 0, weight_no, link_ptr->to->Out.output * help);
+    link_ptr->to->value_a += link_ptr->weight * help;
+
+}
+
+/*****************************************************************************
+  FUNCTION : pr_obs_calculateDerivVector
+
+  PURPOSE  : calculate the derivative vector for certain output unit
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obs_calculateDerivVector (struct Unit *output_unit)
+
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray topo_ptr;
+    float help;
+    int weight_no = 0;
+
+    /* initialize units */
+    FOR_ALL_UNITS (unit_ptr)
+	unit_ptr->value_a = 0.0;
+
+    /* process output units */
+    for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	 unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	{
+	    if (unit_ptr == output_unit)
+		help = (*unit_ptr->act_deriv_func) (unit_ptr);
+	    else
+		help = 0;
+
+	    if (UNIT_HAS_DIRECT_INPUTS (unit_ptr))
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			/* calculate derivative and propagate information back */
+			pr_obs_calculateDerivative (link_ptr, help, weight_no++);
+	    else
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			/* calculate derivative and propagate information back */
+			pr_obs_calculateDerivative (link_ptr, help, weight_no++);
+	}
+
+    /* process hidden units */
+    for (unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	{
+	    help = (*unit_ptr->act_deriv_func) (unit_ptr) *
+		unit_ptr->value_a;
+	    if (UNIT_HAS_DIRECT_INPUTS (unit_ptr))
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			/* calculate derivative and propagate information back */
+			pr_obs_calculateDerivative (link_ptr, help, weight_no++);
+	    else
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			/* calculate derivative and propagate information back */
+			pr_obs_calculateDerivative (link_ptr, help, weight_no++);
+	}
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_updateInverseHessian
+
+  PURPOSE  : add the next step to the inverse Hessian
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static krui_err pr_obs_updateInverseHessian (int no_of_patterns)
+
+{
+
+    float hx, xh, denominator, factor;
+    int i, j;
+
+    /* calculate pr_helpHX, pr_helpXH and denominator */
+    denominator = (float) no_of_patterns;
+    for (i = 0; i < pr_noOfLinks; i++)
+    {
+	hx = 0.0;
+	xh = 0.0;
+
+	for (j = 0 ; j < pr_noOfLinks; j++)
+	{
+	    hx += RbfMatrixGetValue (&pr_inverseHessian, i, j) *
+		RbfMatrixGetValue (&pr_derivVector, 0, j);
+	    xh += RbfMatrixGetValue (&pr_derivVector, 0, j) *
+		RbfMatrixGetValue (&pr_inverseHessian, j, i);
+	}
+
+	RbfMatrixSetValue (&pr_helpHX, 0, i, hx);
+	RbfMatrixSetValue (&pr_helpXH, 0, i, xh);
+	denominator += RbfMatrixGetValue (&pr_derivVector, 0, i) * hx;
+    }
+
+    /* calculate new Hessian matrix */
+    for (i = 0; i < pr_noOfLinks; i++)
+    {
+	factor = RbfMatrixGetValue (&pr_helpHX, 0, i) / denominator;
+	for (j = 0; j < pr_noOfLinks; j++)
+	    RbfMatrixSetValue
+		(&pr_inverseHessian, i, j,
+		 RbfMatrixGetValue (&pr_inverseHessian, i, j) -
+		 RbfMatrixGetValue (&pr_helpXH, 0, j) *
+		 factor);
+    }
+
+    return (KernelErrorCode);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_calculateInverseHessian
+
+  PURPOSE  : calculate the inverse Hessian matrix of the network
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static krui_err pr_obs_calculateInverseHessian (int pattern)
+
+{
+
+    register struct Unit *unit_ptr;
+    register TopoPtrArray topo_ptr;
+    int no_of_patterns, pattern_no, sub_pat_no, i;
+
+    /* initialize matrix */
+    RbfClearMatrix (&pr_inverseHessian, 0.0);
+    for (i = 0; i < pr_noOfLinks; i++)
+	/* diagonal elements are set */
+	RbfMatrixSetValue (&pr_inverseHessian, i, i, 1/pr_obs_initParameter);
+
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)
+	/* all patterns */
+	KernelErrorCode = kr_initSubPatternOrder
+	    (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else
+	/* single pattern */
+	KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    /* calculate total number of subpatterns */
+    no_of_patterns = kr_TotalNoOfSubPatPairs ();
+
+    /* add up inverse Hessian for each (sub-)pattern */
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no))
+    {
+	/* propagate pattern through net */
+	propagateNetForward (pattern_no, sub_pat_no);
+
+	/* add up inverse Hessian for each output unit */
+	for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	     unit_ptr = *(topo_ptr--);
+	     unit_ptr != NULL;
+	     unit_ptr = *(topo_ptr--))
+	{
+	    /* calculate derivative vector for output unit */
+	    pr_obs_calculateDerivVector (unit_ptr);
+
+	    /* add this step to inverse Hessian */
+	    KernelErrorCode =
+		pr_obs_updateInverseHessian (no_of_patterns);
+	    if (KernelErrorCode != KRERR_NO_ERROR)
+		return (KernelErrorCode);
+	}
+    }
+
+    return (KernelErrorCode);
+
+}
+
+/*****************************************************************************
+  FUNCTION : pr_obs_processLink
+
+  PURPOSE  : process one link for OBS
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obs_processLink (struct Unit *unit_ptr,
+				struct Link *link_ptr,
+				int weight_no)
+
+{
+
+    float double_saliency;
+
+    /* calculate saliency of link */
+    double_saliency = link_ptr->weight * link_ptr->weight /
+	RbfMatrixGetValue (&pr_inverseHessian, weight_no, weight_no);
+
+    if ((pr_candidateLink == NULL) ||
+	(double_saliency < pr_candidateSaliency))
+	/* found first or least important link so far */
+    {
+	pr_candidateTargetUnit = unit_ptr;
+	pr_candidateLink = link_ptr;
+	pr_candidateSaliency = double_saliency;
+	pr_candidateLinkNo = weight_no;
+    }
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_obs_updateLink
+
+  PURPOSE  : update one link for OBS
+  RETURNS  :
+  NOTES    :
+
+  UPDATE   :
+******************************************************************************/
+
+static void pr_obs_updateLink (struct Link *link_ptr,
+			       float update_const,
+			       int weight_no)
+
+{
+
+    link_ptr->weight -= update_const *
+	RbfMatrixGetValue (&pr_inverseHessian, weight_no, pr_candidateLinkNo);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : PRUNE_OBS
+
+  PURPOSE  : performs pruning according to Optimal Brain Surgeon,
+             sets global variables 'pr_candidateTargetUnit' and
+	     'pr_candidateLink',
+	     no deletion
+  RETURNS  :
+  NOTES    : 'pr_candidateTargetUnit' and 'pr_candidateLink' must be set to
+             NULL before calling this function
+
+  UPDATE   :
+******************************************************************************/
+
+krui_err PRUNE_OBS (int pattern)
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray topo_ptr;
+    float update_const;
+    int err, link_no;
+
+    /* count links */
+    pr_obs_countLinks ();
+
+    /* create inverse Hessian matrix */
+    err = RbfAllocMatrix (pr_noOfLinks, pr_noOfLinks, &pr_inverseHessian);
+    if (err == 0)
+	/* matrix didn't fit into memory */
+    {
+	KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	return (KernelErrorCode);
+    }
+
+    /* create derivative vector */
+    err = RbfAllocMatrix (1, pr_noOfLinks, &pr_derivVector);
+    if (err == 0)
+	/* vector didn't fit into memory */
+    {
+	KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	return (KernelErrorCode);
+    }
+
+    /* create auxiliary vectors */
+    err = RbfAllocMatrix (1, pr_noOfLinks, &pr_helpHX);
+    if (err == 0)
+	/* vector didn't fit into memory */
+    {
+	KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	return (KernelErrorCode);
+    }
+    err = RbfAllocMatrix (1, pr_noOfLinks, &pr_helpXH);
+    if (err == 0)
+	/* vector didn't fit into memory */
+    {
+	KernelErrorCode = KRERR_INSUFFICIENT_MEM;
+	return (KernelErrorCode);
+    }
+
+    /* calculate inverse Hessian */
+    pr_obs_calculateInverseHessian (pattern);
+
+    /* find link with smallest saliency*/
+    link_no = 0;
+    for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	 unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	/* process links to all output units */
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_processLink (unit_ptr, link_ptr, link_no++);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_processLink (unit_ptr, link_ptr, link_no++);
+
+    for (unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	/* process links to all hidden units */
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_processLink (unit_ptr, link_ptr, link_no++);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_processLink (unit_ptr, link_ptr, link_no++);
+
+    /* calculate auxiliary variable for efficient update of weights */
+    update_const = pr_candidateLink->weight /
+	RbfMatrixGetValue (&pr_inverseHessian, pr_candidateLinkNo,
+			   pr_candidateLinkNo);
+
+    /* update all links */
+    link_no = 0;
+    for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	 unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	/* process links to all output units */
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_updateLink (link_ptr, update_const, link_no++);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_updateLink (link_ptr, update_const, link_no++);
+
+    for (unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--))
+	/* process links to all hidden units */
+	if (!IS_SPECIAL_UNIT (unit_ptr))
+	    if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+		/* unit has direct inputs */
+		FOR_ALL_LINKS (unit_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_updateLink (link_ptr, update_const, link_no++);
+	    else
+		/* unit has sites */
+		FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+		    if (!IS_SPECIAL_UNIT (link_ptr->to))
+			pr_obs_updateLink (link_ptr, update_const, link_no++);
+
+    /* free matrixes */
+    RbfFreeMatrix (&pr_inverseHessian);
+    RbfFreeMatrix (&pr_derivVector);
+    RbfFreeMatrix (&pr_helpXH);
+    RbfFreeMatrix (&pr_helpHX);
+
+    return (KernelErrorCode);
+
+}
+
+
+/*****************************************************************************
+
+  GROUP: Skeletonization
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_skel_processLink
+
+  PURPOSE  : process one link for Skeletonization
+  RETURNS  : void
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+
+static void pr_skel_processLink (struct Unit *unit_ptr, struct Link *link_ptr)
+
+{
+
+    link_ptr->to->value_a += unit_ptr->value_a * link_ptr->weight;
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : pr_skel_check_saliency
+
+  PURPOSE  : update minimum saliency of net
+  RETURNS  : void
+  NOTES    : 
+
+  UPDATE   : Thomas Gern, 07.09.1995
+             - saliency = actbuf[0]
+	     - search for absolute minimum
+******************************************************************************/
+
+static void pr_skel_check_saliency (struct Unit *unit_ptr)
+
+{
+
+    float saliency;
+
+    /* calculate saliency of unit */
+    unit_ptr->actbuf[0] = 0.8 * unit_ptr->actbuf[0] + 0.2 * unit_ptr->value_b;
+    saliency = unit_ptr->actbuf[0];
+    if (saliency != 0.0)   /* is it the initial-value? (for already pruned input units)*/ 
+      if ((pr_candidateUnit == NULL) ||
+	  (fabs(saliency) < pr_candidateSaliency))
+	/* found first or least important unit so far */
+	{
+	  pr_candidateUnit = unit_ptr;
+	  pr_candidateSaliency = fabs(saliency);
+	}
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : PRUNE_Skeletonization
+
+  PURPOSE  : 
+  RETURNS  :
+  NOTES    : 
+
+  UPDATE   :
+******************************************************************************/
+
+krui_err PRUNE_Skeletonization (int pattern)
+
+{
+
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+    register struct Link *link_ptr;
+    register TopoPtrArray topo_ptr;
+    static bool first = TRUE;
+
+    register Patterns out_pat;
+    int size, pattern_no, sub_pat_no, no_of_patterns;
+
+    if (first){
+      FOR_ALL_UNITS (unit_ptr)
+	unit_ptr->actbuf[0] = 0.0;
+      first = FALSE;
+    }
+
+    FOR_ALL_UNITS (unit_ptr)
+	unit_ptr->value_b = 0.0;
+    
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)
+	/* all patterns */
+	KernelErrorCode = kr_initSubPatternOrder
+	    (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else
+	/* single pattern */
+	KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    /* calculate total number of subpatterns */
+    no_of_patterns = kr_TotalNoOfSubPatPairs ();
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no))
+    {
+      /* initialize value_a of each unit */
+      FOR_ALL_UNITS (unit_ptr)
+	unit_ptr->value_a = 0.0;
+
+
+      /* calculate address of the output pattern */
+      out_pat = kr_getSubPatData (pattern_no, sub_pat_no, OUTPUT, &size);
+      out_pat += size;
+	
+      /* propagate pattern through net */
+      propagateNetForward (pattern_no, sub_pat_no);
+
+      /* calculate deviation for output units */
+      for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	   unit_ptr = *(topo_ptr--); unit_ptr != NULL;
+	   unit_ptr = *(topo_ptr--))
+	unit_ptr->value_a = (float) *(--out_pat) - unit_ptr->Out.output;
+
+      /* calculate output units */
+      for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	   unit_ptr = *(topo_ptr--);
+	   unit_ptr != NULL;
+	   unit_ptr = *(topo_ptr--))
+	{
+	  /* calculate delta */
+	  if (unit_ptr->value_a > 0)
+	    unit_ptr->value_a = (unit_ptr->act_deriv_func) (unit_ptr);
+	  else
+	    if (unit_ptr->value_a < 0)
+	      unit_ptr->value_a = - (unit_ptr->act_deriv_func) (unit_ptr);
+	    else
+	      unit_ptr->value_a = 0;
+
+	  /* process all links to that unit */
+	  if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+	    /* unit has direct inputs */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+	      pr_skel_processLink (unit_ptr, link_ptr);
+	  else
+	    /* unit has sites */
+	    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+	      pr_skel_processLink (unit_ptr, link_ptr);
+	}
+      
+      /* calculate hidden units */
+      for (unit_ptr = *(topo_ptr--);
+	   unit_ptr != NULL;
+	   unit_ptr = *(topo_ptr--))
+	{
+	  /* check saliency of unit if not input pruning */
+	  unit_ptr->value_b += unit_ptr->value_a * unit_ptr->Out.output;
+	  
+	  /* calculate delta */
+	  unit_ptr->value_a *= (unit_ptr->act_deriv_func) (unit_ptr);
+	  
+	  /* process all links to that unit */
+	  if UNIT_HAS_DIRECT_INPUTS (unit_ptr)
+	    /* unit has direct inputs */
+	    FOR_ALL_LINKS (unit_ptr, link_ptr)
+	      pr_skel_processLink (unit_ptr, link_ptr);
+	  else
+	    /* unit has sites */
+	    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+	      pr_skel_processLink (unit_ptr, link_ptr);
+	}
+
+      if (pr_inputPruning) 
+	/* calculate input units */
+	for (unit_ptr = *(topo_ptr--);
+	     unit_ptr != NULL;
+	     unit_ptr = *(topo_ptr--))
+	  /* check saliency of unit */
+	  unit_ptr->value_b += unit_ptr->value_a * unit_ptr->Out.output;
+      
+      
+    }
+
+    for (topo_ptr = topo_ptr_array + no_of_topo_units + 2,
+	   unit_ptr = *(topo_ptr--);
+	   unit_ptr != NULL;
+	   unit_ptr = *(topo_ptr--));
+
+    /* check hidden units */
+    for (unit_ptr = *(topo_ptr--);
+	 unit_ptr != NULL;
+	 unit_ptr = *(topo_ptr--)){
+      if (pr_hiddenPruning)
+	pr_skel_check_saliency (unit_ptr); 
+    }
+
+    /* check input units */
+    if (pr_inputPruning) 
+      /* calculate input units */
+      for (unit_ptr = *(topo_ptr--);
+	   unit_ptr != NULL;
+	   unit_ptr = *(topo_ptr--))
+	pr_skel_check_saliency (unit_ptr); 
+
+
+    if (pr_candidateUnit != NULL){
+      pr_candidateUnit->actbuf[0] = 0.0;
+    }
+      
+    return (KRERR_NO_ERROR);
+
+}
+
+
+/*****************************************************************************
+
+  GROUP: Noncontributing Units
+  AUTHOR: Jochen Biedermann
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_nc_calc_stddev
+  PURPOSE  : calculates mean and standard deviation of output 
+             of each unit (pr_Pass: PR_CONST) resp. mean of each unit output
+             and stddev between output of 'this_unit' and each other unit 
+             (pr_Pass: PR_SAME) resp. stddev between output of 'this_unit' and
+             the reverse (1 - output) of each other unit (pr_Pass: PR_REVERSE) 
+  NOTES    : mean in value_b, stddev in value_c
+  RETURNS  : kernel error code
+******************************************************************************/
+
+static krui_err pr_nc_calc_stddev (int pattern, struct Unit *this_unit_ptr)
+{
+    struct Unit *unit_ptr;
+    int pattern_no, sub_pat_no, no_of_patterns;
+
+    /* initialize value_b and value_c of each unit */
+    FOR_ALL_UNITS (unit_ptr) 
+        if (! IS_SPECIAL_UNIT (unit_ptr)) {
+           unit_ptr->value_b = 0;
+           unit_ptr->value_c = 0;
+        }
+
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)        /* all patterns */
+        KernelErrorCode = kr_initSubPatternOrder
+            (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else        /* single pattern */
+        KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+
+    /* calculate total number of subpatterns */
+    no_of_patterns = kr_TotalNoOfSubPatPairs ();
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no)) {
+        /* propagate pattern through net */
+        propagateNetForward (pattern_no, sub_pat_no);
+
+        /* calculate mean for all units */
+        FOR_ALL_UNITS (unit_ptr)
+            if (! IS_SPECIAL_UNIT (unit_ptr))
+                unit_ptr->value_b += unit_ptr->Out.output;
+    }
+
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr)) 
+            unit_ptr->value_b /= (float) no_of_patterns;
+        
+    /* compute the necessary sub patterns */
+    if (pattern == PR_ALL_PATTERNS)        /* all patterns */
+        KernelErrorCode = kr_initSubPatternOrder
+            (0, kr_np_pattern (PATTERN_GET_NUMBER, 0, 0) - 1);
+    else        /* single pattern */
+        KernelErrorCode = kr_initSubPatternOrder (pattern, pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+
+    while (kr_getSubPatternByOrder (&pattern_no, &sub_pat_no)) {
+        /* propagate pattern through net */
+        propagateNetForward (pattern_no, sub_pat_no);
+
+        /* calculate mean for all units */
+        FOR_ALL_UNITS (unit_ptr)
+            if (! IS_SPECIAL_UNIT (unit_ptr)) 
+                if (pr_Pass == PR_CONST) {
+                    unit_ptr->value_c += (unit_ptr->Out.output - unit_ptr->value_b)
+                                         * (unit_ptr->Out.output - unit_ptr->value_b);
+		} else if (pr_Pass == PR_SAME) {
+                    unit_ptr->value_c += (unit_ptr->Out.output 
+                                             - this_unit_ptr->Out.output)
+                                         * (unit_ptr->Out.output 
+                                             - this_unit_ptr->Out.output);
+                } else {
+                    unit_ptr->value_c += (unit_ptr->Out.output 
+                                             + this_unit_ptr->Out.output - 1.0)
+                                         * (unit_ptr->Out.output 
+                                             + this_unit_ptr->Out.output - 1.0);
+                } 
+    }
+
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr)) {
+            unit_ptr->value_c = sqrt ((double) unit_ptr->value_c 
+                                      / (double) no_of_patterns);
+        }        
+
+    return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : pr_nc_check_stddev
+  PURPOSE  : checks, if 'unit' beats minimum stddev of the net 
+  NOTES    : if so, saves unit_ptr, target_unit_ptr (if any), stddev and current
+             pr_Pass
+  RETURNS  : kernel error code
+******************************************************************************/
+
+static void pr_nc_check_stddev (struct Unit *unit_ptr, struct Unit *unit_ptr2)
+{
+    float stddev;
+
+    stddev = unit_ptr->value_c;
+
+    if ((stddev >= 0 && (pr_candidateUnit == NULL)) || (stddev < pr_candidateStddev)) {
+        /* found first or smallest unit so far */
+        pr_candidateUnit       = unit_ptr;
+        pr_candidateTargetUnit = unit_ptr2;
+        pr_candidateStddev     = stddev;
+        pr_candidatePass       = pr_Pass;
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : pr_nc_process_succ_unit
+  PURPOSE  : bias of a succeeding unit (of the pruning candidate unit) and link
+             between this succ. unit and the candidate target unit 
+	     (the unit which will replace the candidate unit) 
+	     are changed (or created)
+  NOTES    : pr_Pass: 
+             PR_CONST:   to the bias the product of the link weight 
+                         between the candidate unit and the succ. unit 
+		         and the mean output of the candidate unit is added;
+	     PR_SAME:    to the link weight between the target candidate 
+	                 unit and the succ. unit the link weight between
+			 the candidate unit and the succ. unit is added;
+             PR_REVERSE: the link weight between the candidate unit and 
+	                 the succ. unit is subtracted from the link weight
+			 between the candidate target and the succ. unit. 
+			 Additionally, this link weight is added to the 
+			 bias of the succ. unit
+  RETURNS  : kernel error code
+******************************************************************************/
+
+static krui_err pr_nc_process_succ_unit (struct Unit *unit_ptr, struct Link *link_ptr)
+{ 
+    struct Site *site_ptr2;
+    struct Link *link_ptr2;
+    FlintType w;
+    int       unit_no, target_unit_no;
+
+    if (unit_ptr == NULL) return (KRERR_UNIT_MISSING);
+    unit_no = unit_ptr - unit_array;
+    w = link_ptr->weight;
+
+    if (pr_candidatePass == PR_CONST) {
+        unit_ptr->bias += w * pr_candidateUnit->value_b;
+    } else {
+        target_unit_no = pr_candidateTargetUnit - unit_array;
+
+        if (pr_candidatePass == PR_REVERSE) w = -w;
+
+        KernelErrorCode = kr_setCurrUnit (unit_no);
+        if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+        KernelErrorCode = kr_createLink (target_unit_no, w); 
+        if (KernelErrorCode != KRERR_NO_ERROR) {
+            if (KernelErrorCode == KRERR_ALREADY_CONNECTED) {
+                if UNIT_HAS_DIRECT_INPUTS (unit_ptr) { /* unit has direct inputs */
+                    FOR_ALL_LINKS (unit_ptr, link_ptr2)
+                        if (link_ptr2->to == pr_candidateTargetUnit) {
+                            link_ptr2->weight += w;
+  		        }
+                } else {                               /* unit has sites */
+                    FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr2, link_ptr2)
+                        if (link_ptr2->to == pr_candidateTargetUnit) {
+                            link_ptr2->weight += w;
+		        }
+		}
+            } else { 
+                return (KernelErrorCode);
+	    }
+        } 
+
+        if (pr_candidatePass == PR_REVERSE) unit_ptr->bias -= w;
+    }
+
+    return (KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : pr_nc_remove_unit
+  PURPOSE  : calls 'pr_nc_process_succ_unit' for each succeeding unit of the
+             pruning candidate unit and deletes (if pr_reallyDelete is TRUE)
+             or disables (if pr_reallyDelete is FALSE) the candidate unit
+  RETURNS  : kernel error code
+******************************************************************************/
+
+static krui_err pr_nc_remove_unit (void)
+{ 
+    struct Unit *unit_ptr;
+    struct Site *site_ptr;
+    struct Link *link_ptr;
+
+    if (pr_candidateUnit == NULL) return (KRERR_NO_ERROR);
+    if (pr_candidatePass != PR_CONST && pr_candidateTargetUnit == NULL) 
+        return (KRERR_UNIT_MISSING);
+
+    FOR_ALL_UNITS (unit_ptr) {
+        if (! IS_SPECIAL_UNIT (unit_ptr))
+            if UNIT_HAS_DIRECT_INPUTS (unit_ptr) {  /* unit has direct inputs */
+                FOR_ALL_LINKS (unit_ptr, link_ptr)
+                    if (link_ptr->to == pr_candidateUnit) {
+                        KernelErrorCode = pr_nc_process_succ_unit (unit_ptr, link_ptr);
+                        if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+		    }
+            } else {                                /* unit has sites */
+                FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+                    if (link_ptr->to == pr_candidateUnit) {
+                        KernelErrorCode = pr_nc_process_succ_unit (unit_ptr, link_ptr);
+                        if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+		    }
+	    }
+    }
+
+    pr_candidateUnit->bias = 0;
+    pr_candidateUnit->Out.output = 0;
+    pr_candidateUnit->act = 0;
+
+    kr_deleteAllInputs (pr_candidateUnit);        /* delete incoming links */
+    kr_deleteAllOutputLinks (pr_candidateUnit);   /* delete outgoing links */
+
+    return (KRERR_NO_ERROR);
+}
+
+#if 0
+
+/*****************************************************************************
+  FUNCTION : pr_nc_output
+  PURPOSE  : name, number, type and layer no. for the pruning candidate unit
+             and the target unit (if any) together with the stddev value are
+             printed out
+  RETURNS  : void
+******************************************************************************/
+
+static void pr_nc_output (void)
+{
+    int candidate_unit_no, target_unit_no;
+
+    if (pr_candidateUnit == NULL) return;
+    candidate_unit_no = pr_candidateUnit - unit_array;
+    if (pr_candidatePass != PR_CONST) {
+        if (pr_candidateTargetUnit == NULL) return;
+        target_unit_no = pr_candidateTargetUnit - unit_array;
+    }
+
+    printf ("  ");
+    switch (krui_getUnitTType (candidate_unit_no)) {
+      case INPUT:   printf ("Input-"); break; 
+      case OUTPUT:  printf ("Output-"); break; 
+      case HIDDEN:  printf ("Hidden-"); break; 
+      default:      break;
+    }
+    printf ("Unit ");
+    if (pr_candidateUnit -> unit_name != NULL) 
+        printf ("%s, ", pr_candidateUnit -> unit_name);
+    printf ("No. %d pruned ", candidate_unit_no);
+    switch (pr_candidatePass) {
+      case PR_CONST:    printf ("(const"); break;
+      case PR_SAME:     printf ("(same as "); break;
+      case PR_REVERSE:  printf ("(reverse to "); break;
+      default:          break;  
+    }
+    if (pr_candidatePass != PR_CONST) {
+        switch (krui_getUnitTType (target_unit_no)) {
+          case INPUT:   printf ("Input-"); break; 
+          case OUTPUT:  printf ("Output-"); break; 
+          case HIDDEN:  printf ("Hidden-"); break; 
+          default:      break;
+        }
+        printf ("Unit ");
+        if (pr_candidateTargetUnit -> unit_name != NULL) 
+            printf ("%s, ", pr_candidateTargetUnit -> unit_name);
+        printf ("No. %d", target_unit_no);
+    }
+    printf ("), StdDev: %lf\n", (double) pr_candidateStddev);      
+}
+
+#endif
+
+/*****************************************************************************
+  FUNCTION : pr_nc_clear_marks
+  PURPOSE  : clear all marks 
+  RETURNS  : void
+******************************************************************************/
+
+static void pr_nc_clear_marks (void)
+{
+    struct Unit *unit_ptr;
+
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr)) unit_ptr->flags &= ~UFLAG_PRUNEFLAG; 
+}
+
+/*****************************************************************************
+  FUNCTION : pr_nc_mark_all_pred
+  PURPOSE  : marks recursively all predating units
+  RETURNS  : void
+******************************************************************************/
+
+static void pr_nc_mark_all_pred (struct Unit *unit_ptr)
+{
+    struct Site *site_ptr;
+    struct Link *link_ptr;
+
+    if (unit_ptr == NULL || IS_SPECIAL_UNIT (unit_ptr)) return;
+
+    unit_ptr->flags |= UFLAG_PRUNEFLAG;
+
+    if UNIT_HAS_DIRECT_INPUTS (unit_ptr) {  /* unit has direct inputs */
+        FOR_ALL_LINKS (unit_ptr, link_ptr)
+            pr_nc_mark_all_pred (link_ptr->to);
+    } else {                                /* unit has sites */
+        FOR_ALL_SITES_AND_LINKS (unit_ptr, site_ptr, link_ptr)
+            pr_nc_mark_all_pred (link_ptr->to);
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : PRUNE_Noncontributing
+  PURPOSE  : this procedure looks for the best unit to prune. In the first pass
+             (pr_Pass: PR_CONST) a nearly constant unit is searched, in the
+             2nd pass (pr_Pass: PR_SAME) two units with nearly identical outputs
+             and in the 3rd pass (pr_Pass: PR_REVERSE) two units with nearly
+             reverse outputs are searched 
+  NOTES    : the procedure 'pr_nc_check_stddev' is called for saving the 'best'
+             unit to prune in 'pr_candidateUnit'
+  RETURNS  : kernel error code
+******************************************************************************/
+
+krui_err PRUNE_Noncontributing (int pattern)
+{
+    struct Unit *unit_ptr, *unit_ptr2;
+
+    /* Looking for unit to prune */
+    pr_Pass = PR_CONST;
+
+    KernelErrorCode = pr_nc_calc_stddev (pattern, NULL); 
+    if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr) && 
+            ((IS_INPUT_UNIT (unit_ptr) && pr_inputPruning) || 
+             (IS_HIDDEN_UNIT (unit_ptr) && pr_hiddenPruning))) 
+            pr_nc_check_stddev (unit_ptr, NULL);
+
+
+    FOR_ALL_UNITS (unit_ptr)
+        if (! IS_SPECIAL_UNIT (unit_ptr) && ! IS_OUTPUT_UNIT (unit_ptr)) {
+            pr_nc_clear_marks ();
+            pr_nc_mark_all_pred (unit_ptr);
+
+
+            pr_Pass = PR_SAME;
+            KernelErrorCode = pr_nc_calc_stddev (pattern, unit_ptr); 
+            if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+ 
+            FOR_ALL_UNITS (unit_ptr2)
+                if (! IS_SPECIAL_UNIT (unit_ptr2) && unit_ptr != unit_ptr2
+                    && ((IS_INPUT_UNIT (unit_ptr2) && pr_inputPruning) || 
+                       (IS_HIDDEN_UNIT (unit_ptr2) && pr_hiddenPruning)) 
+                    && ! (unit_ptr2->flags & UFLAG_PRUNEFLAG)) {
+                    pr_nc_check_stddev (unit_ptr2, unit_ptr);
+		}
+
+
+            pr_Pass = PR_REVERSE;
+  
+            KernelErrorCode = pr_nc_calc_stddev (pattern, unit_ptr); 
+            if (KernelErrorCode != KRERR_NO_ERROR) return (KernelErrorCode);
+
+            FOR_ALL_UNITS (unit_ptr2)
+                if (! IS_SPECIAL_UNIT (unit_ptr2) && unit_ptr != unit_ptr2
+                    && ((IS_INPUT_UNIT (unit_ptr2) && pr_inputPruning) || 
+                       (IS_HIDDEN_UNIT (unit_ptr2) && pr_hiddenPruning)) 
+                    && ! (unit_ptr2->flags & UFLAG_PRUNEFLAG))
+                    pr_nc_check_stddev (unit_ptr2, unit_ptr);
+        }
+
+#if 0
+    pr_nc_output ();
+#endif
+    KernelErrorCode = pr_nc_remove_unit ();
+
+    return (KernelErrorCode);
+
+}
+
+/*****************************************************************************
+
+  GROUP: Calling Function
+
+******************************************************************************/
+
+
+/*****************************************************************************
+  FUNCTION : pr_callPrunFunc
+  PURPOSE  : calls the current pruning function and prunes link or
+             unit with smallest saliency
+  NOTES    : special flags are reset!
+  RETURNS  : returns error passed by pruning function
+******************************************************************************/
+
+krui_err pr_callPrunFunc (int pattern)
+{
+    FunctionPtr func_ptr;
+    NetFunctionPtr net_func_ptr;
+    char *curr_func;
+    int nodePruning;
+    FlintType dummy;
+
+    /* get current pruning function */
+    if ((curr_func = krf_getCurrentNetworkFunc (PRUNING_FUNC)) == NULL)
+        return (KernelErrorCode);
+    if (!krf_funcSearch (curr_func, PRUNING_FUNC, &func_ptr))
+        return (KernelErrorCode);
+    net_func_ptr = (NetFunctionPtr) func_ptr;
+
+    /* check node pruning */
+    nodePruning = (strcmp (curr_func, "Skeletonization") == 0) ||
+	(strcmp (curr_func, "Noncontributing_Units") == 0);
+
+    /* initialize global variables */
+    pr_candidateUnit       = NULL;
+    pr_candidateTargetUnit = NULL;
+    pr_candidateLink       = NULL;
+
+    /* invoke function */
+    KernelErrorCode = (*(PrunFuncPtr) net_func_ptr) (pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    if (nodePruning)
+    {
+        kr_deleteAllInputs (pr_candidateUnit);        /* delete incoming links */
+        kr_deleteAllOutputLinks (pr_candidateUnit);   /* delete outgoing links */
+    }
+    else
+    {
+        unitPtr = pr_candidateTargetUnit;
+        unitNo = unitPtr - unit_array;
+        pr_candidateSourceUnitNo =
+            pr_candidateLink->to - unit_array;
+        kr_isConnected (pr_candidateSourceUnitNo, &dummy);
+        kr_deleteLink ();
+    }
+
+    NetModified = TRUE;
+
+    /* delete dead units, if necessary */
+    pr_checkDeadUnits ();
+    
+    return (KernelErrorCode);
+
+}
diff -Naur snort-2.3.3/src/kernel_snns/prun_f.h snort-2.3.3.new/src/kernel_snns/prun_f.h
--- snort-2.3.3/src/kernel_snns/prun_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/prun_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,53 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/prun_f.h,v $
+  SHORTNAME      : prun_f.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file for pruning algorithms
+  NOTES          :
+
+  AUTHOR         : Tobias Schreiner
+  DATE           : 13.3.94
+
+  CHANGED BY     : Jochen Biedermann, 07.07.94
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:32 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _PRUN_F_DEFINED_
+#define  _PRUN_F_DEFINED_
+
+#define PR_ALL_PATTERNS -1
+
+extern int pr_trainCycles, pr_retrainCycles, pr_recreate, pr_refresh, 
+           pr_inputPruning, pr_hiddenPruning;
+
+extern float pr_maxErrorInc, pr_acceptedError, pr_minError,
+             pr_obs_initParameter;
+
+extern void pr_checkDeadUnits (void);
+
+extern krui_err pr_calcMeanDeviation (int pattern, float *sum_error);
+
+extern krui_err PRUNE_Mag (int pattern);
+
+extern krui_err PRUNE_OBD (int pattern);
+
+extern krui_err PRUNE_OBS (int pattern);
+
+extern krui_err PRUNE_Skeletonization (int pattern);
+
+extern krui_err PRUNE_Noncontributing (int pattern);
+
+extern void pr_obs_setInitParameter (float param);
+
+extern krui_err pr_callPrunFunc (int pattern);
+
+extern void pr_setInputPruning (int value);
+
+extern void pr_setHiddenPruning (int value);
+
+#endif /* _PRUN_F_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/prun_f.ph snort-2.3.3.new/src/kernel_snns/prun_f.ph
--- snort-2.3.3/src/kernel_snns/prun_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/prun_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,128 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/prun_f.ph,v $
+  SHORTNAME      : prun_f.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : private header file for pruning algorithms
+  NOTES          :
+
+  AUTHOR         : Tobias Schreiner
+  DATE           : 13.3.94
+
+  CHANGED BY     : Jochen Biedermann
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:32 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _PRUN_F_DEFINED_
+#define  _PRUN_F_DEFINED_
+
+/* begin global section */
+
+#define PR_ALL_PATTERNS -1
+
+#define DEFAULT_TRAIN_CYCLES 1000
+#define DEFAULT_RETRAIN_CYCLES 100
+#define DEFAULT_ERROR_INCREASE 10.0
+#define DEFAULT_ACCEPTED_ERROR 5.0
+#define DEFAULT_MIN_ERROR 1.0
+#define DEFAULT_OBS_INIT_PARAMETER 0.000001
+
+int pr_trainCycles = DEFAULT_TRAIN_CYCLES,
+    pr_retrainCycles = DEFAULT_RETRAIN_CYCLES,
+    pr_recreate = TRUE,
+    pr_refresh = FALSE,
+    pr_inputPruning = TRUE,
+    pr_hiddenPruning = TRUE;
+
+float pr_maxErrorInc = DEFAULT_ERROR_INCREASE,
+      pr_acceptedError = DEFAULT_ACCEPTED_ERROR,
+      pr_minError = DEFAULT_MIN_ERROR,
+      pr_obs_initParameter = DEFAULT_OBS_INIT_PARAMETER;
+
+
+void pr_checkDeadUnits (void);
+krui_err pr_calcMeanDeviation (int pattern, float *sum_error);
+
+krui_err PRUNE_Mag (int pattern);
+
+krui_err PRUNE_OBD (int pattern);
+
+krui_err PRUNE_OBS (int pattern);
+
+krui_err PRUNE_Skeletonization (int pattern);
+
+krui_err PRUNE_Noncontributing (int pattern);
+
+void pr_obs_setInitParameter (float param);
+
+krui_err pr_callPrunFunc (int pattern);
+
+void pr_setInputPruning (int value);
+
+void pr_setHiddenPruning (int value);
+
+/* end global section */
+
+/* begin private section */
+
+#define SMALL_WEIGHT 0.0001
+
+#define PR_CONST        1
+#define PR_SAME         2
+#define PR_REVERSE      3
+
+#define UFLAG_PRUNEFLAG 0x8000
+
+
+typedef krui_err (* PrunFuncPtr) ();
+
+static struct Unit *pr_candidateTargetUnit, *pr_candidateUnit;
+static struct Link *pr_candidateLink;
+static float pr_candidateSaliency, pr_candidateStddev;
+static int pr_candidateSourceUnitNo, pr_candidatePass, pr_Pass;
+
+/* variables only used by OBS */
+static int pr_candidateLinkNo, pr_noOfLinks;
+static RbfFloatMatrix pr_inverseHessian, pr_derivVector, pr_helpHX, pr_helpXH;
+
+/* functions */
+
+static void pr_updateNoOfLinks (struct Unit *unit_ptr, struct Link *link_ptr);
+
+static void pr_mag_processLink (struct Unit *unit_ptr, struct Link *link_ptr);
+
+static void pr_obd_processLink (struct Unit *unit_ptr, struct Link *link_ptr,
+				float delta, float delta2);
+static void pr_obd_checkLink (struct Unit *unit_ptr, struct Link *link_ptr);
+
+static void pr_obs_countLinks ();
+static void pr_obs_calculateDerivative (struct Link *link_ptr,
+					float help, int weight_no);
+static void pr_obs_calculateDerivVector (struct Unit *output_unit);
+static krui_err pr_obs_updateInverseHessian (int no_of_patterns);
+static krui_err pr_obs_calculateInverseHessian (int pattern);
+static void pr_obs_processLink (struct Unit *unit_ptr,
+				struct Link *link_ptr,
+				int weight_no);
+static void pr_obs_updateLink (struct Link *link_ptr,
+			       float update_const,
+			       int weight_no);
+
+static void pr_skel_processLink (struct Unit *unit_ptr, struct Link *link_ptr);
+static void pr_skel_check_saliency (struct Unit *unit_ptr);
+
+static krui_err pr_nc_calc_stddev (int pattern, struct Unit *this_unit_ptr);
+static void     pr_nc_check_stddev (struct Unit *unit_ptr, struct Unit *unit_ptr2);
+static krui_err pr_nc_process_succ_unit (struct Unit *unit_ptr, struct Link *link_ptr);
+static void     pr_nc_mark_all_pred (struct Unit *root_unit_ptr);
+static krui_err pr_nc_remove_unit (void);
+#if 0
+static void     pr_nc_output (void);
+#endif
+/* end private section */
+
+#endif /* _PRUN_F_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/random.h snort-2.3.3.new/src/kernel_snns/random.h
--- snort-2.3.3/src/kernel_snns/random.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/random.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,30 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/random.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : System V Library Functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 01.10.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:34 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef SYS_FUNCS
+#define SYS_FUNCS
+
+double	drand48( void );
+#ifndef __linux__
+int	rand( void );
+#endif
+long    lrand48(void );
+void    srand48( long );
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/README snort-2.3.3.new/src/kernel_snns/README
--- snort-2.3.3/src/kernel_snns/README	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/README	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,96 @@
+/*****************************************************************************
+  FILE           : README
+  SHORTNAME      : readme
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Readme File for the SNNS Kernel
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : 2.1
+  LAST CHANGE    : $Date: 1998/03/13 17:35:30 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+
+This Directory contains the following files:
+
+README          :       This file
+
+alloca.c	:	implementation of the alloca function for non-standard 
+			systems 
+art_ui.c        :       contains user interface functions for ART networks
+arttr_f.c       :       contains transfer functions for ART networks
+calc_err.c      :       Program for calculating the accurancy of activation
+                        functions that uses the table-lookup technique
+cc_display.c    :	display functions of Cascade-Correlation
+cc_glob.c	:	contains some general functions for cc
+cc_learn.c	:	contains learning functions for cascade correlation
+cc_modify.c	:	contains the modification modules on the cascade 
+			correlation algorithm
+dlvq_learn.c    :	contains all functions of the DLVQ algorithm
+func_tbl.c      :       contains the function table
+getcwd.c	:	implementation of the getcwd function for non-standard 
+			systems 
+init_f.c        :       contains the network initialisation functions
+kernel.c        :       contains the simulator kernel
+kr_JordElm.c    :	handling of Jordan and Elman networks
+kr_amap.c       :       contains kernel functions for ARTMAP networks.
+kr_art.c        :       contains kernel functions for all ART networks
+kr_art1.c       :       contains kernel functions for ART1 networks
+kr_art2.c       :       contains kernel functions for ART2 networks
+kr_funcs.c      :       contains internal interface functions of the kernel
+kr_inversion.c  :	contains network inversion functions
+kr_io.c         :       contains the file I/O interface functions
+kr_mem.c        :       contains the memory management functions of the kernel
+kr_newpattern.c :	pattern handling functions
+kr_pat_parse.c  :       parser for pattern files
+kr_pat_scan.c   :	scanner for pattern files
+kr_rand.c       :	random number generator
+kr_td.c		:	contains the learning functions for time delay networks
+kr_ui.c         :       contains the user interface functions
+learn_f.c       :       contains the learning functions
+lrand48.c	:	implementation of the lrand function for non-standard 
+			systems 
+make_tbl.c      :	generates lookup table for transfer functions
+matrix.c        :       contains matrix operation functions
+memcmp.c	:	implementation of the memcmp function for non-standard 
+			systems 
+prun_f.c        :       contains all pruning related functions
+remap_f.c	:       pattern remapping implementation
+scaled_conj_grad.c:     learning functions for scg algorithm
+stochastic_learn_f.c:   learning functions for stochastic learning
+strdup.c        :       Compatibility source file for ULTRIX-32 and MS-DOS
+tbl_func.c      :       contains the activation functions using table-lookup.
+trans_f.c       :       contains the network transfer functions
+update_f.c      :       contains the network update functions
+
+
+All these source files have two corresponding headder files. A .h file that 
+contains the external declarations for the functions accessible from other
+moduls, and a .ph file for function prototypes and definitions local to the 
+modul.
+
+Additionally there are the following global header files:
+
+art_typ.h       :       contains global data types and constants for external 
+                        programs using ART networks.
+ext_typ.h       :       contains data types for external kernels
+func_mac.h      :       contains macros for transfer functions
+glob_typ.h      :       contains global data types and constants
+                        for external programs
+krart_df.h      :       contains constants and macros for all ART algorithms
+krui_typ.h      :       contains ANSII prototypes of kr_ui.c
+kr_const.h      :       contains kernel constants
+kr_def.h        :       contains kernel default values
+kr_mac.h        :       contains kernel macros
+kr_typ.h        :       contains kernel data types and constants
+version.h       :       contains the version numbers of the kernel
+
+
diff -Naur snort-2.3.3/src/kernel_snns/remap_f.c snort-2.3.3.new/src/kernel_snns/remap_f.c
--- snort-2.3.3/src/kernel_snns/remap_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/remap_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,228 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/remap_f.c,v $
+  SHORTNAME      : remap_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : pattern remapping functions
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.8 $
+  LAST CHANGE    : $Date: 1998/04/08 09:17:37 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <math.h>
+
+#include "glob_typ.h"
+
+#include "remap_f.ph"
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_none
+
+  PURPOSE  : default pattern remapping function that does no remapping at all.
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_none(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params)
+{
+    KernelErrorCode = KRERR_NO_ERROR;
+    return(KernelErrorCode);
+}
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_binary
+
+  PURPOSE  : produces the patterns for a binary classifier. All patterns 
+             greater than 0.5 are mapped to one, all others to 0
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_binary(float *pat_data, int pat_size, 
+		       float *remap_params, int no_of_remap_params)
+{
+
+    register int   i;
+
+    for(i=0; i<pat_size; i++){
+	*pat_data = (*pat_data < 0.5)? 0.0: 1.0;
+	pat_data++;
+    }
+
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_invers
+
+  PURPOSE  : inverts the patterns of a binary classifier
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_invers(float *pat_data, int pat_size, 
+		       float *remap_params, int no_of_remap_params)
+{
+    register int   i;
+
+    for(i=0; i<pat_size; i++){
+	*pat_data = (*pat_data < 0.5)? 1.0: 0.0;
+	pat_data++;
+    }
+
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_clip
+
+  PURPOSE  : clips values below and above the limits
+  NOTES    :
+
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_clip(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params)
+{
+    register float param1;
+    register float param2;
+    register int   i;
+
+    param1 = remap_params[0];
+    param2 = remap_params[1];
+
+    for(i=0; i<pat_size; i++){
+	*pat_data = (*pat_data < param1)? param1: 
+	                                  ((*pat_data > param2)? param2:
+					                         *pat_data);
+	pat_data++;
+    }
+
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_norm
+
+  PURPOSE  : produces normalized patterns, i.e. the length of the pattern 
+             vector is 1 after calling this function.
+	     Some learning algorithms like DLVQ require the output patterns 
+	     to be normalized. 
+  RETURNS  :
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_norm(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params)
+{
+    register int i;
+    double length = 0.0;
+
+    for(i=0; i<pat_size; i++){
+	length += pat_data[i] * pat_data[i];
+    }
+    length = sqrt(length);
+
+    if(length == 0.0)
+	return(KRERR_CANT_NORM);
+
+    for(i=0; i<pat_size; i++)
+	pat_data[i] = pat_data[i] / length;
+
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : REMAP_threshold
+
+  PURPOSE  : produces a pattern with only two output values. All values 
+             within [lower threshold value, upper threshold value] are mapped 
+	     to "background" value, the others to "signal" value. If the two 
+	     thresholds are equal, values below it will be mapped to background.
+  NOTES    : Parameter meanings: 0 - lower threshold value
+                                 1 - upper threshold value
+				 2 - background value
+				 3 - signal value
+  RETURNS  : 0 or kernel error code KRERR_PARAMETERS
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_threshold(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params)
+{
+
+    register float param1;
+    register float param2;
+    register float param3;
+    register float param4;
+    register int   i;
+
+    param1 = remap_params[0];
+    param2 = remap_params[1];
+    param3 = remap_params[2];
+    param4 = remap_params[3];
+
+    if(param1 == param2){
+	for(i=0; i<pat_size; i++){
+	    *pat_data = (*pat_data < param1)? param3: param4;
+	    pat_data++;
+	}
+    }else{
+	for(i=0; i<pat_size; i++){
+	    *pat_data = (*pat_data < param1)? param4:
+		                              ((*pat_data > param2)? param4:
+		                                                     param3);
+	    pat_data++;
+	}
+    }
+    return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : REMAP_linearscale
+
+  PURPOSE  : rescales the pattern outputs to a new range like
+             out = a*orig_out + b
+
+  NOTES    : Parameter meanings: 0 - factor a
+                                 1 - addin b
+
+  RETURNS  : 0 or kernel error code KRERR_PARAMETERS
+  UPDATE   : 
+******************************************************************************/
+krui_err  REMAP_linearscale(float *pat_data, int pat_size, 
+			    float *remap_params, int no_of_remap_params)
+{
+
+    register float param1;
+    register float param2;
+    register int   i;
+
+    param1 = remap_params[0];
+    param2 = remap_params[1];
+
+    for(i=0; i<pat_size; i++){
+	*pat_data = param1 * *pat_data + param2;
+	pat_data++;
+    }
+
+    return(KRERR_NO_ERROR);
+}
diff -Naur snort-2.3.3/src/kernel_snns/remap_f.h snort-2.3.3.new/src/kernel_snns/remap_f.h
--- snort-2.3.3/src/kernel_snns/remap_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/remap_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,39 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/remap_f.h,v $
+  SHORTNAME      : remap_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : public header
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.5 $
+  LAST CHANGE    : $Date: 1998/04/08 09:17:37 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _REMAP_F_DEFINED_
+#define  _REMAP_F_DEFINED_
+
+extern krui_err  REMAP_none(float *pat_data, int pat_size, 
+			    float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_binary(float *pat_data, int pat_size, 
+			      float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_invers(float *pat_data, int pat_size, 
+			      float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_clip(float *pat_data, int pat_size, 
+			    float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_norm(float *pat_data, int pat_size, 
+			    float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_threshold(float *pat_data, int pat_size, 
+				 float *remap_params, int no_of_remap_params);
+extern krui_err  REMAP_linearscale(float *pat_data, int pat_size, 
+				  float *remap_params, int no_of_remap_params);
+#endif 
+
+
diff -Naur snort-2.3.3/src/kernel_snns/remap_f.ph snort-2.3.3.new/src/kernel_snns/remap_f.ph
--- snort-2.3.3/src/kernel_snns/remap_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/remap_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,38 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/remap_f.ph,v $
+  SHORTNAME      : remap_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : private header
+  NOTES          :
+
+  AUTHOR         : Guenter Mamier
+  DATE           : 
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.5 $
+  LAST CHANGE    : $Date: 1998/04/08 09:17:38 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _REMAP_F_DEFINED_
+#define  _REMAP_F_DEFINED_
+
+krui_err  REMAP_none(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params);
+krui_err  REMAP_binary(float *pat_data, int pat_size, 
+		       float *remap_params, int no_of_remap_params);
+krui_err  REMAP_invers(float *pat_data, int pat_size, 
+		       float *remap_params, int no_of_remap_params);
+krui_err  REMAP_clip(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params);
+krui_err  REMAP_norm(float *pat_data, int pat_size, 
+		     float *remap_params, int no_of_remap_params);
+krui_err  REMAP_threshold(float *pat_data, int pat_size, 
+			  float *remap_params, int no_of_remap_params);
+krui_err  REMAP_linearscale(float *pat_data, int pat_size, 
+                            float *remap_params, int no_of_remap_params);
+#endif 
+
diff -Naur snort-2.3.3/src/kernel_snns/scaled_conj_grad.c snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.c
--- snort-2.3.3/src/kernel_snns/scaled_conj_grad.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,514 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/scaled_conj_grad.c,v $
+  SHORTNAME      : scaled_conj_grad.c
+  SNNS VERSION   : 4.2
+  
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+                   - SCG
+  
+  AUTHOR         : Bruno ORSIER
+  DATE           : 09.95
+  VERSION        : 1.01
+
+  CHANGES :1.01 -> 1.02 
+		 - bug fix: in case the first computed gradient is null, 
+		 norm_of_p_2 = |p|^2 is equal to zero and then a division by 
+		 zero occurs in the computation of sigma.  The 4th learning 
+		 parameter, tolerance, is now also used to check whether |p| 
+		 is almost equal to zero. If the answer is yes, SCG stops.  
+		 SCG also now stops if the norm of the gradient is smaller 
+		 than tolerance.
+			
+		 1.0 -> 1.01    
+                 new termination criterion, based on the book 'Numerical
+                 Recipes'. Takes into account the floating-point precision of
+		 the machine. (new #define TOLERANCE in .ph)
+		 
+		 new learning parameters with defaults
+  
+		 Validation-function by Thomas Gern
+ ******************************************************************************/
+#include <config.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"		/* Kernel Types and Constants  */
+#include "kr_const.h"		/* Constant Declarators for SNNS-Kernel */
+#include "kernel.h"		/* kernel function prototypes  */
+#include "kr_mac.h"		/* Kernel Macros   */
+#include "glob_typ.h"
+#include "learn_f.h"
+#include "scaled_conj_grad.ph"
+#include "kr_newpattern.h"
+
+
+#ifdef SCG_DEBUG
+#define TRACE(s)         printf s
+#else
+#define TRACE(s)
+#endif
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_SCG
+
+  PURPOSE  : main function for SCG learning algorithm
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+krui_err LEARN_SCG(int start_pattern, int end_pattern, float *parameterInArray,
+		   int NoOfInParams, float **parameterOutArray,
+		   int *NoOfOutParams)
+{
+    static float    OutParameter[1]; /* OutParameter[0] stores the
+				      * learning error. */
+    static int      k, restart_scg = FALSE,
+	            stop_scg = FALSE,
+	            success;
+    static int      count_under_tol ; /* scg stops after 3 consecutive under
+			  	        tolerance cases. This is the counter. */
+    static float    delta, norm_of_p_2, lambda, lambda_bar, current_error, 
+	            old_error, norm_of_rk ;
+    static FlintType* *weights ;
+    static FlintType  *old_gradient, *p, *r, *old_weights, *step ;
+
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+    int   i, ret_code ;
+    int   start_scg,  make_allocations, under_tolerance ;
+    float sigma,  mu, alpha, grand_delta, beta ;
+    float sigma_1, lambda_1, tolerance ;    /* learning parameters */
+    
+    
+    if (NoOfInParams < 4)	
+	return (KRERR_PARAMETERS); /* Not enough input parameters  */
+
+    /* DEFAULTS: */
+
+    if (( sigma_1 = LEARN_PARAM1( parameterInArray )) == 0.0) 
+	  sigma_1 = SCG_FIRST_SIGMA ;
+
+    if (( lambda_1 = LEARN_PARAM2( parameterInArray )) == 0.0) 
+	lambda_1 = SCG_FIRST_LAMBDA ;
+
+				/* param 3 is DELTA_max */
+    if (( tolerance = LEARN_PARAM4( parameterInArray )) == 0.0) 
+	  tolerance = SCG_TOLERANCE ; 
+
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				 * learning error)  */
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    start_scg = NetModified || NetInitialize || LearnFuncHasChanged ;
+    make_allocations = NetModified || LearnFuncHasChanged ;
+    
+    if (NetModified) {		/* Net has been modified */
+      /* count the no. of I/O units and check the patterns  */
+      ret_code = kr_IOCheck();
+      if (ret_code < KRERR_NO_ERROR)
+	return (ret_code);
+
+      /* sort units by topology and by topologic type  */
+      ret_code = kr_topoSort(TOPOLOGICAL_FF);
+      if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	return (ret_code);
+      NetModified = FALSE;
+    }
+
+    if (make_allocations) {
+       int ts = 0, malloc_size ;
+       
+      /* store pointers to weigths and biases into a table */
+      /* 1) determines the size of the table */
+      scg_space_size = 0 ;
+      FOR_ALL_UNITS(unit_ptr)
+	if (!IS_INPUT_UNIT(unit_ptr) && !IS_SPECIAL_UNIT(unit_ptr)) {
+	flags = unit_ptr->flags;
+	scg_space_size++ ; /* bias */
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+	  /* unit is in use  */
+	  if (flags & UFLAG_SITES) { /* unit has sites  */
+	    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+	      scg_space_size++;
+	  } else {	/* unit has no sites   */
+	    if (flags & UFLAG_DLINKS) {
+	      /* unit has direct links         */
+	      FOR_ALL_LINKS(unit_ptr, link_ptr)
+		scg_space_size++;
+	    }
+	  }
+	}
+      }
+      TRACE(("SCG - weights+biases space size : %d\n",scg_space_size));
+
+      /* allocate space for all vectors of size scg_space_size */
+      malloc_size = scg_space_size*(sizeof(FlintType *)) ;
+      
+      if (weights != NULL) free(weights) ;
+      weights = (FlintType **)malloc(malloc_size) ;
+      if (scg_gradient != NULL) free(scg_gradient) ;
+      scg_gradient = (FlintType **)malloc(malloc_size) ;
+      if (step != NULL) free(step) ;
+      step = (FlintType *) malloc(scg_space_size*sizeof(FlintType)) ;
+      if (p != NULL) free(p) ;
+      p = (FlintType *) malloc(scg_space_size*sizeof(FlintType)) ;
+      if (r != NULL) free(r) ;
+      r = (FlintType *) malloc(scg_space_size*sizeof(FlintType)) ;
+      if (old_weights != NULL) free(old_weights) ;
+      old_weights = (FlintType *) malloc(scg_space_size*sizeof(FlintType)) ;
+      if (old_gradient != NULL) free(old_gradient) ;
+      old_gradient = (FlintType *) malloc(scg_space_size*sizeof(FlintType)) ;
+
+      if ((step == NULL)||(scg_gradient == NULL)||(weights == NULL)
+	||(p==NULL)||(r==NULL) ||(old_weights==NULL) ||(old_gradient ==NULL))
+	{
+	  printf("SCG : malloc problem\n") ;
+	  return(KRERR_CRITICAL_MALLOC);
+      }
+      else TRACE(("SCG - malloc's done\n"));
+
+      /* 2) store the adresses */
+
+      FOR_ALL_UNITS(unit_ptr)
+	if (!IS_INPUT_UNIT(unit_ptr) && !IS_SPECIAL_UNIT(unit_ptr)) {
+	    flags = unit_ptr->flags;
+	    scg_gradient[ts] = &unit_ptr->value_a ;
+	    weights[ts++] = &unit_ptr->bias;
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use  */
+		if (flags & UFLAG_SITES) { /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr) {
+			scg_gradient[ts] = &link_ptr->value_a ;
+			weights[ts++] = &link_ptr->weight;
+		    }
+		} else {	/* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {
+			/* unit has direct links         */
+			FOR_ALL_LINKS(unit_ptr, link_ptr) {
+			    scg_gradient[ts] = &link_ptr->value_a ;
+			    weights[ts++] = &link_ptr->weight;
+			}
+		    }
+		}
+	    }
+	}
+      
+    }				/* make_allocations */
+    
+
+    
+    if (start_scg || restart_scg) {
+      /* now we choose initial values for SCG parameters */
+      lambda = lambda_1 ;
+      lambda_bar = 0.0 ;
+      success = TRUE ;
+      k = 1 ;
+      restart_scg = FALSE ;
+      count_under_tol = 0 ;
+      TRACE(("START || RESTART\n"));
+    } 
+
+    TRACE(("\nSCG K=%d\n",k));
+    if (start_scg) {
+      TRACE(("SCG - starting\n"));
+      /* initialize  p and r */
+
+      /* we have starting weight vector (initialized through xgui or snnsbat)
+	 and we need the current gradient : we do as in LEARN_backpropBatch */
+      ret_code = compute_gradient(start_pattern,end_pattern,
+				   LEARN_PARAM3(parameterInArray),
+				  &current_error) ;
+      if(ret_code != KRERR_NO_ERROR) return (ret_code);
+      
+      /* now we have the gradient in vector 'gradient' and copy it to p and r */
+
+      for (i=0 ; i < scg_space_size ; i++) {
+	p[i] = - *scg_gradient[i] ;
+	r[i] = p[i] ;
+      }
+      norm_of_rk = sqrt(square_of_norm(r,scg_space_size)) ;
+      start_scg = FALSE ;
+      stop_scg = FALSE ;
+    }				/* end of start scg */
+
+    if (stop_scg) {
+      OutParameter[0] = current_error ;
+      return (ret_code);
+    }
+    
+    /* main part of SCG */
+    
+    if (success) {/* calculate second order information */
+      TRACE(("success\n")) ;
+      norm_of_p_2 = square_of_norm(p,scg_space_size) ;
+      TRACE((" norm_of_p_2=%e ", norm_of_p_2)) ;
+      if (norm_of_p_2 <= tolerance*tolerance) {
+	stop_scg = 1 ;
+	OutParameter[0] = current_error ;
+	k++;
+	return(ret_code) ;
+      }
+      sigma = sigma_1/sqrt(norm_of_p_2) ;
+      /* in order to compute the new step we need a need gradient. */
+      for (i=0 ; i < scg_space_size ; i++) {
+	old_gradient[i] = *scg_gradient[i] ;
+	old_weights[i] = *weights[i];
+      }
+      old_error = current_error ;
+      TRACE(("old_error=%e ", old_error)) ;
+      /* now we move to the new point in weight space */
+      for (i=0 ; i < scg_space_size ; i++)
+	*weights[i] += sigma*p[i] ;
+      /* and compute the new gradient */
+      ret_code = compute_gradient(start_pattern,end_pattern,
+				   LEARN_PARAM3(parameterInArray),
+				  &current_error) ;
+      if(ret_code != KRERR_NO_ERROR) return (ret_code);
+      TRACE(("current_error = %e",current_error)) ;
+      /* now we have the new gradient and we continue the step computation */
+      for (i=0 ; i < scg_space_size ; i++)
+	step[i] = (*scg_gradient[i]-old_gradient[i])/sigma ;
+
+      delta = product_of_xt_by_y(p,step,scg_space_size) ;
+      TRACE(("\n delta=%e\n",delta)) ;
+      TRACE(("end of success true\n"));
+    }				/* end of if (success) */
+
+    /* scale delta */
+    delta += (lambda - lambda_bar) * norm_of_p_2 ;
+    TRACE(("delta scaled = %e\n", delta));
+    
+    if (delta <=0) {		/* make the Hessian positive definite */
+      lambda_bar = 2.0 * (lambda - delta/norm_of_p_2) ;
+      delta = -delta + lambda*norm_of_p_2 ;
+      lambda = lambda_bar ;
+      TRACE(("hessian: l_bar=%e delta=%e lambda=%e\n",lambda_bar,delta,lambda));
+      
+    }
+
+    /* calculate step size */
+    mu = product_of_xt_by_y(p,r,scg_space_size) ;
+    alpha = mu/delta ;
+
+    TRACE(("mu=%e alpha=%e\n",mu,alpha));
+    
+    /* calculate the comparison parameter */
+
+    /* we must compute a new gradient but this time we do not want to */
+    /* keep the previous values  (they were useful only for */
+    /* approximating the Hessian )*/
+    
+    for (i=0 ; i < scg_space_size ; i++) *weights[i]=old_weights[i]+alpha*p[i];
+    ret_code = compute_gradient(start_pattern,end_pattern,
+				LEARN_PARAM3(parameterInArray),
+				&current_error) ;
+    if(ret_code != KRERR_NO_ERROR) return (ret_code);
+    
+    TRACE(("current error=%e\n",current_error)) ;
+    
+    grand_delta = 2.0*delta*(old_error-current_error)/(mu*mu) ;
+    TRACE(("grand delta=%e\n",grand_delta));
+    if (grand_delta >= 0) {	/* a successful reduction in error */
+				/* can be made */
+      float r_sum = 0.0 ;	/* product of r(k+1) by r(k) */
+      float tmp ;
+
+
+      TRACE(("ERROR REDUCTION of %e %% --- ",
+	     (old_error-current_error)/old_error*100.0));
+
+      under_tolerance =
+	2.0 * fabs(old_error-current_error)
+	<=
+	tolerance * (fabs(old_error)+fabs(current_error)+1E-10) ;
+      TRACE(("under tolerance = %d\n",under_tolerance));
+	
+      /* we already are at w(k+1) in weight space, so we don't move */
+      
+      /* we compute |r(k)| before changing r to r(k+1) */
+      norm_of_rk = sqrt(square_of_norm(r,scg_space_size)) ;
+
+      /* now, r <- r(k+1) */
+      for (i=0 ; i < scg_space_size ; i++) {
+	tmp = -1.0 * *scg_gradient[i] ;
+	r_sum +=  tmp * r[i] ;
+	r[i] = tmp ;
+      }
+
+      lambda_bar = 0 ;
+      success = TRUE ;
+      
+      if (k >= scg_space_size) {
+	restart_scg = TRUE ;
+	for (i=0 ; i < scg_space_size ; i++) p[i] = r[i] ;
+      }
+      else {			/* compute new conjugate direction */
+	beta = (square_of_norm(r,scg_space_size) - r_sum)/mu ;
+	TRACE(("beta=%e\n",beta));
+	for (i=0 ; i < scg_space_size ; i++) p[i] = r[i]+ beta*p[i] ;
+
+	restart_scg = FALSE ;
+      }
+
+      if (grand_delta >=0.75) lambda = lambda/4.0 ;
+    }
+    
+    else {
+      /* no reduction can be made */
+      TRACE(("NO REDUCTION\n"));
+      under_tolerance = 0 ;
+      /* we must go back to w(k), since w(k)+alpha*p(k) is not better */
+      for (i=0 ; i < scg_space_size ; i++) *weights[i] = old_weights[i] ;
+      current_error = old_error ;
+      
+      lambda_bar = lambda ;
+      success = FALSE ;
+    }
+
+    if (grand_delta < 0.25)
+      lambda = lambda+delta*(1-grand_delta)/norm_of_p_2 ;
+
+				/* let's try to prevent floating-point
+				   exceptions. Lambda may become too big even
+				   with the under_tolerance criterion, in case
+				   of a several consecutive 'NO REDUCTION'. */
+    if (lambda > MAXFLOAT) lambda = MAXFLOAT ;
+    
+    TRACE(("lambda after resizing=%e\n",lambda)) ;
+
+    TRACE(("|r(k)| = %e\n",norm_of_rk)) ;
+
+    /* scg stops after 3 consecutive under tolerance steps */
+    if (under_tolerance)     count_under_tol++ ;
+    else count_under_tol = 0 ;
+
+    stop_scg = (count_under_tol > 2) || (norm_of_rk <= tolerance) ;
+    TRACE(("STOP SCG : count_under_tol=%d, stop_scg=%d\n", 
+	   count_under_tol, stop_scg)) ;
+
+    if (stop_scg) count_under_tol = 0 ;	/* just in case the user wants to try
+					   with a smaller tolerance */
+
+    k++;
+       
+    OutParameter[0] = current_error ;
+    
+    return (ret_code);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : product_of_xt_by_y
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static float product_of_xt_by_y(float * x, float * y, int tab_size)
+{
+  int indice ;
+  float sum = 0 ;
+
+  for (indice = 0 ; indice < tab_size ; indice++)
+    sum += x[indice]*y[indice] ;
+
+  return(sum) ;
+}
+
+
+/*****************************************************************************
+  FUNCTION : square_of_norm
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static float square_of_norm(float * x, int tab_size)
+{
+  return(product_of_xt_by_y(x,x,tab_size));
+}
+
+
+/*****************************************************************************
+  FUNCTION : compute_gradient
+
+  PURPOSE  : computes the SCG gradient
+  RETURNS  : kernel error code
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err compute_gradient(int start_pattern, int end_pattern, 
+				 float delta_max,  float * error)
+{
+    int pattern_no, sub_pat_no, i ;
+  
+    clearDeltas();
+
+    /* compute the necessary sub patterns */
+  
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern,end_pattern);
+    if(KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+
+    *error = 0.0;	/* reset network error value  */
+
+    while(kr_getSubPatternByOrder(&pattern_no,&sub_pat_no)){
+    
+	propagateNetForward(pattern_no,sub_pat_no);  /* Forward propagation */
+	
+	*error += propagateNetBackwardBatch(pattern_no,sub_pat_no, delta_max,
+					    NULL, 0);
+	/* -0.5 * gradient's coordinates are stored in value_a's */
+    }
+
+    for (i=0 ; i< scg_space_size ; i++) 
+	*scg_gradient[i] = - 2.0 * *scg_gradient[i];
+
+    return (KernelErrorCode);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : TEST_SCG
+
+  PURPOSE  : tests the network using TEST_backprop.
+  RETURNS  : kernel error code
+  NOTES    : saves the value of NetModified for initialising LEARN_SCG
+
+  UPDATE   : 18.10.95 by Thomas Gern
+******************************************************************************/
+krui_err TEST_SCG(int start_pattern, int end_pattern,
+		  float *parameterInArray, int NoOfInParams,
+		  float **parameterOutArray, int *NoOfOutParams)
+{
+    bool OldNetModified;
+    krui_err ret_val;
+
+    OldNetModified = NetModified;
+    ret_val = TEST_backprop(start_pattern, end_pattern, 
+			    parameterInArray, NoOfInParams,
+			    parameterOutArray, NoOfOutParams);
+    NetModified = OldNetModified;
+    return ret_val;
+}
+
diff -Naur snort-2.3.3/src/kernel_snns/scaled_conj_grad.h snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.h
--- snort-2.3.3/src/kernel_snns/scaled_conj_grad.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,31 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/scaled_conj_grad.h,v $
+  SHORTNAME      : scaled_conj_grad.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+	           - scaled conjugated gradient
+
+  AUTHOR         : Bruno Orsier
+  DATE           : 01.10.96
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:38 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _SCALED_CONJ_GRAD_DEFINED_
+#define _SCALED_CONJ_GRAD_DEFINED_
+
+extern krui_err LEARN_SCG(int start_pattern, int end_pattern, 
+			  float *parameterInArray, int NoOfInParams, 
+			  float **parameterOutArray, int *NoOfOutParams) ;
+
+extern krui_err TEST_SCG(int start_pattern, int end_pattern,
+			 float *parameterInArray, int NoOfInParams,
+			 float **parameterOutArray, int *NoOfOutParams);
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/scaled_conj_grad.ph snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.ph
--- snort-2.3.3/src/kernel_snns/scaled_conj_grad.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/scaled_conj_grad.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,56 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/scaled_conj_grad.ph,v $
+  SHORTNAME      : scaled_conj_grad.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+	           - scaled conjugated gradient
+
+  AUTHOR         : Bruno Orsier
+  DATE           : 01.10.96
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.4 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:39 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _SCALED_CONJ_GRAD_DEFINED_
+#define _SCALED_CONJ_GRAD_DEFINED_
+
+/* begin global definition section */
+krui_err LEARN_SCG(int start_pattern, int end_pattern, 
+		   float *parameterInArray, int NoOfInParams, 
+		   float **parameterOutArray, int *NoOfOutParams) ;
+
+krui_err TEST_SCG(int start_pattern, int end_pattern,
+		  float *parameterInArray, int NoOfInParams,
+		  float **parameterOutArray, int *NoOfOutParams);
+/* end global definition section */
+
+/* begin private definition section */
+static float product_of_xt_by_y(float * x, float * y, int tab_size) ;
+static float square_of_norm(float * x, int tab_size) ;
+static krui_err compute_gradient(int start_pattern, int end_pattern, 
+				 float delta_max, float * error) ;
+
+static int        scg_space_size ;
+static FlintType* *scg_gradient ;
+
+#define SCG_FIRST_SIGMA     1E-4	/* should be in ]0 ; 1E-4] */
+#define SCG_FIRST_LAMBDA    1E-6        /* should be in ]0 ; 1E-6] */
+
+#define  LEARN_PARAM1( param )   param[ 0 ]  /* contains 1st learning param */
+#define  LEARN_PARAM2( param )   param[ 1 ]  /* contains 2nd learning param */
+#define  LEARN_PARAM3( param )   param[ 2 ]  /* contains 3rd learning param */
+#define  LEARN_PARAM4( param )   param[ 3 ]  /* contains 4th learning param */
+
+
+#define SCG_TOLERANCE 1E-8		/* for single precision */
+				/* should be 1E-16 for double precision */
+/* end private definition section */
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/sigmoid.tbl snort-2.3.3.new/src/kernel_snns/sigmoid.tbl
--- snort-2.3.3/src/kernel_snns/sigmoid.tbl	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/sigmoid.tbl	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,243 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/sigmoid.tbl,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Approximation Table for the Sigmoid Function
+  NOTES          :
+
+  AUTHOR         : Niels Mache 
+  DATE           : 08.12.91 
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.2 $
+  LAST CHANGE    : $Date: 1997/11/12 17:37:07 $
+
+    Copyright (c) 1990-1998  SNNS Group, IPVR, Univ. Stuttgart, Germany
+
+******************************************************************************/
+
+/*
+No. of Approx.: 1000
+Min. x: -12
+Max. x: 12
+Minus inf. border: -13
+Plus inf. border : 13
+Error in [-100,+100]: 7.42501e-05
+*/
+
+#define NO_OF_APPROX 1000
+#define INDEX_OFFSET 500
+#define MINUS_INFINITE_FUNC_VALUE 0.000000000
+#define PLUS_INFINITE_FUNC_VALUE 1.000000000
+#define SCALE_FACTOR 41.66666667
+#define MIN_INDEX -41
+#define MAX_INDEX 1041
+
+static float m[] = {
+3.8838503e-06,  /*  minus infinite border  */
+6.218459e-06, 6.3695054e-06, 6.5242207e-06, 6.6826939e-06, 6.8450165e-06, 7.0112818e-06, 7.1815856e-06, 7.356026e-06, 7.5347035e-06, 7.7177211e-06,
+7.905184e-06, 8.0972003e-06, 8.2938806e-06, 8.4953382e-06, 8.7016891e-06, 8.9130521e-06, 9.129549e-06, 9.3513045e-06, 9.5784463e-06, 9.8111053e-06,
+1.0049415e-05, 1.0293514e-05, 1.0543541e-05, 1.0799642e-05, 1.1061963e-05, 1.1330655e-05, 1.1605874e-05, 1.1887778e-05, 1.2176528e-05, 1.2472293e-05,
+1.2775241e-05, 1.3085548e-05, 1.3403391e-05, 1.3728955e-05, 1.4062426e-05, 1.4403997e-05, 1.4753864e-05, 1.511223e-05, 1.5479299e-05, 1.5855284e-05,
+1.6240402e-05, 1.6634873e-05, 1.7038926e-05, 1.7452792e-05, 1.7876711e-05, 1.8310926e-05, 1.8755688e-05, 1.9211252e-05, 1.9677881e-05, 2.0155843e-05,
+2.0645415e-05, 2.1146878e-05, 2.166052e-05, 2.2186637e-05, 2.2725533e-05, 2.3277518e-05, 2.3842909e-05, 2.4422033e-05, 2.5015222e-05, 2.5622819e-05,
+2.6245172e-05, 2.6882642e-05, 2.7535594e-05, 2.8204404e-05, 2.8889458e-05, 2.9591151e-05, 3.0309886e-05, 3.1046077e-05, 3.1800148e-05, 3.2572534e-05,
+3.3363678e-05, 3.4174037e-05, 3.5004077e-05, 3.5854276e-05, 3.6725124e-05, 3.7617122e-05, 3.8530783e-05, 3.9466634e-05, 4.0425214e-05, 4.1407074e-05,
+4.241278e-05, 4.344291e-05, 4.4498058e-05, 4.5578832e-05, 4.6685852e-05, 4.7819758e-05, 4.8981202e-05, 5.0170851e-05, 5.1389392e-05, 5.2637525e-05,
+5.3915969e-05, 5.5225461e-05, 5.6566753e-05, 5.7940618e-05, 5.9347847e-05, 6.078925e-05, 6.2265656e-05, 6.3777916e-05, 6.5326899e-05, 6.6913498e-05,
+6.8538625e-05, 7.0203216e-05, 7.190823e-05, 7.3654646e-05, 7.5443471e-05, 7.7275734e-05, 7.9152488e-05, 8.1074816e-05, 8.3043822e-05, 8.5060639e-05,
+8.7126429e-05, 8.924238e-05, 9.140971e-05, 9.3629665e-05, 9.5903523e-05, 9.8232592e-05, 0.00010061821, 0.00010306176, 0.00010556463, 0.00010812828,
+0.00011075416, 0.00011344381, 0.00011619875, 0.00011902058, 0.00012191093, 0.00012487144, 0.00012790383, 0.00013100984, 0.00013419126, 0.00013744991,
+0.00014078768, 0.00014420647, 0.00014770825, 0.00015129505, 0.00015496891, 0.00015873196, 0.00016258636, 0.00016653432, 0.00017057811, 0.00017472006,
+0.00017896254, 0.000183308, 0.00018775894, 0.00019231791, 0.00019698753, 0.00020177049, 0.00020666954, 0.00021168748, 0.0002168272, 0.00022209166,
+0.00022748389, 0.00023300697, 0.00023866408, 0.00024445847, 0.00025039347, 0.00025647248, 0.00026269901, 0.00026907662, 0.00027560897, 0.00028229982,
+0.000289153, 0.00029617246, 0.00030336222, 0.0003107264, 0.00031826924, 0.00032599506, 0.00033390829, 0.00034201348, 0.00035031527, 0.00035881843,
+0.00036752784, 0.00037644848, 0.00038558548, 0.00039494407, 0.00040452962, 0.00041434763, 0.00042440372, 0.00043470365, 0.00044525334, 0.00045605881,
+0.00046712627, 0.00047846205, 0.00049007265, 0.00050196471, 0.00051414505, 0.00052662064, 0.00053939861, 0.00055248629, 0.00056589116, 0.00057962089,
+0.00059368334, 0.00060808654, 0.00062283875, 0.00063794838, 0.00065342409, 0.00066927471, 0.0006855093, 0.00070213714, 0.00071916772, 0.00073661078,
+0.00075447627, 0.00077277439, 0.00079151558, 0.00081071055, 0.00083037023, 0.00085050585, 0.00087112888, 0.00089225108, 0.00091388449, 0.00093604144,
+0.00095873454, 0.00098197673, 0.0010057812, 0.0010301616, 0.0010551317, 0.0010807057, 0.0011068982, 0.0011337241, 0.0011611986, 0.0011893373,
+0.0012181562, 0.0012476716, 0.0012779004, 0.0013088597, 0.0013405669, 0.0013730402, 0.0014062978, 0.0014403587, 0.0014752421, 0.0015109677,
+0.0015475558, 0.0015850271, 0.0016234027, 0.0016627043, 0.0017029541, 0.0017441749, 0.0017863898, 0.0018296227, 0.0018738979, 0.0019192405,
+0.0019656758, 0.00201323, 0.0020619299, 0.0021118029, 0.0021628768, 0.0022151805, 0.0022687433, 0.0023235951, 0.0023797666, 0.0024372895,
+0.0024961957, 0.0025565182, 0.0026182908, 0.002681548, 0.0027463248, 0.0028126576, 0.0028805832, 0.0029501394, 0.0030213649, 0.0030942992,
+0.0031689828, 0.0032454572, 0.0033237645, 0.0034039483, 0.0034860528, 0.0035701233, 0.0036562063, 0.0037443491, 0.0038346003, 0.0039270096,
+0.0040216275, 0.0041185061, 0.0042176985, 0.0043192589, 0.0044232428, 0.0045297069, 0.0046387094, 0.0047503095, 0.0048645679, 0.0049815467,
+0.0051013091, 0.0052239201, 0.0053494459, 0.0054779542, 0.0056095142, 0.0057441966, 0.0058820738, 0.0060232196, 0.0061677096, 0.0063156208,
+0.0064670321, 0.006622024, 0.0067806788, 0.0069430805, 0.007109315, 0.0072794699, 0.0074536348, 0.0076319011, 0.0078143622, 0.0080011136,
+0.0081922525, 0.0083878784, 0.0085880927, 0.008792999, 0.009002703, 0.0092173127, 0.0094369381, 0.0096616915, 0.0098916877, 0.010127044,
+0.010367878, 0.010614314, 0.010866474, 0.011124485, 0.011388476, 0.011658579, 0.011934928, 0.012217659, 0.012506912, 0.012802829,
+0.013105554, 0.013415234, 0.013732019, 0.014056063, 0.01438752, 0.01472655, 0.015073312, 0.015427972, 0.015790696, 0.016161654,
+0.016541018, 0.016928965, 0.017325672, 0.017731322, 0.018146099, 0.01857019, 0.019003786, 0.01944708, 0.019900269, 0.020363552,
+0.020837132, 0.021321213, 0.021816004, 0.022321717, 0.022838565, 0.023366766, 0.023906539, 0.024458107, 0.025021696, 0.025597534,
+0.026185852, 0.026786883, 0.027400863, 0.028028032, 0.02866863, 0.029322901, 0.02999109, 0.030673446, 0.031370218, 0.032081658,
+0.03280802, 0.033549559, 0.034306534, 0.035079201, 0.035867821, 0.036672654, 0.037493963, 0.03833201, 0.039187058, 0.04005937,
+0.04094921, 0.041856842, 0.042782528, 0.04372653, 0.044689111, 0.045670531, 0.046671047, 0.047690918, 0.048730398, 0.049789739,
+0.050869192, 0.051969001, 0.053089409, 0.054230656, 0.055392975, 0.056576595, 0.05778174, 0.059008627, 0.060257469, 0.061528469,
+0.062821825, 0.064137726, 0.065476352, 0.066837874, 0.068222455, 0.069630246, 0.071061385, 0.072516003, 0.073994215, 0.075496123,
+0.077021817, 0.078571372, 0.080144846, 0.081742283, 0.083363708, 0.085009132, 0.086678544, 0.088371914, 0.090089194, 0.091830314,
+0.093595181, 0.095383681, 0.097195677, 0.099031006, 0.10088948, 0.10277088, 0.10467498, 0.1066015, 0.10855014, 0.11052059,
+0.11251247, 0.11452541, 0.11655898, 0.11861273, 0.12068618, 0.1227788, 0.12489004, 0.12701931, 0.12916597, 0.13132938,
+0.13350881, 0.13570354, 0.13791279, 0.14013574, 0.14237153, 0.14461927, 0.14687803, 0.14914683, 0.15142465, 0.15371044,
+0.15600312, 0.15830153, 0.16060452, 0.16291087, 0.16521933, 0.16752861, 0.16983738, 0.1721443, 0.17444794, 0.17674689,
+0.17903968, 0.18132482, 0.18360076, 0.18586595, 0.1881188, 0.19035771, 0.19258102, 0.19478709, 0.19697422, 0.19914072,
+0.20128486, 0.20340492, 0.20549916, 0.20756581, 0.20960312, 0.21160933, 0.21358267, 0.21552138, 0.2174237, 0.21928788,
+0.22111218, 0.22289487, 0.22463425, 0.22632863, 0.22797635, 0.22957576, 0.23112526, 0.23262328, 0.23406827, 0.23545874,
+0.23679324, 0.23807035, 0.23928871, 0.24044703, 0.24154403, 0.24257854, 0.24354941, 0.24445557, 0.24529602, 0.24606982,
+0.2467761, 0.24741406, 0.24798298, 0.24848222, 0.24891121, 0.24926945, 0.24955654, 0.24977214, 0.24991602, 0.249988,
+0.249988, 0.24991602, 0.24977214, 0.24955654, 0.24926945, 0.24891121, 0.24848222, 0.24798298, 0.24741406, 0.2467761,
+0.24606982, 0.24529602, 0.24445557, 0.24354941, 0.24257854, 0.24154403, 0.24044703, 0.23928871, 0.23807035, 0.23679324,
+0.23545874, 0.23406827, 0.23262328, 0.23112526, 0.22957576, 0.22797635, 0.22632863, 0.22463425, 0.22289487, 0.22111218,
+0.21928788, 0.2174237, 0.21552138, 0.21358267, 0.21160933, 0.20960312, 0.20756581, 0.20549916, 0.20340492, 0.20128486,
+0.19914072, 0.19697422, 0.19478709, 0.19258102, 0.19035771, 0.1881188, 0.18586595, 0.18360076, 0.18132482, 0.17903968,
+0.17674689, 0.17444794, 0.1721443, 0.16983738, 0.16752861, 0.16521933, 0.16291087, 0.16060452, 0.15830153, 0.15600312,
+0.15371044, 0.15142465, 0.14914683, 0.14687803, 0.14461927, 0.14237153, 0.14013574, 0.13791279, 0.13570354, 0.13350881,
+0.13132938, 0.12916597, 0.12701931, 0.12489004, 0.1227788, 0.12068618, 0.11861273, 0.11655898, 0.11452541, 0.11251247,
+0.11052059, 0.10855014, 0.1066015, 0.10467498, 0.10277088, 0.10088948, 0.099031006, 0.097195677, 0.095383681, 0.093595181,
+0.091830314, 0.090089194, 0.088371914, 0.086678544, 0.085009132, 0.083363708, 0.081742283, 0.080144846, 0.078571372, 0.077021817,
+0.075496123, 0.073994215, 0.072516003, 0.071061385, 0.069630246, 0.068222455, 0.066837874, 0.065476352, 0.064137726, 0.062821825,
+0.061528469, 0.060257469, 0.059008627, 0.05778174, 0.056576595, 0.055392975, 0.054230656, 0.053089409, 0.051969001, 0.050869192,
+0.049789739, 0.048730398, 0.047690918, 0.046671047, 0.045670531, 0.044689111, 0.04372653, 0.042782528, 0.041856842, 0.04094921,
+0.04005937, 0.039187058, 0.03833201, 0.037493963, 0.036672654, 0.035867821, 0.035079201, 0.034306534, 0.033549559, 0.03280802,
+0.032081658, 0.031370218, 0.030673446, 0.02999109, 0.029322901, 0.02866863, 0.028028032, 0.027400863, 0.026786883, 0.026185852,
+0.025597534, 0.025021696, 0.024458107, 0.023906539, 0.023366766, 0.022838565, 0.022321717, 0.021816004, 0.021321213, 0.020837132,
+0.020363552, 0.019900269, 0.01944708, 0.019003786, 0.01857019, 0.018146099, 0.017731322, 0.017325672, 0.016928965, 0.016541018,
+0.016161654, 0.015790696, 0.015427972, 0.015073312, 0.01472655, 0.01438752, 0.014056063, 0.013732019, 0.013415234, 0.013105554,
+0.012802829, 0.012506912, 0.012217659, 0.011934928, 0.011658579, 0.011388476, 0.011124485, 0.010866474, 0.010614314, 0.010367878,
+0.010127044, 0.0098916877, 0.0096616915, 0.0094369381, 0.0092173127, 0.009002703, 0.008792999, 0.0085880927, 0.0083878784, 0.0081922525,
+0.0080011136, 0.0078143622, 0.0076319011, 0.0074536348, 0.0072794699, 0.007109315, 0.0069430805, 0.0067806788, 0.006622024, 0.0064670321,
+0.0063156208, 0.0061677096, 0.0060232196, 0.0058820738, 0.0057441966, 0.0056095142, 0.0054779542, 0.0053494459, 0.0052239201, 0.0051013091,
+0.0049815467, 0.0048645679, 0.0047503095, 0.0046387094, 0.0045297069, 0.0044232428, 0.0043192589, 0.0042176985, 0.0041185061, 0.0040216275,
+0.0039270096, 0.0038346003, 0.0037443491, 0.0036562063, 0.0035701233, 0.0034860528, 0.0034039483, 0.0033237645, 0.0032454572, 0.0031689828,
+0.0030942992, 0.0030213649, 0.0029501394, 0.0028805832, 0.0028126576, 0.0027463248, 0.002681548, 0.0026182908, 0.0025565182, 0.0024961957,
+0.0024372895, 0.0023797666, 0.0023235951, 0.0022687433, 0.0022151805, 0.0021628768, 0.0021118029, 0.0020619299, 0.00201323, 0.0019656758,
+0.0019192405, 0.0018738979, 0.0018296227, 0.0017863898, 0.0017441749, 0.0017029541, 0.0016627043, 0.0016234027, 0.0015850271, 0.0015475558,
+0.0015109677, 0.0014752421, 0.0014403587, 0.0014062978, 0.0013730402, 0.0013405669, 0.0013088597, 0.0012779004, 0.0012476716, 0.0012181562,
+0.0011893373, 0.0011611986, 0.0011337241, 0.0011068982, 0.0010807057, 0.0010551317, 0.0010301616, 0.0010057812, 0.00098197673, 0.00095873454,
+0.00093604144, 0.00091388449, 0.00089225108, 0.00087112888, 0.00085050585, 0.00083037023, 0.00081071055, 0.00079151558, 0.00077277439, 0.00075447627,
+0.00073661078, 0.00071916772, 0.00070213714, 0.0006855093, 0.00066927471, 0.00065342409, 0.00063794838, 0.00062283875, 0.00060808654, 0.00059368334,
+0.00057962089, 0.00056589116, 0.00055248629, 0.00053939861, 0.00052662064, 0.00051414505, 0.00050196471, 0.00049007265, 0.00047846205, 0.00046712627,
+0.00045605881, 0.00044525334, 0.00043470365, 0.00042440372, 0.00041434763, 0.00040452962, 0.00039494407, 0.00038558548, 0.00037644848, 0.00036752784,
+0.00035881843, 0.00035031527, 0.00034201348, 0.00033390829, 0.00032599506, 0.00031826924, 0.0003107264, 0.00030336222, 0.00029617246, 0.000289153,
+0.00028229982, 0.00027560897, 0.00026907662, 0.00026269901, 0.00025647248, 0.00025039347, 0.00024445847, 0.00023866408, 0.00023300697, 0.00022748389,
+0.00022209166, 0.0002168272, 0.00021168748, 0.00020666954, 0.00020177049, 0.00019698753, 0.00019231791, 0.00018775894, 0.000183308, 0.00017896254,
+0.00017472006, 0.00017057811, 0.00016653432, 0.00016258636, 0.00015873196, 0.00015496891, 0.00015129505, 0.00014770825, 0.00014420647, 0.00014078768,
+0.00013744991, 0.00013419126, 0.00013100984, 0.00012790383, 0.00012487144, 0.00012191093, 0.00011902058, 0.00011619875, 0.00011344381, 0.00011075416,
+0.00010812828, 0.00010556463, 0.00010306176, 0.00010061821, 9.8232592e-05, 9.5903523e-05, 9.3629665e-05, 9.140971e-05, 8.924238e-05, 8.7126429e-05,
+8.5060639e-05, 8.3043822e-05, 8.1074816e-05, 7.9152488e-05, 7.7275734e-05, 7.5443471e-05, 7.3654646e-05, 7.190823e-05, 7.0203216e-05, 6.8538625e-05,
+6.6913498e-05, 6.5326899e-05, 6.3777916e-05, 6.2265656e-05, 6.078925e-05, 5.9347847e-05, 5.7940618e-05, 5.6566753e-05, 5.5225461e-05, 5.3915969e-05,
+5.2637525e-05, 5.1389392e-05, 5.0170851e-05, 4.8981202e-05, 4.7819758e-05, 4.6685852e-05, 4.5578832e-05, 4.4498058e-05, 4.344291e-05, 4.241278e-05,
+4.1407074e-05, 4.0425214e-05, 3.9466634e-05, 3.8530783e-05, 3.7617122e-05, 3.6725124e-05, 3.5854276e-05, 3.5004077e-05, 3.4174037e-05, 3.3363678e-05,
+3.2572534e-05, 3.1800148e-05, 3.1046077e-05, 3.0309886e-05, 2.9591151e-05, 2.8889458e-05, 2.8204404e-05, 2.7535594e-05, 2.6882642e-05, 2.6245172e-05,
+2.5622819e-05, 2.5015222e-05, 2.4422033e-05, 2.3842909e-05, 2.3277518e-05, 2.2725533e-05, 2.2186637e-05, 2.166052e-05, 2.1146878e-05, 2.0645415e-05,
+2.0155843e-05, 1.9677881e-05, 1.9211252e-05, 1.8755688e-05, 1.8310926e-05, 1.7876711e-05, 1.7452792e-05, 1.7038926e-05, 1.6634873e-05, 1.6240402e-05,
+1.5855284e-05, 1.5479299e-05, 1.511223e-05, 1.4753864e-05, 1.4403997e-05, 1.4062426e-05, 1.3728955e-05, 1.3403391e-05, 1.3085548e-05, 1.2775241e-05,
+1.2472293e-05, 1.2176528e-05, 1.1887778e-05, 1.1605874e-05, 1.1330655e-05, 1.1061963e-05, 1.0799642e-05, 1.0543541e-05, 1.0293514e-05, 1.0049415e-05,
+9.8111053e-06, 9.5784463e-06, 9.3513045e-06, 9.129549e-06, 8.9130521e-06, 8.7016891e-06, 8.4953382e-06, 8.2938806e-06, 8.0972003e-06, 7.905184e-06,
+7.7177211e-06, 7.5347035e-06, 7.356026e-06, 7.1815856e-06, 7.0112818e-06, 6.8450165e-06, 6.6826939e-06, 6.5242207e-06, 6.3695054e-06, 
+3.8838503e-06  };  /*  plus infinite border  */
+
+static float b[] = {
+5.2750378e-05,  /*  minus infinite border  */
+8.0765682e-05, 8.2574614e-05, 8.4423771e-05, 8.631404e-05, 8.8246328e-05, 9.022156e-05, 9.2240682e-05, 9.4304661e-05, 9.6414485e-05, 9.8571163e-05,
+0.00010077573, 0.00010302923, 0.00010533275, 0.00010768739, 0.00011009426, 0.00011255453, 0.00011506936, 0.00011763995, 0.00012026752, 0.00012295334,
+0.00012569867, 0.00012850483, 0.00013137314, 0.00013430498, 0.00013730173, 0.00014036483, 0.00014349572, 0.00014669589, 0.00014996686, 0.00015331018,
+0.00015672743, 0.00016022024, 0.00016379026, 0.00016743918, 0.00017116872, 0.00017498066, 0.00017887678, 0.00018285893, 0.000186929, 0.0001910889,
+0.0001953406, 0.00019968609, 0.00020412744, 0.00020866673, 0.00021330609, 0.00021804772, 0.00022289384, 0.00022784674, 0.00023290873, 0.0002380822,
+0.00024336957, 0.00024877333, 0.00025429601, 0.0002599402, 0.00026570854, 0.00027160374, 0.00027762855, 0.00028378579, 0.00029007834, 0.00029650914,
+0.0003030812, 0.00030979758, 0.00031666141, 0.00032367589, 0.0003308443, 0.00033816997, 0.00034565631, 0.00035330681, 0.00036112502, 0.00036911458,
+0.00037727918, 0.00038562264, 0.00039414881, 0.00040286165, 0.0004117652, 0.00042086358, 0.000430161, 0.00043966176, 0.00044937025, 0.00045929097,
+0.00046942848, 0.00047978747, 0.00049037272, 0.0005011891, 0.00051224159, 0.0005235353, 0.0005350754, 0.0005468672, 0.00055891613, 0.00057122772,
+0.00058380761, 0.00059666158, 0.00060979551, 0.00062321543, 0.00063692747, 0.0006509379, 0.00066525314, 0.00067987971, 0.0006948243, 0.00071009373,
+0.00072569495, 0.00074163508, 0.00075792136, 0.00077456122, 0.00079156221, 0.00080893206, 0.00082667866, 0.00084481005, 0.00086333445, 0.00088226027,
+0.00090159606, 0.00092135058, 0.00094153275, 0.0009621517, 0.00098321672, 0.0010047373, 0.0010267232, 0.0010491842, 0.0010721306, 0.0010955726,
+0.0011195207, 0.0011439857, 0.0011689785, 0.0011945105, 0.0012205929, 0.0012472376, 0.0012744563, 0.0013022613, 0.001330665, 0.00135968,
+0.0013893194, 0.0014195962, 0.001450524, 0.0014821164, 0.0015143877, 0.001547352, 0.001581024, 0.0016154186, 0.001650551, 0.0016864369,
+0.001723092, 0.0017605325, 0.0017987749, 0.0018378362, 0.0018777334, 0.0019184842, 0.0019601065, 0.0020026185, 0.0020460389, 0.0020903868,
+0.0021356814, 0.0021819427, 0.0022291909, 0.0022774466, 0.0023267309, 0.0023770651, 0.0024284713, 0.0024809718, 0.0025345893, 0.0025893472,
+0.0026452692, 0.0027023795, 0.0027607028, 0.0028202643, 0.0028810898, 0.0029432054, 0.0030066378, 0.0030714145, 0.0031375632, 0.0032051123,
+0.0032740908, 0.0033445282, 0.0034164546, 0.0034899009, 0.0035648982, 0.0036414787, 0.0037196748, 0.0037995199, 0.0038810479, 0.0039642932,
+0.0040492913, 0.0041360781, 0.0042246902, 0.004315165, 0.0044075406, 0.0045018561, 0.0045981509, 0.0046964655, 0.0047968412, 0.0048993199,
+0.0050039445, 0.0051107587, 0.005219807, 0.0053311348, 0.0054447884, 0.0055608149, 0.0056792625, 0.0058001801, 0.0059236178, 0.0060496264,
+0.006178258, 0.0063095653, 0.0064436023, 0.006580424, 0.0067200864, 0.0068626466, 0.0070081627, 0.007156694, 0.007308301, 0.0074630451,
+0.0076209891, 0.0077821969, 0.0079467335, 0.0081146654, 0.0082860601, 0.0084609865, 0.0086395146, 0.0088217159, 0.0090076632, 0.0091974307,
+0.0093910937, 0.0095887293, 0.0097904158, 0.0099962328, 0.010206262, 0.010420585, 0.010639287, 0.010862454, 0.011090173, 0.011322532,
+0.011559624, 0.011801538, 0.01204837, 0.012300215, 0.01255717, 0.012819333, 0.013086807, 0.013359693, 0.013638096, 0.013922121,
+0.014211878, 0.014507475, 0.014809025, 0.015116641, 0.01543044, 0.015750538, 0.016077057, 0.016410117, 0.016749842, 0.01709636,
+0.017449797, 0.017810285, 0.018177955, 0.018552944, 0.018935386, 0.019325423, 0.019723195, 0.020128847, 0.020542525, 0.020964377,
+0.021394554, 0.021833211, 0.022280503, 0.022736588, 0.023201628, 0.023675786, 0.024159228, 0.024652122, 0.025154641, 0.025666958,
+0.026189249, 0.026721694, 0.027264474, 0.027817776, 0.028381784, 0.028956691, 0.029542688, 0.030139972, 0.03074874, 0.031369196,
+0.032001542, 0.032645985, 0.033302736, 0.033972007, 0.034654014, 0.035348975, 0.036057112, 0.03677865, 0.037513815, 0.038262837,
+0.03902595, 0.03980339, 0.040595394, 0.041402206, 0.042224069, 0.043061231, 0.043913943, 0.044782456, 0.045667028, 0.046567916,
+0.047485383, 0.048419692, 0.049371111, 0.050339908, 0.051326356, 0.052330729, 0.053353304, 0.054394362, 0.055454185, 0.056533056,
+0.057631262, 0.058749093, 0.059886839, 0.061044793, 0.06222325, 0.063422508, 0.064642864, 0.06588462, 0.067148077, 0.068433539,
+0.06974131, 0.071071696, 0.072425004, 0.073801541, 0.075201617, 0.07662554, 0.078073621, 0.079546168, 0.081043493, 0.082565904,
+0.08411371, 0.085687222, 0.087286747, 0.088912592, 0.090565062, 0.092244463, 0.093951096, 0.095685263, 0.097447262, 0.099237387,
+0.10105593, 0.10290319, 0.10477944, 0.10668496, 0.10862004, 0.11058495, 0.11257995, 0.11460531, 0.11666128, 0.11874812,
+0.12086606, 0.12301535, 0.1251962, 0.12740886, 0.12965351, 0.13193037, 0.13423964, 0.13658148, 0.13895608, 0.14136359,
+0.14380417, 0.14627795, 0.14878504, 0.15132557, 0.15389963, 0.15650729, 0.15914862, 0.16182366, 0.16453246, 0.16727501,
+0.17005131, 0.17286134, 0.17570504, 0.17858236, 0.18149321, 0.18443746, 0.187415, 0.19042566, 0.19346926, 0.19654559,
+0.19965441, 0.20279546, 0.20596846, 0.20917308, 0.21240898, 0.21567577, 0.21897304, 0.22230036, 0.22565725, 0.22904319,
+0.23245765, 0.23590005, 0.23936977, 0.24286616, 0.24638853, 0.24993616, 0.25350829, 0.2571041, 0.26072276, 0.26436339,
+0.26802506, 0.2717068, 0.27540761, 0.27912644, 0.28286221, 0.28661377, 0.29037997, 0.29415957, 0.29795132, 0.30175393,
+0.30556604, 0.30938628, 0.31321321, 0.31704538, 0.32088127, 0.32471934, 0.32855799, 0.33239562, 0.33623055, 0.34006109,
+0.34388551, 0.34770204, 0.35150889, 0.35530422, 0.35908619, 0.36285291, 0.36660247, 0.37033294, 0.37404238, 0.37772882,
+0.38139027, 0.38502475, 0.38863024, 0.39220474, 0.39574624, 0.39925272, 0.40272217, 0.40615259, 0.40954199, 0.41288839,
+0.41618984, 0.4194444, 0.42265015, 0.42580524, 0.42890781, 0.43195606, 0.43494823, 0.43788262, 0.44075757, 0.44357149,
+0.44632284, 0.44901015, 0.45163204, 0.45418717, 0.45667432, 0.45909234, 0.46144016, 0.46371682, 0.46592145, 0.46805328,
+0.47011166, 0.47209604, 0.47400598, 0.47584117, 0.47760141, 0.47928662, 0.48089687, 0.48243232, 0.4838933, 0.48528025,
+0.48659375, 0.4878345, 0.48900337, 0.49010133, 0.4911295, 0.49208915, 0.49298166, 0.49380857, 0.49457152, 0.49527232,
+0.49591288, 0.49649524, 0.49702158, 0.49749417, 0.49791542, 0.49828784, 0.49861405, 0.49889678, 0.49913882, 0.49934311,
+0.49951261, 0.49965041, 0.49975965, 0.49984352, 0.49990529, 0.49994828, 0.49997584, 0.49999137, 0.49999827, 0.5,
+0.5, 0.50000173, 0.50000863, 0.50002416, 0.50005172, 0.50009471, 0.50015648, 0.50024035, 0.50034959, 0.50048739,
+0.50065689, 0.50086118, 0.50110322, 0.50138595, 0.50171216, 0.50208458, 0.50250583, 0.50297842, 0.50350476, 0.50408712,
+0.50472768, 0.50542848, 0.50619143, 0.50701834, 0.50791085, 0.5088705, 0.50989867, 0.51099663, 0.51216549, 0.51340625,
+0.51471974, 0.51610669, 0.51756768, 0.51910313, 0.52071338, 0.52239859, 0.52415883, 0.52599402, 0.52790396, 0.52988834,
+0.53194672, 0.53407855, 0.53628318, 0.53855984, 0.54090766, 0.54332568, 0.54581283, 0.54836796, 0.55098985, 0.55367716,
+0.55642851, 0.55924243, 0.56211738, 0.56505177, 0.56804394, 0.57109219, 0.57419476, 0.57734984, 0.5805556, 0.58381016,
+0.58711161, 0.59045801, 0.59384741, 0.59727783, 0.60074728, 0.60425376, 0.60779526, 0.61136976, 0.61497525, 0.61860972,
+0.62227118, 0.62595762, 0.62966706, 0.63339753, 0.63714709, 0.64091381, 0.64469578, 0.64849111, 0.65229796, 0.65611449,
+0.65993891, 0.66376945, 0.66760438, 0.671442, 0.67528066, 0.67911873, 0.68295462, 0.68678678, 0.69061372, 0.69443396,
+0.69824607, 0.70204868, 0.70584043, 0.70962003, 0.71338622, 0.71713779, 0.72087356, 0.72459239, 0.7282932, 0.73197494,
+0.73563661, 0.73927723, 0.7428959, 0.74649171, 0.75006384, 0.75361147, 0.75713384, 0.76063023, 0.76409995, 0.76754235,
+0.7709568, 0.77434275, 0.77769964, 0.78102696, 0.78432423, 0.78759102, 0.79082692, 0.79403154, 0.79720454, 0.80034559,
+0.80345441, 0.80653074, 0.80957434, 0.812585, 0.81556253, 0.81850679, 0.82141764, 0.82429496, 0.82713866, 0.82994869,
+0.83272499, 0.83546754, 0.83817633, 0.84085138, 0.84349271, 0.84610037, 0.84867442, 0.85121496, 0.85372205, 0.85619583,
+0.85863641, 0.86104392, 0.86341852, 0.86576036, 0.86806962, 0.87034649, 0.87259114, 0.87480379, 0.87698465, 0.87913394,
+0.88125188, 0.88333872, 0.88539469, 0.88742005, 0.88941505, 0.89137996, 0.89331504, 0.89522056, 0.89709681, 0.89894407,
+0.90076261, 0.90255274, 0.90431474, 0.9060489, 0.90775554, 0.90943494, 0.91108741, 0.91271325, 0.91431278, 0.91588629,
+0.9174341, 0.91895651, 0.92045383, 0.92192638, 0.92337446, 0.92479838, 0.92619846, 0.927575, 0.9289283, 0.93025869,
+0.93156646, 0.93285192, 0.93411538, 0.93535714, 0.93657749, 0.93777675, 0.93895521, 0.94011316, 0.94125091, 0.94236874,
+0.94346694, 0.94454582, 0.94560564, 0.9466467, 0.94766927, 0.94867364, 0.94966009, 0.95062889, 0.95158031, 0.95251462,
+0.95343208, 0.95433297, 0.95521754, 0.95608606, 0.95693877, 0.95777593, 0.95859779, 0.9594046, 0.96019661, 0.96097405,
+0.96173716, 0.96248618, 0.96322135, 0.96394289, 0.96465102, 0.96534599, 0.96602799, 0.96669726, 0.96735402, 0.96799846,
+0.9686308, 0.96925126, 0.96986003, 0.97045731, 0.97104331, 0.97161822, 0.97218222, 0.97273552, 0.97327831, 0.97381075,
+0.97433304, 0.97484536, 0.97534788, 0.97584077, 0.97632421, 0.97679837, 0.97726341, 0.9777195, 0.97816679, 0.97860544,
+0.97903562, 0.97945748, 0.97987115, 0.9802768, 0.98067458, 0.98106461, 0.98144706, 0.98182204, 0.98218972, 0.9825502,
+0.98290364, 0.98325016, 0.98358988, 0.98392294, 0.98424946, 0.98456956, 0.98488336, 0.98519098, 0.98549252, 0.98578812,
+0.98607788, 0.9863619, 0.98664031, 0.98691319, 0.98718067, 0.98744283, 0.98769978, 0.98795163, 0.98819846, 0.98844038,
+0.98867747, 0.98890983, 0.98913754, 0.98936071, 0.98957941, 0.98979374, 0.99000377, 0.99020958, 0.99041127, 0.99060891,
+0.99080257, 0.99099234, 0.99117828, 0.99136048, 0.99153901, 0.99171394, 0.99188533, 0.99205327, 0.9922178, 0.99237901,
+0.99253695, 0.9926917, 0.9928433, 0.99299184, 0.99313735, 0.99327991, 0.99341958, 0.9935564, 0.99369043, 0.99382174,
+0.99395037, 0.99407638, 0.99419982, 0.99432074, 0.99443918, 0.99455521, 0.99466886, 0.99478019, 0.99488924, 0.99499606,
+0.99510068, 0.99520316, 0.99530353, 0.99540185, 0.99549814, 0.99559246, 0.99568484, 0.99577531, 0.99586392, 0.99595071,
+0.99603571, 0.99611895, 0.99620048, 0.99628032, 0.99635852, 0.9964351, 0.9965101, 0.99658354, 0.99665547, 0.99672591,
+0.99679489, 0.99686244, 0.99692858, 0.99699336, 0.99705679, 0.99711891, 0.99717974, 0.9972393, 0.99729762, 0.99735473,
+0.99741065, 0.99746541, 0.99751903, 0.99757153, 0.99762293, 0.99767327, 0.99772255, 0.99777081, 0.99781806, 0.99786432,
+0.99790961, 0.99795396, 0.99799738, 0.99803989, 0.99808152, 0.99812227, 0.99816216, 0.99820122, 0.99823947, 0.99827691,
+0.99831356, 0.99834945, 0.99838458, 0.99841898, 0.99845265, 0.99848561, 0.99851788, 0.99854948, 0.9985804, 0.99861068,
+0.99864032, 0.99866933, 0.99869774, 0.99872554, 0.99875276, 0.99877941, 0.99880549, 0.99883102, 0.99885601, 0.99888048,
+0.99890443, 0.99892787, 0.99895082, 0.99897328, 0.99899526, 0.99901678, 0.99903785, 0.99905847, 0.99907865, 0.9990984,
+0.99911774, 0.99913666, 0.99915519, 0.99917332, 0.99919107, 0.99920844, 0.99922544, 0.99924208, 0.99925836, 0.9992743,
+0.99928991, 0.99930518, 0.99932012, 0.99933475, 0.99934906, 0.99936307, 0.99937678, 0.9993902, 0.99940334, 0.99941619,
+0.99942877, 0.99944108, 0.99945313, 0.99946492, 0.99947646, 0.99948776, 0.99949881, 0.99950963, 0.99952021, 0.99953057,
+0.99954071, 0.99955063, 0.99956034, 0.99956984, 0.99957914, 0.99958823, 0.99959714, 0.99960585, 0.99961438, 0.99962272,
+0.99963088, 0.99963887, 0.99964669, 0.99965434, 0.99966183, 0.99966916, 0.99967632, 0.99968334, 0.9996902, 0.99969692,
+0.99970349, 0.99970992, 0.99971621, 0.99972237, 0.9997284, 0.99973429, 0.99974006, 0.9997457, 0.99975123, 0.99975663,
+0.99976192, 0.99976709, 0.99977215, 0.99977711, 0.99978195, 0.99978669, 0.99979133, 0.99979587, 0.99980031, 0.99980466,
+0.99980891, 0.99981307, 0.99981714, 0.99982112, 0.99982502, 0.99982883, 0.99983256, 0.99983621, 0.99983978, 0.99984327,
+0.99984669, 0.99985003, 0.9998533, 0.9998565, 0.99985964, 0.9998627, 0.9998657, 0.99986863, 0.9998715, 0.9998743,
+0.99987705, 0.99987973, 0.99988236, 0.99988493, 0.99988744, 0.9998899, 0.99989231, 0.99989467, 0.99989697, 0.99989922,
+0.99990143, 0.99990358, 0.9999057, 0.99990776, 0.99990978, 0.99991175, 0.99991368, 0.99991558, 0.99991742, 
+0.99994725  };  /*  plus infinite border  */
diff -Naur snort-2.3.3/src/kernel_snns/stochastic_learn_f.c snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.c
--- snort-2.3.3/src/kernel_snns/stochastic_learn_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,799 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/stochastic_learn_f.c,v $
+  SHORTNAME      : stochastic_learn_f.c
+  SNNS VERSION   : 4.2
+  
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions:
+                   - Monte-Carlo
+                   - Simulated Annealing
+  
+  AUTHOR         : Joachim Danz
+  DATE           : 27.04.1994
+  
+  CHANGED BY     : Guenter Mamier
+  RCS VERSION    : $Revision: 1.9 $
+  LAST CHANGE    : $Date: 1998/03/13 16:24:03 $
+  
+             Copyright (c) 1994-95 Joachim Danz, TH Darmstadt, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+  
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"		/* Kernel Types and Constants  */
+#include "kr_const.h"		/* Constant Declarators for SNNS-Kernel */
+#include "kr_def.h"		/* Default Values  */
+#include "kernel.h"		/* kernel function prototypes  */
+#include "kr_mac.h"		/* Kernel Macros   */
+#include "glob_typ.h"
+#include "kr_art.h"
+#include "kr_art1.h"
+#include "kr_art2.h"
+#include "kr_amap.h"
+#include "krart_df.h"
+#include "learn_f.h"
+#include "stochastic_learn_f.ph"
+#include "random.h"
+#include "kr_newpattern.h"
+
+#define NOT_MODIFIED 0
+#define LAST_MODIFIED 1
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_MonteCarlo
+  
+  PURPOSE  : Monte Carlo adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 19.02.1995
+******************************************************************************/
+
+krui_err
+LEARN_MonteCarlo(int start_pattern, int end_pattern, float *parameterInArray,
+		 int NoOfInParams, float **parameterOutArray,
+		 int *NoOfOutParams)
+{
+    static float    OutParameter[1]; /* OutParameter[0] stores the
+				      * learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+    float           error;
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+    if (NoOfInParams < 2)
+	return (KRERR_PARAMETERS); /* Not enough input parameters  */
+    *NoOfOutParams = 1;		/* One return value is available (the
+				 * learning error)  */
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    if (NetModified) {		/* Net has been modified */
+
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGICAL_FF);
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	MinimumError = 10000000;
+	NetModified = FALSE;
+    }
+    if (NetInitialize || LearnFuncHasChanged) {	/* Net has been modified */
+	MinimumError = 10000000;
+    }
+    /* randomize weigths and bias */
+
+    FOR_ALL_UNITS(unit_ptr) {
+	unit_ptr->bias = (FlintType) drand48() *
+	    (LEARN_PARAM2(parameterInArray) - LEARN_PARAM1(parameterInArray))
+		+ LEARN_PARAM1(parameterInArray);
+	flags = unit_ptr->flags;
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) { /* unit is in use  */
+	    unit_ptr->value_a = (FlintType) 0;
+
+	    if (flags & UFLAG_SITES) { /* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    link_ptr->weight = (FlintType) drand48() *
+			(LEARN_PARAM2(parameterInArray) -
+			 LEARN_PARAM1(parameterInArray)) +
+			     LEARN_PARAM1(parameterInArray);
+	    } else {		/* unit has no sites   */
+		if (flags & UFLAG_DLINKS) { /* unit has direct links */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			link_ptr->weight = (FlintType) drand48() *
+			    (LEARN_PARAM2(parameterInArray) -
+			     LEARN_PARAM1(parameterInArray)) +
+				 LEARN_PARAM1(parameterInArray);
+		}
+	    }
+	}
+    }
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+    NET_ERROR(OutParameter) = 0.0; /* reset network error value  */
+
+    /* calculate performance of new net */
+    while (kr_getSubPatternByOrder(&pattern_no, &sub_pat_no)) {
+	propagateNetForward(pattern_no, sub_pat_no);
+	/* Forward propagation */
+	if ((error = calculate_SS_error(pattern_no, sub_pat_no)) == -1)
+	    return (-1);
+	NET_ERROR(OutParameter) += error;
+    }
+
+    /* store weights and bias if error decreased */
+    if (NET_ERROR(OutParameter) < MinimumError) {
+	MinimumError = NET_ERROR(OutParameter);
+	FOR_ALL_UNITS(unit_ptr) {
+	    flags = unit_ptr->flags;
+	    unit_ptr->value_b = unit_ptr->bias;
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use  */
+		if (flags & UFLAG_SITES) { /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			link_ptr->value_b = link_ptr->weight;
+		} else {	/* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {
+			/* unit has direct links         */
+			FOR_ALL_LINKS(unit_ptr, link_ptr)
+			    link_ptr->value_b = link_ptr->weight;
+		    }
+		}
+	    }
+	}
+
+    }
+
+    /* restore best net */
+    FOR_ALL_UNITS(unit_ptr) {
+	flags = unit_ptr->flags;
+	unit_ptr->bias = unit_ptr->value_b;
+	if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) { /* unit is in use  */
+	    if (flags & UFLAG_SITES) { /* unit has sites  */
+		FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+		    link_ptr->weight = link_ptr->value_b;
+	    } else {		/* unit has no sites   */
+		if (flags & UFLAG_DLINKS) { /* unit has direct links */
+		    FOR_ALL_LINKS(unit_ptr, link_ptr)
+			link_ptr->weight = link_ptr->value_b;
+		}
+	    }
+	}
+    }
+
+    return (ret_code);
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_MonteCarlo
+  
+  PURPOSE  : Monte Carlo adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 17.02.1995
+*****************************************************************************/
+
+krui_err
+TEST_MonteCarlo(int start_pattern, int end_pattern, float *parameterInArray,
+		int NoOfInParams, float **parameterOutArray,
+		int *NoOfOutParams)
+{
+    static float    OutParameter[1]; /* OutParameter[0] stores the
+				      * learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+    float           error;
+
+    *NoOfOutParams = 1;		/* One return value is available (the
+				 * learning error)  */
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+    NET_ERROR(OutParameter) = 0.0; /* reset network error value  */
+
+    /* calculate performance of new net */
+    while (kr_getSubPatternByOrder(&pattern_no, &sub_pat_no)) {
+	propagateNetForward(pattern_no, sub_pat_no);
+	/* Forward propagation */
+	if ((error = calculate_SS_error(pattern_no, sub_pat_no)) == -1)
+	    return (-1);
+	NET_ERROR(OutParameter) += error;
+    }
+
+    return (ret_code);
+}
+
+/*****************************************************************************
+  FUNCTION : calculate_WTA_errror
+  
+  PURPOSE  : Winner Takes All error calculation for one pattern
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+
+float 
+calculate_WTA_error(int pattern_no, int sub_pat_no)
+{
+    int             j, wta_pos, out_pat_pos, size;
+    float           wta_value, out_pat_value;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate address of the output pattern (with number pattern_no + 1) */
+    out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, &size);
+    if (out_pat == NULL) {
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return (-1);
+    }
+    out_pat += size;
+
+    /*
+     * add 3 to no_of_topo_units because the topologic array contains 4 NULL
+     * pointers
+     */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+    wta_value = 0;
+    wta_pos = 0;
+    out_pat_value = 0;
+    out_pat_pos = 0;
+    j = 0;
+    /* Winner Takes All - error computation */
+    if (NoOfOutputUnits > 1) {
+
+	/* calculate output units only  */
+	while ((unit_ptr = *--topo_ptr) != NULL) {
+	    j++;
+	    if (wta_value < unit_ptr->Out.output) {
+		wta_value = unit_ptr->Out.output;
+		wta_pos = j;
+	    }
+	    if (out_pat_value < *(--out_pat)) {
+		out_pat_value = *(out_pat);
+		out_pat_pos = j;
+	    }
+	}
+	if (wta_pos != out_pat_pos) {
+	    return ((float) 1.0);
+	}
+    } else {
+	unit_ptr = *--topo_ptr;
+	if ((float) unit_ptr->Out.output > 0.5) {
+	    if (*(--out_pat) < 0.5)
+		return ((float) 1.0);
+	} else {
+	    if (*(--out_pat) > 0.5)
+		return ((float) 1.0);
+	}
+    }
+    return ((float) 0.0);
+}
+/*****************************************************************************
+  FUNCTION : calculate_w_WTA_errror
+  
+  PURPOSE  : weighted Winner Takes All error calculation for one pattern
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+
+float 
+calculate_w_WTA_error(int pattern_no, int sub_pat_no)
+{
+    int             j, wta_pos, out_pat_pos, size;
+    float           wta_value, out_pat_value, sum_value;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate address of the output pattern (with number pattern_no + 1) */
+    out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, &size);
+    if (out_pat == NULL) {
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return (-1);
+    }
+    out_pat += size;
+
+    /*
+     * add 3 to no_of_topo_units because the topologic array contains 4 NULL
+     * pointers
+     */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+    wta_value = 0;
+    wta_pos = 0;
+    sum_value = 0;
+    out_pat_value = 0;
+    out_pat_pos = 0;
+    j = 0;
+    /* weighted Winner Takes All - error computation */
+    if (NoOfOutputUnits > 1) {
+
+	/* calculate output units only  */
+	while ((unit_ptr = *--topo_ptr) != NULL) {
+	    j++;
+	    sum_value += unit_ptr->Out.output;
+	    if (wta_value < unit_ptr->Out.output) {
+		wta_value = unit_ptr->Out.output;
+		wta_pos = j;
+	    }
+	    if (out_pat_value < *(--out_pat)) {
+		out_pat_value = *(out_pat);
+		out_pat_pos = j;
+	    }
+	}
+	if (wta_pos != out_pat_pos)
+	    return ((float) 1.0);
+	else
+	    return ((float) fabs(wta_value - (sum_value - wta_value) / (--j)));
+    } else {
+	unit_ptr = *--topo_ptr;
+	if ((float) unit_ptr->Out.output > 0.5) {
+	    if (*(--out_pat) < 0.5)
+		return ((float) 1.0);
+	    else
+		return ((float) fabs(unit_ptr->Out.output - *(out_pat)) / 2);
+	} else {
+	    if (*(--out_pat) > 0.5)
+		return ((float) 1.0);
+	    else
+		return ((float) fabs(*(out_pat) - unit_ptr->Out.output) / 2);
+	}
+    }
+    return ((float) 0.0);
+}
+
+/*****************************************************************************
+  FUNCTION : calculate_SS_errror
+  
+  PURPOSE  : sum squared error for one pattern
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+
+float
+calculate_SS_error(int pattern_no, int sub_pat_no)
+{
+    int             size;
+    float           sum_error, error;
+    register struct Unit *unit_ptr;
+    register Patterns out_pat;
+    register TopoPtrArray topo_ptr;
+
+    /* calculate address of the output pattern (with number pattern_no + 1) */
+    out_pat = kr_getSubPatData(pattern_no, sub_pat_no, OUTPUT, &size);
+    if (out_pat == NULL) {
+	KernelErrorCode = KRERR_NP_NO_SUCH_PATTERN;
+	return (-1);
+    }
+    out_pat += size;
+
+    /*
+     * add 3 to no_of_topo_units because the topologic array contains 4 NULL
+     * pointers
+     */
+    topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+    sum_error = 0;
+    /* calculate output units only  */
+    while ((unit_ptr = *--topo_ptr) != NULL) {
+	error = *(--out_pat) - unit_ptr->Out.output;
+	sum_error += error * error;
+    }
+    /* calc. devitation */
+
+    return ((float) sum_error);
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_SimulatedAnnealingSS
+  
+  PURPOSE  : Simulated Annealing adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+krui_err
+LEARN_SimulatedAnnealingSS(int start_pattern, int end_pattern,
+			   float *parameterInArray, int NoOfInParams,
+			   float **parameterOutArray, int *NoOfOutParams)
+{
+    return (LEARN_SimulatedAnnealing(start_pattern, end_pattern,
+				     parameterInArray, NoOfInParams,
+				     parameterOutArray, NoOfOutParams, SS_ERROR));
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_SimulatedAnnealingWTA
+  
+  PURPOSE  : Simulated Annealing adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+krui_err
+LEARN_SimulatedAnnealingWTA(int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams,
+			    float **parameterOutArray, int *NoOfOutParams)
+{
+    return (LEARN_SimulatedAnnealing(start_pattern, end_pattern,
+				     parameterInArray, NoOfInParams,
+				     parameterOutArray, NoOfOutParams, WTA_ERROR));
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_SimulatedAnnealingWWTA
+  
+  PURPOSE  : Simulated Annealing adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+  ******************************************************************************/
+
+krui_err
+LEARN_SimulatedAnnealingWWTA(int start_pattern, int end_pattern,
+			     float *parameterInArray, int NoOfInParams,
+			     float **parameterOutArray, int *NoOfOutParams)
+{
+    return (LEARN_SimulatedAnnealing(start_pattern, end_pattern,
+				     parameterInArray, NoOfInParams,
+				     parameterOutArray, NoOfOutParams, WWTA_ERROR));
+}
+
+
+/*****************************************************************************
+  FUNCTION : LEARN_SimulatedAnnealing
+  
+  PURPOSE  : Simulated Annealing adjustment of weights and bias
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 19.02.1995
+******************************************************************************/
+
+krui_err
+LEARN_SimulatedAnnealing(int start_pattern, int end_pattern,
+			 float *parameterInArray, int NoOfInParams,
+			 float **parameterOutArray, int *NoOfOutParams,
+			 int errorFunction)
+{
+    static float    OutParameter[1]; /* OutParameter[0] stores the
+				      * learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+    float           error;
+    long int        NextParameter;
+    register FlagWord flags;
+    register struct Link *link_ptr;
+    register struct Unit *unit_ptr;
+    register struct Site *site_ptr;
+
+    if (NoOfInParams < 4)
+	return (KRERR_PARAMETERS); /* Not enough input parameters  */
+    *NoOfOutParams = 1;		/* One return value is available (the
+				 * learning error)  */
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+    NextParameter = FALSE;
+
+    if (NetModified || NetInitialize || LearnFuncHasChanged) {
+	/* Net has been modified */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)
+	    return (ret_code);
+	/* sort units by topology and by topologic type  */
+	ret_code = kr_topoSort(TOPOLOGIC_TYPE);
+
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return (ret_code);
+	FOR_ALL_UNITS(unit_ptr) {
+	    flags = unit_ptr->flags;
+	    unit_ptr->value_b = NOT_MODIFIED;
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use  */
+		if (flags & UFLAG_SITES) { /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			link_ptr->value_b = NOT_MODIFIED;
+		} else {	/* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {
+			/* unit has direct links         */
+			FOR_ALL_LINKS(unit_ptr, link_ptr)
+			    link_ptr->value_b = NOT_MODIFIED;
+		    }
+		}
+	    }
+	}
+	Temperature = LEARN_PARAM3(parameterInArray);
+	MinimumError = 99999;
+	NetModified = FALSE;
+	NextParameter = TRUE;
+    }
+    /* randomize one weigth or one bias */
+    do {
+	FOR_ALL_UNITS(unit_ptr) {
+	    flags = unit_ptr->flags;
+	    if (((flags & UFLAG_IN_USE) == UFLAG_IN_USE) && ((flags & UFLAG_TTYP_IN) != UFLAG_TTYP_IN) && !(IS_SPECIAL_UNIT(unit_ptr))) {
+		/* unit is in use  */
+		if (NextParameter == TRUE) {
+		    unit_ptr->value_c = unit_ptr->bias;
+		    unit_ptr->bias = (FlintType) drand48() *
+			(LEARN_PARAM2(parameterInArray) -
+			 LEARN_PARAM1(parameterInArray)) +
+			     LEARN_PARAM1(parameterInArray);
+		    NextParameter = FALSE;
+		    unit_ptr->value_b = LAST_MODIFIED;
+		} else {
+		    if (unit_ptr->value_b == LAST_MODIFIED) {
+			unit_ptr->value_b = NOT_MODIFIED;
+			NextParameter = TRUE;
+		    }
+		}
+		if (flags & UFLAG_SITES) { /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			if (NextParameter == TRUE) {
+			    link_ptr->value_c = link_ptr->weight;
+			    link_ptr->weight = (FlintType) drand48() *
+				(LEARN_PARAM2(parameterInArray) -
+				 LEARN_PARAM1(parameterInArray)) +
+				     LEARN_PARAM1(parameterInArray);
+			    NextParameter = FALSE;
+			    link_ptr->value_b = LAST_MODIFIED;
+			} else {
+			    if (link_ptr->value_b == LAST_MODIFIED) {
+				link_ptr->value_b = NOT_MODIFIED;
+				NextParameter = TRUE;
+			    }
+			}
+		} else {	/* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {
+			/* unit has direct links         */
+			FOR_ALL_LINKS(unit_ptr, link_ptr)
+			    if (NextParameter == TRUE) {
+				link_ptr->value_c = link_ptr->weight;
+				link_ptr->weight = (FlintType) drand48() *
+				    (LEARN_PARAM2(parameterInArray) -
+				     LEARN_PARAM1(parameterInArray)) +
+					 LEARN_PARAM1(parameterInArray);
+				NextParameter = FALSE;
+				link_ptr->value_b = LAST_MODIFIED;
+
+			    } else {
+				if (link_ptr->value_b == LAST_MODIFIED) {
+				    link_ptr->value_b = NOT_MODIFIED;
+				    NextParameter = TRUE;
+				}
+			    }
+		    }
+		}
+	    }
+	}
+    } while (NextParameter == TRUE);
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+    NET_ERROR(OutParameter) = 0.0; /* reset network error value  */
+
+    /* calculate performance of new net */
+    while (kr_getSubPatternByOrder(&pattern_no, &sub_pat_no)) {
+	propagateNetForward(pattern_no, sub_pat_no);
+	/* Forward propagation */
+
+	switch (errorFunction) {
+	  case SS_ERROR:
+	    if ((error = calculate_SS_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	  case WTA_ERROR:
+	    if ((error = calculate_WTA_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	  case WWTA_ERROR:
+	    if ((error = calculate_w_WTA_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	}
+	NET_ERROR(OutParameter) += error;
+    }
+
+    /*
+     * throw away new weight or bias if error decreased or propability is to
+     * low
+     */
+    if ((NET_ERROR(OutParameter) > MinimumError) && (Temperature > 0) &&
+	(drand48() > exp((MinimumError - NET_ERROR(OutParameter)) /
+			 ((end_pattern - start_pattern) * Temperature)))) {
+	FOR_ALL_UNITS(unit_ptr) {
+	    flags = unit_ptr->flags;
+	    if ((flags & UFLAG_IN_USE) == UFLAG_IN_USE) {
+		/* unit is in use  */
+		if (unit_ptr->value_b == LAST_MODIFIED) {
+		    unit_ptr->bias = unit_ptr->value_c;
+		    break;
+		}
+		if (flags & UFLAG_SITES) { /* unit has sites  */
+		    FOR_ALL_SITES_AND_LINKS(unit_ptr, site_ptr, link_ptr)
+			if (link_ptr->value_b == LAST_MODIFIED)
+			    link_ptr->weight = link_ptr->value_c;
+		} else {	/* unit has no sites   */
+		    if (flags & UFLAG_DLINKS) {
+			/* unit has direct links         */
+			FOR_ALL_LINKS(unit_ptr, link_ptr)
+			    if (link_ptr->value_b == LAST_MODIFIED)
+				link_ptr->weight = link_ptr->value_c;
+		    }
+		}
+	    }
+	}
+    } else {
+	MinimumError = NET_ERROR(OutParameter);
+    }
+    
+    /* decrease Temperature */
+    Temperature *= LEARN_PARAM4(parameterInArray);
+
+    return (ret_code);
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_SimulatedAnnealingSS
+  Squared Sum Error
+  PURPOSE  : Test Performance of the Network during Simulated Annealing 
+  Learning
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+krui_err
+TEST_SimulatedAnnealingSS(int start_pattern, int end_pattern,
+			  float *parameterInArray, int NoOfInParams,
+			  float **parameterOutArray, int *NoOfOutParams)
+{
+    return (TEST_SimulatedAnnealing(start_pattern, end_pattern,
+				    parameterInArray, NoOfInParams,
+				    parameterOutArray, NoOfOutParams, SS_ERROR));
+}
+
+
+/*****************************************************************************
+  FUNCTION : TEST_SimulatedAnnealingWTA
+  Winner Takes All Error
+  
+  PURPOSE  : Test Performance of the Network during Simulated Annealing 
+  Learning
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+krui_err
+TEST_SimulatedAnnealingWTA(int start_pattern, int end_pattern,
+			   float *parameterInArray, int NoOfInParams,
+			   float **parameterOutArray, int *NoOfOutParams)
+{
+    return (TEST_SimulatedAnnealing(start_pattern, end_pattern,
+				    parameterInArray, NoOfInParams,
+				    parameterOutArray, NoOfOutParams, WTA_ERROR));
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_SimulatedAnnealingWWTA
+  Weighted Winner Takes All Error
+  
+  PURPOSE  : Test Performance of the Network during Simulated Annealing 
+  Learning
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 06.10.1994
+******************************************************************************/
+
+krui_err
+TEST_SimulatedAnnealingWWTA(int start_pattern, int end_pattern,
+			    float *parameterInArray, int NoOfInParams,
+			    float **parameterOutArray, int *NoOfOutParams)
+{
+    return (TEST_SimulatedAnnealing(start_pattern, end_pattern,
+				    parameterInArray, NoOfInParams,
+				    parameterOutArray, NoOfOutParams, WWTA_ERROR));
+}
+
+/*****************************************************************************
+  FUNCTION : TEST_SimulatedAnnealing
+  
+  PURPOSE  : Test Performance of the Network during Simulated Annealing 
+  Learning
+  RETURNS  : error
+  NOTES    :
+  
+  UPDATE   : 19.02.1995
+******************************************************************************/
+
+krui_err
+TEST_SimulatedAnnealing(int start_pattern, int end_pattern,
+			float *parameterInArray, int NoOfInParams,
+			float **parameterOutArray, int *NoOfOutParams,
+			int errorFunction)
+{
+    static float    OutParameter[1]; /* OutParameter[0] stores the
+				      * learning error  */
+    int             ret_code, pattern_no, sub_pat_no;
+    float           error;
+    
+    if (NoOfInParams < 4)
+	return (KRERR_PARAMETERS); /* Not enough input parameters  */
+    *NoOfOutParams = 1;		/* One return value is available (the
+				 * learning error)  */
+    *parameterOutArray = OutParameter; /* set the output parameter reference  */
+    ret_code = KRERR_NO_ERROR;	/* reset return code  */
+
+
+    /* compute the necessary sub patterns */
+    KernelErrorCode = kr_initSubPatternOrder(start_pattern, end_pattern);
+    if (KernelErrorCode != KRERR_NO_ERROR)
+	return (KernelErrorCode);
+    NET_ERROR(OutParameter) = 0.0; /* reset network error value  */
+
+    /* calculate performance of new net */
+    while (kr_getSubPatternByOrder(&pattern_no, &sub_pat_no)) {
+	propagateNetForward(pattern_no, sub_pat_no);
+	/* Forward propagation */
+
+	switch (errorFunction) {
+	  case SS_ERROR:
+	    if ((error = calculate_SS_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	  case WTA_ERROR:
+	    if ((error = calculate_WTA_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	  case WWTA_ERROR:
+	    if ((error = calculate_w_WTA_error(pattern_no, sub_pat_no)) == -1)
+		return (-1);
+	    break;
+	}
+	NET_ERROR(OutParameter) += error;
+    }
+
+    return (ret_code);
+}
diff -Naur snort-2.3.3/src/kernel_snns/stochastic_learn_f.h snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.h
--- snort-2.3.3/src/kernel_snns/stochastic_learn_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,63 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/stochastic_learn_f.h,v $
+  SHORTNAME      : stochastic_learn_f.h
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions: 
+                   - Monte-Carlo
+                   - Simulated Annealing
+
+  AUTHOR         : Joachim Danz
+  DATE           : 27.04.94
+
+  CHANGED BY     : Guenter Mamier
+  RCS VERSION    : $Revision: 1.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:41 $
+
+             Copyright (c) 1994-95 Joachim Danz, TH Darmstadt, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+
+******************************************************************************/
+#ifndef _STOCHASTIC_LEARN_F_DEFINED_
+#define _STOCHASTIC_LEARN_F_DEFINED_
+
+extern krui_err LEARN_MonteCarlo(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams, 
+				 float **parameterOutArray, int *NoOfOutParams);
+extern krui_err TEST_MonteCarlo(int start_pattern, int end_pattern, 
+				float *parameterInArray, int NoOfInParams, 
+				float **parameterOutArray, int *NoOfOutParams);
+extern krui_err LEARN_SimulatedAnnealingSS(int start_pattern, int end_pattern, 
+					   float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray, 
+					   int *NoOfOutParams);
+extern krui_err LEARN_SimulatedAnnealingWTA(int start_pattern, int end_pattern,
+					    float *parameterInArray, 
+					    int NoOfInParams, 
+					    float **parameterOutArray, 
+					    int *NoOfOutParams);
+extern krui_err LEARN_SimulatedAnnealingWWTA(int start_pattern, int end_pattern,
+					     float *parameterInArray, 
+					     int NoOfInParams, 
+					     float **parameterOutArray, 
+					     int *NoOfOutParams);
+extern krui_err TEST_SimulatedAnnealingSS(int start_pattern, int end_pattern, 
+					  float *parameterInArray, 
+					  int NoOfInParams, 
+					  float **parameterOutArray, 
+					  int *NoOfOutParams);
+extern krui_err TEST_SimulatedAnnealingWTA(int start_pattern, int end_pattern, 
+					   float *parameterInArray, 
+					   int NoOfInParams, 
+					   float **parameterOutArray, 
+					   int *NoOfOutParams);
+extern krui_err TEST_SimulatedAnnealingWWTA(int start_pattern, int end_pattern,
+					    float *parameterInArray, 
+					    int NoOfInParams, 
+					    float **parameterOutArray, 
+					    int *NoOfOutParams);
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/stochastic_learn_f.ph snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.ph
--- snort-2.3.3/src/kernel_snns/stochastic_learn_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/stochastic_learn_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,89 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/stochastic_learn_f.ph,v $
+  SHORTNAME      : stochastic_learn_f.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Learning Functions
+  NOTES          : with following learning functions: 
+                   - Monte-Carlo
+                   - Simulated Annealing
+	           
+  AUTHOR         : Joachim Danz
+  DATE           : 27.04.94
+
+  CHANGED BY     : Guenter Mamier
+  RCS VERSION    : $Revision: 1.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:42 $
+
+             Copyright (c) 1994-95 Joachim Danz, TH Darmstadt, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _STOCHASTIC_LEARN_F_DEFINED_
+#define _STOCHASTIC_LEARN_F_DEFINED_
+
+/* begin global definition section */
+krui_err LEARN_MonteCarlo(int start_pattern, int end_pattern, 
+			  float *parameterInArray, int NoOfInParams, 
+			  float **parameterOutArray, int *NoOfOutParams);
+krui_err TEST_MonteCarlo(int start_pattern, int end_pattern, 
+			 float *parameterInArray, int NoOfInParams, 
+			 float **parameterOutArray, int *NoOfOutParams);
+krui_err LEARN_SimulatedAnnealing(int start_pattern, int end_pattern, 
+				  float *parameterInArray, int NoOfInParams, 
+				  float **parameterOutArray, 
+				  int *NoOfOutParams , int errorFunction);
+krui_err LEARN_SimulatedAnnealingSS(int start_pattern, int end_pattern, 
+				    float *parameterInArray, int NoOfInParams, 
+				    float **parameterOutArray, 
+				    int *NoOfOutParams);
+krui_err LEARN_SimulatedAnnealingWTA(int start_pattern, int end_pattern, 
+				     float *parameterInArray, int NoOfInParams,
+				     float **parameterOutArray, 
+				     int *NoOfOutParams);
+krui_err LEARN_SimulatedAnnealingWWTA(int start_pattern, int end_pattern, 
+				      float *parameterInArray, 
+				      int NoOfInParams, 
+				      float **parameterOutArray, 
+				      int *NoOfOutParams);
+krui_err TEST_SimulatedAnnealing(int start_pattern, int end_pattern, 
+				 float *parameterInArray, int NoOfInParams, 
+				 float **parameterOutArray, int *NoOfOutParams,
+				 int errorFunction);
+krui_err TEST_SimulatedAnnealingSS(int start_pattern, int end_pattern, 
+				   float *parameterInArray, int NoOfInParams, 
+				   float **parameterOutArray, 
+				   int *NoOfOutParams);
+krui_err TEST_SimulatedAnnealingWTA(int start_pattern, int end_pattern, 
+				    float *parameterInArray, int NoOfInParams, 
+				    float **parameterOutArray, 
+				    int *NoOfOutParams);
+krui_err TEST_SimulatedAnnealingWWTA(int start_pattern, int end_pattern, 
+				     float *parameterInArray, int NoOfInParams,
+				     float **parameterOutArray, 
+				     int *NoOfOutParams);
+float calculate_WTA_error (int pattern_no, int sub_pat_n);
+float calculate_w_WTA_error (int pattern_no, int sub_pat_n);
+float calculate_SS_error (int pattern_no, int sub_pat_n);
+
+
+/* end global definition section */
+
+/* begin private definition section */
+ 
+#define  NET_ERROR( param )      param[ 0 ]  /* returns the net error */
+#define  LEARN_PARAM1( param )   param[ 0 ]  /* contains 1st learning param */
+#define  LEARN_PARAM2( param )   param[ 1 ]  /* contains 2nd learning param */
+#define  LEARN_PARAM3( param )   param[ 2 ]  /* contains 3rd learning param */
+#define  LEARN_PARAM4( param )   param[ 3 ]  /* contains 4th learning param */ 
+#define  LEARN_PARAM5( param )   param[ 4 ]  /* contains 5th learning param */
+#define  SS_ERROR   1
+#define  WTA_ERROR  2
+#define  WWTA_ERROR 3
+ 
+#endif 
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/strdup.c snort-2.3.3.new/src/kernel_snns/strdup.c
--- snort-2.3.3/src/kernel_snns/strdup.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/strdup.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,38 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/strdup.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : strdup.
+  NOTES          : 
+
+  AUTHOR         : Niels Mache
+  DATE           : 30.07.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.11 $
+  LAST CHANGE    : $Date: 1998/03/03 15:59:58 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+#if ! defined(HAVE_STRDUP) || HAVE_STRDUP == 0
+#include <string.h>
+#include <stdlib.h>
+
+char *strdup(const char *source)
+{
+    int len;
+    char *copy;
+    
+    len = strlen(source) + 1;
+    if ((copy = malloc(len * sizeof(char))))
+	strcpy(copy, source);
+
+    return(copy);
+}
+
+#endif /* ! HAVE_STRDUP */
diff -Naur snort-2.3.3/src/kernel_snns/strdup.h snort-2.3.3.new/src/kernel_snns/strdup.h
--- snort-2.3.3/src/kernel_snns/strdup.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/strdup.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,29 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/strdup.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : System V Library Function strdup.
+  NOTES          : The strdup function is missing in the ULTRIX-32 operating system
+                    environment.
+
+  AUTHOR         : Niels Mache
+  DATE           : 30.07.90
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/02 17:57:56 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+
+#if ! defined(HAVE_STRDUP) || HAVE_STRDUP == 0
+#ifndef _STRDUP_DEFINED_
+#define _STRDUP_DEFINED_
+
+extern char *strdup(const char *str);
+
+#endif /* _STRDUP_DEFINED_ */
+#endif /* ! HAVE_STRDUP */
diff -Naur snort-2.3.3/src/kernel_snns/tacoma_learn.c snort-2.3.3.new/src/kernel_snns/tacoma_learn.c
--- snort-2.3.3/src/kernel_snns/tacoma_learn.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tacoma_learn.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1466 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tacoma_learn.c,v $
+  SHORTNAME      : tacoma_learn.c
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Learn-Functions of Tacoma
+  NOTES          : For informations about the algorithms see one of
+                   the following papers:
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Growing Artificial Neural Networks Based on
+                    Correlation Measures, Task Decomposition and Local 
+                    Attention Neurons."
+                   IEEE '94, pp. 1355-1358.
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Task Decomposition and Correlations in Growing
+                     Artificial Neural Networks."
+                   ICANN '94, pp. 735-738.
+
+                   J. Gatter:
+                   "Lernverfahren neuronaler Netze mit automatischer
+                    Bestimmung der Netzwerktopologie"
+                   Diplomarbeit Nr. 1337, university of Stuttgart
+
+
+  AUTHOR         : Juergen Gatter
+  DATE           : October 1995 - March 1996
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.10 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <time.h>  
+#include <memory.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "random.h"
+#include "kr_typ.h"      /*  Kernel Types and Constants  */
+#include "kr_const.h"    /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"      /*  Default Values  */
+#include "kernel.h"      /*  kernel function prototypes  */
+#include "kr_mac.h"      /*  Kernel Macros   */
+
+
+#include "kr_ui.h"
+#include "cc_type.h"
+#include "cc_mac.h"
+#include "cc_glob.h"
+#include "cc_display.h"
+#include "kr_newpattern.h"
+#include "cc_learn.ph"
+#include "tacoma_learn.ph"
+
+
+
+/*****************************************************************************
+  FUNCTION : tac_testCorrectnessOfAddParameters
+
+  PURPOSE  : 
+      tests correctness of additional parameters. Correct values are :
+      [0] TAC_KOHONEN             [0    .. inf)
+      [1] TAC_XI_RI_ETA           [0.0  .. inf)
+      [2] TAC_THRESHOLD           (-inf .. 1.0)
+      [3] TAC_LAMBDA              (-inf .. inf)
+      [4] TAC_BETA                (0.0  .. 1.0)
+
+  NOTES    :
+
+      if parameter setting is incorrect KRERR_CC_INVALID_ADD_PARAMETERS
+      will be returned tests correctness of additional parameters
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+krui_err tac_testCorrectnessOfAddParameters(void)
+{
+   if ((TAC_KOHONEN < 0) || (TAC_XI_RI_ETA < 0.0 ) || (TAC_THRESHOLD >= 1.0) ||
+       (TAC_BETA<=0.0) || (TAC_BETA>=1.0))
+        return (KRERR_CC_INVALID_ADD_PARAMETERS);
+
+   return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : tac_initVariables
+
+  PURPOSE  :
+      Initializes global variables, read the Parameters, sorts the units, 
+      assigns the learning routines, generates the Layerlist, checks 
+      the parameters and calculates the initial display-Parameters.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+
+krui_err tac_initVariables(float* ParameterInArray,
+				int StartPattern,int EndPattern)
+{
+   int i;
+
+   cc_LayerCorrectnessTest(ParameterInArray,StartPattern,EndPattern);
+
+   srand48((long)time(NULL)); 
+	      /* inits the random-generator */
+   cc_printOnOff = (int)ParameterInArray[8]; 
+   cc_backfittingOnOff = (int)ParameterInArray[18];
+   cc_MaxSpecialUnitNo = (int)ParameterInArray[12];
+   cc_modification = (int)ParameterInArray[21];
+   for (i=0;i<5;i++){
+     cc_Parameter[i]=ParameterInArray[22+i];
+   }
+   cc_fastmode=(int)ParameterInArray[27];
+   cc_end=0;
+   KernelErrorCode=tac_testCorrectnessOfAddParameters();
+   ERROR_CHECK;
+
+   /* take the outputpart and overwrite the special part */
+
+   cc_propagateSpecialUnitsBackward = tac_propagateSpecial;
+   cc_propagateOutputUnitsBackward  = cc_propagateOutput;
+ 
+   switch(LEARNING_FUNCTION) { 
+     case BACKPROP: 
+       cc_SpecialUnitUpdate = 
+               cc_OutputUnitUpdate = BackPropOfflinePart;
+     break; 
+     case BACKPROP_ONLINE:
+       cc_SpecialUnitUpdate =
+               cc_OutputUnitUpdate = OnlineBackPropOfflinePart;
+       cc_propagateOutputUnitsBackward  = cc_propagateOutputOnlineCase;
+       cc_propagateSpecialUnitsBackward = tac_propagateSpecialOnlineCase;
+     break;            
+     case QUICKPROP: 
+       cc_SpecialUnitUpdate = 
+               cc_OutputUnitUpdate = QuickPropOfflinePart;
+ 
+     break; 
+     case RPROP: 
+       cc_SpecialUnitUpdate = 
+               cc_OutputUnitUpdate = RPropOfflinePart;
+
+     break;
+     default: CC_ERROR(KRERR_CC_ERROR3);
+   }
+   KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+   ERROR_CHECK;    /* Sort the Units */
+   cc_setPointers(); 
+   if (NoOfHiddenUnits<=0) 
+   {    
+     KernelErrorCode = 
+       cc_calculateNetParameters();
+     ERROR_CHECK;
+   }
+
+   KernelErrorCode = cc_generateLayerList();
+   ERROR_CHECK;    /* build the array with the dates of the Layers */ 
+ 
+   return KRERR_NO_ERROR;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : tac_allocateStorage
+
+  PURPOSE  :  
+      allocates the first part of the storage used by TACOMA. Tacoma
+      uses much more Arrays than for example Cascade-Correlation.
+      The Second Part of the Arrays will be allocated later, when
+      the number of Units to be inserted, is calculated
+  NOTES    : 
+      the second part of the needed storage will be allocated
+      when then no of new units is calculated 
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+ krui_err tac_allocateStorage(int StartPattern, int  EndPattern)
+{
+  int start,end,n;
+  int p,i;
+
+
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  ERROR_CHECK;
+
+  CALLOC_2DIMENSIONAL_ARRAY(SpecialUnitAct,n,cc_MaxSpecialUnitNo,float,p);
+  CALLOC_2DIMENSIONAL_ARRAY(OutputUnitError,n,NoOfOutputUnits,float,p);
+  CALLOC_2DIMENSIONAL_ARRAY
+     (CorBetweenSpecialActAndOutError,cc_MaxSpecialUnitNo,NoOfOutputUnits,float,p);
+
+  CALLOC_ERRORCHECK(SpecialUnitSumAct,cc_MaxSpecialUnitNo,float);
+  MeanYi=SpecialUnitSumAct; 
+  CALLOC_ERRORCHECK(MeanOutputUnitError,NoOfOutputUnits,float);
+  CALLOC_ERRORCHECK(PatternSumError,n,float);
+  CALLOC_ERRORCHECK(SpecialUnitData,cc_MaxSpecialUnitNo,TAC_SPECIAL_UNIT_TYPE);
+  CALLOC_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,Ri,
+		   NoOfInputUnits,float,i);
+  CALLOC_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,Xi,
+		   NoOfInputUnits,float,i);
+  CALLOC_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,LinkError,
+	 NoOfInputUnits+NoOfHiddenUnits+cc_MaxSpecialUnitNo,TAC_LINK_ERROR_TYPE,i);
+  if(cc_fastmode){
+    CALLOC_2DIMENSIONAL_ARRAY
+     (ActOfUnit,n,NoOfInputUnits+NoOfHiddenUnits+cc_MaxSpecialUnitNo,float,p);
+  }
+  return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : tac_freeStorage
+
+  PURPOSE  :
+      Deallocates all the storage needed by TACOMA
+  NOTES    : 
+      Between two Learning-Cycles no add. memory should be held by TACOMA
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+ *****************************************************************************/
+
+ krui_err tac_freeStorage(int StartPattern, int  EndPattern)
+{
+  int start,end,n;
+
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  ERROR_CHECK;
+
+  FREE_IF_USED(PatternSumError);
+
+  FREE_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,LinkError,i);
+  FREE_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,Xi,i);
+  FREE_2ND_ARRAY(SpecialUnitData,cc_MaxSpecialUnitNo,Ri,i);
+
+  FREE_2DIMENSIONAL_ARRAY(Rij,NoOfInstalledUnits,i);
+  FREE_2DIMENSIONAL_ARRAY(Nij,NoOfInstalledUnits,i);
+
+  FREE_IF_USED(SpecialUnitData);
+
+  FREE_2DIMENSIONAL_ARRAY(PrimesOfSpecialUnits,NoOfInstalledUnits,i);
+
+  return(cc_freeStorage(StartPattern,EndPattern,0));
+}
+
+/*****************************************************************************
+  FUNCTION : tac_calculateOutputUnitError
+
+  PURPOSE  : 
+      Calculates the error of all output units and stores the result
+      in the array OutputUnitError. Additionaly the Arrays 
+      MeanOutputUnitError and PatternSumError are calculated here. 
+      And the WholeSummedError, too.
+      PSE und WSE are using fabs(act-teach), whereas the others
+      are using act-teach.
+      The routine is similar to the one in cc_learn.c.
+  NOTES    : OUTPUT_UNIT_SUM_ERROR is only used temporarly
+
+  UPDATE   : 30.3.96
+******************************************************************************/
+ krui_err tac_calculateOutputUnitError(int StartPattern,int EndPattern)
+{
+    register struct Unit *UnitPtr;
+    register Patterns  out_pat;
+    register int o,p;
+    int start, end,pat,sub,n;
+    float devit;
+  
+    cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+    ERROR_CHECK;     
+
+    for(p=start; p<=end;p++){
+	PatternSumError[p] = 0.0;
+	cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	      /* propagate through in and hidden-Layers */
+	out_pat = kr_getSubPatData(pat,sub,OUTPUT,NULL);
+	ERROR_CHECK;/* get Pattern-Data for Output-Units */
+	FOR_ALL_OUTPUT_UNITS(UnitPtr,o) {
+	    CALCULATE_ACTIVATION_AND_OUTPUT(UnitPtr,
+		      (*UnitPtr->act_func)(UnitPtr),p);
+	      /* Propagate through Output-Layer */
+	    devit =  UnitPtr->Out.output - *(out_pat++);
+	      /* difference between actual and Should be */
+	    OUTPUT_UNIT_SUM_ERROR[o] += 
+	        (OutputUnitError[p][o] =  devit) ;
+	    PatternSumError[p] += fabs(OutputUnitError[p][o]);
+	      /* And calculate the summed Error for this Pattern */
+	}
+    }
+    WholeSummedError=0.0;
+    for(p=start;p<=end;p++)
+        WholeSummedError += PatternSumError[p];
+
+    FOR_ALL_OUTPUT_UNITS(UnitPtr,o){
+	MeanOutputUnitError[o] = (OUTPUT_UNIT_SUM_ERROR[o] / n);
+    }
+    cc_actualNetSaved=TRUE;
+  return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION :  tac_connect(int NewUnitNo,struct Unit* OldUnit,int StartPattern,int EndPattern)
+
+  PURPOSE  :  returns true, iff s and OldUnit have to be connected.
+	      If the oldUnit is a input unit then it's clear,
+              if it is a hidden Unit,
+	      then the two window functions have to have a siginificant
+	      overlap. 
+  NOTES    :  NewUnitNo is not GET_UNIT_NO(NewUnit). It's the internal number
+              as used in the kohonen-mapping.
+  
+  UPDATE   :  30.3.96
+******************************************************************************/
+ bool tac_connect(int s,struct Unit* OldUnit,
+		   int StartPattern,int EndPattern,float* Correlation)
+{
+  int start,end,n,p,pat,sub,k;
+  Patterns in_pat;
+  float SumFirst,SumSecond,First,Second,devit,devit2,SumZaehler,Zaehler;
+  struct Link* LinkPtr;
+  int UnitNo;
+  
+  if (krui_getUnitActFuncName(GET_UNIT_NO(OldUnit)) != "ACT_TACOMA") return (TRUE);
+  /* in/output or with CC calculated units */
+  /* Now start with connection routing */
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  if(KernelErrorCode!=KRERR_NO_ERROR) {
+      return 0;
+  }
+
+  SumFirst = SumSecond = SumZaehler = 0.0;
+
+  for(p=start;p<=end;p++){
+     kr_getSubPatternByNo(&pat,&sub,p);
+     in_pat =  kr_getSubPatData(pat,sub,INPUT,NULL);
+     First = Second = Zaehler = 0.0; 
+     FOR_ALL_LINKS(OldUnit,LinkPtr) {
+	if (IS_INPUT_UNIT(LinkPtr->to)){
+           UnitNo=GET_UNIT_NO(LinkPtr->to);
+   	   k = (NoOfInputUnits - UnitNo);  /* the patterns are stored backw. */
+	   devit  = (in_pat[k] - SpecialUnitData[s].Xi[k]) / SpecialUnitData[s].Ri[k];
+	   devit2 = (in_pat[k] - XI_OF_LINK(LinkPtr)) / RI_OF_LINK(LinkPtr);
+	   First  += (devit*devit);
+	   Second += (devit2*devit2);
+	}
+     }
+     SumFirst   += (TAC_EXP(-First) *TAC_EXP(-First));
+     SumSecond  += (TAC_EXP(-Second)*TAC_EXP(-Second));
+     SumZaehler += (TAC_EXP(-First) *TAC_EXP(-Second));
+  }     
+
+  *Correlation = ((SumSecond>0.0) ? SumZaehler/sqrt(SumFirst*SumSecond) : 0.0 );
+
+  return(*Correlation>TAC_LAMBDA);
+}
+/*****************************************************************************
+  FUNCTION : tac_initWindowFuncParameter(struct Unit* UnitPtr)
+
+  PURPOSE  : Link values of xi and ri are copied from the internal array
+  NOTES    : UnitNo is the internal number of the unit
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+ void tac_initWindowFuncParameter(struct Unit* UnitPtr,int UnitNo)
+{
+  struct Link * LinkPtr;
+  int InpUnitNo;
+
+   FOR_ALL_LINKS(UnitPtr,LinkPtr){
+      if(IS_INPUT_UNIT(LinkPtr->to)){
+	 InpUnitNo = GET_UNIT_NO(LinkPtr->to)-1;
+            XI_OF_LINK(LinkPtr) = SpecialUnitData[UnitNo].Xi[InpUnitNo];
+            RI_OF_LINK(LinkPtr) = SpecialUnitData[UnitNo].Ri[InpUnitNo];
+      }
+      else{
+	 XI_OF_LINK(LinkPtr) = RI_OF_LINK(LinkPtr) = 0.0;
+      }
+   }
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_generateNewUnit   
+
+  PURPOSE  : 
+      Builds a new special unit. The new unit is declared as a special
+      unit to make the old routines of cc_learn/cc_rcc useable.
+      The routine does the following things :  
+         Set type to SPECIAL
+         Set activition function to ACT_TACOMA
+         Actualizes the Layerlist and the LayerNo of the Unit
+         Sets the display (like a hidden unit in CC)
+         Generates the links between the input/ older hidden units
+              and the new one.
+         Sets Xi and Ri (see above)
+  NOTES    :
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+krui_err tac_generateNewUnit(int UnitNo,int LayerNo,int StartPattern,int EndPattern)
+{
+   struct Unit* NewUnitPtr;
+   struct Unit* UnitPtr;
+   struct Link* NewLink;
+   int CurrentUnit;
+   float Correlation;
+
+   KernelErrorCode = 
+      kr_unitSetTType(CurrentUnit=kr_makeDefaultUnit(),SPECIAL); 
+   ERROR_CHECK;
+   KernelErrorCode = 
+      krui_setUnitActFunc(CurrentUnit,"Act_TACOMA");
+   ERROR_CHECK;  
+   NewUnitPtr = kr_getUnitPtr(CurrentUnit); 
+   ERROR_CHECK;
+   KernelErrorCode = krui_setCurrentUnit(CurrentUnit); 
+   ERROR_CHECK;
+   KernelErrorCode =
+     cc_actualizeLayerlist(NewUnitPtr,LayerNo);
+   CC_SET_LAYER_NO(NewUnitPtr,NoOfLayers);
+   cc_setHiddenUnit(NewUnitPtr,NoOfLayers);
+
+   FOR_ALL_UNITS(UnitPtr){
+      if((IS_INPUT_UNIT(UnitPtr) ||  IS_HIDDEN_UNIT(UnitPtr)) &&
+	 UNIT_IN_USE(UnitPtr) &&
+	 (CC_LAYER_NO(UnitPtr)<NoOfLayers)
+	 &&(tac_connect(UnitNo,UnitPtr,StartPattern,EndPattern,&Correlation))) 
+         {
+            ERROR_CHECK;
+            NewLink=kr_createLinkWithAdditionalParameters(GET_UNIT_NO(UnitPtr),
+	      cc_generateRandomNo(TAC_MAX_VALUE), 0.0, 0.0, 0.0); 
+            ERROR_CHECK;
+            if(!IS_INPUT_UNIT(UnitPtr)){
+               PRINTF(
+               "Link from unit %2d to unit %2d added. Correlation between the units is %5.3f\n",
+               GET_UNIT_NO(UnitPtr),
+               GET_UNIT_NO(NewUnitPtr),Correlation);
+            }
+         }
+      ERROR_CHECK;
+   }
+
+   tac_initWindowFuncParameter(NewUnitPtr,UnitNo);
+   
+   return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : tac_initXiAndRis
+
+  PURPOSE  : 
+      Initialises the Array Xi with values 
+      (sum(x_i)/n_p) + random*(max(x_i)-min(x_i). -0.1 < Random < 0.1
+      Ri with 0.0
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+krui_err tac_initXiAndRis(StartPattern,EndPattern)
+{
+  int p,i;
+  int start,end,n,pat,sub;
+  float* MaxXI,*MinXI,*SumXI;
+  float Xi;
+  Patterns in_pat;
+
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+
+  CALLOC_ERRORCHECK(MaxXI,NoOfInputUnits,float);
+  CALLOC_ERRORCHECK(MinXI,NoOfInputUnits,float);
+  CALLOC_ERRORCHECK(SumXI,NoOfInputUnits,float);
+ 
+  for(i=0;i<NoOfInputUnits;i++)
+  {
+     MaxXI[i]=-100000.0; MinXI[i]=10000.0; SumXI[i]=0.0;
+  }
+
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  for(p=start;p<=end;p++){
+     kr_getSubPatternByNo(&pat,&sub,p);
+     in_pat =  kr_getSubPatData(pat,sub,INPUT,NULL);
+     for(i=0;i<NoOfInputUnits;i++){
+	  if(*in_pat > MaxXI[i]) MaxXI[i]=*in_pat;
+	  if(*in_pat < MinXI[i]) MinXI[i]=*in_pat;
+          SumXI[i] += *in_pat;
+          in_pat++;
+     }
+  }
+  for(p=0;p<cc_MaxSpecialUnitNo;p++){
+     for(i=0;i<NoOfInputUnits;i++)
+     { 
+        Xi=SumXI[i]/n +  cc_generateRandomNo((MaxXI[i]-MinXI[i]) * 0.1);
+	SpecialUnitData[p].Xi[i]=Xi;
+	SpecialUnitData[p].Ri[i]=0.0;
+     }
+  }
+  FREE_IF_USED(MaxXI);
+  FREE_IF_USED(MinXI);
+  FREE_IF_USED(SumXI);
+
+  return(KRERR_NO_ERROR); 
+}        
+
+/*****************************************************************************
+  FUNCTION : tac_NextSpecialUnit
+
+  PURPOSE  : searches the unit with minimal distance to the given
+             pattern in input space.
+             Returns internal number of this unit.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+int  tac_NextSpecialUnit(int p,Patterns in_pat_First)
+{
+  int s,i,NextSpecialUnitInInputSpace;
+  float devit,SummedSquaredDistance,BestSSD;
+  Patterns in_pat;
+
+  BestSSD = 1e20;
+  for(s=0;s<cc_MaxSpecialUnitNo;s++){
+      SummedSquaredDistance = 0.0;
+      in_pat = in_pat_First;
+      for(i=0;i<NoOfInputUnits;i++){
+	  devit = *in_pat++ - SpecialUnitData[s].Xi[i];
+	  SummedSquaredDistance+= (devit*devit);
+      }
+      if (SummedSquaredDistance < BestSSD)
+      {
+	  BestSSD=SummedSquaredDistance;
+	  NextSpecialUnitInInputSpace=s;
+      }
+   }
+  return(NextSpecialUnitInInputSpace);
+}
+
+/*****************************************************************************
+  FUNCTION : void tac_changeXi(int UnitNo,int p,int d,Patterns in_pat)
+
+  PURPOSE  : 
+      changes the Xis of the virt. SpecialUnit, which was calculated
+      before as the next in Input-Space. Here is TAC_ALPHA a 
+      regulation term, which is decreased in time.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+ void tac_changeXi(int UnitNo,int p,int d,int MaxD,Patterns in_pat)
+{
+  int i;
+  float Xi_alt;
+  float alpha;
+  float Res_Error;
+
+  alpha =  TAC_ALPHA((float)d,(float)MaxD);
+  for (i=0;i<NoOfInputUnits;i++){
+     Xi_alt=SpecialUnitData[UnitNo].Xi[i];
+     Res_Error = (PatternSumError[p] / WholeSummedError);
+     SpecialUnitData[UnitNo].Xi[i] = 
+ 	  Xi_alt + alpha * Res_Error  * (*in_pat++ - Xi_alt); 
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : void tac_printRanks
+
+  PURPOSE  : Prints the data after the kohonen-mapping
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+void tac_printRanks(float MaxSummedError)
+{
+  int UnitNo,NewUnitCnt=0;
+
+  if (cc_printOnOff)
+  {
+    cc_printHeadline("Installing new units",LENGTH_HEADLINE);
+
+    for(UnitNo=0;UnitNo<cc_MaxSpecialUnitNo;UnitNo++){
+       printf (
+         "Unit %2d has %4d inputpattern in its voronoi region, Summed and normed error is %4f. ",
+          UnitNo,SpecialUnitData[UnitNo].NoOfUnitsInRegion,
+          SpecialUnitData[UnitNo].SummedErrorInRegion/MaxSummedError);
+       if ((SpecialUnitData[UnitNo].SummedErrorInRegion/MaxSummedError) > TAC_THRESHOLD){
+          printf(" Installed as hidden unit %d",++NewUnitCnt + NO_OF_NET_UNITS);
+       }
+       printf("\n");
+    }
+    printf("\nInstalled %d units on layer %d\n",NewUnitCnt,NoOfLayers+1);
+  }
+}
+
+/*****************************************************************************
+  FUNCTION : void tac_calculateRanksAndRadius(int start,int end)
+
+  PURPOSE  :
+      When we made a certain amount of changes to the X_i, we hope,
+      that the X's are now located at the maxima of the remaining
+      error. Now we count the no of Patterns, which are in our
+      region, the correlated error and the mean distances of the
+      patterns to the X. These results are used to determine, which
+      of the units have to be taken and which initial radius they
+      should get. (for formulas see one of the papers or the DA)
+
+  NOTES    : SUMMED_DISTANCES is only used internal.
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+int tac_calculateRanksAndRadius(int start,int end)
+{
+  int p,pat,sub;
+  int UnitNo,dim;
+  Patterns in_pat;
+  float MaxSummedError=0.0000001;
+  float MeanDistance;
+
+      /* init the values */
+  for(UnitNo=0;UnitNo<cc_MaxSpecialUnitNo;UnitNo++){
+     SpecialUnitData[UnitNo].NoOfUnitsInRegion=0;
+     SpecialUnitData[UnitNo].SummedErrorInRegion=0.0;
+     for (dim=0;dim<NoOfInputUnits;dim++)
+	SpecialUnitData[UnitNo].SUMMED_DISTANCES[dim]=0.0;
+  }
+      /* determine units and error in voronoi regions */
+  for(p=start;p<=end;p++){
+     kr_getSubPatternByNo(&pat,&sub,p);
+     in_pat = kr_getSubPatData(pat,sub,INPUT,NULL);
+     UnitNo=tac_NextSpecialUnit(p,in_pat);
+     SpecialUnitData[UnitNo].NoOfUnitsInRegion++;
+     SpecialUnitData[UnitNo].SummedErrorInRegion += PatternSumError[p];
+      /* now add the distance to the sum of the unit. The values
+         are weighten with the Errorvalue */
+     for(dim=0;dim<NoOfInputUnits;dim++){
+	SpecialUnitData[UnitNo].SUMMED_DISTANCES[dim] +=
+	   fabs((*in_pat++) - SpecialUnitData[UnitNo].Xi[dim])
+           * PatternSumError[p];
+     }
+  }
+
+  for(UnitNo=0;UnitNo<cc_MaxSpecialUnitNo;UnitNo++){
+     if (SpecialUnitData[UnitNo].SummedErrorInRegion > MaxSummedError)
+	MaxSummedError=SpecialUnitData[UnitNo].SummedErrorInRegion;
+  }        /* determine max (SummedErrorInRegion) */
+
+
+  for(UnitNo=0;UnitNo<cc_MaxSpecialUnitNo;UnitNo++){
+    if(SpecialUnitData[UnitNo].SummedErrorInRegion > 0.0){
+       for(dim=0;dim<NoOfInputUnits;dim++){
+	  MeanDistance =  (SpecialUnitData[UnitNo].SUMMED_DISTANCES[dim] / 
+		 SpecialUnitData[UnitNo].SummedErrorInRegion);
+	  SpecialUnitData[UnitNo].Ri[dim] = 
+	     sqrt((-MeanDistance*MeanDistance) / (2*log(TAC_BETA)));
+       }
+    }   
+  }
+
+  tac_printRanks(MaxSummedError);  
+
+  return MaxSummedError;
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_MappingOfTheNewUnits
+
+  PURPOSE  : 
+      Realizes the mapping of the new units onto the input space.
+      Unlike in CC the Special
+      Units are now virtual, they where never generated. Only the two
+      Arrays Xi and Ri are generated and calculated   NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+ int tac_MappingOfTheNewUnits(int StartPattern,int EndPattern)
+{
+  int start,end,n,p,d;
+  int pat,sub;
+  Patterns in_pat;
+  int UnitNo;
+  int Modulo;
+
+  Modulo = TAC_KOHONEN /20;  /* for the printing */
+
+  cc_printHeadline("Kohonen-Training",LENGTH_HEADLINE);
+
+  KernelErrorCode=tac_initXiAndRis(StartPattern,EndPattern);
+  ERROR_CHECK;
+
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  ERROR_CHECK;
+
+  for (d=0;d<TAC_KOHONEN;d++){
+     if ((d % Modulo)==0) PRINTF("Pass %5d\n",d);
+     for(p=start;p<=end;p++){
+	kr_getSubPatternByNo(&pat,&sub,p);
+	in_pat = kr_getSubPatData(pat,sub,INPUT,NULL);
+	UnitNo=tac_NextSpecialUnit(p,in_pat);
+	tac_changeXi(UnitNo,p,d,TAC_KOHONEN,in_pat);
+     }
+  }
+
+  return tac_calculateRanksAndRadius(start,end);
+}
+
+/*****************************************************************************
+  FUNCTION : tac_calculateCorrelation
+
+  PURPOSE  : 
+      Calculates the Correlation as given in CC. The Correlation is a 
+      measure of how good a new special unit correlates with the given
+      Output-Error. The unit weights (not the r_i and x_i) are trained
+      to maximize this Correlation.
+      Prints the values.
+  NOTES    : 
+      Sideeffect : SpecialUnitSumAct is divided by the No
+      of Patterns, so it now contains the mean activation.
+      SUSA is accesable via MeanYi, now.
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+ krui_err tac_calculateCorrelation(int StartPattern, int EndPattern,
+			      int counter)
+{
+ int s,o,n;
+ float scoreBuffer;
+ struct Unit *SpecialUnitPtr,*OutputUnitPtr;
+ int start, end;
+
+ cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+ ERROR_CHECK;
+
+ PRINTF("Cycle %3d ",counter);
+ FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+   SpecialUnitData[s].ErrorCorrelation = 0.0;
+   FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o) {
+     scoreBuffer =  (CorBetweenSpecialActAndOutError[s][o] - 
+		    (MeanOutputUnitError[o] * SpecialUnitSumAct[s] ));
+     SpecialUnitData[s].ErrorCorrelation += fabs(scoreBuffer);
+     SIGN_OF_THE_CORRELATION[s][o] = SIGN(scoreBuffer);
+   }
+   SpecialUnitData[s].ErrorCorrelation /= SumSqError;
+   PRINTF("s[%2d]=%4f   ",s,SpecialUnitData[s].ErrorCorrelation);
+   MeanYi[s]= SpecialUnitSumAct[s] / n;
+ }
+ return KRERR_NO_ERROR;
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_calculateRijAndSumRij
+
+  PURPOSE  : 
+      the Arrays Nij and Rij were calculated. Both Arrays were needed
+      by the AntiCorrelation F. (Formulas see papers or DA)
+      The routine gives back the divident of F.
+  NOTES    : 
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+ float tac_calculateRijAndSumRij(float** Rij,float* MeanYi,
+				int start,int end,int n)
+{
+  double** Di;   /* temporal array to hold  (Yi-MeanYi)^2  */
+  int s,p,i,j;
+  double FNenner,Sum,Zaehler;
+
+  CALLOC_2DIMENSIONAL_ARRAY(Di,NoOfInstalledUnits,n,double,i);
+
+  for(s=0;s<NoOfInstalledUnits;s++){
+     for(p=start;p<=end;p++){
+	 Di[s][p] = SpecialUnitAct[p][s] - MeanYi[s];
+	 Di[s][p] *= Di[s][p];   /* set Di= (Yi-MeanYi)^2 */
+     }
+  }
+
+  FNenner=0.0;
+
+  for(i=0;i<NoOfInstalledUnits;i++){
+     for(j=i+1;j<NoOfInstalledUnits;j++){
+	Sum = Zaehler = 0.0;
+	for(p=0;p<n;p++){
+	   Sum += Di[i][p] * Di[j][p];
+	   Zaehler += SpecialUnitAct[p][i]*SpecialUnitAct[p][j];
+	}
+	if (Sum>0) {
+	   Nij[i][j] = sqrt(Sum);
+	   Rij[i][j] = (Zaehler - MeanYi[i]*MeanYi[j]*n) / Nij[i][j];
+	}
+	else {
+	   Rij[i][j] = Nij[i][j] = 0.00001; /* no rij==0 allowed */
+	}
+       FNenner += fabs(Rij[i][j]);
+     }
+  }
+
+  FREE_2DIMENSIONAL_ARRAY(Di,NoOfInstalledUnits,i);
+
+  return(FNenner);
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_calculateAntiCorrelation
+
+  PURPOSE  :  Calculates the AntiCorrelation F. F is a measure of :
+      1. How good is the Correlation between the units and the 
+         ouput error ? This is achieved by using the calculated and 
+         summarized Correlations S. 
+      2. Do the new units all have different outputs ? The Correlation
+         Rij between 2 different units is calculated, and the sum is
+         placed in the Nenner, to guarantee minimal correlation.
+      F will be used to determine, if the learning procedure is stagnant
+      or further learning could be usefull.
+      F will be trained by a gradient ascent procedure. 
+
+  NOTES    :
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+float tac_calculateAntiCorrelation(int StartPattern, int EndPattern,bool First)
+{
+  int start,end,n,i;
+  
+  cc_getPatternParameter(StartPattern,EndPattern,&start,&end,&n);
+  ERROR_CHECK;
+  
+  AC_Nenner = 
+     TAC_ETA + tac_calculateRijAndSumRij(Rij,MeanYi,start,end,n);
+    
+  AC_Zaehler=0.0;
+
+  for(i=0;i<NoOfInstalledUnits;i++)
+     AC_Zaehler+= SpecialUnitData[i].ErrorCorrelation;
+
+  return(AC_Zaehler/AC_Nenner);
+} 
+
+/*****************************************************************************
+  FUNCTION : tac_initSpecialUnitLinks
+
+  PURPOSE  : 
+      initializes the weights, radii, xi and the variables used by the 
+      learning routine of all special units.
+      The weights and the bias are set to a random value. 
+      Further are the arrays allocated, which are needed for the
+      thraining of the new hidden units.
+
+  NOTES    :
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+
+krui_err tac_initSpecialUnitLinks(void)
+{
+ int i,s,LinkCnt;
+ struct Unit *SpecialUnitPtr;
+ struct Link *LinkPtr;
+
+ FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+   SpecialUnitPtr->bias = cc_generateRandomNo(TAC_MAX_VALUE);
+   BIAS_CURRENT_SLOPE(SpecialUnitPtr)      = 0.0; 
+   BIAS_PREVIOUS_SLOPE(SpecialUnitPtr)     = 0.0; 
+   BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr) = 0.0;
+   LinkCnt = 0;
+   FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+     SpecialUnitData[s].LinkError[LinkCnt  ].LnCurrentSlope     = 0.0;
+     SpecialUnitData[s].LinkError[LinkCnt  ].LnPreviousSlope    = 0.0;
+     SpecialUnitData[s].LinkError[LinkCnt++].LnLastWeightChange = 0.0;
+     LinkPtr->weight = cc_generateRandomNo(TAC_MAX_VALUE);
+   }
+ }
+ CALLOC_2DIMENSIONAL_ARRAY
+    (Rij,NoOfInstalledUnits,NoOfInstalledUnits,float,i);
+ CALLOC_2DIMENSIONAL_ARRAY
+    (Nij,NoOfInstalledUnits,NoOfInstalledUnits,float,i);
+ CALLOC_2DIMENSIONAL_ARRAY
+   (PrimesOfSpecialUnits,NoOfInstalledUnits,NoOfInputUnits,TAC_PRIME_TYPE,i);
+
+ return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_trainSpecialUnits
+
+  PURPOSE  : 
+      Calls the training procedure for the training of the Special units.
+      It calls the routines for the calculation of the correlations, the
+      anticorrelation, and the online/offline parts of the training. 
+      See cc_trainSpecialUnits,too.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+ krui_err tac_trainSpecialUnits(int maxNoOfCovarianceUpdateCycles, 
+			    float minCovarianceChange,
+     	                    int specialPatience,int StartPattern, 
+			    int EndPattern,float param1, float param2,
+			    float param3,int MaxSpecialUnitNo,int LayerNo)
+{
+    int counter,start,end,n;
+    float oldHighScore=0.0;
+
+    cc_printHeadline("Training of the candidates",LENGTH_HEADLINE);
+
+    for (counter=0;counter<maxNoOfCovarianceUpdateCycles;counter++){
+	KernelErrorCode=cc_getPatternParameter
+			  (StartPattern,EndPattern,&start,&end,&n);
+	ERROR_CHECK;
+
+	cc_calculateSpecialUnitActivation(StartPattern,EndPattern);
+        ERROR_CHECK;
+
+	KernelErrorCode=
+           tac_calculateCorrelation(StartPattern,EndPattern,counter);
+        ERROR_CHECK;
+
+	AntiCorr=tac_calculateAntiCorrelation
+            (StartPattern,EndPattern,counter==0);
+        ERROR_CHECK;
+
+        PRINTF("AntiCorr is %0.5f\n",AntiCorr);
+
+	(*cc_propagateSpecialUnitsBackward)
+			     (start,end,n,counter,param1,param2,param3);
+	ERROR_CHECK;
+
+        tac_updateSpecial(param1,param2,param3);
+
+	cc_initActivationArrays(); 
+
+	if ((counter % specialPatience)==0){
+	   if(fabs(AntiCorr-oldHighScore) <
+	      minCovarianceChange * oldHighScore)
+	      return(KRERR_NO_ERROR);
+           oldHighScore = AntiCorr;
+	}
+        
+    } 
+  PRINTF("\n");
+  return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : tac_protocollNet
+
+  PURPOSE  : Write protocoll data to 'protokoll.dat', if it's not done by now
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+void tac_protocollNet(void)
+{
+    /* This function should be removed */
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_protocollNet
+
+  PURPOSE  : Write protocoll data of learning process to protokoll.dat.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+
+void tac_protocollLearning(int LayerNo,int StartPattern,int EndPattern)
+{
+    /* This function should be removed */
+}
+
+/*****************************************************************************
+  FUNCTION : tac_installNewUnits
+
+  PURPOSE  : 
+      Determine how much and which hiddden units have to be generated.
+      Do this and initialize the links.
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+krui_err tac_installNewUnits(int LayerNo,float MaxError,int StartPattern,int EndPattern)
+{
+  int i;
+
+  NoOfInstalledUnits=0;
+
+  if (LayerNo>1) cc_printHeadline("Connection routing",LENGTH_HEADLINE);
+
+  for (i=0;i<cc_MaxSpecialUnitNo;i++){
+     if ((SpecialUnitData[i].SummedErrorInRegion/MaxError)
+          >TAC_THRESHOLD){
+	NoOfInstalledUnits++;
+	KernelErrorCode = 
+	   tac_generateNewUnit(i,LayerNo,StartPattern,EndPattern);
+	ERROR_CHECK;
+	
+        KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+	ERROR_CHECK;
+        KernelErrorCode = cc_setPointers();
+        ERROR_CHECK;
+     }
+  }
+  KernelErrorCode = tac_initSpecialUnitLinks();
+  ERROR_CHECK;
+
+  return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION : LEARN_TACOMA
+
+  PURPOSE  : The main learn routine of Tacoma
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+
+krui_err LEARN_Tacoma(int StartPattern, int EndPattern,
+		      float *ParameterInArray, int NoOfInParams,
+		      float **ParameterOutArray, int *NoOfOutParams)
+{
+   int TempErrorCode; /* Used by the macro ERROR_CHECK_WITH_MEM_DEALLOC */
+   int LayerNo; 
+   struct Unit * UnitPtr,*OutputUnitPtr;
+   struct Link* LinkPtr;
+   int dummy;
+   int CurrentUnit;    
+   float MaxError;
+
+   NetLearnAlgorithm = TACOMA;
+
+   cc_deleteAllSpecialUnits(); /* no need for special units here.
+                                  the could be some, if learning func was switched
+                                  from CC to Tacoma */
+
+   if (cc_allButtonIsPressed) { /* something might have changed */
+      KernelErrorCode =       
+	 tac_initVariables(ParameterInArray,StartPattern,EndPattern);
+      ERROR_CHECK;
+   }
+
+   if (cc_end) return(KRERR_NO_ERROR);
+                                /* We're ready last time */
+   KernelErrorCode = tac_allocateStorage(StartPattern,EndPattern);
+   TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION; 
+
+   if(cc_test(StartPattern,EndPattern,MAX_PIXEL_ERR) !=  CONTINUE_LEARNING) {
+      cc_end = 1;               /* we're ready now */
+      tac_protocollNet();       
+      return(tac_freeStorage(StartPattern,EndPattern));
+   }
+
+   if (NoOfHiddenUnits<1) {
+      if((OUT_PATIEN != 0) && (MAX_NO_ERROR_UPDATE_CYCLES != 0)) {
+	 cc_trainOutputUnits(MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE, 
+			     MINIMAL_ERROR_CHANGE,
+			     OUT_PATIEN,StartPattern,EndPattern,PARAM1,
+			     PARAM2,PARAM3,ParameterOutArray,
+			     NoOfOutParams);
+      }  
+      cc_getErr(StartPattern, EndPattern);
+   }
+
+  KernelErrorCode = tac_calculateOutputUnitError(StartPattern,EndPattern);
+  TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+                                /* determine errors */
+  if (SumSqError==0.0)
+     MaxError=cc_getErr(StartPattern,EndPattern);
+                                /* calc SumSqError, use MaxError as dummy */
+
+  MaxError = tac_MappingOfTheNewUnits(StartPattern,EndPattern);
+  TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+                                /* kohonen-feature maps */
+  LayerNo=NoOfLayers+1; 
+
+  KernelErrorCode = 
+      tac_installNewUnits(LayerNo,MaxError,StartPattern,EndPattern);
+  TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+                                /* generate units and install them */
+
+  if((SPEC_PATIENCE != 0) && (MAX_NO_OF_COVAR_UPDATE_CYCLES != 0)) {
+      tac_trainSpecialUnits(MAX_NO_OF_COVAR_UPDATE_CYCLES,
+			    MIN_COVAR_CHANGE,SPEC_PATIENCE,
+			    StartPattern,EndPattern,
+			    PARAM4,PARAM5,PARAM6,
+                            MAX_SPECIAL_UNIT_NUMBER,LayerNo);
+  }                            /* train the candidates */
+
+  FOR_ALL_UNITS(UnitPtr){
+     if (IS_SPECIAL_UNIT(UnitPtr)){
+	KernelErrorCode = kr_unitSetTType(GET_UNIT_NO(UnitPtr),HIDDEN); 
+        TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION; 
+	/* generate links between output unit and new hidden unit */
+	FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,dummy){
+	   CurrentUnit = GET_UNIT_NO(OutputUnitPtr);
+	   KernelErrorCode = krui_setCurrentUnit(CurrentUnit); 
+	   ERROR_CHECK;
+	   LinkPtr = krui_createLinkWithAdditionalParameters
+               (GET_UNIT_NO(UnitPtr), 0.0, 0.0, 0.0, 0.0 );
+	   ERROR_CHECK; 
+	}   
+     }    
+  }
+
+  KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+  TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+  KernelErrorCode = cc_setPointers();
+  TAC_ERROR_CHECK_WITH_MEMORY_DEALLOCATION;
+
+  if((OUT_PATIEN != 0) && (MAX_NO_ERROR_UPDATE_CYCLES!= 0)) {
+    cc_trainOutputUnits    (MAX_NO_ERROR_UPDATE_CYCLES, BACKFITT_PATIENCE,
+			   MINIMAL_ERROR_CHANGE,
+			   OUT_PATIEN,StartPattern,EndPattern,PARAM1,
+			   PARAM2,PARAM3,ParameterOutArray,NoOfOutParams); 
+  }
+
+  tac_protocollLearning(LayerNo,StartPattern,EndPattern);
+
+  cc_allButtonIsPressed = NetModified = FALSE;
+
+  KernelErrorCode=tac_freeStorage(StartPattern,EndPattern);
+  return(KernelErrorCode);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : tac_propagateXiRi
+
+  PURPOSE  : online part of learning of the xi and ri for the offline
+             learning algorithms like Quickprop and Rprop.
+  NOTES    : This routine will never used by default. Only if
+             TAC_XIRI_ONLINE is set to FALSE, then the training of the
+             xis and ris will be done with the same learning function 
+             and parametersm as the training of the weights.
+             By default TAC_XIRI_ONLINE is true because learning with
+             for example Quickprop is to good. Then xi and ri will
+             be changed too much, and the calculated links to other
+             hidden units will make no sense. And the overhead of
+             calculating the refernce vecors, too.
+
+  UPDATE   : 30.03.96
+******************************************************************************/
+void tac_propagateXiRi(struct Unit* SpecialUnitPtr,
+          int p,int s,float SummedDeltaS,double nMinus1Divn,
+          float eta,float mu, float dummy)
+
+{
+  struct Unit* SecondSpecUnitPtr;
+  struct Link* LinkPtr;
+  int s2;
+  int First,Sec,i;
+  float sum;
+  float Diff,Prime_Xi,Prime_Ri,DeltaF;
+
+    sum=0.0; 
+  FOR_ALL_SPECIAL_UNITS(SecondSpecUnitPtr,s2){
+     if(s2!=s){
+	  if(s<s2) { First=s; Sec=s2; }
+	      else { First=s2; Sec=s; }
+	  sum += SIGN(Rij[First][Sec]) *
+		 (SpecialUnitAct[p][s2]*Nij[First][Sec]-Rij[First][Sec]*
+		 (SpecialUnitAct[p][s]-MeanYi[s])*
+                 (SpecialUnitAct[p][s2]-MeanYi[s2])*
+                 (SpecialUnitAct[p][s2]-MeanYi[s2]))
+		 / (Nij[First][Sec]*Nij[First][Sec]);
+     }
+  }
+  DeltaF = (SummedDeltaS*AC_Nenner-nMinus1Divn*AC_Zaehler*sum) /
+	      (AC_Nenner*AC_Nenner);
+  
+  i=0;
+  FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr){
+     if (IS_INPUT_UNIT(LinkPtr->to)){
+	  Diff = 
+		(LinkPtr->to->Out.output-XI_OF_LINK(LinkPtr));
+	  Prime_Xi =   (DeltaF*2*Diff*SpecialUnitPtr->Out.output) / 
+		(RI_OF_LINK(LinkPtr)*RI_OF_LINK(LinkPtr));
+	  Prime_Ri=(Prime_Xi*Diff)/RI_OF_LINK(LinkPtr);
+	  PrimesOfSpecialUnits[s][i].xi_CurrentSlope -= Prime_Xi;
+	  PrimesOfSpecialUnits[s][i].ri_CurrentSlope -= Prime_Ri;
+	  i++;
+     }
+  }
+}
+/*****************************************************************************
+  FUNCTION : tac_propagateXiRiOnlineCase
+
+  PURPOSE  : 
+      online part of learning of the xi and ri for the offline
+      learning algorithms like Quickprop and Rprop.
+      This routine will never used by default. Only if
+      TAC_XIRI_ONLINE is set to FALSE, then the training of the
+      xis and ris will be done with the same learning function 
+      and parametersm as the training of the weights.
+      By default TAC_XIRI_ONLINE is true because learning with
+      for example Quickprop is to good. Then xi and ri will
+      be changed too much, and the calculated links to other
+      hidden units will make no sense. And the overhead of
+      calculating the refernce vecors, too.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+void tac_propagateXiRiOnlineCase(struct Unit* SpecialUnitPtr,
+          int p,int s,float SummedDeltaS,double nMinus1Divn ,float eta,float mu, float dummy)
+
+{
+  struct Unit* SecondSpecUnitPtr;
+  struct Link* LinkPtr;
+  int s2;
+  int First,Sec,i;
+  float sum;
+  float Diff,Prime_Xi,Prime_Ri,DeltaF;
+
+  sum=0.0;
+    FOR_ALL_SPECIAL_UNITS(SecondSpecUnitPtr,s2){
+       if(s2!=s){
+	  if(s<s2) { First=s; Sec=s2; }
+	      else { First=s2; Sec=s; }
+	  sum += SIGN(Rij[First][Sec]) *
+		 (SpecialUnitAct[p][s2]*Nij[First][Sec]-Rij[First][Sec]*
+		 (SpecialUnitAct[p][s]-MeanYi[s])*
+                 (SpecialUnitAct[p][s2]-MeanYi[s2])*(SpecialUnitAct[p][s2]-MeanYi[s2]))
+		 / (Nij[First][Sec]*Nij[First][Sec]);
+       }
+    }
+    DeltaF = (SummedDeltaS*AC_Nenner-nMinus1Divn*AC_Zaehler*sum) / (AC_Nenner*AC_Nenner);
+    
+    i=0;
+    FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr){
+       if (IS_INPUT_UNIT(LinkPtr->to)){
+	  Diff = 
+		(LinkPtr->to->Out.output-XI_OF_LINK(LinkPtr));
+	  Prime_Xi =   (DeltaF*2*Diff*SpecialUnitPtr->Out.output) / 
+		(RI_OF_LINK(LinkPtr)*RI_OF_LINK(LinkPtr));
+	  Prime_Ri=(Prime_Xi*Diff)/RI_OF_LINK(LinkPtr);
+          XI_OF_LINK(LinkPtr) += Prime_Xi*eta;
+          RI_OF_LINK(LinkPtr) += Prime_Ri*eta;    
+	  i++;
+       }
+    }
+}
+
+/*****************************************************************************
+  FUNCTION : tac_propagateSpecialOnlineCase  
+
+  PURPOSE  : online Part of training (weights, bias), this one 
+             for backprop online 
+  NOTES    : Calls tac_propagateXiRiOnline
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+ krui_err tac_propagateSpecialOnlineCase (int start,int end,int n,
+		   int counter,float eta, float mu,float dummy)
+{
+    float change=0.0,actPrime;
+    int s,o,p,pat,sub,i;
+    struct Unit *SpecialUnitPtr,*OutputUnitPtr;
+    struct Link *LinkPtr;
+    int LinkCnt;
+    double nMinus1Divn = (n-1) / n;
+    double SummedDeltaS;
+    float  lastChange;
+
+    for(s=0;s<NoOfInstalledUnits;s++){
+       for(i=0;i<NoOfInputUnits;i++){
+	  PrimesOfSpecialUnits[s][i].xi_CurrentSlope=0.0;
+	  PrimesOfSpecialUnits[s][i].ri_CurrentSlope=0.0;
+       }
+    }
+
+    for(p=start; p<=end;p++){
+	cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+
+
+	    SummedDeltaS = 0.0;
+	    SpecialUnitPtr->Out.output =
+                  SpecialUnitPtr->act = 
+                        SpecialUnitAct[p][s];
+	    actPrime = (*SpecialUnitPtr->act_deriv_func)(SpecialUnitPtr);
+	    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o){
+		SummedDeltaS += SIGN_OF_THE_CORRELATION[s][o] *
+		   (OutputUnitError[p][o]-MeanOutputUnitError[o]);
+	    }  
+            SummedDeltaS /= SumSqError;
+	    change = SummedDeltaS*actPrime;
+	    BIAS_CURRENT_SLOPE(SpecialUnitPtr) += change;     
+            lastChange = BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr);
+	              SpecialUnitPtr->bias -= 
+               (BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr) =
+                   eta*change + lastChange*mu);
+
+	    LinkCnt = 0;
+	    FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+                lastChange =
+                  SpecialUnitData[s].LinkError[LinkCnt].LnLastWeightChange;
+ 	        LinkPtr->weight -= 
+                   (SpecialUnitData[s].LinkError[LinkCnt].LnLastWeightChange =
+                   eta*LinkPtr->to->Out.output*change + lastChange*mu);
+                LinkCnt++;
+	    }
+
+            if (TAC_XIRI_ONLINE) 
+              tac_propagateXiRiOnlineCase
+                 (SpecialUnitPtr,p,s,SummedDeltaS,nMinus1Divn,
+                  TAC_XI_RI_ETA,0.0,0.0);
+            else
+              tac_propagateXiRiOnlineCase
+                 (SpecialUnitPtr,p,s,SummedDeltaS,nMinus1Divn,eta,mu,dummy);
+
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return(KRERR_NO_ERROR);
+}
+
+
+/*****************************************************************************
+  FUNCTION : tac_propagateSpecial
+
+  PURPOSE  : online Part of training (weights, bias), this one 
+             for Quickprop, RProp, Backprop offline
+  NOTES    :
+
+  UPDATE   : 30.4.96 <Juergen Gatter>
+******************************************************************************/
+krui_err tac_propagateSpecial (int start,int end,int n,
+		   int counter,float dummy1, float dummy2,float dummy3)
+{
+    float change=0.0,actPrime;
+    int s,o,p,pat,sub,i,LinkCnt;
+    struct Unit *SpecialUnitPtr,*OutputUnitPtr;
+    struct Link *LinkPtr;
+    double nMinus1Divn = (n-1) / n;
+    double SummedDeltaS;
+ 
+    for(s=0;s<NoOfInstalledUnits;s++){
+       for(i=0;i<NoOfInputUnits;i++){
+	  PrimesOfSpecialUnits[s][i].xi_CurrentSlope=0.0;
+	  PrimesOfSpecialUnits[s][i].ri_CurrentSlope=0.0;
+       }
+    }
+
+    for(p=start; p<=end;p++){
+
+	cc_getActivationsForActualPattern(p,start,&pat,&sub);
+	FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+	    SummedDeltaS = 0.0;
+	    SpecialUnitPtr->Out.output = SpecialUnitPtr->act = SpecialUnitAct[p][s];
+	    actPrime = (*SpecialUnitPtr->act_deriv_func)(SpecialUnitPtr);
+	    FOR_ALL_OUTPUT_UNITS(OutputUnitPtr,o){
+		SummedDeltaS += SIGN_OF_THE_CORRELATION[s][o] *
+		   (OutputUnitError[p][o]-MeanOutputUnitError[o]);
+	    }  
+            SummedDeltaS /= SumSqError;
+	    change = SummedDeltaS*actPrime;
+	    BIAS_CURRENT_SLOPE(SpecialUnitPtr) += change;     
+	    LinkCnt = 0;
+	    FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+
+		SpecialUnitData[s].LinkError[LinkCnt++].LnCurrentSlope += 
+		  change * LinkPtr->to->Out.output;
+	    }
+
+            if (TAC_XIRI_ONLINE) 
+              tac_propagateXiRiOnlineCase
+                 (SpecialUnitPtr,p,s,SummedDeltaS,nMinus1Divn,TAC_XI_RI_ETA,0.0,0.0);
+            else
+ 
+            tac_propagateXiRi
+               (SpecialUnitPtr,p,s,SummedDeltaS,nMinus1Divn, dummy1,dummy2,dummy3);
+
+	}
+    }
+    cc_actualNetSaved=TRUE;
+    return(KRERR_NO_ERROR);
+}
+
+/*****************************************************************************
+  FUNCTION :  tac_updateSpecial
+
+  PURPOSE  : 
+      this routine updates the bias of the Special-Units and
+      the weights, the radii and the xi of links to a special unit. 
+      The routine calls the procedure, which makes the update-step
+      according to the actual valid learning function (QuickProp,RProp
+      or BackProp, according to cc_SpecialUnitUpdate)
+  NOTES    :
+
+  UPDATE   : 30.03.96 <Juergen Gatter>
+******************************************************************************/
+   void tac_updateSpecial(float param1,float param2,float param3)
+{
+    struct Unit *SpecialUnitPtr;
+    struct Link *LinkPtr;
+    int s,LinkCnt,InpCnt;
+
+    FOR_ALL_SPECIAL_UNITS(SpecialUnitPtr,s) {
+      	SpecialUnitPtr->bias +=
+           (*cc_SpecialUnitUpdate)
+              (SpecialUnitPtr->bias,&BIAS_PREVIOUS_SLOPE(SpecialUnitPtr),
+               &BIAS_CURRENT_SLOPE(SpecialUnitPtr),
+               &BIAS_LAST_WEIGHT_CHANGE(SpecialUnitPtr),
+               param1,param2,param3);  		          
+	LinkCnt = InpCnt = 0;
+	FOR_ALL_LINKS(SpecialUnitPtr,LinkPtr) {
+ 	         /* training the weights ... */
+	              LinkPtr->weight +=
+                 (*cc_SpecialUnitUpdate) (LinkPtr->weight,
+                     &SpecialUnitData[s].LinkError[LinkCnt].LnPreviousSlope,
+		     &SpecialUnitData[s].LinkError[LinkCnt].LnCurrentSlope,
+		     &SpecialUnitData[s].LinkError[LinkCnt].LnLastWeightChange,
+                     param1,param2,param3);
+            LinkCnt++;
+	    if ((IS_INPUT_UNIT(LinkPtr->to)&&(!TAC_XIRI_ONLINE))){ 
+		/* and now the Xi */
+	      	                    XI_OF_LINK(LinkPtr) +=
+		      (*cc_SpecialUnitUpdate) (XI_OF_LINK(LinkPtr),
+                          &PrimesOfSpecialUnits[s][InpCnt].xi_PreviousSlope,
+			  &PrimesOfSpecialUnits[s][InpCnt].xi_CurrentSlope,
+			  &PrimesOfSpecialUnits[s][InpCnt].xi_LastChange,
+                          param1,param2,param3);
+		/* and now the radii */
+	      		                RI_OF_LINK(LinkPtr) +=
+		      (*cc_SpecialUnitUpdate) (RI_OF_LINK(LinkPtr),
+                           &PrimesOfSpecialUnits[s][InpCnt].ri_PreviousSlope,
+			   &PrimesOfSpecialUnits[s][InpCnt].ri_CurrentSlope,
+			   &PrimesOfSpecialUnits[s][InpCnt].ri_LastChange,
+                           param1,param2,param3);
+		InpCnt++;
+            }
+        }
+    } 
+}
+
+
+
+
+
diff -Naur snort-2.3.3/src/kernel_snns/tacoma_learn.h snort-2.3.3.new/src/kernel_snns/tacoma_learn.h
--- snort-2.3.3/src/kernel_snns/tacoma_learn.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tacoma_learn.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,50 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tacoma_learn.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : For informations about the algorithms see one of
+                   the following papers:
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Growing Artificial Neural Networks Based on
+                    Correlation Measures, Task Decomposition and Local 
+                    Attention Neurons."
+                   IEEE '94, pp. 1355-1358.
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Task Decomposition and Correlations in Growing
+                     Artificial Neural Networks."
+                   ICANN '94, pp. 735-738.
+
+                   J. Gatter:
+                   "Lernverfahren neuronaler Netze mit automatischer
+                    Bestimmung der Netzwerktopologie"
+                   Diplomarbeit Nr. 1337, university of Stuttgart
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 30.03.96
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TACOMA_LEARN_DEFINED_
+#define  _TACOMA_LEARN_DEFINED_
+
+/* begin global definition section */
+extern krui_err LEARN_Tacoma(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+
+/* end   global definition section */
+
+/* begin privat definition section */
+/* end privat definition section */
+
+#endif /* _TACOMA_LEARN_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/tacoma_learn.ph snort-2.3.3.new/src/kernel_snns/tacoma_learn.ph
--- snort-2.3.3/src/kernel_snns/tacoma_learn.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tacoma_learn.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,310 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tacoma_learn.ph,v $
+  SHORTNAME      : tacoma_learn.ph
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : Header file of correspondent '.c' file
+  NOTES          : For informations about the algorithms see one of
+                   the following papers:
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Growing Artificial Neural Networks Based on
+                    Correlation Measures, Task Decomposition and Local 
+                    Attention Neurons."
+                   IEEE '94, pp. 1355-1358.
+
+                   J.M. Lange, H.M. Voigt, D. Wolf: 
+                   "Task Decomposition and Correlations in Growing
+                     Artificial Neural Networks."
+                   ICANN '94, pp. 735-738.
+
+                   J. Gatter:
+                   "Lernverfahren neuronaler Netze mit automatischer
+                    Bestimmung der Netzwerktopologie"
+                   Diplomarbeit Nr. 1337, university of Stuttgart
+
+  AUTHOR         : Juergen Gatter
+  DATE           : 30.3.1996
+
+  CHANGED BY     : 
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : 
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TACOMA_LEARN_DEFINED_
+#define  _TACOMA_LEARN_DEFINED_
+
+/* begin global definition section */
+krui_err LEARN_Tacoma(int StartPattern, int EndPattern,
+                      float *ParameterInArray, int NoOfInParams,
+                      float **ParameterOutArray, int *NoOfOutParams);
+
+/* end   global definition section */
+
+/* begin privat definition section */
+
+krui_err tac_testCorrectnessOfAddParameters(void);
+   /* tests correctness of additional parameters. Correct values are :
+      [0] TAC_KOHONEN             [0    .. inf)
+      [1] TAC_XI_RI_ETA           [0.0  .. inf)
+      [2] TAC_THRESHOLD           (-inf .. 1.0)
+      [3] TAC_LAMBDA              (-inf .. inf)
+      [4] TAC_BETA                (0.0  .. 1.0)
+      if parameter setting is incorrect KRERR_CC_INVALID_ADD_PARAMETERS
+      will be returned */
+
+
+krui_err tac_initVariables(float* ParameterInArray,
+                                int StartPattern,int EndPattern);
+   /* Initializes global variables, read the Parameters, sorts the units, 
+      assigns the learning routines, generates the Layerlist, checks 
+      the parameters and calculates the initial display-Parameters. */
+
+krui_err tac_allocateStorage(int StartPattern, int  EndPattern);
+
+   /* allocates the first part of the storage used by TACOMA. Tacoma
+      uses much more Arrays than for example Cascade-Correlation.
+      The Second Part of the Arrays will be allocated later, when
+      the number of Units to be inserted, is calculated */
+
+krui_err tac_freeStorage(int StartPattern, int  EndPattern);
+
+   /* frees all allocated Memory. Between two Learning-Cycles no
+      add. memory should be held by TACOMA */
+
+krui_err tac_calculateOutputUnitError(int StartPattern,int EndPattern);
+
+   /* Calculates the error of all output units and stores the result
+      in the array OutputUnitError. Additionaly the Arrays 
+      MeanOutputUnitError and PatternSumError are calculated here. 
+      And the WholeSummedError, too.
+      PSE und WSE are using fabs(act-teach), whereas the others
+      are using act-teach.
+      The routine is similar to the one in cc_learn.c. */
+
+bool tac_connect(int s,struct Unit* OldUnit,
+	         int StartPattern,int EndPattern,float* Correlation);
+
+   /* returns true, iff Special Unit s and Input/Hidden-Unit OldUnit
+      have to be connected. If OldUnit is a Input-Unit than it's
+      quite clear to connect them, but if it is another hidden unit
+      then the two window functions have to have a significant 
+      overlap. For further Details see the original paper or my DA */
+
+void tac_initWindowFuncParameter(struct Unit* UnitPtr,int UnitNo);
+
+   /* if a new Unit is in construction, the WindowFuncParameters
+      Xi and Ri are taken from the arrays calculated above */
+
+krui_err tac_generateNewUnit(int UnitNo,int LayerNo,
+			   int StartPattern,int EndPattern);
+   
+   /* Builds a new special unit. The new unit is declared as a special
+      unit to make the old routines of cc_learn/cc_rcc useable.
+      The routine does the following things :  
+         Set type to SPECIAL
+         Set activition function to ACT_TACOMA
+         Actualizes the Layerlist and the LayerNo of the Unit
+         Sets the display (like a hidden unit in CC)
+         Generates the links between the input/ older hidden units
+              and the new one.
+         Sets Xi and Ri (see above) */
+
+krui_err tac_initXiAndRis(int StartPattern,int EndPattern);
+                         
+   /* Initialises the Arrays Xi and Ri with values 
+      (sum(x_i)/n_p) + random*(max(x_i)-min(x_i). -0.1 < Random < 0.1 */
+
+int  tac_NextSpecialUnit(int p,Patterns in_pat_First);
+
+   /* returns the X in Input-Space, which has the minimum
+      distance the the given Pattern. As distance-norm is
+      sqrt( sum_i ( diff_i ^ 2 ) ) used . */
+
+void tac_changeXi(int UnitNo,int p,int d,int maxD,
+                                Patterns in_pat);
+
+   /* changes the Xis of the virt. SpecialUnit, which was calculated
+      before as the next in Input-Space. Here is TAC_ALPHA a 
+      regulation term, which is decreased in time. */
+
+void tac_printRanks(float MaxSummedError);
+
+   /* Prints the data after the kohonen-mapping */
+
+int tac_calculateRanksAndRadius(int start,int end);
+
+   /* When we made a certain amount of changes to the X, we hope,
+      that the X's are now located at the maxima of the remaining
+      error. Now we count the now of Patterns, which are in our
+      region, the correlated error and the mean distances of the
+      patterns to the X. These results are used to determine, which
+      of the units have to be taken and which initial radius they
+      should get. (for formulas see paper or DA, please) */
+
+int tac_MappingOfTheNewUnits(int StartPattern,int EndPattern);
+
+   /* Realizes the Mapping of the new units. Unlike in CC the Special
+      Units are now virtual, they where never generated. Only the two
+      Arrays Xi and Ri are generated and calculated */
+
+krui_err tac_calculateCorrelation(int StartPattern, int EndPattern,
+			      int counter);
+
+   /* Calculates the Correlation as given in CC. The Correlation is a 
+      measure of how good a new special unit correlates with the given
+      Output-Error. The unit weights (not the r_i and x_i) are trained
+      to maximize this Correlation. As a sideeffect, this routine 
+      divides the array SpecialUnitSumAct through the number of
+      patterns. SUSA is then accesible via MeanYi. 
+      Prints the values */
+
+ float tac_calculateRijAndSumRij(float** Rij,float* MeanYi,
+				int start,int end,int n);
+
+   /* the Arrays Nij and Rij were calculated. Both Arrays were needed
+      by the AntiCorrelation F. (More see papers or DA)
+      The routine gives back the divident of F. */
+
+float tac_calculateAntiCorrelation(int StartPattern, int EndPattern,bool First);
+
+   /* Calculates the AntiCorrelation F. F is a measure of :
+      1. How good is the Correlation between the units and the 
+         ouput error ? This is achieved by using the calculated and 
+         summarized Correlations S. 
+      2. Do the new units all have different outputs ? The Correlation
+         Rij between 2 different units is calculated, and the sum is
+         placed in the Nenner, to guarantee minimal correlation.
+      F will be used to determine, if the learning procedure is stagnant
+      or further learning could be usefull.
+      F will be trained by a gradient ascent procedure. */
+
+krui_err tac_initSpecialUnitLinks(void);
+
+   /* initializes the weights, radii, xi and the variables used by the 
+      learning routine of all special units.
+      The weights and the bias are set to a random value. 
+      Further are the arrays allocated, which are needed for the
+      thraining of the new hidden units.*/
+
+krui_err tac_trainSpecialUnits(int maxNoOfCovarianceUpdateCycles, 
+			    float minCovarianceChange,
+			    int specialPatience,int StartPattern, 
+			    int EndPattern,float param1, float param2,
+			    float param3,int MaxSpecialUnitNo,int LayerNo);
+    
+   /* Calls the training procedure for the training of the Special units.
+      It calls the routines for the calculation of the correlations, the
+      anticorrelation, and the online/offline parts of the training. 
+      See cc_trainSpecialUnits,too. */
+
+void tac_protocollNet(void);
+
+   /* protocolls net to the file 'protokoll.dat', if it's the first call. */
+
+void tac_protocollLearning(int LayerNo,int StartPattern,int EndPattern);
+
+   /* Write protocoll data of learning process to protokoll.dat. */
+
+krui_err tac_installNewUnits(int LayerNo,float MaxError,int StartPattern,int EndPattern);
+   /* Determine how much and which hiddden units have to be generated.
+      Do this and initialize the links. */
+
+void tac_propagateXiRiOnlineCase(struct Unit* SpecialUnitPtr,
+          int p,int s,float SummedDeltaS,double nMinus1Divn ,
+          float eta,float mu, float dummy);
+
+   /* online part of learning of the xi and ri for the online
+      Backprop. This one is used by default, as TAC_XIRI_ONLINE 
+      isn't changed. The parameters mu and dummy aren't used in
+      the function as implemented. 
+      For more information see tac_propagateXiRi, too */
+ 
+void tac_propagateXiRi(struct Unit* SpecialUnitPtr,int p,int s,
+          float SummedDeltaS, double nMinus1Divn, float eta, float mu, 
+          float dummy);
+   /* online part of learning of the xi and ri for the offline
+      learning algorithms like Quickprop and Rprop.
+      This routine will never used by default. Only if
+      TAC_XIRI_ONLINE is set to FALSE, then the training of the
+      xis and ris will be done with the same learning function 
+      and parametersm as the training of the weights.
+      By default TAC_XIRI_ONLINE is true because learning with
+      for example Quickprop is to good. Then xi and ri will
+      be changed too much, and the calculated links to other
+      hidden units will make no sense. And the overhead of
+      calculating the refernce vecors, too. */
+
+krui_err tac_propagateSpecial(int start,int end,int n,
+                  int counter,float dummy1, float dummy2,float dummy);
+
+   /* Calculates and summarizes the slopes needed by the gradient 
+      procedures. Calls the routines for the training of the xi and
+      ris. */
+
+krui_err tac_propagateSpecialOnlineCase (int start,int end,int n,
+		   int counter,float eta, float mu,float dummy3);
+ 
+   /* Does the online-learning, iff the learning procedure is 
+      Backprop online. Calls tac_propagateXiRiOnline */
+
+
+
+void tac_updateSpecial(float param1,float param2,float param3);
+
+   /* this routine updates the bias of the Special-Units and
+      the weights, the radii and the xi of links to a special unit. 
+      The routine calls the procedure, which makes the update-step
+      according to the actual valid learning function (QuickProp,RProp
+      or BackProp, according to cc_SpecialUnitUpdate) */
+      
+float*  PatternSumError=NULL;
+ 
+   /* Array [n_p] of the summed absolute errors of the output-units
+      for a given pattern */
+
+float   WholeSummedError;
+
+   /* Sum of the array above */
+
+float** Rij;
+
+   /* Two-dim. array [n_i][n_i], whereas n_i is the number of 
+      new units. See papers for further explanation */
+
+float** Nij;  
+
+   /* see Rij */
+
+float*  MeanYi;  /* points to SpecialUnitSumAct */
+
+   /* Stores the mean activations of the outputs */
+
+TAC_SPECIAL_UNIT_TYPE* SpecialUnitData=NULL;
+
+   /* Stores additional data of actually used hidden units */
+
+TAC_PRIME_TYPE** PrimesOfSpecialUnits;
+
+   /* Stores the last changes and primes of the vectors resp. the 
+      radii. This is only needed if the xi and ri are trained
+      with the offline versions */
+
+int NoOfInstalledUnits;
+
+   /* Counts the actually installed units */
+
+float AntiCorr;
+
+   /* F as in the formulas */
+
+float AC_Zaehler,AC_Nenner;
+
+  /* the divisor and the divident of F */
+
+/* end privat definition section */
+
+#endif /* _TACOMA_LEARN_DEFINED_ */
diff -Naur snort-2.3.3/src/kernel_snns/tbl_func.c snort-2.3.3.new/src/kernel_snns/tbl_func.c
--- snort-2.3.3/src/kernel_snns/tbl_func.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tbl_func.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,91 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tbl_func.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Transfer functions using table lookup and
+	           linear approximation method
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 25.07.91
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.7 $
+  LAST CHANGE    : $Date: 1998/03/03 14:08:58 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <math.h>
+
+#include "kr_typ.h"	    /*	Kernel types and constants  */
+#include "kr_const.h"       /*  Constant Declarators for SNNS-Kernel  */
+#include "func_mac.h"	    /*	Transfer function macros  */
+#include "tbl_func.ph"
+
+
+/*#################################################
+
+GROUP: Unit activation functions using table lookup
+       and linear approximation method
+
+#################################################*/
+
+
+/*  Sigmoid function
+    using table lookup and linear approximation method
+*/
+FlintType   ACT_LogisticTbl(struct Unit *unit_ptr)
+{
+#include "sigmoid.tbl"	/*  m,b value tables for linear approximation  */
+
+  ACT_FUNC_DEFS
+  register FlintType  sum, x;
+  register int	index;
+
+
+  sum =  0.0;
+  if (GET_FIRST_SITE( unit_ptr ))
+    do
+      sum += GET_SITE_VALUE;
+    while (GET_NEXT_SITE);
+  else
+    if (GET_FIRST_UNIT_LINK( unit_ptr ))
+      do
+        sum += GET_WEIGHTED_OUTPUT;
+      while (GET_NEXT_LINK);
+
+/*  ***************************************************  */
+
+
+  x = sum + GET_UNIT_BIAS( unit_ptr );
+  index = (int) (x * SCALE_FACTOR) + INDEX_OFFSET;
+
+  if (index < 0)
+    {  /*  x is less then MIN_APPROX_X:
+	   approx. func value to MINUS_INFINITE_FUNC_VALUE  */
+    if (index <= MIN_INDEX)
+      { /*  printf( "x below -infinite : %g\n", x );  */
+	return( MINUS_INFINITE_FUNC_VALUE );
+      }
+    /*	printf( "x below MIN_APPROX_X : %g\n", x );  */
+    return( m[0] * x + b[0] );
+    }
+
+  if (index > NO_OF_APPROX)
+    {  /*  x is greater then MAX_APPROX_X:
+	   approx. func value to PLUS_INFINITE_FUNC_VALUE  */
+    if (index >= MAX_INDEX)
+      { /*  printf( "x above +infinite : %g\n", x );  */
+	return( PLUS_INFINITE_FUNC_VALUE );
+      }
+    /*	printf( "x above MAX_APPROX_X : %g\n", x );  */
+    return( m[ NO_OF_APPROX ] * x + b[ NO_OF_APPROX ] );
+    }
+
+  return( m[ index ] * x + b[ index ] );
+}
diff -Naur snort-2.3.3/src/kernel_snns/tbl_func.h snort-2.3.3.new/src/kernel_snns/tbl_func.h
--- snort-2.3.3/src/kernel_snns/tbl_func.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tbl_func.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,27 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tbl_func.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Transfer functions using table lookup and
+	           linear approximation method
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 25.02.93
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:50 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TBL_FUNC_DEFINED_
+#define  _TBL_FUNC_DEFINED_
+
+extern FlintType   ACT_LogisticTbl(struct Unit *unit_ptr);
+
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/tbl_func.ph snort-2.3.3.new/src/kernel_snns/tbl_func.ph
--- snort-2.3.3/src/kernel_snns/tbl_func.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/tbl_func.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,34 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/tbl_func.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Transfer functions using table lookup and
+	           linear approximation method
+  NOTES          :
+
+  AUTHOR         : Sven Doering
+  DATE           : 25.02.93
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.6 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:51 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TBL_FUNC_DEFINED_
+#define  _TBL_FUNC_DEFINED_
+
+/* begin global definition section */
+
+FlintType   ACT_LogisticTbl(struct Unit *unit_ptr);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/trans_f.c snort-2.3.3.new/src/kernel_snns/trans_f.c
--- snort-2.3.3/src/kernel_snns/trans_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/trans_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,1672 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/trans_f.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel transfer functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 25.06.90
+
+  CHANGED BY     : Sven Doering, Ralf Huebner, Marc Seemann (Uni Tuebingen)
+  RCS VERSION    : $Revision: 2.15 $
+  LAST CHANGE    : $Date: 1998/03/13 16:24:05 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+#include <string.h>
+
+#include "kr_typ.h"	    /*	Kernel types and constants  */
+#include "kr_const.h"       /*  Constant Declarators for SNNS-Kernel  */
+#include "func_mac.h"	    /*	Transfer function macros  */
+#include "glob_typ.h"
+#include "kr_mac.h"
+#include "cc_mac.h" 
+
+#include "trans_f.ph"
+
+#ifdef  __BORLANDC__
+#pragma option -w-
+#endif
+
+/*#################################################
+
+GROUP: Aritmetic Functions
+
+#################################################*/
+
+/*  exp function that prevents from over- and underflow, that means
+    exp_s ist a "save" exp function.
+*/
+static float exp_s( float arg )
+{
+  if (arg > 88.72) return( MAXFLOAT );
+  else if (arg < -88.0) return( 0.0 );
+  return( exp( arg ) );
+}
+
+
+/*#################################################
+
+GROUP: Unit Output Functions
+
+#################################################*/
+
+/*  Linear Output Function
+    This function isn't used now, because the identity output function is
+    the NULL pointer.
+*/
+FlintType  OUTP_Identity(register FlintType activation)
+{
+  return( activation );
+}
+
+
+/*  Clipping [0,1] function
+*/
+FlintType  OUT_Clip_01(register FlintType activation)
+{
+  if (activation < 0.0)  return( (FlintType) 0.0 );
+  if (activation > 1.0)  return( (FlintType) 1.0 );
+  return( activation );
+}
+
+
+/*  Clipping [-1,1] function
+*/
+FlintType  OUT_Clip_11(register FlintType activation)
+{
+  if (activation < -1.0)  return( (FlintType) -1.0 );
+  if (activation > 1.0)  return( (FlintType) 1.0 );
+  return( activation );
+}
+
+/*  Threshold 0.5 Output Function
+*/
+FlintType  OUT_Threshold05(register FlintType activation)
+{
+  if (activation < 0.5)  return( (FlintType) 0.0 );
+  return( (FlintType) 1.0 );
+}
+
+
+/*#################################################
+
+GROUP: Unit Activation Functions
+
+#################################################*/
+
+
+/*  Linear Activation Function
+*/
+FlintType   ACT_Linear(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( sum );
+}
+
+/*  Brain-State-in-a-Box Function
+*/
+FlintType   ACT_BSBFunction(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( sum * GET_UNIT_BIAS( unit_ptr ));
+}
+
+/*  Minimum Function (Unit's output and weight)
+*/
+FlintType   ACT_MinOutPlusWeight(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  min1, min2;
+
+
+  min1 = 0.0;
+
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))  {
+    min1 = GET_OUTPUT + GET_WEIGHT;
+    while (GET_NEXT_LINK)
+      if ((min2 = GET_OUTPUT + GET_WEIGHT) < min1)
+	min1 = min2;
+  }
+  else
+    if (GET_FIRST_SITE( unit_ptr ))  {
+      min1 = GET_SITE_VALUE;
+      while (GET_NEXT_SITE)
+       if ((min2 = GET_SITE_VALUE) < min1)
+	    min1 = min2;
+    }
+
+  return( min1 );
+}
+
+
+/*  Hyperbolic Tangent Function with Bias
+*/
+FlintType   ACT_TanHFunction(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( tanh( sum + GET_UNIT_BIAS( unit_ptr )));
+}
+
+
+/*  Hyperbolic Tangent Function of (unit_ptr/2)
+*/
+FlintType   ACT_TanHFunction_Xdiv2( unit_ptr )
+UNIT_PTR    unit_ptr;
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+   float expon;
+   float wert;
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+  
+  wert =  sum + GET_UNIT_BIAS( unit_ptr );
+  if( wert > 9 )  wert = 9;
+  if( wert <  -9 )  wert = -9;
+
+  expon = exp_s(wert);
+  return( (expon - 1) / (expon + 1));   
+
+}
+
+
+
+
+/*  Sigmoid Function
+*/
+FlintType   ACT_Logistic(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( (FlintType) (1.0 / (1.0 + exp_s( -sum - GET_UNIT_BIAS( unit_ptr )))) );
+}
+
+
+/*  Elliott Function
+*/
+FlintType   ACT_Elliott(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  sum += GET_UNIT_BIAS(unit_ptr);
+  if (sum <= 0.0)
+      return (FlintType) sum/(1.0 - sum);
+  else
+      return (FlintType) sum/(1.0 + sum);
+}
+
+
+/*  Perceptron Function
+*/
+FlintType   ACT_Perceptron(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum >= GET_UNIT_BIAS(unit_ptr))
+    return( (FlintType) 1.0 );
+
+  return( (FlintType) 0.0 );
+}
+
+/*  Signum Function
+*/
+FlintType   ACT_Signum(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum > 0.0)
+    return( (FlintType) 1.0 );
+
+  return( (FlintType) -1.0 );
+}
+
+/*  Softmax Function
+*/
+FlintType   ACT_Softmax(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( exp_s( -sum - GET_UNIT_BIAS( unit_ptr )) );
+}
+
+FlintType ACT_EXPONENT(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+  sum =  GET_UNIT_BIAS(unit_ptr);
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+  return exp_s(-0.5*sum*sum);
+}
+
+FlintType ACT_DERIV_EXPONENT(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  GET_UNIT_BIAS(unit_ptr);
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+  return (-sum*exp_s(-0.5*sum*sum));
+}
+
+FlintType ACT_SIN(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  GET_UNIT_BIAS(unit_ptr);
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return(sin(SIN_FAKTOR*sum));
+}
+
+FlintType ACT_DERIV_SIN(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  GET_UNIT_BIAS(unit_ptr);
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+  return SIN_FAKTOR*cos(SIN_FAKTOR*sum);
+}
+
+ 
+FlintType   ACT_CC_Threshold(struct Unit *unit_ptr)
+     /* only used, because I need a pseudo-derivation */
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum >=  - GET_UNIT_BIAS(unit_ptr)) /* remember it's negative */
+    return( (FlintType) 1.0 );
+
+  return( (FlintType) 0.0 );
+}
+
+FlintType   ACT_DERIV_CC_Threshold(struct Unit *unit_ptr)
+{
+  /*  return ACT_DERIV_Logistic(unit_ptr);*/
+  return (THRESHOLD_DERIV);
+}
+
+/*  Signum0 Function
+*/
+FlintType   ACT_Signum0(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum > 0.0)  return( (FlintType) 1.0 );
+  if (sum < 0.0)  return( (FlintType) -1.0 );
+  return( (FlintType) 0.0 );
+}
+
+
+/*  Step Function
+*/
+FlintType   ACT_StepFunction(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum > 0.0)  return( (FlintType) 1.0 );
+  return( (FlintType) 0.0 );
+}
+
+
+/*  Hysteresis Step Function
+*/
+FlintType   ACT_HystStepFunction(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+           FlintType  Schwellwert = 0.1;
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if  (sum - (unit_ptr->bias) > Schwellwert)   return( (FlintType) 1.0 );
+  if  (sum - (unit_ptr->bias) < -Schwellwert)  return( (FlintType) 0.0 );
+
+  return( unit_ptr->act );
+}
+
+/*  Bi-Directional Associative Memory
+*/
+FlintType   ACT_BAMFunction(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  if (sum > 0.0)  return( (FlintType) 1.0 );
+  if (sum < 0.0)  return( (FlintType) -1.0 );
+  return( unit_ptr->Out.output );
+}
+
+/* Rummelhart-McClelland's activation function for the delta rule
+*/
+FlintType ACT_RM (struct Unit *unit_ptr)
+{
+    ACT_FUNC_DEFS
+    register FlintType RM_act, sum;
+    FlintType Eparam=.15, Dparam=.15;
+
+    sum = 0.0;
+
+    if (GET_FIRST_UNIT_LINK (unit_ptr))
+	do
+	    sum += GET_WEIGHTED_OUTPUT;
+	while (GET_NEXT_LINK);
+    else
+	if (GET_FIRST_SITE (unit_ptr))
+	    do
+		sum += GET_SITE_VALUE;
+	    while (GET_NEXT_SITE);
+
+    if (sum > 0)
+	RM_act = (unit_ptr->act + (Eparam * sum * (1 - unit_ptr->act)) 
+		  - (Dparam * unit_ptr->act));
+    else
+	RM_act = (unit_ptr->act + (Eparam * sum * (unit_ptr->act + 1)) 
+		  - (Dparam * unit_ptr->act));
+    
+    return (RM_act);
+}  
+
+/* Tacoma-Activation-Function.
+   This Function needs additional parameters. They are stored
+   in value_a (radius) and value_b (coord.) */
+
+
+
+FlintType ACT_TACOMA(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType sum, coordAct,WeightSum;
+
+  sum =  0.0;
+  WeightSum = GET_UNIT_BIAS( unit_ptr );
+
+  if (GET_FIRST_UNIT_LINK(unit_ptr))
+     do{
+        if ((GET_TACOMA_RADIUS > 0.0)&&(GET_TACOMA_RADIUS>0)){
+           coordAct = ((GET_OUTPUT-GET_TACOMA_COORD) / GET_TACOMA_RADIUS);
+           sum += coordAct*coordAct;
+        }
+        WeightSum += GET_WEIGHTED_OUTPUT;
+     }while (GET_NEXT_LINK);
+/*     {
+        printf("Summe ist %.3f, exp ist : %.3f, normal was %.4f Erg ist %.3f\n",
+      sum,exp_s(-sum),(1/(1+exp_s(-WeightSum))-0.5),
+       (exp_s(-sum) * (1/(1+exp_s(-WeightSum))-0.5)));
+     }*/
+  return(exp_s(-sum) * (1/(1+exp_s(-WeightSum))-0.5));
+}
+
+
+
+
+/*  demonstation function: this function act like the Logistic function,
+    but the site with the name "Inhibit" will be skipped.
+*/
+FlintType   ACT_LogisticI(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE( unit_ptr ))
+    /*	Do not calculate the 'Inhibit' site */
+    do
+      if (strcmp( "Inhibit", GET_SITE_NAME ))
+        sum += GET_SITE_VALUE;
+    while (GET_NEXT_SITE);
+  else
+    if (GET_FIRST_UNIT_LINK( unit_ptr ))
+      do
+        sum += GET_WEIGHTED_OUTPUT;
+      while (GET_NEXT_LINK);
+
+  return( (FlintType) (1.0 / (1.0 + exp_s( -sum - GET_UNIT_BIAS( unit_ptr )))) );
+}
+
+/* help function for all Radial Basis Activation, Derivation and Learn
+ * functions. Computes the square of the L2-Norm of (T - X), where T is the
+ * vector of all weights from links leading to <unit_ptr> and X is the
+ * vector of output units the links are connected from.
+ * Store calculated value into value_a field of the current unit.
+ * ALL FUTURE RBF ACTIVATION FUNCTIONS HAVE TO CALL THIS FUNCTION !!!!!!!!!!
+ */
+
+FlintType RbfUnitGetNormsqr(struct Unit *unit_ptr)
+{
+        ACT_FUNC_DEFS
+        register FlintType      norm_2 = 0.0;   /* |X - T|^2            */
+        register FlintType      diff;           /* difference           */
+
+
+        if (!GET_FIRST_UNIT_LINK(unit_ptr))
+        {
+                fprintf(stderr,"No input links!\n");
+                return norm_2;
+        }
+
+        do
+        {
+                diff = GET_OUTPUT - GET_WEIGHT;
+                norm_2 += diff * diff;
+        }
+        while (GET_NEXT_LINK);
+
+      return unit_ptr -> value_a = norm_2;
+}
+
+/*
+ * Gaussian RBF Activation function: h(L2, s) = exp(-s*L2^2)
+ * where L2 is the L2 Norm (see RbfUnitGetNormsqr), and s is the bias 
+ * of <unit_ptr>.
+ */
+
+FlintType   ACT_RBF_Gaussian(struct Unit *unit_ptr)
+{
+        register FlintType      norm_2;
+
+        norm_2 = RbfUnitGetNormsqr(unit_ptr);
+        return (FlintType) exp_s(- GET_UNIT_BIAS(unit_ptr)*norm_2);
+}
+
+/*
+ * Multiquadratic Activation function: h(L2, s) = sqrt(s^2 + L2^2)
+ */
+
+FlintType ACT_RBF_Multiquadratic(struct Unit *unit_ptr)
+{
+      register FlintType      norm_2;
+
+      norm_2 = RbfUnitGetNormsqr(unit_ptr);
+      return (FlintType) sqrt(norm_2 + GET_UNIT_BIAS(unit_ptr));
+}
+
+/*
+ * Thin plate splines Activation function: h(L2, s) = (L2*s)^2*ln(L2*s)
+ */
+
+FlintType ACT_RBF_Thinplatespline(struct Unit *unit_ptr)
+{
+      register FlintType      norm_2;
+      register FlintType      bias;
+
+      norm_2 = RbfUnitGetNormsqr(unit_ptr);
+      bias = GET_UNIT_BIAS(unit_ptr);
+
+      if (norm_2 == (FlintType) 0.0)
+          return (FlintType) 0.0;
+      else
+          return (FlintType) bias*bias*norm_2*(0.5*log(norm_2) + log(bias));
+}
+
+/*  Linear Activation Function + BIAS
+*/
+FlintType   ACT_Linear_bias(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+      sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+
+  return( sum + GET_UNIT_BIAS(unit_ptr));
+}
+
+
+
+/* NOTE: This function is nothing but a threshold function,
+   which checks, whether the netinput is greater or equal 2, and if so
+   returns 1.0, else 0.0 .
+*/
+FlintType  ACT_at_least_2 (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    sum = 0.0;
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+
+   if (sum >= 2.0) {
+      return ( (FlintType) 1.0);
+   } else {
+      return ( (FlintType) 0.0);
+   } /*if*/
+} /* ACT_at_least_2 */
+
+
+
+FlintType  ACT_less_than_0 (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    sum = 0.0;
+
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (sum >= 0.0) {
+      return ( (FlintType) 0.0);
+   } else {
+      return ( (FlintType) 1.0);
+   } /*if*/
+
+} /* ACT_less_than_0 */
+
+
+
+
+
+FlintType  ACT_at_least_1 (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType   sum = 0.0;
+
+
+   if (GET_FIRST_SITE (unit_ptr)) {
+      do {
+         sum += GET_SITE_VALUE;
+      } while (GET_NEXT_SITE);
+   } else {
+      if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+         do {
+            sum += GET_WEIGHTED_OUTPUT;
+         } while (GET_NEXT_LINK);
+      } /*if*/
+   } /*if*/
+
+
+   if (sum >= 1.0) {
+      return ( (FlintType) 1.0);
+   } else {
+      return ( (FlintType) 0.0);
+   } /*if*/
+
+} /* ACT_at_least_1 */
+
+
+
+FlintType  ACT_at_most_0 (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    sum = 0.0;
+
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if (sum > 0.0) {
+      return ( (FlintType) 0.0);
+   } else {
+      return ( (FlintType) 1.0);
+   } /*if*/
+
+} /* ACT_at_most_0 */
+
+
+
+FlintType  ACT_Product (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    prod = 1.0;
+
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         prod *= GET_WEIGHTED_OUTPUT;
+         if (prod == 0.0) {
+            break;
+         } /*if*/
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            prod *= GET_SITE_VALUE;
+            if (prod == 0.0) {
+               break;
+            } /*if*/
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   return (prod);
+
+} /* ACT_Product () */
+
+
+FlintType  ACT_exactly_1 (struct Unit *unit_ptr)
+{
+   ACT_FUNC_DEFS
+   register FlintType    sum = 0.0;
+
+
+   if (GET_FIRST_UNIT_LINK (unit_ptr)) {
+      do {
+         sum += GET_WEIGHTED_OUTPUT;
+      } while (GET_NEXT_LINK);
+   } else {
+      if (GET_FIRST_SITE (unit_ptr)) {
+         do {
+            sum += GET_SITE_VALUE;
+         } while (GET_NEXT_SITE);
+      } /*if*/
+   } /*if*/
+
+   if ((sum > 0.8) && (sum < 1.2)) {
+      return (1.0);
+   } else {
+      return (0.0);
+   } /*if*/
+
+} /* ACT_exactly_1 */
+
+/*****************************************************************************
+  FUNCTION : ACT_TD_Logistic
+
+  PURPOSE  : logistic activation function for use in time delay networks
+  RETURNS  : activation
+  NOTES    : the TD section of the unit must be initialized correct
+             the units must be sorted TOPOLOGIC_LOGICAL
+
+  UPDATE   : 19.2.93 M. Vogt
+******************************************************************************/
+
+FlintType   ACT_TD_Logistic(struct Unit *unit_ptr)
+{
+/* the common macros are not used */
+
+  register FlintType  sum;
+  register UNIT_PTR ref_unit;
+  register int source_offset;
+  register struct Link *link;
+
+  if (unit_ptr -> TD.td_connect_typ == 0)
+      return ACT_Logistic(unit_ptr);
+
+  ref_unit = *(unit_ptr -> TD.my_topo_ptr + unit_ptr -> TD.target_offset);
+  source_offset = unit_ptr -> TD.source_offset;
+  sum =  0.0;
+  if ((ref_unit -> flags) & UFLAG_DLINKS)
+  {
+      link = (struct Link *) ref_unit->sites;
+      while (link != (struct Link *) NULL)
+      {
+          sum += (*(link->to->TD.my_topo_ptr + source_offset))->Out.output 
+                 * link->weight;
+          link = link->next;
+      }
+  }
+  else
+  {
+      fprintf(stderr, 
+              "Warning: Illegal link structure used in time delay layer\n");
+  }
+  return( (FlintType) (1.0 / (1.0 + exp_s( -sum - ref_unit->bias))) );
+}
+
+/*****************************************************************************
+  FUNCTION : ACT_TD_Elliott
+
+  PURPOSE  : elliott activation function for use in time delay networks
+  RETURNS  : activation
+  NOTES    : the TD section of the unit must be initialized correct
+             the units must be sorted TOPOLOGIC_LOGICAL
+
+  UPDATE   : 5.3.93 M. Vogt
+******************************************************************************/
+
+FlintType   ACT_TD_Elliott(struct Unit *unit_ptr)
+{
+/* the common macros are not used */
+
+  register FlintType  sum;
+  register UNIT_PTR ref_unit;
+  register int source_offset;
+  register struct Link *link;
+
+  if (unit_ptr -> TD.td_connect_typ == 0)
+      return ACT_Elliott(unit_ptr);
+
+  ref_unit = *(unit_ptr -> TD.my_topo_ptr + unit_ptr -> TD.target_offset);
+  source_offset = unit_ptr -> TD.source_offset;
+  sum =  0.0;
+  if ((ref_unit -> flags) & UFLAG_DLINKS)
+  {
+      link = (struct Link *) ref_unit->sites;
+      while (link != (struct Link *) NULL)
+      {
+          sum += (*(link->to->TD.my_topo_ptr + source_offset))->Out.output 
+                 * link->weight;
+          link = link->next;
+      }
+  }
+  else
+  {
+      fprintf(stderr, 
+              "Warning: Illegal link structure used in time delay layer\n");
+  }
+
+  sum += ref_unit->bias;
+  if (sum <= 0.0)
+      return (FlintType) sum/(1.0 - sum);
+  else
+      return (FlintType) sum/(1.0 + sum);
+}
+
+
+
+/* This function is called by a xgui function for kohonen networks */
+void kohonen_SetExtraParameter(int x)
+  /* no. of layer chosen in remote panel */
+{
+  ExtraParameter=x;
+}
+
+
+/* Activate specific layer of the net chosen in the remote panel, to set
+the layer call:  kohonen_SetExtraParameter( Layer ) 
+*/
+FlintType   ACT_Component( UNIT_PTR unit_ptr )
+
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+  int i=1,n;
+
+  n = ExtraParameter;
+
+  sum =  0.0;
+  if (GET_FIRST_SITE( unit_ptr ))
+    sum = GET_SITE_VALUE;
+  else
+    if (GET_FIRST_UNIT_LINK( unit_ptr ))
+      do
+        sum=GET_WEIGHT;
+      while((i++<n)&&GET_NEXT_LINK);
+
+  return( sum );
+}
+
+/*  Calculate the simple euclidic distance
+    between in-vector and weight-vector for kohonen networks
+*/
+FlintType   ACT_Euclid( UNIT_PTR unit_ptr )
+
+{
+  ACT_FUNC_DEFS
+  register FlintType  dist;
+
+  dist=  0.0;
+  if (GET_FIRST_SITE( unit_ptr ))
+    do
+      dist += GET_SITE_VALUE;
+    while (GET_NEXT_SITE);
+  else
+    if (GET_FIRST_UNIT_LINK( unit_ptr ))
+      do
+        dist += GET_EUCLID_COMP;
+      while (GET_NEXT_LINK);
+
+  return(sqrt(dist));
+}
+
+
+
+/*######################################################################
+
+GROUP: First and Second Derivation Functions of the Activation Functions
+
+Second Derivation Funtions are not available for TD and RBF activation
+functions.
+
+######################################################################*/
+
+/*  Sigmoid Derivation Function
+*/
+FlintType   ACT_DERIV_Logistic(struct Unit *unit_ptr)
+{
+    return( GET_UNIT_ACT( unit_ptr ) * (1.0 - GET_UNIT_ACT( unit_ptr )) );
+}
+
+
+FlintType ACT_2_DERIV_Logistic (struct Unit *unit_ptr)
+{
+
+    return (GET_UNIT_ACT (unit_ptr) * (1.0 - GET_UNIT_ACT (unit_ptr)) 
+	    * (2 * GET_UNIT_ACT (unit_ptr) - 1.0));
+
+}
+
+
+/*  Elliott Derivation Function
+*/
+FlintType   ACT_DERIV_Elliott(struct Unit *unit_ptr)
+{
+    register FlintType act;
+    if ((act = GET_UNIT_ACT(unit_ptr)) <= 0.0)
+	act = 1.0 + act;
+    else
+	act = 1.0 - act;
+
+    return (act*act);
+}
+
+
+FlintType ACT_2_DERIV_Elliott (struct Unit *unit_ptr)
+{
+
+    register FlintType act;
+    
+    if ((act = GET_UNIT_ACT(unit_ptr)) <= 0.0)
+	act = 1.0 + act;
+    else
+	act = 1.0 - act;
+
+    if (act <= 0.0)
+	return (2 * act * act);
+    else
+	return (-2 * act * act);
+
+}
+
+
+/*  Sigmoid Derivation Function for TD Networks
+*/
+
+FlintType   ACT_DERIV_TD_Logistic(struct Unit *unit_ptr)
+{
+  return( GET_UNIT_ACT( unit_ptr ) * (1.0 - GET_UNIT_ACT( unit_ptr )) );
+}
+
+
+/*  Elliott Derivation Function for TD Networks
+*/
+
+FlintType   ACT_DERIV_TD_Elliott(struct Unit *unit_ptr)
+{
+    register FlintType act;
+    if ((act = GET_UNIT_ACT(unit_ptr)) <= 0.0)
+	act = 1.0 + act;
+    else
+	act = 1.0 - act;
+
+    return (act*act);
+}
+
+
+/*  Identity Derivation Function
+*/
+FlintType   ACT_DERIV_Identity(struct Unit *unit_ptr)
+{
+  return( (FlintType) 1.0 );
+}
+
+
+FlintType ACT_2_DERIV_Identity (struct Unit *unit_ptr)
+{
+
+    return ((FlintType) 0.0);
+
+}
+
+/*  Brain-State-in-a-Box Derivation Function
+*/
+FlintType   ACT_DERIV_BSBFunction(struct Unit *unit_ptr)
+{
+  return( GET_UNIT_BIAS( unit_ptr ));
+}
+
+
+FlintType ACT_2_DERIV_BSBFunction (struct Unit *unit_ptr)
+{
+
+    return ((FlintType) 0.0);
+
+}
+
+
+/* TanH Derivation Function
+*/
+FlintType   ACT_DERIV_TanHFunction(struct Unit *unit_ptr)
+{
+  return(1.0-GET_UNIT_ACT( unit_ptr ) * (GET_UNIT_ACT( unit_ptr )) );
+}
+
+
+FlintType ACT_2_DERIV_TanHFunction (struct Unit *unit_ptr)
+{
+
+    return (2 * GET_UNIT_ACT (unit_ptr) * 
+	    (1.0 - GET_UNIT_ACT (unit_ptr) * 
+	           GET_UNIT_ACT (unit_ptr)));
+
+}
+
+
+/* TanH Derivation Function
+*/
+FlintType   ACT_DERIV_TanHFunction_Xdiv2(struct Unit *unit_ptr)
+{
+  return(1.0-(GET_UNIT_ACT( unit_ptr ) * (GET_UNIT_ACT( unit_ptr )))/2 );
+}
+
+
+FlintType ACT_2_DERIV_TanHFunction_Xdiv2 (struct Unit *unit_ptr)
+{
+
+    return (ACT_2_DERIV_TanHFunction (unit_ptr) / 2);
+
+}
+
+
+/*  Dummy function for the derivation functions. Returns always the value 1.0.
+    This function is used for activation functions that can't have a derivation
+    function.
+
+    NOTE: All activation functions have to provide a derivation function.
+*/
+FlintType   ACT_DERIV_Dummy(struct Unit *unit_ptr)
+{
+  return( (FlintType) 1.0 );
+}
+
+
+/* Dummy function for second derivation, always returns 0.0. */
+
+FlintType ACT_2_DERIV_Dummy (struct Unit *unit_ptr)
+{
+
+    return ((FlintType) 0.0);
+
+}
+
+
+/* Gaussian Radial Basis Derivation functionS
+ * depending on Aux: 0 derivated to T
+ *                   1 derivated to s (BIAS)
+ *                 2 derivated to T if value_a holds norm ^ 2;
+ *                 3 derivated to s if value_a holds norm ^ 2;
+ *                 others: const 1;
+ */
+
+FlintType   ACT_DERIV_RBF_Gaussian(struct Unit *unit_ptr)
+{
+      register FlintType      rc;             /* return value         */
+      register FlintType      norm_2;         /* norm ^ 2             */
+
+      switch (unit_ptr -> Aux.int_no)
+      {
+          case 0:
+              /* derivated to norm_2:                                 */
+              norm_2 = RbfUnitGetNormsqr(unit_ptr);
+              rc =  (FlintType) -GET_UNIT_BIAS(unit_ptr)
+                      * exp_s(- GET_UNIT_BIAS(unit_ptr)*norm_2);
+              break;
+          case 1:
+              /* derivated to BIAS:                                   */
+              norm_2 = RbfUnitGetNormsqr(unit_ptr);
+              rc = (FlintType) -norm_2 
+                      * exp_s(- GET_UNIT_BIAS(unit_ptr)*norm_2);
+              break;
+          case 2:
+              /* derivated to norm_2: (norm ^ 2 = value_a)            */
+              rc =  (FlintType) -GET_UNIT_BIAS(unit_ptr)
+                      * exp_s(- GET_UNIT_BIAS(unit_ptr)*unit_ptr -> value_a);
+              break;
+          case 3:
+              /* derivated to BIAS: (norm ^ 2 = value_a)              */
+              rc = (FlintType) -unit_ptr -> value_a 
+                      * exp_s(- GET_UNIT_BIAS(unit_ptr)*unit_ptr -> value_a);
+              break;
+          default:
+              rc = (FlintType) 1.0;
+      }
+
+  return rc;
+}
+
+/* Multiquadratic Radial Basis Derivation functionS
+ * depending on Aux: 0 derivated to T
+ *                   1 derivated to s (BIAS)
+ *                 2 derivated to T if value_a holds norm ^ 2;
+ *                 3 derivated to s if value_a holds norm ^ 2;
+ *                 others: const 1;
+ */
+
+FlintType   ACT_DERIV_RBF_Multiquadratic(struct Unit *unit_ptr)
+{
+      register FlintType      rc;             /* return value         */
+      register FlintType      norm_2;         /* norm ^ 2             */
+      register FlintType      bias;           /* s                    */
+
+      bias = (FlintType) GET_UNIT_BIAS(unit_ptr);
+      switch (unit_ptr -> Aux.int_no)
+      {
+          case 0:
+          case 1:
+              /* derivated to BIAS:                                   */
+              /* derivated to norm_2:                                 */
+              norm_2 = RbfUnitGetNormsqr(unit_ptr);
+              rc =  (FlintType) 1.0/(2.0 * sqrt(bias + norm_2));
+              break;
+          case 2:
+          case 3:
+              /* derivated to BIAS: (norm ^ 2 = value_a)              */
+              /* derivated to norm_2: (norm ^ 2 = value_a)            */
+              rc =  (FlintType) 1.0/(2.0 * sqrt(bias + unit_ptr -> value_a));
+              break;
+          default:
+              rc = (FlintType) 1.0;
+      }
+
+  return rc;
+}
+
+/* Thin Plate Spline Radial Basis Derivation functionS
+ * depending on Aux: 0 derivated to T
+ *                   1 derivated to s (BIAS)
+ *                 2 derivated to T if value_a holds norm ^ 2;
+ *                 3 derivated to s if value_a holds norm ^ 2;
+ *                 others: const 1;
+ */
+
+FlintType   ACT_DERIV_RBF_Thinplatespline(struct Unit *unit_ptr)
+{
+      register FlintType      rc;             /* return value         */
+      register FlintType      norm_2;         /* norm ^ 2             */
+      register FlintType      bias;           /* s                    */
+
+      bias = (FlintType) GET_UNIT_BIAS(unit_ptr);
+      switch (unit_ptr -> Aux.int_no)
+      {
+          case 0:
+              /* derivated to norm_2:                                 */
+              norm_2 = RbfUnitGetNormsqr(unit_ptr);
+              if (norm_2 == (FlintType) 0.0)
+                  rc = (FlintType) 0.0;
+              else
+                  rc =  (FlintType) bias * bias *
+                      (log(norm_2) + 2.0*log(bias) + 1.0) / 2.0;
+              break;
+          case 1:
+              /* derivated to BIAS:                                   */
+              norm_2 = RbfUnitGetNormsqr(unit_ptr);
+              if (norm_2 == (FlintType) 0.0)
+                  rc = (FlintType) 0.0;
+              else
+                  rc = (FlintType) bias * norm_2 *
+                      (log(norm_2) + 2.0*log(bias) + 1.0);
+              break;
+          case 2:
+              /* derivated to norm_2: (norm ^ 2 = value_a)            */
+              if (unit_ptr -> value_a == (FlintType) 0.0)
+                  rc = (FlintType) 0.0;
+              else
+                  rc =  (FlintType) bias * bias *
+                      (log(unit_ptr -> value_a) + 2.0*log(bias) + 1.0) / 2.0;
+              break;
+          case 3:
+              /* derivated to BIAS: (norm ^ 2 = value_a)              */
+              if (unit_ptr -> value_a == (FlintType) 0.0)
+                  rc = (FlintType) 0.0;
+              else
+                  rc = (FlintType) bias * unit_ptr -> value_a *
+                      (log(unit_ptr -> value_a) + 2.0*log(bias) + 1.0);
+              break;
+          default:
+              rc = (FlintType) 1.0;
+      }
+
+  return rc;
+}
+
+
+
+
+/* Tacoma-Deriv-Activation-Function.
+   This Function needs additional parameters. They are stored
+   in value_a (radius) and value_b (coord.) */
+
+FlintType ACT_DERIV_TACOMA(struct Unit *unit_ptr)
+{
+
+/*  returns ( (        1           1  ) 2        1   )    _
+           ( (   -------------  - ---  )      - ---   ) h(x)
+            ( (    1+e^(-Net)      2  )          4   )              
+
+    or in latex-code :
+    ((\frac{1}{1+e^{-Net}}-\frac{1}{2})^2 - frac{1}{4} )*h(\vec{x}) */
+
+
+  ACT_FUNC_DEFS
+  float sum,coordAct,WeightSum;
+  float bruch;
+
+  sum = 0.0;
+
+  WeightSum=GET_UNIT_BIAS(unit_ptr);
+
+  if (GET_FIRST_UNIT_LINK(unit_ptr))
+     do{
+        if (GET_TACOMA_RADIUS > 0.0){
+           coordAct = ((GET_OUTPUT-GET_TACOMA_COORD) / GET_TACOMA_RADIUS);
+           sum += coordAct*coordAct;
+        }
+        WeightSum+=GET_WEIGHTED_OUTPUT;
+     }while (GET_NEXT_LINK);
+  bruch=1/(1+exp_s(-WeightSum))-0.5;
+  return (bruch*bruch-0.25)*(exp_s(-sum));
+}
+
+  
+
+
+
+/*#################################################
+
+GROUP: Site functions
+
+#################################################*/
+
+/*  Linear Site Function
+*/
+FlintType  SITE_WeightedSum(struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE_LINK( site_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+  return( sum );
+}
+
+
+/*  Product of all predecessor outputs and input link weights
+*/
+FlintType  SITE_Product(struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  prod;
+
+
+  if (GET_FIRST_SITE_LINK( site_ptr ))  {
+    prod = 1.0;
+    do
+      prod *= GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+    return( prod );
+  }
+  else
+    return( (FlintType) 0.0 );
+}
+
+
+/*  Like SITE_Product() but no weighting of the unit's output
+*/
+FlintType  SITE_ProductA(struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  prod;
+
+
+  if (GET_FIRST_SITE_LINK( site_ptr ))  {
+    prod = 1.0;
+    do
+      prod *= GET_OUTPUT;
+    while (GET_NEXT_LINK);
+
+/*  Future Application (in SNNS-Kernel V2.1 the sites don't have weights).
+    So the return value is only the product.
+*/
+    return( GET_SITE_WEIGHT * prod );
+  }
+  else
+    return( (FlintType) 0.0 );
+}
+
+
+
+/*  Get the highest weighted output
+*/
+FlintType  SITE_Max(struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  max, out;
+
+
+  if (GET_FIRST_SITE_LINK( site_ptr ))  {
+    max = GET_WEIGHTED_OUTPUT;
+
+    while (GET_NEXT_LINK)  {
+      out = GET_WEIGHTED_OUTPUT;
+      if (max < out)  max = out;
+    }
+
+    return( max );
+  }
+  else
+    return( (FlintType) 0.0 );
+}
+
+
+/*  Get the lowest weighted output
+*/
+FlintType  SITE_Min(struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  min, out;
+
+
+  if (GET_FIRST_SITE_LINK( site_ptr ))  {
+    min = GET_WEIGHTED_OUTPUT;
+
+    while (GET_NEXT_LINK)  {
+      out = GET_WEIGHTED_OUTPUT;
+      if (min > out)  min = out;
+    }
+
+    return( min );
+  }
+  else
+    return( (FlintType) 0.0 );
+
+}
+
+
+FlintType  SITE_at_least_2 (struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  sum = 0.0;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE_LINK (site_ptr))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+  if (sum >= 2.0) {
+     return ( (FlintType) 1.0);
+  } else {
+     return ( (FlintType) 0.0);
+  } /*if*/
+
+} /* SITE_at_least_2 */
+
+
+FlintType  SITE_at_least_1 (struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  sum = 0.0;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE_LINK (site_ptr))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+  if (sum >= 1.0) {
+     return ( (FlintType) 1.0);
+  } else {
+     return ( (FlintType) 0.0);
+  } /*if*/
+
+} /* SITE_at_least_1 */
+
+
+FlintType  SITE_at_most_0 (struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  sum = 0.0;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE_LINK (site_ptr))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+  if (sum <= 0.0) {
+     return ( (FlintType) 1.0);
+  } else {
+     return ( (FlintType) 0.0);
+  } /*if*/
+
+} /* SITE_at_most_0 */
+
+
+
+/* IMPORTANT:
+   This function doesn't check for overflows. So make sure
+   that sum is greater than 0.0 when using this Site function.
+*/
+FlintType  SITE_Reciprocal_WeightedSum (struct Site *site_ptr)
+{
+  SITE_FUNC_DEFS
+  register FlintType  sum = 0.0;
+
+
+  sum = 0.0;
+  if (GET_FIRST_SITE_LINK( site_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+
+  if (sum == 0.0) {
+     return (0.0);
+  } else {
+     return((FlintType) (1/sum));
+  } /*if*/
+} /* SITE_Reciprocal_WeightedSum */
+
+
+
+FlintType   ACT_LogisticSym(struct Unit *unit_ptr)
+{
+  ACT_FUNC_DEFS
+  register FlintType  sum;
+
+
+  sum =  0.0;
+  if (GET_FIRST_UNIT_LINK( unit_ptr ))
+    do
+      sum += GET_WEIGHTED_OUTPUT;
+    while (GET_NEXT_LINK);
+  else
+    if (GET_FIRST_SITE( unit_ptr ))
+      do
+	sum += GET_SITE_VALUE;
+      while (GET_NEXT_SITE);
+  return( (FlintType) (1.0 / (1.0 + exp_s( -sum - GET_UNIT_BIAS( unit_ptr ))))-0.5);
+}
+
+FlintType   ACT_DERIV_LogisticSym(struct Unit *unit_ptr)
+{
+  return( 0.25 - GET_UNIT_ACT( unit_ptr ) * GET_UNIT_ACT( unit_ptr ));
+}
+
+FlintType   ACT_DERIV_tanh(struct Unit *unit_ptr)
+{
+  return( 2 * (1.0 - GET_UNIT_ACT( unit_ptr )) * GET_UNIT_ACT( unit_ptr ));
+}
+
+
+FlintType ACT_2_DERIV_tanh (struct Unit *unit_ptr)
+{
+
+    return (2 * ACT_2_DERIV_Logistic (unit_ptr));
+
+}
+
+
+#ifdef  __BORLANDC__
+#pragma option -w+.
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/trans_f.h snort-2.3.3.new/src/kernel_snns/trans_f.h
--- snort-2.3.3/src/kernel_snns/trans_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/trans_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,106 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/trans_f.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel transfer functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 25.06.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/03/10 15:12:32 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TRANS_F_DEFINED_
+#define  _TRANS_F_DEFINED_
+
+
+extern FlintType  OUTP_Identity(register FlintType activation);
+extern FlintType  OUT_Clip_01(register FlintType activation);
+extern FlintType  OUT_Clip_11(register FlintType activation);
+extern FlintType  OUT_Threshold05(register FlintType activation);
+extern FlintType   ACT_Linear(struct Unit *unit_ptr);
+extern FlintType   ACT_BSBFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_MinOutPlusWeight(struct Unit *unit_ptr);
+extern FlintType   ACT_TanHFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+extern FlintType   ACT_Logistic(struct Unit *unit_ptr);
+extern FlintType   ACT_Elliott(struct Unit *unit_ptr);
+extern FlintType   ACT_Perceptron(struct Unit *unit_ptr);
+extern FlintType   ACT_Signum(struct Unit *unit_ptr);
+extern FlintType   ACT_Softmax(struct Unit *unit_ptr);
+extern FlintType   ACT_CC_Threshold(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_CC_Threshold(struct Unit *unit_ptr);
+extern FlintType   ACT_EXPONENT(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_EXPONENT(struct Unit *unit_ptr);
+extern FlintType   ACT_SIN(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_SIN(struct Unit *unit_ptr);
+extern FlintType   ACT_Signum0(struct Unit *unit_ptr);
+extern FlintType   ACT_StepFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_HystStepFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_BAMFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_RM (struct Unit *unit_ptr);
+extern FlintType   ACT_LogisticI(struct Unit *unit_ptr);
+extern FlintType RbfUnitGetNormsqr(struct Unit *unit_ptr);
+extern FlintType   ACT_RBF_Gaussian(struct Unit *unit_ptr);
+extern FlintType ACT_RBF_Multiquadratic(struct Unit *unit_ptr);
+extern FlintType ACT_RBF_Thinplatespline(struct Unit *unit_ptr);
+extern FlintType   ACT_Linear_bias(struct Unit *unit_ptr);
+extern FlintType  ACT_at_least_2 (struct Unit *unit_ptr);
+extern FlintType  ACT_less_than_0 (struct Unit *unit_ptr);
+extern FlintType  ACT_at_least_1 (struct Unit *unit_ptr);
+extern FlintType  ACT_at_most_0 (struct Unit *unit_ptr);
+extern FlintType  ACT_Product (struct Unit *unit_ptr);
+extern FlintType  ACT_exactly_1 (struct Unit *unit_ptr);
+extern FlintType   ACT_TD_Logistic(struct Unit *unit_ptr);
+extern FlintType   ACT_TD_Elliott(struct Unit *unit_ptr);
+extern FlintType   ACT_Euclid(struct Unit *unit_ptr);
+extern FlintType   ACT_Component(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_Logistic(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_Logistic(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_Elliott(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_Elliott(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_TD_Logistic(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_TD_Elliott(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_Identity(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_Identity(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_BSBFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_BSBFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_TanHFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_TanHFunction(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_Dummy(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_Dummy(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_RBF_Gaussian(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_RBF_Multiquadratic(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_RBF_Thinplatespline(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_TACOMA(struct Unit *unit_ptr);
+extern FlintType  SITE_WeightedSum(struct Site *site_ptr);
+extern FlintType  SITE_Product(struct Site *site_ptr);
+extern FlintType  SITE_ProductA(struct Site *site_ptr);
+extern FlintType  SITE_Max(struct Site *site_ptr);
+extern FlintType  SITE_Min(struct Site *site_ptr);
+extern FlintType  SITE_at_least_2 (struct Site *site_ptr);
+extern FlintType  SITE_at_least_1 (struct Site *site_ptr);
+extern FlintType  SITE_at_most_0 (struct Site *site_ptr);
+extern FlintType  SITE_Reciprocal_WeightedSum (struct Site *site_ptr);
+extern FlintType   ACT_LogisticSym(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_LogisticSym(struct Unit *unit_ptr);
+extern FlintType   ACT_DERIV_tanh(struct Unit *unit_ptr);
+extern FlintType   ACT_2_DERIV_tanh(struct Unit *unit_ptr);
+extern FlintType   ACT_TACOMA(struct Unit *unit_ptr);
+extern void kohonen_SetExtraParameter(int x);
+
+
+
+
+#endif 
+
+/* 82 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/trans_f.ph snort-2.3.3.new/src/kernel_snns/trans_f.ph
--- snort-2.3.3/src/kernel_snns/trans_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/trans_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,111 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/trans_f.ph,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel transfer functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 25.06.90
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.12 $
+  LAST CHANGE    : $Date: 1998/03/10 15:12:33 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _TRANS_F_DEFINED_
+#define  _TRANS_F_DEFINED_
+
+/* begin global definition section */
+
+FlintType  OUTP_Identity(register FlintType activation);
+FlintType  OUT_Clip_01(register FlintType activation);
+FlintType  OUT_Clip_11(register FlintType activation);
+FlintType  OUT_Threshold05(register FlintType activation);
+FlintType   ACT_Linear(struct Unit *unit_ptr);
+FlintType   ACT_BSBFunction(struct Unit *unit_ptr);
+FlintType   ACT_MinOutPlusWeight(struct Unit *unit_ptr);
+FlintType   ACT_TanHFunction(struct Unit *unit_ptr);
+FlintType   ACT_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+FlintType   ACT_Logistic(struct Unit *unit_ptr);
+FlintType   ACT_Elliott(struct Unit *unit_ptr);
+FlintType   ACT_Perceptron(struct Unit *unit_ptr);
+FlintType   ACT_Signum(struct Unit *unit_ptr);
+FlintType   ACT_Softmax(struct Unit *unit_ptr);
+FlintType   ACT_CC_Threshold(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_CC_Threshold(struct Unit *unit_ptr);
+FlintType   ACT_EXPONENT(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_EXPONENT(struct Unit *unit_ptr);
+FlintType   ACT_SIN(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_SIN(struct Unit *unit_ptr);
+FlintType   ACT_Signum0(struct Unit *unit_ptr);
+FlintType   ACT_StepFunction(struct Unit *unit_ptr);
+FlintType   ACT_HystStepFunction(struct Unit *unit_ptr);
+FlintType   ACT_BAMFunction(struct Unit *unit_ptr);
+FlintType   ACT_RM (struct Unit *unit_ptr);
+FlintType   ACT_LogisticI(struct Unit *unit_ptr);
+FlintType RbfUnitGetNormsqr(struct Unit *unit_ptr);
+FlintType   ACT_RBF_Gaussian(struct Unit *unit_ptr);
+FlintType ACT_RBF_Multiquadratic(struct Unit *unit_ptr);
+FlintType ACT_RBF_Thinplatespline(struct Unit *unit_ptr);
+FlintType   ACT_Linear_bias(struct Unit *unit_ptr);
+FlintType  ACT_at_least_2 (struct Unit *unit_ptr);
+FlintType  ACT_less_than_0 (struct Unit *unit_ptr);
+FlintType  ACT_at_least_1 (struct Unit *unit_ptr);
+FlintType  ACT_at_most_0 (struct Unit *unit_ptr);
+FlintType  ACT_Product (struct Unit *unit_ptr);
+FlintType  ACT_exactly_1 (struct Unit *unit_ptr);
+FlintType   ACT_TD_Logistic(struct Unit *unit_ptr);
+FlintType   ACT_TD_Elliott(struct Unit *unit_ptr);
+FlintType   ACT_Euclid(struct Unit *unit_ptr);
+FlintType   ACT_Component(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_Logistic(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_Logistic(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_Elliott(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_Elliott(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_TD_Logistic(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_TD_Elliott(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_Identity(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_Identity(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_BSBFunction(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_BSBFunction(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_TanHFunction(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_TanHFunction(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_TanHFunction_Xdiv2(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_Dummy(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_Dummy(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_RBF_Gaussian(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_RBF_Multiquadratic(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_RBF_Thinplatespline(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_TACOMA(struct Unit *unit_ptr);
+FlintType  SITE_WeightedSum(struct Site *site_ptr);
+FlintType  SITE_Product(struct Site *site_ptr);
+FlintType  SITE_ProductA(struct Site *site_ptr);
+FlintType  SITE_Max(struct Site *site_ptr);
+FlintType  SITE_Min(struct Site *site_ptr);
+FlintType  SITE_at_least_2 (struct Site *site_ptr);
+FlintType  SITE_at_least_1 (struct Site *site_ptr);
+FlintType  SITE_at_most_0 (struct Site *site_ptr);
+FlintType  SITE_Reciprocal_WeightedSum (struct Site *site_ptr);
+FlintType   ACT_LogisticSym(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_LogisticSym(struct Unit *unit_ptr);
+FlintType   ACT_DERIV_tanh(struct Unit *unit_ptr);
+FlintType   ACT_2_DERIV_tanh(struct Unit *unit_ptr);
+FlintType   ACT_TACOMA(struct Unit *unit_ptr);
+void kohonen_SetExtraParameter(int x);
+
+
+/* end global definition section */
+
+/* begin private definition section */
+
+static int ExtraParameter;
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/update_f.c snort-2.3.3.new/src/kernel_snns/update_f.c
--- snort-2.3.3/src/kernel_snns/update_f.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/update_f.c	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,2281 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/update_f.c,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Network Update Functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 18.03.91
+
+  CHANGED BY     : Sven Doering, Michael Vogt (Martin Reczko)
+  RCS VERSION    : $Revision: 2.18 $
+  LAST CHANGE    : $Date: 1998/03/13 16:24:06 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#include <config.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#ifdef HAVE_VALUES_H
+#include <values.h>
+#endif
+
+#include "kr_typ.h"	 /*  Kernel Types and Constants  */
+#include "kr_const.h"	 /*  Constant Declarators for SNNS-Kernel  */
+#include "kr_def.h"	 /*  Default Values  */
+#include "kernel.h"	 /*  Kernel Functions  */
+#include "glob_typ.h"
+#include "kr_ui.h"
+#include "kr_mem.h"	 /*  Memory Manager Functions  */
+#include "random.h"	 /*  Randomize Library Function Prototypes  */
+#include "kr_mac.h"	 /*  Kernel Macros   */
+#include "krart_df.h"    /*  Macros and Definitions for ART */
+#include "kr_art1.h"
+#include "kr_art2.h"
+#include "kr_amap.h"
+#include "kr_art.h"      /*  Function Prototypes of ART kernel functions */
+#include "kr_td.h"       /*  Function Prototypes of Time Delay functions */
+#include "cc_glob.h"
+#include "cc_mac.h"
+#include "dlvq_learn.h"
+#include "update_f.ph"
+#include "kr_JordElm.h"
+#include "func_mac.h" 
+#include "kr_newpattern.h"
+
+/*#################################################
+
+GROUP: Update Functions
+
+#################################################*/
+
+/*****************************************************************************
+  FUNCTION : UPDATE_syncPropagate
+
+  PURPOSE  : synchronous propagation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 01.12.93
+******************************************************************************/
+krui_err  UPDATE_syncPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr;
+
+
+    /*    update unit activations first  */
+    FOR_ALL_UNITS( unit_ptr )
+	if ( !IS_INPUT_UNIT( unit_ptr) && UNIT_IN_USE( unit_ptr ))
+	    /*  unit isn't an input unit and is in use and enabled  */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+    /*    update unit outputs */
+    FOR_ALL_UNITS( unit_ptr )
+	if UNIT_IN_USE( unit_ptr )
+	    /*  unit is in use and enabled  */
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		/*  identity output function: don't call the output function  */
+		unit_ptr->Out.output = unit_ptr->act;
+	    else
+		/* no identity output function: calculate unit's output also  */
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_serialPropagate
+
+  PURPOSE  :  serial propagation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 01.12.93
+******************************************************************************/
+krui_err  UPDATE_serialPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr;
+
+
+    /*    update unit activations and outputs */
+    FOR_ALL_UNITS( unit_ptr )
+	if UNIT_IN_USE( unit_ptr ){
+	    /*  unit is in use and enabled  */
+	    if (!IS_INPUT_UNIT( unit_ptr ))
+		/*  this isn't a input unit: calculate the activation of 
+		    the unit by calling the activation function   */
+		unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		/*  identity output function: don't call the output function */
+		unit_ptr->Out.output = unit_ptr->act;
+	    else
+		/*  no identity output function: calculate unit's output also */
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_randomOrderPropagate
+
+  PURPOSE  : random order propagation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_randomOrderPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr, *u_array;
+    register int   no_of_units;
+    int   n;
+
+
+    u_array = unit_array;
+    no_of_units = NoOfUnits;
+
+    for (n = 0; n < no_of_units; n++){
+	/*	  choose unit  */
+	unit_ptr = u_array + (1 + lrand48() % no_of_units);
+
+	if (!IS_INPUT_UNIT( unit_ptr ))
+	    /*  this isn't a input unit: calculate the activation of the unit by
+		calling the activation function */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_randomPermutPropagate
+
+  PURPOSE  : random permutation propagation
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_randomPermutPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit	 *unit_ptr;
+    register TopoPtrArray  topo_ptr;
+    int  ret_code;
+
+
+    if (NetModified || (TopoSortID != PERMUTATION)){
+	/*  networt was modified or permutation array isn't initialized  */
+	ret_code = kr_makeUnitPermutation();
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+    }
+
+    topo_ptr = topo_ptr_array;
+
+    /*  propagate net  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	if (!IS_INPUT_UNIT( unit_ptr ))
+	    /*  this isn't a input unit: calculate the activation of the unit
+		by calling the activation function */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_topologicalPropagate
+
+  PURPOSE  : Propagate Units in topological order
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_topologicalPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit  *unit_ptr;
+    register TopoPtrArray  topo_ptr;
+    int  ret_code;
+
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_FF)){
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGICAL_FF );
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+
+    topo_ptr = topo_ptr_array + 1;
+
+    /*  propagate input units only  */
+    while ((unit_ptr = *topo_ptr++) != NULL){
+	/*  input units, don't call the activation function  */
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /*  propagate hidden units only  */
+    while ((unit_ptr = *topo_ptr++) != NULL){
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /*  propagate output units only  */
+    while ((unit_ptr = *topo_ptr++) != NULL){
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: don't call the output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_KohonenPropagate
+
+  PURPOSE  : Propagate Units in topological order for Kohonen networks
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_KohonenPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit  *unit_ptr;
+    register TopoPtrArray  topo_ptr;
+    int  ret_code;
+
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code == KRERR_NO_OUTPUT_UNITS) ret_code = KRERR_NO_ERROR;
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+
+    topo_ptr = topo_ptr_array + 1;
+
+    /*  propagate input units only  */
+    while ((unit_ptr = *topo_ptr++) != NULL){
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+    /*  propagate hidden units only  */
+    while ((unit_ptr = *topo_ptr++) != NULL){
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : normalize_inputvector
+
+  PURPOSE  : normalize input vector for Counterpropagation Update Function
+  RETURNS  :  
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+static void normalize_inputvector(float sum)
+{
+    register struct Unit *unit_ptr;
+    register float amount;
+
+
+    amount = 1.0 / sqrt( sum );
+
+    FOR_ALL_UNITS( unit_ptr )
+	if (IS_INPUT_UNIT( unit_ptr ) && UNIT_IN_USE( unit_ptr ))
+	    /* this is a input unit */
+	    unit_ptr->Out.output = unit_ptr->Out.output * amount;
+}  
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_CPNPropagate
+
+  PURPOSE  : Counterpropagation Update Function
+  RETURNS  :  
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_CPNPropagate(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr, *winner_ptr;
+    register struct Site   *site_ptr;
+    register struct Link   *link_ptr;
+    register TopoPtrArray  topo_ptr;
+
+    float maximum, unit_ptr_net, sum; 
+    int  ret_code;
+
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/*  networt was modified or topologic array isn't initialized  */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if (ret_code != KRERR_NO_ERROR)
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    topo_ptr = topo_ptr_array;
+    sum = 0.0;
+
+    /*  propagagate all input units  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/*  this is an input unit     */
+	unit_ptr->Out.output = unit_ptr->act;
+	sum += unit_ptr->Out.output * unit_ptr->Out.output;
+    }
+  
+    if (sum != 0.0)
+	/* normalize the inputvector */
+	normalize_inputvector( sum );
+
+
+    /* propagate Kohonen Layer */
+
+    /* calculate the activation and the output values 
+       of the hidden units (Kohonen Layer) */
+
+    winner_ptr = NULL;
+    maximum = -1.0e30;		/* contains the maximum of the activations */
+
+    /*  propagagate all hidden units  */
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	/* this is a hidden unit */
+	unit_ptr_net = 0.0;
+
+	if (unit_ptr->flags & UFLAG_SITES){
+	    /* the unit has sites */
+	    FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	}else{			/* the unit has direct links */
+	    FOR_ALL_LINKS( unit_ptr, link_ptr )
+		unit_ptr_net += (link_ptr->weight * link_ptr->to->Out.output);
+	}
+
+	if (maximum < unit_ptr_net){ /*  determine winner unit  */
+	    winner_ptr = unit_ptr;
+	    maximum = unit_ptr_net;
+	}
+
+	/* reset output and activation of hidden units  */
+	unit_ptr->Out.output = unit_ptr->act = (FlintType) 0;
+    }
+
+    /* the competitive winner is chosen */
+    winner_ptr->Out.output = winner_ptr->act = (FlintType) 1;
+
+
+    /* propagate the Grossberg Layer */
+
+    /*  propagagate all output units  */
+    while ((unit_ptr = *++topo_ptr) != NULL){ /* this is a output unit */
+	/* the activation function is the identity function ( weighted sum) */
+	unit_ptr->Out.output = unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+    }
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_TimeDelayPropagate
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_TimeDelayPropagate(float parameterArray[], int NoOfParams )
+{
+    register struct Unit    *unit_ptr;
+    register TopoPtrArray   topo_ptr;
+    int                     ret_code;
+
+    /* initialization if necessary */
+    if (NetModified || (TopoSortID != TOPOLOGIC_LOGICAL)){
+
+	/*  Net has been modified or topologic array isn't initialized */
+	/*  check the topology of the network  */
+	/* first: save the logical layer numbers, restore them after check */
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> Aux.int_no = unit_ptr -> lln;
+	ret_code = kr_topoCheck();
+	FOR_ALL_UNITS(unit_ptr)
+	    unit_ptr -> lln = unit_ptr -> Aux.int_no;
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );	/*  an error has occured  */
+	if (ret_code < 2)  
+	    return( KRERR_NET_DEPTH ); /*  the network has less then 2 layers  */
+
+	/*  count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+	ret_code = kr_topoSort( TOPOLOGIC_LOGICAL );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+
+	NetModified = FALSE;
+    }
+
+    topo_ptr = topo_ptr_array;
+    unit_ptr = *++topo_ptr;
+
+    /*  propagate input units only  */
+    while (unit_ptr != (struct Unit *) NULL){
+	/* input units doesn't have inputs, so don't call the 
+	   activation function */
+
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    /*  identity output function: there is no need to call the 
+		output function  */
+	    unit_ptr->Out.output = unit_ptr->act;
+	else
+	    /*  no identity output function: calculate unit's output also  */
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	unit_ptr = *++topo_ptr;
+    }
+
+    /* use the propagation function of the learning function for the update */
+    /* This way, the necessary time delay code is present only once */
+    /* Use the special pattern_no -1, to prevent loading of a pattern */
+    propagateTDNetForward(-1,-1);
+
+    return (KRERR_NO_ERROR);  
+
+} /* UPDATE_TimeDelayPropagate */
+
+
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ART1_syncPropagate
+
+  PURPOSE  : ART 1 update function which does exactly the same as the normal
+             synchronous propagate function except that additionally the winner
+	     of the ART 1 recognition layer is calculated.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ART1_syncPropagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+
+    int          i;
+    struct Unit  *winner_ptr; /* recognition unit which is the winner of w.t.a*/
+    struct Unit  *unit_ptr;
+    TopoPtrArray topo_layer[6];	/* topo_layer[0] : *first input unit
+				   topo_layer[1] : *first comp. unit
+				   topo_layer[2] : *first rec.  unit
+				   topo_layer[3] : *first delay unit
+				   topo_layer[4] : *first local reset unit
+				   topo_layer[5] : *first special unit
+				   (classified_unit)*/
+    TopoPtrArray topo_ptr;
+    static float rho;
+    bool         inp_pat_changed   = FALSE;
+    bool         rho_has_changed   = FALSE;
+
+
+    /* Check vigilance parameter */
+
+    if (NoOfParams < 1) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } /*if*/
+
+    /* Check if rho has changed from last to actual call of this update function
+       If rho has changed, then put new activation value into unit rho */
+    if (rho != parameterArray[0]) {
+	rho_has_changed = TRUE;
+    }
+
+    rho = parameterArray[0];
+
+    if ((rho < 0.0) || (rho > 1.0)) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+
+    /* Check if network has been modified or learning function has just
+       been changed */
+
+    if (NetModified || (TopoSortID != ART1_TOPO_TYPE)) {
+	(void) kr_topoSort (ART1_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} /*if*/
+
+	NetModified = FALSE;
+    }
+
+
+    /* get pointers to resep. first elements of each layer in topo_ptr_array */
+
+    topo_ptr = topo_ptr_array+1;
+
+    for(i=0; i<=5; i++){
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+
+    }
+
+
+    /* Check if input pattern changed since last call to this function */
+    if (krart_inp_pat_changed(topo_layer[0])) {
+	inp_pat_changed = TRUE;
+	krart_save_inp_pat(topo_layer[0]);
+    }
+
+
+    /* Push activation of input units to their output value.
+       This is important for the first cycle. */
+
+    topo_ptr = topo_layer[0];
+    for (unit_ptr = *topo_ptr; *topo_ptr != NULL; unit_ptr = *topo_ptr++) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->Out.output = unit_ptr->act;
+	} else {
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}
+
+    } 
+
+    /* if rho had changed from last to this call of this update function then
+       reinitialize the values of the i_act field of the unit structure and
+       reset the activations of all non input units */
+    if (rho_has_changed || inp_pat_changed) {
+	ret_code = kra1_init_i_act (rho);
+	if (ret_code != KRERR_NO_ERROR) 
+	    return (ret_code);
+
+	ret_code = krart_reset_activations ();
+	if (ret_code != KRERR_NO_ERROR) 
+	    return (ret_code);
+    }
+
+    /* 1 propagation step (all units push their information onto
+       their output and calculate their new activation.*/
+
+    krart_prop_synch ();
+
+    /* look for the recognition unit with the highest activation
+       returns a NULL pointer if all recognition units have
+       activation 0.0 */
+    winner_ptr = krart_get_winner (topo_layer[2],1.0);
+
+    return (ret_code);
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ART1_Propagate
+
+  PURPOSE  : ART1 Update function for updating until a stable state is reached,
+             e.g. either the 'classified' unit is on or the 'not classifiable' 
+	     unit is.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ART1_Propagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+    int          i;
+    struct Unit  *winner_ptr;	/* recogn. unit which is the winner of w.t.a */
+    TopoPtrArray topo_layer[6];	/* topo_layer[0] : *first input unit
+				   topo_layer[1] : *first comp. unit
+				   topo_layer[2] : *first rec.  unit
+				   topo_layer[3] : *first delay unit
+				   topo_layer[4] : *first local reset unit
+				   topo_layer[5] : *first special unit
+				   (classified_unit) */
+    TopoPtrArray  topo_ptr;
+    float         rho;
+
+
+    /* Check vigilance parameter */
+
+    if (NoOfParams < 1) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+    rho = parameterArray[0];
+
+    if ((rho < 0.0) || (rho > 1.0)) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+
+    /* Check if network has been modified or learning function has just
+       been changed  */
+
+    if (NetModified || (TopoSortID != ART1_TOPO_TYPE)) {
+	(void) kr_topoSort (ART1_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} 
+
+	NetModified = FALSE;
+    }
+
+    ret_code = kra1_init_i_act (rho);
+
+    if (ret_code != KRERR_NO_ERROR) {
+	return (ret_code);
+    }
+
+    /* get pointers to resp. first elements of each layer in topo_ptr_array */
+
+    topo_ptr = topo_ptr_array+1;
+
+    for (i=0; i<=5; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+    } 
+
+    /* initialize activations of non input units */
+
+    ret_code = krart_reset_activations ();
+    if (ret_code != KRERR_NO_ERROR) 
+	return (ret_code);
+
+    do {
+	/* 1 propagation step (all units push their information onto
+	   their output and calculate their new activation */
+
+	krart_prop_synch ();
+
+	/* look for the recognition unit with the highest activation
+	   returns a NULL pointer if all recognition units have
+	   activation 0.0 */
+	winner_ptr = krart_get_winner (topo_layer[2],1.0);
+
+    } while (!(ART1_CLASSIFIED) && !(ART1_NOT_CLASSIFIABLE));
+
+    return (ret_code);
+
+}
+
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ART2_syncPropagate
+
+  PURPOSE  : ART 2 update function which does exactly the same as the normal
+             synchronous propagate function except that additionally the winner
+	     of the ART 1 recognition layer is calculated.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ART2_syncPropagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+    int          i;
+    struct Unit  *winner_ptr; /* recogn. unit which is the winner of w.t.a */
+    struct Unit  *unit_ptr;
+    TopoPtrArray topo_layer[12]; /* topo_layer[0] : *first input unit
+                                    topo_layer[1] : *first w unit
+				    topo_layer[2] : *first x unit
+				    topo_layer[3] : *first u unit
+				    topo_layer[4] : *first v unit
+				    topo_layer[5] : *first p unit
+				    topo_layer[6] : *first q unit
+				    topo_layer[7] : *first r unit
+				    topo_layer[8] : *first rec.  unit
+				    topo_layer[9] : *first local reset unit */
+    TopoPtrArray topo_ptr;
+    static float rho, param_a, param_b, param_c, param_d, theta;
+    bool         inp_pat_changed   = FALSE;
+    bool         rho_has_changed   = FALSE;
+    bool         a_has_changed     = FALSE;
+    bool         b_has_changed     = FALSE;
+    bool         c_has_changed     = FALSE;
+    bool         theta_has_changed = FALSE;
+
+
+
+
+    /* Check vigilance parameter */
+
+    if (NoOfParams < 5) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+
+    /* Check if input pattern had changed from last step to this one */
+
+
+    /* Check if one of the parameters has changed from last to actual
+       call of this update function.
+       If so, then put new activation value into unit rho or change
+       the weights of the relevant links. */
+    if (rho != parameterArray[0]) 
+	rho_has_changed = TRUE;
+
+    if (param_a != parameterArray[1]) 
+	a_has_changed = TRUE;
+
+    if (param_b != parameterArray[2]) 
+	b_has_changed = TRUE;
+
+    if (param_c != parameterArray[3]) 
+	c_has_changed = TRUE;
+
+    if (theta != parameterArray[4]) 
+	theta_has_changed = TRUE;
+
+    rho     = parameterArray[0];
+    param_a = parameterArray[1];
+    param_b = parameterArray[2];
+    param_c = parameterArray[3];
+    theta   = parameterArray[4];
+
+
+    /* Check if network has been modified */
+
+    if (NetModified || (TopoSortID != ART2_TOPO_TYPE)) {
+	(void) kr_topoSort (ART2_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} 
+	NetModified = FALSE;
+    } 
+
+    /* get pointers to resp. first elements of each layer in topo_ptr_array */
+
+    topo_ptr = topo_ptr_array+1;
+
+    for (i=0; i<=9; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+    } 
+
+    /* Check if input pattern changed since last call to this function */
+    if (krart_inp_pat_changed(topo_layer[0])) {
+	inp_pat_changed = TRUE;
+	krart_save_inp_pat(topo_layer[0]);
+    } 
+
+
+    /* Read out value of parameter d from bias field of any unit. The
+       value has been written into the bias field by the init-function */
+    param_d = (*(topo_ptr_array+1))->bias;
+
+
+    /* Check values of the parameters */
+
+    if ((rho < 0.0) || (rho > 1.0) || (param_a <= 0.0) || (param_b <= 0.0) ||
+	((param_c*param_d)/(1-param_d) > 1.0) ||(theta < 0.0) || (theta > 1.0)){
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+
+    /* if one of the parameters had changed from last to this call
+       of this update function then reinitialize the values of the i_act 
+       field of the unit structure, set the weights of the relevant links and
+       reset the activations of all non input units */
+    if (rho_has_changed || a_has_changed || b_has_changed ||
+	c_has_changed || theta_has_changed || inp_pat_changed){
+
+	ret_code = kra2_set_params (rho,param_a,param_b,param_c,param_d,theta);
+
+	if (ret_code != KRERR_NO_ERROR) 
+	    return (ret_code);
+
+	ret_code = kra2_init_propagate();
+
+	if (ret_code != KRERR_NO_ERROR) 
+	    return (ret_code);
+
+	kra2_init_pattern();
+    }
+
+
+    /* Push activation of input units to their output value.
+       This is important for the first cycle. */
+
+    topo_ptr = topo_layer[ART2_INP_LAY-1];
+    unit_ptr = *topo_ptr;
+    while (unit_ptr != NULL) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->Out.output = unit_ptr->act;
+	} else {
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}
+	topo_ptr++;
+	unit_ptr = *topo_ptr;
+    }
+
+    /* compute vector norms */
+    kra2_compute_norms();
+
+    /* save old activation values of f1-units */
+    kra2_save_for_stability_check ();
+
+    /* Propagate */
+    krart_prop_synch ();
+
+    /* Get winner */
+    winner_ptr = krart_get_winner (topo_layer[ART2_REC_LAY-1], param_d);
+
+    /* Check F1 stability */
+    kra2_check_f1_stability ();
+
+    /* Check reset */
+    kra2_checkReset ();
+
+    return (ret_code);
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ART2_Propagate 
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ART2_Propagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+    int          i;
+    struct Unit  *winner_ptr; /* recogn. unit which is the winner of w.t.a */
+    TopoPtrArray topo_layer[12]; /* topo_layer[0] : *first input unit
+                                          topo_layer[1] : *first w unit
+                                          topo_layer[2] : *first x unit
+                                          topo_layer[3] : *first u unit
+                                          topo_layer[4] : *first v unit
+                                          topo_layer[5] : *first p unit
+                                          topo_layer[6] : *first q unit
+                                          topo_layer[7] : *first r unit
+                                          topo_layer[8] : *first rec. unit
+                                          topo_layer[10] : *first local reset
+					                   unit */
+    TopoPtrArray topo_ptr;
+    FlintType    rho, param_a, param_b, param_c, param_d, theta;
+
+
+    /* Check number of incoming parameters */
+
+    if (NoOfParams < 5) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+    rho     = parameterArray[0];
+    param_a = parameterArray[1];
+    param_b = parameterArray[2];
+    param_c = parameterArray[3];
+    theta   = parameterArray[4];
+
+
+
+    /* Check if network has been modified or learning function has just
+       been changed */
+
+    if (NetModified || (TopoSortID != ART2_TOPO_TYPE)) {
+	(void) kr_topoSort (ART2_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} 
+
+	NetModified = FALSE;
+    } 
+
+
+    /* Read out value of parameter d from bias field of any unit. The
+       value has been written into the bias field by the init-function */
+    param_d = (*(topo_ptr_array+1))->bias;
+
+
+    /* Check values of the parameters */
+
+    if ((rho < 0.0) || (rho > 1.0) ||(param_a <= 0.0) || (param_b <= 0.0) ||
+	((param_c*param_d)/(1-param_d)>1.0) || (theta<0.0) || (theta>1.0)){
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+    ret_code = kra2_set_params (rho, param_a, param_b, param_c, param_d, theta);
+
+    if (ret_code != KRERR_NO_ERROR) 
+	return (ret_code);
+
+    ret_code = kra2_init_propagate ();
+
+    if (ret_code != KRERR_NO_ERROR) 
+	return (ret_code);
+
+    /* get pointers to resp. first elements of each layer in topo_ptr_array */
+    topo_ptr = topo_ptr_array+1;
+
+    for (i=0; i<=9; i++){
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+    }
+
+
+    /* initialize the unit activations of the whole net */
+    ret_code = krart_reset_activations();
+    if (ret_code != KRERR_NO_ERROR)
+	return (ret_code);
+
+    /* initialize of ART2 Simulator for new pattern */
+    kra2_init_pattern ();
+
+
+    /* repeat synchronous propagation and look for winner until pattern is
+       classified or network tells us, that pattern is not classifiable */
+    do {
+	/* compute vector norms */
+	kra2_compute_norms();
+
+	/* save old activation values of f1-units */
+	kra2_save_for_stability_check ();
+
+	/* 1 propagation step (all units push their information onto
+	   their output and calculate their new activation.  */
+	krart_prop_synch ();
+
+	/* look for the recognition unit with the highest activation returns
+	   a NULL pointer if all recognition units have activation 0.0 */
+	winner_ptr = krart_get_winner (topo_layer[ART2_REC_LAY-1], param_d);
+
+	/* Check if F1-Layer is stable */
+	kra2_check_f1_stability();
+
+	/* Check Reset */
+	kra2_checkReset ();
+
+    } while (!(ART2_CLASSIFIED) && !(ART2_NOT_CLASSIFIABLE));
+
+    return (ret_code);
+}
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ARTMAP_syncPropagate
+
+  PURPOSE  : ARTMAP update function which does exactly the same as the normal
+             synchronous propagate function except that additionally the winner
+	     of the ARTMAP recognition layer is calculated.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ARTMAP_syncPropagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+    int          i;
+    struct Unit  *winner_ptr_a;	/* the winner of wta of ARTa */
+    struct Unit  *winner_ptr_b;	/* the winner of w.t.a of ARTb */
+    struct Unit  *unit_ptr;
+    TopoPtrArray topo_layer[14]; /* topo_layer[0] : *first input unit ARTa
+                                    topo_layer[1] : *first comp. unit ARTa
+				    topo_layer[2] : *first rec.  unit ARTa
+				    topo_layer[3] : *first delay unit ARTa
+				    topo_layer[4] : *first local reset unit ARTa
+				    topo_layer[5] : *first special unit ARTa
+				    (classified_unit)
+				    topo_layer[6] : *first input unit ARTb
+				    topo_layer[7] : *first comp. unit ARTb
+				    topo_layer[8] : *first rec.  unit ARTb
+				    topo_layer[9] : *first delay unit ARTb
+				    topo_layer[10]: *first local reset unit ARTb
+				    topo_layer[11]: *first special unit ARTb
+				    (classified_unit)
+                                    topo_layer[12]: *first map unit
+				    topo_layer[13]: *first special map unit */
+    TopoPtrArray topo_ptr;
+    static float rho_a = -1.0;
+    static float rho_b = -1.0;
+    static float rho   = -1.0;
+    bool         inp_pat_changed   = FALSE;
+    bool         rho_has_changed   = FALSE;
+
+
+    /* Check vigilance parameter */
+    if (NoOfParams < 3) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+    /* Check if rho has changed from last to actual call of this update function
+       If rho has changed, then put new activation value into unit rho */
+    if ((rho_a != parameterArray[0]) || (rho_b != parameterArray[1]) ||
+	(rho   != parameterArray[2]))
+	rho_has_changed = TRUE;
+
+    rho_a = parameterArray[0];
+    rho_b = parameterArray[1];
+    rho   = parameterArray[2];
+
+
+    if((rho_a<0.0) || (rho_a>1.0) || (rho_b<0.0) || (rho_b>1.0) ||
+       (rho<0.0) || (rho>1.0)){
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    }
+
+
+    /* Check if network has been modified or learn func has just been changed */
+
+    if (NetModified || (TopoSortID != ARTMAP_TOPO_TYPE)) {
+	(void) kr_topoSort (ARTMAP_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} 
+
+	NetModified = FALSE;
+    }
+
+
+    /* get pointers to resp. first elements of each layer in topo_ptr_array */
+    topo_ptr = topo_ptr_array+1;
+
+    for (i=0; i<=13; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+    }
+
+
+    /* Check if input pattern changed since last call to this function */
+    if (krart_inp_pat_changed(topo_layer[0]) ||
+	krart_inp_pat_changed(topo_layer[6])){
+	inp_pat_changed = TRUE;
+	krart_save_inp_pat(topo_layer[0]);
+	krart_save_inp_pat(topo_layer[6]);
+    } 
+
+
+    /* Push activation of input units to their output value.
+       This is important for the first cycle. */
+
+    /* inpa - units */
+    topo_ptr = topo_layer[0];
+    for (unit_ptr = *topo_ptr; *topo_ptr != NULL; unit_ptr = *++topo_ptr) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->Out.output = unit_ptr->act;
+	} else {
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	} 
+    } 
+
+    topo_ptr = topo_layer[6];
+    for (unit_ptr = *topo_ptr; *topo_ptr != NULL; unit_ptr = *++topo_ptr) {
+	if (unit_ptr->out_func == OUT_IDENTITY) {
+	    unit_ptr->Out.output = unit_ptr->act;
+	} else {
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	}
+    }
+
+    /* if rho or input pattern had changed from last to this call of this
+       update function then reinitialize the values of the i_act field of the 
+       unit structure and reset the activations of all non input units */
+    if (rho_has_changed || inp_pat_changed) {
+
+	ret_code = kram_init_i_act (rho_a, rho_b, rho);
+	if (ret_code != KRERR_NO_ERROR)
+	    return (ret_code);
+
+	ret_code = krart_reset_activations ();
+	if (ret_code != KRERR_NO_ERROR) 
+	    return (ret_code);
+    } 
+
+    /* 1 propagation step (all units push their information onto
+       their output and calculate their new activation. */
+
+    krart_prop_synch ();
+
+    /* look for the recognition unit with the highest activation returns a 
+       NULL pointer if all recognition units have activation 0.0 */
+    winner_ptr_a = krart_get_winner (topo_layer[2],1.0);
+    winner_ptr_b = krart_get_winner (topo_layer[8],1.0);
+
+    return (ret_code);
+
+}
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_ARTMAP_Propagate
+
+  PURPOSE  : ARTMAP Update function for updating until a stable state is 
+             reached, e.g. either the 'classified' unit is on or the 'not 
+	     classifiable' unit is.
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_ARTMAP_Propagate(float *parameterArray, int NoOfParams)
+{
+    krui_err     ret_code      = KRERR_NO_ERROR;
+    int          i;
+    struct Unit  *winner_ptr_a;	/* the winner of w.t.a of ARTa */
+    struct Unit  *winner_ptr_b;	/* the winner of w.t.a of ARTb */
+    TopoPtrArray topo_layer[14]; /* topo_layer[0] : *first input unit ARTa
+                                    topo_layer[1] : *first comp. unit ARTa
+				    topo_layer[2] : *first rec.  unit ARTa
+				    topo_layer[3] : *first delay unit ARTa
+				    topo_layer[4] : *first local reset unit ARTa
+				    topo_layer[5] : *first special unit ARTa
+				    (classified_unit)
+                                    topo_layer[6] : *first input unit ARTb
+				    topo_layer[7] : *first comp. unit ARTb
+				    topo_layer[8] : *first rec.  unit ARTb
+				    topo_layer[9] : *first delay unit ARTb
+				    topo_layer[10]: *first local reset unit ARTb
+				    topo_layer[11]: *first special unit ARTb
+				    (classified_unit)
+                                    topo_layer[12]: *first map unit
+				    topo_layer[13]: *first special map unit */
+    TopoPtrArray topo_ptr;
+    float        rho_a;
+    float        rho_b;
+    float        rho;
+
+
+    /* Check vigilance parameters */
+
+    if (NoOfParams < 3) {
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+    rho_a = parameterArray[0];
+    rho_b = parameterArray[1];
+    rho   = parameterArray[2];
+
+    if ((rho_a < 0.0) || (rho_a > 1.0) || (rho_b < 0.0) ||
+	(rho_b > 1.0) || (rho   < 0.0) || (rho   > 1.0)){
+	ret_code = KRERR_PARAMETERS;
+	return (ret_code);
+    } 
+
+
+    /* Check if network has been modified or learn func has just been changed */
+    if (NetModified || (TopoSortID != ARTMAP_TOPO_TYPE)) {
+	(void) kr_topoSort (ARTMAP_TOPO_TYPE);
+	ret_code = KernelErrorCode;
+	if (ret_code != KRERR_NO_ERROR) {
+	    NetModified = TRUE;
+	    return (ret_code);
+	} 
+
+	NetModified = FALSE;
+    }
+
+
+    ret_code = kram_init_i_act (rho_a, rho_b, rho);
+
+    if (ret_code != KRERR_NO_ERROR) 
+	return (ret_code);
+
+    /* get pointers to resp. first elements of each layer in topo_ptr_array */
+    topo_ptr = topo_ptr_array+1;
+
+    for (i=0; i<=13; i++) {
+	topo_layer[i] = topo_ptr;
+	do {
+	} while (*topo_ptr++ != NULL);
+    } 
+
+    /* initialize activations of non input units */
+    ret_code = krart_reset_activations ();
+    if (ret_code != KRERR_NO_ERROR) 
+	return (ret_code);
+
+    do {
+	/* 1 propagation step (all units push their information onto
+	   their output and calculate their new activation. */
+	krart_prop_synch ();
+
+	/* look for the recognition unit with the highest activation
+	   returns a NULL pointer if all recognition units have
+	   activation 0.0 */
+	winner_ptr_a = krart_get_winner (topo_layer[2],1.0);
+	winner_ptr_b = krart_get_winner (topo_layer[8],1.0);
+
+    } while (!(ARTMAP_CLASSIFIED) && !(ARTMAP_NOT_CLASSIFIABLE));
+
+    return (ret_code);
+
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_CC_Propagate
+
+  PURPOSE  : Propagates a pattern through the net after pressing the test 
+             button.
+  NOTES    :
+
+  UPDATE   : 5.2.93
+******************************************************************************/
+krui_err UPDATE_CC_Propagate(float parameterArray[],  int NoOfParams)
+{
+    register struct Unit  *inputUnitPtr,*outputUnitPtr,*hiddenUnitPtr,*unitPtr;
+    register int dummy,o;
+  
+    if(NetModified || LearnFuncHasChanged) {
+    
+	NoOfInputUnits = NoOfHiddenUnits = NoOfOutputUnits = 0;
+	FOR_ALL_UNITS(unitPtr) {
+	    if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfInputUnits++;
+	    }
+	    if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfHiddenUnits++;
+	    }
+	    if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfOutputUnits++;
+	    }
+	}
+	KernelErrorCode = cc_deleteAllSpecialUnits();
+	ERROR_CHECK; 
+
+	KernelErrorCode = kr_topoSort(TOPOLOGICAL_CC);
+	ERROR_CHECK; 
+
+	KernelErrorCode = cc_setPointers();
+	ERROR_CHECK;
+
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }
+
+    FOR_ALL_INPUT_UNITS(inputUnitPtr,dummy){
+	if(inputUnitPtr->out_func == OUT_IDENTITY) {
+	    inputUnitPtr->Out.output = inputUnitPtr->act;
+	}else{
+	    inputUnitPtr->Out.output = 
+		(*inputUnitPtr->out_func) (inputUnitPtr->act);
+	}
+    }
+
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,dummy) {
+	hiddenUnitPtr->act = (*hiddenUnitPtr->act_func) (hiddenUnitPtr);
+	if(hiddenUnitPtr->out_func == OUT_IDENTITY) {
+	    hiddenUnitPtr->Out.output = hiddenUnitPtr->act;
+	}else{
+	    hiddenUnitPtr->Out.output = 
+		(*hiddenUnitPtr->out_func) (hiddenUnitPtr->act);
+	}
+    }
+    
+    FOR_ALL_OUTPUT_UNITS(outputUnitPtr,o) {
+	outputUnitPtr->act = (*outputUnitPtr->act_func) (outputUnitPtr);
+	if(outputUnitPtr->out_func == OUT_IDENTITY) {
+	    outputUnitPtr->Out.output = outputUnitPtr->act;
+	}else{
+	    outputUnitPtr->Out.output = 
+		(*outputUnitPtr->out_func) (outputUnitPtr->act);
+	}
+    }
+    return(KRERR_NO_ERROR);
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_DLVQ_Propagate
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err UPDATE_DLVQ_Propagate(float parameterArray[], int NoOfParams)
+{
+    struct Unit *inputUnitPtr,*hiddenUnitPtr,*maxActivatedUnitPtr=NULL;
+    double maxAct,act;
+    int i,h,startPattern,endPattern,d1,d2,d3,generatedNewUnit,noOfLinks;
+
+    if(newPatternsLoaded){
+	newPatternsLoaded = 0;
+	startPattern = 0;
+/*	endPattern = krui_getNoOfPatterns()-1;*/
+	endPattern = kr_TotalNoOfSubPatPairs()-1;
+	KernelErrorCode = getNoOfClasses(startPattern,endPattern);
+	ERROR_CHECK;
+
+	normPatterns(startPattern,endPattern);
+	allocInitialUnitArray();
+	initInitialUnitArray(startPattern,endPattern);
+    }
+
+    if(NetModified || LearnFuncHasChanged) {
+	NoOfInputUnits = NoOfHiddenUnits = NoOfOutputUnits = 0;
+	FOR_ALL_UNITS(unitPtr) {
+	    if(IS_INPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfInputUnits++;
+	    }
+	    if(IS_HIDDEN_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfHiddenUnits++;
+	    }
+	    if(IS_OUTPUT_UNIT(unitPtr) && UNIT_IN_USE(unitPtr)) {
+		NoOfOutputUnits++;
+	    }
+	}
+	if(NoOfOutputUnits != 1){
+	    return(DLVQ_ERROR3); /* Wrong no. of output units */
+	}
+	allocArrays();
+	KernelErrorCode = kr_topoSort(TOPOLOGICAL_FF);
+	ERROR_CHECK;    
+
+	KernelErrorCode = dlvq_setPointers();
+	ERROR_CHECK; 
+
+	krui_getNetInfo(&d1,&noOfLinks,&d2,&d3);
+	if(noOfLinks != NoOfInputUnits * NoOfHiddenUnits + NoOfHiddenUnits) {
+	    return(DLVQ_ERROR4); /* wrong topology */
+	}
+
+	generateMissingClassHiddenUnits(&generatedNewUnit);
+	if(generatedNewUnit) {
+	    return(DLVQ_ERROR5); /* There is not a class for every unit */
+	}
+	NetModified = FALSE;
+	LearnFuncHasChanged = FALSE;
+    }
+
+    FOR_ALL_INPUT_UNITS(inputUnitPtr,i){
+	inputUnitPtr->Out.output = inputUnitPtr->act;
+    }
+  
+    maxAct = -1.0;
+ 
+    FOR_ALL_HIDDEN_UNITS(hiddenUnitPtr,h) {
+	hiddenUnitPtr->Out.output = hiddenUnitPtr->act = act = 0.0;
+	FOR_ALL_LINKS(hiddenUnitPtr,linkPtr) {
+	    act += linkPtr->weight * linkPtr->to->Out.output;
+	}
+	if(maxAct < act){
+	    maxAct = act;
+	    maxActivatedUnitPtr = hiddenUnitPtr;
+	}
+    }
+
+    maxActivatedUnitPtr->Out.output = maxActivatedUnitPtr->act = 1.0;
+    (*FirstOutputUnitPtr)->Out.output = 
+	(*FirstOutputUnitPtr)->act = maxActivatedUnitPtr->bias;
+    return(KRERR_NO_ERROR);
+} 
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_BPTT
+
+  PURPOSE  : Backpropagation through time synchronous order using activity 
+             buffer for each unit.
+  RETURNS  : 
+  NOTES    : The "TEST" button in the remote panel first increases the pattern 
+             number, copies the input pattern to the input units and, 
+	     depending on the setting of the "SHOW" button,
+	        - does not copy the output pattern with setting "none"
+		- copies the output pattern to unit_ptr->act with setting 
+		  "activation"
+		- copies the output pattern to unit_ptr->act and 
+		  unit_ptr->Out.output with setting "output"
+	     An all-zero-input pattern for reset is only effective using 
+	     "TEST" if the current pattern is the pattern immediatly before 
+	     the reset pattern.
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_BPTT(float *parameterArray, int NoOfParams)
+{
+    krui_err ret_code;
+    register struct Unit   *unit_ptr;
+    register TopoPtrArray  topo_ptr;
+    register TopoPtrArray  first_hidden_ptr;
+    int all_zero_input=1;	/* flag to reset net-copies */
+    int done_hidden;
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );
+      
+	/* sort units by ''topologic type'',
+	   criterion is visibility (input,hidden,output), not topology */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+      
+	NetModified = FALSE;
+    }
+  
+
+    /* check all zero pattern in input layer => reset net_activities */
+    topo_ptr = topo_ptr_array;
+
+    while ((unit_ptr = *++topo_ptr) != NULL) {
+	unit_ptr->Out.output = unit_ptr->act;
+	if(fabs(unit_ptr->act)>0.0001) all_zero_input = 0; /* no reset-input */
+    }
+    first_hidden_ptr = topo_ptr;
+
+    if (all_zero_input) {	/* clear netact-copies */
+	FOR_ALL_UNITS( unit_ptr ) unit_ptr->i_act = 0.0;
+    }
+
+    /* copy last unit_ptr->i_act to unit_ptr->Out.output */
+    /*  one step back in time, make most recent activity
+	visible in unit_ptr->Out.output for subsequent calls to act_func */
+
+    while ((unit_ptr = *++topo_ptr) != NULL) { /* hidden layer */
+	unit_ptr->Out.output = unit_ptr->i_act; }
+
+    while ((unit_ptr = *++topo_ptr) != NULL) { /* output layer */
+	unit_ptr->Out.output = unit_ptr->i_act; }
+
+    /*  calculate new activities for hidden and output units */
+    /* point to first hidden unit */
+    topo_ptr = first_hidden_ptr;
+    done_hidden=0;
+    while ( ((unit_ptr = *++topo_ptr) != NULL) || (done_hidden==0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	}else{  
+	    /* calc act using i_act copied to Out.output,  SYNCHRONOUS UPDATE:
+	       don't update Out.output while updating units, wait until all 
+	       units are processed  */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+	}
+
+    /*  calculate new Out.output values from act by calling out_func,
+	and save values in i_act (since they may be disturbed by show pattern)*/
+
+    /* point to first hidden unit */
+    topo_ptr = first_hidden_ptr;
+    done_hidden=0;
+    while ( ((unit_ptr = *++topo_ptr) != NULL) || (done_hidden==0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	}else{  
+	    if (unit_ptr->out_func == OUT_IDENTITY) {
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	    }
+	    unit_ptr->i_act = unit_ptr->Out.output;
+	}
+
+    return( KRERR_NO_ERROR );
+} 
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_BAM
+
+  PURPOSE  :
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_BAM(float *parameterArray, int NoOfParams)
+{
+    krui_err ret_code;
+    register struct Unit   *unit_ptr;
+    register TopoPtrArray  topo_ptr;
+    register TopoPtrArray  first_hidden_ptr;
+    int done_hidden;
+    FlintType new_output;
+
+    if (NetModified || (TopoSortID != TOPOLOGIC_TYPE)){
+	/* Net has been modified or topologic array isn't initialized */
+	/* any connected topology allowed */
+	/* count the no. of I/O units and check the patterns  */
+	ret_code = kr_IOCheck();
+	if (ret_code < KRERR_NO_ERROR)  
+	    return( ret_code );
+      
+	/* sort units by ''topologic type'',
+	   criterion is visibility (input,hidden,output), not topology */
+	ret_code = kr_topoSort( TOPOLOGIC_TYPE );
+	if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+	    return( ret_code );
+      
+	NetModified = FALSE;
+    }
+
+    /* Search hidden Units */  
+    topo_ptr = topo_ptr_array;
+    while ((unit_ptr = *++topo_ptr) != NULL) {
+    }
+    first_hidden_ptr = topo_ptr;
+
+    /*  calculate new Out.output values from act by calling out_func */
+    /* point to first hidden unit and remember the old ones*/
+    topo_ptr = first_hidden_ptr;
+    done_hidden=0;
+    while ( ((unit_ptr = *++topo_ptr) != NULL) || (done_hidden==0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	}else{  
+	    unit_ptr->value_a = unit_ptr->Out.output;
+	    if (unit_ptr->out_func == OUT_IDENTITY) {
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+	    }
+	}
+
+
+    /*  calculate new activities for hidden and output units */
+    /* point to first hidden unit */
+    topo_ptr = first_hidden_ptr;
+    done_hidden=0;
+    while ( ((unit_ptr = *++topo_ptr) != NULL) || (done_hidden==0))
+	if (unit_ptr == NULL) {
+	    done_hidden = 1;
+	}else{ 
+	    /* save new value and restore old value from output */
+	    new_output = unit_ptr->Out.output; 
+	    unit_ptr->Out.output = unit_ptr->value_a; 
+
+	    /* calc act */
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+	    /* restore new value */
+	    unit_ptr->Out.output = new_output;
+	}
+
+    return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_JE_Propagate 
+
+  PURPOSE  : update function for JORDAN / ELMAN networks
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_JE_Propagate (float *parameterArray, int NoOfParams)
+{
+    register struct Unit  *unit_ptr ;
+    register TopoPtrArray  topo_ptr, help_ptr ;
+    int      ret_code, i ;
+
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_JE)){  
+	/* network was modified or topologic array isn't initialized */
+
+	ret_code = kr_topoCheckJE () ;
+	if (ret_code != KRERR_NO_ERROR) return (ret_code) ;
+
+	ret_code = kr_topoSort (TOPOLOGICAL_JE) ;
+	if (ret_code != KRERR_NO_ERROR) return (ret_code) ;
+ 
+	NetModified = FALSE ;
+    }
+
+    topo_ptr = topo_ptr_array ;
+
+
+    /*  calculate output of input units */
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act ;
+	else
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+
+    /* propagate hidden and output units */
+
+    for (i = 0 ; i < 2 ; i++){
+	while ((unit_ptr = *++topo_ptr) != NULL){
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		unit_ptr->Out.output = unit_ptr->act ;
+	    else
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+	}
+    }
+
+
+    /* update of context units */
+
+    help_ptr = topo_ptr ;
+
+    while ((unit_ptr = *++help_ptr) != NULL){ 
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act ;
+	else
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+    return (KRERR_NO_ERROR) ;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_JE_Special
+
+  PURPOSE  : update function with dynamic pattern generation for JORDAN / 
+             ELMAN networks
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_JE_Special (float *parameterArray, int NoOfParams)
+{
+    register struct Unit  *unit_ptr  ;
+    register TopoPtrArray  topo_ptr, help_ptr ;
+    int      ret_code, i ;
+
+
+    if (NetModified || (TopoSortID != TOPOLOGICAL_JE)){  
+	/*  network was modified or topologic array isn't initialized */
+
+	ret_code = kr_topoCheckJE () ;
+	if (ret_code != KRERR_NO_ERROR) return (ret_code) ;
+
+	ret_code = kr_topoSort (TOPOLOGICAL_JE) ;
+	if (ret_code != KRERR_NO_ERROR) return (ret_code) ;
+ 
+	NetModified = FALSE ;
+    }
+
+    if (NoOfInputUnits < NoOfOutputUnits) return (-1) ;
+
+
+    /* create new input pattern from the output of input and output units */ 
+
+    help_ptr = topo_ptr_array ;
+    while (*++help_ptr != NULL) ; /* skip input  units */
+    while (*++help_ptr != NULL) ; /* skip hidden units */
+  
+    topo_ptr = topo_ptr_array ;
+
+    for (i = 1 ; i <= NoOfInputUnits ; i++)
+	if (i <= NoOfInputUnits - NoOfOutputUnits)
+	    (*(topo_ptr+i))->act = (*(topo_ptr+i+NoOfOutputUnits))->Out.output;
+	else
+	    (*(topo_ptr+i))->act = (*++help_ptr)->Out.output ;
+
+    topo_ptr = topo_ptr_array ;
+
+
+    /* calculate output of input units */
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act ;
+	else
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+
+    /* propagate hidden and output units  */
+
+    for (i = 0 ; i < 2 ; i++){
+	while ((unit_ptr = *++topo_ptr) != NULL){
+	    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+
+	    if (unit_ptr->out_func == OUT_IDENTITY)
+		unit_ptr->Out.output = unit_ptr->act ;
+	    else
+		unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+	}
+    }
+
+
+    /* synchronous update of context units */
+
+    help_ptr = topo_ptr ;
+
+    while ((unit_ptr = *++help_ptr) != NULL){ 
+	unit_ptr->act = (*unit_ptr->act_func) (unit_ptr) ;
+    }
+
+    while ((unit_ptr = *++topo_ptr) != NULL){
+	if (unit_ptr->out_func == OUT_IDENTITY)
+	    unit_ptr->Out.output = unit_ptr->act ;
+	else
+	    unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act) ;
+    }
+
+    return (KRERR_NO_ERROR) ;
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_syncPropagateHop
+
+  PURPOSE  : synchronous propagation for Hopfield 
+  RETURNS  : 
+  NOTES    :
+
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_syncPropagateHop(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr; 
+
+    /* update unit outputs first, because the patterns set only          */
+    /* the activations of the input units, and they would be overwritten */
+    FOR_ALL_UNITS( unit_ptr ) {
+	if UNIT_IN_USE(unit_ptr) {
+	    if (*unit_ptr->out_func == OUT_IDENTITY) {
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{ /* the default way */
+		unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+	}
+    }
+
+    /* update unit activations second */
+
+    /* first non input, then input units, so function can be used for BAM too */
+    FOR_ALL_UNITS( unit_ptr ){
+	if (UNIT_IN_USE(unit_ptr)&&!IS_INPUT_UNIT(unit_ptr))
+	    unit_ptr->act  = (*unit_ptr->act_func) (unit_ptr);
+    } 
+
+    /* output update of non input units (for resultfile) */
+    FOR_ALL_UNITS( unit_ptr ) {
+	if (UNIT_IN_USE(unit_ptr) && !IS_INPUT_UNIT(unit_ptr)) {
+	    if (*unit_ptr->out_func == OUT_IDENTITY) { 
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{ /* the default way */
+		unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+	}
+    }
+
+    /* update input units */
+
+    FOR_ALL_UNITS( unit_ptr ){
+	if (UNIT_IN_USE(unit_ptr)&&IS_INPUT_UNIT(unit_ptr))
+	    unit_ptr->act  = (*unit_ptr->act_func) (unit_ptr);
+    } 
+
+    /* output update of input units (for resultfile) */
+
+    FOR_ALL_UNITS( unit_ptr ) {
+	if (UNIT_IN_USE(unit_ptr) && IS_INPUT_UNIT(unit_ptr)) {
+	    if (*unit_ptr->out_func == OUT_IDENTITY) { 
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{ /* the default way */
+		unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+	}
+    }
+
+    return( KRERR_NO_ERROR );
+} 
+
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_FixAct_Hop
+
+  PURPOSE  : synchronous update with fixed activity
+  RETURNS  : 
+  NOTES    : the units updated are given the activity 1 the others 0  
+             To decide which units are to  be updated, the arrays 
+             'unitsToUpdate' and 'netInputArray' are needed:
+             'netInputArray' contains the n highest netinputs ( n = NoOfOnes )
+             'unitsToUpdate' contains the corresponding unit pointers, so that
+              unitsToUpdate[i] points to the unit which has netinput equal to
+              netInputArray[i].
+  UPDATE   : 
+******************************************************************************/
+krui_err  UPDATE_FixAct_Hop(float *parameterArray, int NoOfParams)
+{
+    register struct Unit   *unit_ptr; 
+    FlintType               sum, aux, min;
+    ACT_FUNC_DEFS    /* defines link- and site-pointer */
+    register int            i;
+    int                     NoOfOnes, where;
+    struct Unit            **unitsToUpdate;
+    FlintType              *netInputArray;
+   
+
+    NoOfOnes = parameterArray[0]; /* the fixed Number of 1 */
+
+    /* init netInputArray and unitsToUpdate */
+    netInputArray = (FlintType *) calloc(NoOfOnes, sizeof(FlintType));
+    unitsToUpdate = (struct Unit * *) calloc(NoOfOnes, sizeof( struct Unit *)); 
+    for(i=0; i<= NoOfOnes-1; i++) {
+	unitsToUpdate[i] = NULL;
+	netInputArray[i] = -9e37;
+    }
+
+    FOR_ALL_UNITS(unit_ptr) { 
+	if UNIT_IN_USE(unit_ptr) {
+	    if (*unit_ptr->out_func == OUT_IDENTITY) { 
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{/* the default way */
+		unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+	}
+    }
+
+
+    /* find the units to update (their nr. is given by "NoOfOnes") by 
+       saving the units with highest netinputs ( the netinputs are held in 
+       the netInputArray and if a higher netinput occures, it replaces the 
+       lowest value in the array ) */
+ 
+    FOR_ALL_UNITS(unit_ptr) {
+	/* get the netInput of this unit */
+	sum =  0.0; aux = 0.0;
+	if (GET_FIRST_UNIT_LINK( unit_ptr )){
+	    do
+		sum += GET_WEIGHTED_OUTPUT;
+	    while (GET_NEXT_LINK);
+	}
+      
+	/* get the min of netInputArray, i.e. the worst netinput value already 
+           computed */
+
+	min = netInputArray[0];
+	where = 0;
+	for(i = 1; i <= NoOfOnes - 1; i++) {
+	    if( netInputArray[i] < min) {
+		min = netInputArray[i];
+		where = i;
+	    }
+	}
+
+	/* replace the lowest netinput with the actual one if this is higher
+	   and save the pointer to the actual unit in 'unitsToUpdate' */
+
+	if( sum > min ){
+	    netInputArray[where] = sum;
+	    unitsToUpdate[where] = unit_ptr;
+	}
+    }
+
+    /*    update unit activations    */
+    FOR_ALL_UNITS(unit_ptr){
+	unit_ptr->act =  0.0;
+    }
+    for(i=0; i<= NoOfOnes-1; i++){
+	unit_ptr = unitsToUpdate[i];
+	unit_ptr->act =  1.0;
+    }
+
+    /* output update for resultfile */
+    FOR_ALL_UNITS(unit_ptr) { 
+	if UNIT_IN_USE(unit_ptr) {
+	    if (*unit_ptr->out_func == OUT_IDENTITY) { 
+		unit_ptr->Out.output = unit_ptr->act;
+	    }else{/* the default way */
+		unit_ptr->Out.output = (*unit_ptr->out_func)(unit_ptr->act);
+	    }
+	}
+    }
+    free(netInputArray);
+    free(unitsToUpdate);
+  
+    return( KRERR_NO_ERROR );
+}
+
+
+/*****************************************************************************
+  FUNCTION : UPDATE_RM_Propagate
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : McClelland & Rummelhart's update rule
+
+  UPDATE   : 
+******************************************************************************/
+krui_err UPDATE_RM_Propagate (float *parameterArray, int NoOfParams)
+{
+  register struct Unit   *unit_ptr;
+  int t, NoTimes; 
+
+  NoTimes = parameterArray[0];
+
+  for (t=0; t < NoTimes; ++t){ 
+
+      /*  update unit activations */
+      FOR_ALL_UNITS( unit_ptr )
+	  if UNIT_IN_USE( unit_ptr )
+	      if ( !IS_INPUT_UNIT( unit_ptr)) 
+		  /*  unit isn't an input unit and is in use and enabled  */
+		  unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+      /* update unit outputs  */
+      FOR_ALL_UNITS( unit_ptr )
+	  if UNIT_IN_USE( unit_ptr )
+	      if (unit_ptr->out_func == OUT_IDENTITY)
+		  /*  identity output function: don't call output function  */
+		  unit_ptr->Out.output = unit_ptr->act;
+	      else
+		  /* calculate unit's output also  */
+		  unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+  }
+
+  return( KRERR_NO_ERROR );
+
+}
+
+
+/*#########################################################
+
+GROUP: Update Functions for the use with the GA tool Enzo
+
+#########################################################*/
+
+
+
+/*****************************************************************************
+  FUNCTION : ENZO_PROPAGATE_error_back()
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err  ENZO_PROPAGATE_error_back(void)
+{
+  register struct Link *link_ptr;
+  register struct Site *site_ptr;
+  register struct Unit *unit_ptr;
+  register float error;                    /*  error  */
+  TopoPtrArray topo_ptr;
+  int ret_code;
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_FF))
+    {  /*  Net has been modified or topologic array isn't initialized */
+    /*  check the topology of the network  */
+    ret_code = kr_topoCheck();
+    if(ret_code < KRERR_NO_ERROR)  return(ret_code); /* an error has occured */
+    if(ret_code<2)return(KRERR_NET_DEPTH); /* network has less than 2 layers */
+
+    /*	count the no. of I/O units and check the patterns  */
+    ret_code = kr_IOCheck();
+    if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+    /*	sort units by topology and by topologic type  */
+    ret_code = kr_topoSort( TOPOLOGICAL_FF );
+    if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+      return( ret_code );
+
+    NetModified = FALSE;
+    }
+
+  /*  add 3 to no_of_topo_units because the topologic array contains
+      4 NULL pointers  */
+  topo_ptr = topo_ptr_array + (no_of_topo_units + 3);
+
+  /*  calculate output units only  */
+  while ((unit_ptr = *--topo_ptr) != NULL) {
+    /* Out.output == dEdw */
+    error = - unit_ptr->Out.output * ((unit_ptr->act_deriv_func) ( unit_ptr ));
+    unit_ptr->value_c += -error /* * 1 */;   /*  calculate the bias slopes  */
+                                            /*  learn bias like a weight  */
+    if (UNIT_HAS_DIRECT_INPUTS( unit_ptr ))
+      {  /*  the unit has direct links  */
+      FOR_ALL_LINKS( unit_ptr, link_ptr )
+        {  /*	calculate the slopes  */
+        link_ptr->value_c += - error * link_ptr->to->Out.output;
+        link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+        }
+      }
+    else
+      {  /*  the unit has sites  */
+      FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr )
+	{  /*  calculate the value_cs  */
+	link_ptr->value_c += - error * link_ptr->to->Out.output;
+	link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	}
+      }
+    }
+
+
+  /*  calculate hidden units only  */
+  while ((unit_ptr = *--topo_ptr) != NULL) {
+      error = ((unit_ptr->act_deriv_func) (unit_ptr)) * unit_ptr->Aux.flint_no;
+
+      unit_ptr->value_c += - error /* * 1 */;   /* calculate the bias slopes */
+      /*  learn bias like a weight  */
+      if (UNIT_HAS_DIRECT_INPUTS( unit_ptr )){
+	  /*  the unit has direct links  */
+	  FOR_ALL_LINKS( unit_ptr, link_ptr ){
+	      /*  calculate the slopes  */
+	      if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+		/*  this link points to a hidden unit: 
+		    sum up the error's from previos units  */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	      
+	      link_ptr->value_c += - error * link_ptr->to->Out.output;
+	  }
+      } else {  /*  the unit has sites  */
+	  FOR_ALL_SITES_AND_LINKS( unit_ptr, site_ptr, link_ptr ){
+	      /*  calculate the slopes  */
+	      if (link_ptr->to->flags & UFLAG_TTYP_HIDD)
+		/*  this link points to a hidden unit: 
+		    sum up the error's from previos units  */
+		link_ptr->to->Aux.flint_no += link_ptr->weight * error;
+	      
+	      link_ptr->value_c += - error * link_ptr->to->Out.output;
+	  }
+      }
+  }
+  return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : ENZO_PROPAGATE_ff
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : 
+
+  UPDATE   : 
+******************************************************************************/
+static krui_err ENZO_PROPAGATE_ff(void)
+{
+  register struct Unit   *unit_ptr;
+  register TopoPtrArray     topo_ptr;
+  int ret_code;
+
+  if (NetModified || (TopoSortID != TOPOLOGICAL_FF))
+    {  /*  Net has been modified or topologic array isn't initialized */
+    /*  check the topology of the network  */
+    ret_code = kr_topoCheck();
+    if(ret_code < KRERR_NO_ERROR) return(ret_code);  /* an error has occured */
+    if(ret_code<2)return(KRERR_NET_DEPTH); /* network has less than 2 layers */
+
+    /*	count the no. of I/O units and check the patterns  */
+    ret_code = kr_IOCheck();
+    if (ret_code < KRERR_NO_ERROR)  return( ret_code );
+
+    /*	sort units by topology and by topologic type  */
+    ret_code = kr_topoSort( TOPOLOGICAL_FF );
+    if ((ret_code != KRERR_NO_ERROR) && (ret_code != KRERR_DEAD_UNITS))
+      return( ret_code );
+
+    NetModified = FALSE;
+    }
+
+
+  topo_ptr = topo_ptr_array;
+
+  /*  copy pattern into input unit's activation and
+      calculate output of the input units
+  */
+  while ((unit_ptr = *++topo_ptr) != NULL)
+    {  /*  topo_ptr points to a (topological sorted) unit stucture (input units first)  */
+    if (unit_ptr->out_func == OUT_IDENTITY)
+      /*  identity output function: no need to call the output function  */
+      unit_ptr->Out.output = unit_ptr->act;
+    else
+      /*  no identity output function: calculate unit's output also  */
+      unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+  /*  popagate hidden units  */
+  while ((unit_ptr = *++topo_ptr) != NULL)
+    {  /*  topo_ptr points to a (topological sorted) unit stucture */
+    /*  clear error values  */
+    unit_ptr->Aux.flint_no = 0.0;
+
+    /*  calculate the activation value of the unit: 
+	call the activation function if needed  */
+    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+    if (unit_ptr->out_func == OUT_IDENTITY)
+      /*  identity output function: no need to call the output function  */
+      unit_ptr->Out.output = unit_ptr->act;
+    else
+      /*  no identity output function: calculate unit's output also  */
+      unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+
+  /*  popagate output units  */
+  while ((unit_ptr = *++topo_ptr) != NULL)
+    {  /*  topo_ptr points to a (topological sorted) unit stucture */
+    /*  clear error values  */
+    unit_ptr->Aux.flint_no = 0.0;
+
+    /*  calculate the activation value of the unit: 
+	call the activation function if needed  */
+    unit_ptr->act = (*unit_ptr->act_func) (unit_ptr);
+
+    if (unit_ptr->out_func == OUT_IDENTITY)
+      /*  identity output function: no need to call the output function  */
+      unit_ptr->Out.output = unit_ptr->act;
+    else
+      /*  no identity output function: calculate unit's output also  */
+      unit_ptr->Out.output = (*unit_ptr->out_func) (unit_ptr->act);
+    }
+  return( KRERR_NO_ERROR );
+}
+
+
+
+/*****************************************************************************
+  FUNCTION : ENZO_propagate
+
+  PURPOSE  : 
+  RETURNS  : 
+  NOTES    : If the Input-Parameter is 0, the input activation is propagated 
+             forward, else the error gradient is propagated backward.
+             This is done because NetInitialized is set TRUE every
+             time the Update-function is changed.
+  UPDATE   : 
+******************************************************************************/
+krui_err  ENZO_propagate( float *parameterArray, int NoOfParams )
+{  
+  if (NoOfParams < 1)    
+    return( KRERR_PARAMETERS );       /*  not enough input parameters  */
+
+  if (UPDATE_PARAM1 (parameterArray)) 
+    return (ENZO_PROPAGATE_error_back());  /* rueckwaerts-Propagieren */
+  else
+    return (ENZO_PROPAGATE_ff());          /* vorwaerts-Propagieren */
+}
+
+
+
+
+/*#################################################
+
+GROUP: User Defined Update Functions
+
+#################################################*/
+
diff -Naur snort-2.3.3/src/kernel_snns/update_f.h snort-2.3.3.new/src/kernel_snns/update_f.h
--- snort-2.3.3/src/kernel_snns/update_f.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/update_f.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,52 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/update_f.h,v $
+  SHORTNAME      : update_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Network Update Functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 18.03.91
+
+  CHANGED BY     : Sven Doering, Michael Vogt (Martin Reczko)
+  RCS VERSION    : $Revision: 2.9 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:57 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _UPDATE_F_DEFINED_
+#define  _UPDATE_F_DEFINED_
+
+
+extern krui_err  UPDATE_syncPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_syncPropagateHop(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_FixAct_Hop(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_serialPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_randomOrderPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_randomPermutPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_topologicalPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_KohonenPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_CPNPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_TimeDelayPropagate(float parameterArray[], int NoOfParams );
+extern krui_err  UPDATE_ART1_syncPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_ART1_Propagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_ART2_syncPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_ART2_Propagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_ARTMAP_syncPropagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_ARTMAP_Propagate(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_CC_Propagate(float parameterArray[],  int NoOfParams);
+extern krui_err  UPDATE_BPTT(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_DLVQ_Propagate(float parameterArray[], int NoOfParams);
+extern krui_err  UPDATE_BAM(float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_JE_Propagate (float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_JE_Special   (float *parameterArray, int NoOfParams);
+extern krui_err  UPDATE_RM_Propagate(float *parameterArray, int NoOfParams);
+extern krui_err  ENZO_propagate(float *parameterArray, int NoOfParams);
+
+
+#endif 
+
+/* 45 lines generated by deleteprivatedefinitions.awk */
diff -Naur snort-2.3.3/src/kernel_snns/update_f.ph snort-2.3.3.new/src/kernel_snns/update_f.ph
--- snort-2.3.3/src/kernel_snns/update_f.ph	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/update_f.ph	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,63 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/update_f.ph,v $
+  SHORTNAME      : update_f
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel Network Update Functions
+  NOTES          :
+
+  AUTHOR         : Niels Mache
+  DATE           : 18.03.91
+
+  CHANGED BY     : Sven Doering, Michael Vogt (Martin Reczko)
+  RCS VERSION    : $Revision: 2.10 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:58 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef _UPDATE_F_DEFINED_
+#define  _UPDATE_F_DEFINED_
+
+/* begin global definition section */
+
+krui_err  UPDATE_syncPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_syncPropagateHop(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_FixAct_Hop(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_serialPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_randomOrderPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_randomPermutPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_topologicalPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_CPNPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_TimeDelayPropagate(float parameterArray[], int NoOfParams );
+krui_err  UPDATE_ART1_syncPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_ART1_Propagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_ART2_syncPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_ART2_Propagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_ARTMAP_syncPropagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_ARTMAP_Propagate(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_CC_Propagate(float parameterArray[],  int NoOfParams);
+krui_err  UPDATE_BPTT(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_DLVQ_Propagate(float parameterArray[], int NoOfParams);
+krui_err  UPDATE_BAM(float *parameterArray, int NoOfParams);
+krui_err  UPDATE_JE_Propagate (float *parameterArray, int NoOfParams) ;
+krui_err  UPDATE_JE_Special   (float *parameterArray, int NoOfParams) ;
+krui_err  UPDATE_RM_Propagate(float *parameterArray, int NoOfParams);
+krui_err  ENZO_propagate(float *parameterArray, int NoOfParams);
+
+/* end global definition section */
+
+/* begin private definition section */
+
+#define  UPDATE_PARAM1( param )   param[ 0 ]  /*    contains the 1st initialisation parameter  */
+#define  UPDATE_PARAM2( param )   param[ 1 ]  /*    contains the 2nd initialisation parameter  */
+#define  UPDATE_PARAM3( param )   param[ 2 ]  /*    contains the 3rd initialisation parameter  */
+#define  UPDATE_PARAM4( param )   param[ 3 ]  /*    contains the 4th initialisation parameter  */
+static void normalize_inputvector(float sum);
+static krui_err ENZO_PROPAGATE_error_back(void);
+static krui_err ENZO_PROPAGATE_ff(void);
+
+/* end private definition section */
+
+#endif 
diff -Naur snort-2.3.3/src/kernel_snns/version.h snort-2.3.3.new/src/kernel_snns/version.h
--- snort-2.3.3/src/kernel_snns/version.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/version.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,47 @@
+/*****************************************************************************
+  FILE           : $Source: /projects/higgs1/SNNS/CVS/SNNS/kernel/sources/version.h,v $
+  SHORTNAME      : 
+  SNNS VERSION   : 4.2
+
+  PURPOSE        : SNNS-Kernel: Current Version and Patchlevel
+  NOTES          :
+
+  AUTHOR         : Niels Mache 
+  DATE           : 15.08.9
+
+  CHANGED BY     : Sven Doering
+  RCS VERSION    : $Revision: 2.10 $
+  LAST CHANGE    : $Date: 1998/02/25 15:27:59 $
+
+    Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+    Copyright (c) 1996-1998  SNNS Group, WSI, Univ. Tuebingen, FRG
+
+******************************************************************************/
+#ifndef VERSION_INCLUDE
+#define VERSION_INCLUDE
+
+/*  define the current patchlevel
+*/
+#define KERNEL_DATE    "01-01-1996"
+#define KERNEL_PATCH   "0"
+
+
+#ifdef MASPAR_KERNEL
+#define  SNNS_VERSION   "SNNS MasPar 3D-Kernel V3.3 (Spontanous Warp Speed)"
+#else
+#define  SNNS_VERSION   "SNNS 3D-Kernel V4.2"
+#endif
+
+#ifdef PARAGON_KERNEL
+#define  SNNS_VERSION   "SNNS 3D-Paragon Kernel V3.3"
+#endif
+
+
+/*  Version of I/O Manager  */
+#define NETFILE_VERSION  "V1.4"
+#define NETFILE_VERSION2  "V2.1"
+
+/*  3D-Kernel Netfile Version  */
+#define KERNEL3D_NETFILE_VERSION  "-3D"
+
+#endif
diff -Naur snort-2.3.3/src/kernel_snns/y.tab.h snort-2.3.3.new/src/kernel_snns/y.tab.h
--- snort-2.3.3/src/kernel_snns/y.tab.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/kernel_snns/y.tab.h	2008-02-17 10:28:39.000000000 -0300
@@ -0,0 +1,34 @@
+typedef union
+{
+	float	value;		/* allgemeine Zahl */	
+        char    *name;          /* allgemeiner String */
+	struct
+	{
+		int	v;
+		int	r;
+	}	version;	/* Versionsnummer #.# */
+} YYSTYPE;
+#define	L_BRACKET	258
+#define	R_BRACKET	259
+#define	VERSION_HEADER	260
+#define	GENERATED_AT	261
+#define	NO_OF_PATTERN	262
+#define	NO_OF_INPUT	263
+#define	NO_OF_OUTPUT	264
+#define	NO_OF_VAR_IDIM	265
+#define	NO_OF_VAR_ODIM	266
+#define	MAXIMUM_IDIM	267
+#define	MAXIMUM_ODIM	268
+#define	NO_OF_CLASSES	269
+#define	CLASS_REDISTRIB	270
+#define	REMAPFUNCTION	271
+#define	REMAP_PARAM	272
+#define	ERROR	273
+#define	PATTERNEND	274
+#define	PATTERNNOCLASS	275
+#define	NUMBER	276
+#define	NAME	277
+#define	V_NUMBER	278
+
+
+extern YYSTYPE pplval;
diff -Naur snort-2.3.3/src/log.c snort-2.3.3.new/src/log.c
--- snort-2.3.3/src/log.c	2004-12-09 15:38:46.000000000 -0200
+++ snort-2.3.3.new/src/log.c	2008-02-05 15:18:06.000000000 -0200
@@ -1478,8 +1478,10 @@
                 {
                     for(j = 0; j < p->ip_options[i].len; j++)
                     {
-                        fprintf(fp, "%02X", p->ip_options[i].data[j]);
-                        
+			if (p->ip_options[i].data)
+				fprintf(fp, "%02X", p->ip_options[i].data[j]);
+			else
+				fprintf(fp, "%02X", 0);
                         if((j % 2) == 0)
                             fprintf(fp, " ");
                     }
@@ -1522,7 +1524,8 @@
             case TCPOPT_MAXSEG:
                 bzero((char *) tmp, 5);
                 fwrite("MSS: ", 5, 1, fp);
-                memcpy(tmp, p->tcp_options[i].data, 2);
+                if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 2);
                 fprintf(fp, "%u ", EXTRACT_16BITS(tmp));
                 break;
 
@@ -1535,15 +1538,20 @@
                 break;
 
             case TCPOPT_WSCALE:
-                fprintf(fp, "WS: %u ", p->tcp_options[i].data[0]);
+                if (p->tcp_options[i].data)
+			fprintf(fp, "WS: %u ", p->tcp_options[i].data[0]);
+                else
+			fprintf(fp, "WS: %u ", 0);
                 break;
 
             case TCPOPT_SACK:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 2);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 2);
                 fprintf(fp, "Sack: %u@", EXTRACT_16BITS(tmp));
                 bzero((char *) tmp, 5);
-                memcpy(tmp, (p->tcp_options[i].data) + 2, 2);
+		if (p->tcp_options[i].data)
+                	memcpy(tmp, (p->tcp_options[i].data) + 2, 2);
                 fprintf(fp, "%u ", EXTRACT_16BITS(tmp));
                 break;
 
@@ -1553,40 +1561,47 @@
 
             case TCPOPT_ECHO:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "Echo: %u ", EXTRACT_32BITS(tmp));
                 break;
 
             case TCPOPT_ECHOREPLY:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "Echo Rep: %u ", EXTRACT_32BITS(tmp));
                 break;
 
             case TCPOPT_TIMESTAMP:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "TS: %u ", EXTRACT_32BITS(tmp));
                 bzero((char *) tmp, 5);
-                memcpy(tmp, (p->tcp_options[i].data) + 4, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, (p->tcp_options[i].data) + 4, 4);
                 fprintf(fp, "%u ", EXTRACT_32BITS(tmp));
                 break;
 
             case TCPOPT_CC:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "CC %u ", EXTRACT_32BITS(tmp));
                 break;
 
             case TCPOPT_CCNEW:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "CCNEW: %u ", EXTRACT_32BITS(tmp));
                 break;
 
             case TCPOPT_CCECHO:
                 bzero((char *) tmp, 5);
-                memcpy(tmp, p->tcp_options[i].data, 4);
+		if (p->tcp_options[i].data)
+			memcpy(tmp, p->tcp_options[i].data, 4);
                 fprintf(fp, "CCECHO: %u ", EXTRACT_32BITS(tmp));
                 break;
 
@@ -1598,7 +1613,10 @@
 
                     for(j = 0; j < p->tcp_options[i].len; j++)
                     {
-                        fprintf(fp, "%02X", p->tcp_options[i].data[j]);
+			if (p->tcp_options[i].data)
+				fprintf(fp, "%02X", p->tcp_options[i].data[j]);
+			else
+				fprintf(fp, "%02X", 0);
                         
                         if((j % 2) == 0)
                             fprintf(fp, " ");
diff -Naur snort-2.3.3/src/Makefile.am snort-2.3.3.new/src/Makefile.am
--- snort-2.3.3/src/Makefile.am	2004-09-13 14:44:49.000000000 -0300
+++ snort-2.3.3.new/src/Makefile.am	2008-02-18 00:42:44.000000000 -0300
@@ -45,7 +45,12 @@
 smalloc.h \
 snort_packet_header.h \
 event_queue.c event_queue.h \
-inline.c inline.h
+inline.c inline.h \
+rna.c rna.h \
+rna_alg.c rna_alg.h \
+rna_lib.c rna_lib.h \
+rna_train.c rna_train.h \
+define_values.c define_values.h
 
 snort_LDADD = output-plugins/libspo.a \
 detection-plugins/libspd.a            \
@@ -54,8 +59,9 @@
 preprocessors/flow/libflow.a \
 parser/libparser.a \
 preprocessors/HttpInspect/libhttp_inspect.a \
-sfutil/libsfutil.a
+sfutil/libsfutil.a \
+kernel_snns/libkernel.a kernel_snns/libfunc.a
 
-SUBDIRS = sfutil win32 output-plugins detection-plugins preprocessors parser
+SUBDIRS = sfutil win32 output-plugins detection-plugins preprocessors parser kernel_snns
 
 INCLUDES = @INCLUDES@
diff -Naur snort-2.3.3/src/Makefile.in snort-2.3.3.new/src/Makefile.in
--- snort-2.3.3/src/Makefile.in	2005-04-23 16:47:24.000000000 -0300
+++ snort-2.3.3.new/src/Makefile.in	2008-02-18 00:42:44.000000000 -0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,168 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+bin_PROGRAMS = snort$(EXEEXT)
+subdir = src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__installdirs = "$(DESTDIR)$(bindir)"
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+PROGRAMS = $(bin_PROGRAMS)
+am_snort_OBJECTS = codes.$(OBJEXT) debug.$(OBJEXT) decode.$(OBJEXT) \
+	log.$(OBJEXT) mstring.$(OBJEXT) parser.$(OBJEXT) \
+	plugbase.$(OBJEXT) snort.$(OBJEXT) snprintf.$(OBJEXT) \
+	strlcatu.$(OBJEXT) strlcpyu.$(OBJEXT) tag.$(OBJEXT) \
+	ubi_BinTree.$(OBJEXT) ubi_SplayTree.$(OBJEXT) util.$(OBJEXT) \
+	detect.$(OBJEXT) signature.$(OBJEXT) mempool.$(OBJEXT) \
+	sf_sdlist.$(OBJEXT) fpcreate.$(OBJEXT) fpdetect.$(OBJEXT) \
+	pcrm.$(OBJEXT) byte_extract.$(OBJEXT) sfthreshold.$(OBJEXT) \
+	packet_time.$(OBJEXT) event_wrapper.$(OBJEXT) \
+	event_queue.$(OBJEXT) inline.$(OBJEXT) \
+	rna.$(OBJEXT) rna_alg.$(OBJEXT) \
+	rna_lib.$(OBJEXT) rna_train.$(OBJEXT) \
+	define_values.$(OBJEXT)
+snort_OBJECTS = $(am_snort_OBJECTS)
+snort_DEPENDENCIES = output-plugins/libspo.a \
+	detection-plugins/libspd.a preprocessors/libspp.a \
+	preprocessors/flow/portscan/libportscan.a \
+	preprocessors/flow/libflow.a parser/libparser.a \
+	preprocessors/HttpInspect/libhttp_inspect.a sfutil/libsfutil.a \
+	kernel_snns/libkernel.a kernel_snns/libfunc.a
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(snort_SOURCES)
+DIST_SOURCES = $(snort_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
-bin_PROGRAMS = snort
-
 snort_SOURCES = cdefs.h \
 event.h \
 fatal.h \
@@ -126,8 +217,12 @@
 smalloc.h \
 snort_packet_header.h \
 event_queue.c event_queue.h \
-inline.c inline.h
-
+inline.c inline.h \
+rna.c rna.h \
+rna_alg.c rna_alg.h \
+rna_lib.c rna_lib.h \
+rna_train.c rna_train.h \
+define_values.c define_values.h
 
 snort_LDADD = output-plugins/libspo.a \
 detection-plugins/libspd.a            \
@@ -136,77 +231,53 @@
 preprocessors/flow/libflow.a \
 parser/libparser.a \
 preprocessors/HttpInspect/libhttp_inspect.a \
-sfutil/libsfutil.a
-
-
-SUBDIRS = sfutil win32 output-plugins detection-plugins preprocessors parser
-subdir = src
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-bin_PROGRAMS = snort$(EXEEXT)
-PROGRAMS = $(bin_PROGRAMS)
-
-am_snort_OBJECTS = codes.$(OBJEXT) debug.$(OBJEXT) decode.$(OBJEXT) \
-	log.$(OBJEXT) mstring.$(OBJEXT) parser.$(OBJEXT) \
-	plugbase.$(OBJEXT) snort.$(OBJEXT) snprintf.$(OBJEXT) \
-	strlcatu.$(OBJEXT) strlcpyu.$(OBJEXT) tag.$(OBJEXT) \
-	ubi_BinTree.$(OBJEXT) ubi_SplayTree.$(OBJEXT) util.$(OBJEXT) \
-	detect.$(OBJEXT) signature.$(OBJEXT) mempool.$(OBJEXT) \
-	sf_sdlist.$(OBJEXT) fpcreate.$(OBJEXT) fpdetect.$(OBJEXT) \
-	pcrm.$(OBJEXT) byte_extract.$(OBJEXT) sfthreshold.$(OBJEXT) \
-	packet_time.$(OBJEXT) event_wrapper.$(OBJEXT) \
-	event_queue.$(OBJEXT) inline.$(OBJEXT)
-snort_OBJECTS = $(am_snort_OBJECTS)
-snort_DEPENDENCIES = output-plugins/libspo.a detection-plugins/libspd.a \
-	preprocessors/libspp.a \
-	preprocessors/flow/portscan/libportscan.a \
-	preprocessors/flow/libflow.a parser/libparser.a \
-	preprocessors/HttpInspect/libhttp_inspect.a sfutil/libsfutil.a
-snort_LDFLAGS =
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(snort_SOURCES)
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
-	uninstall-info-recursive all-recursive install-data-recursive \
-	install-exec-recursive installdirs-recursive install-recursive \
-	uninstall-recursive check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
-DIST_SUBDIRS = $(SUBDIRS)
-SOURCES = $(snort_SOURCES)
+sfutil/libsfutil.a \
+kernel_snns/libkernel.a kernel_snns/libfunc.a
 
+SUBDIRS = sfutil win32 output-plugins detection-plugins preprocessors parser kernel_snns
 all: all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
-	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
 	@list='$(bin_PROGRAMS)'; for p in $$list; do \
 	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
 	  if test -f $$p \
 	  ; then \
 	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
-	   echo " $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f"; \
-	   $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) '$$p' '$(DESTDIR)$(bindir)/$$f'"; \
+	   $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) "$$p" "$(DESTDIR)$(bindir)/$$f" || exit 1; \
 	  else :; fi; \
 	done
 
@@ -214,8 +285,8 @@
 	@$(NORMAL_UNINSTALL)
 	@list='$(bin_PROGRAMS)'; for p in $$list; do \
 	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
-	  echo " rm -f $(DESTDIR)$(bindir)/$$f"; \
-	  rm -f $(DESTDIR)$(bindir)/$$f; \
+	  echo " rm -f '$(DESTDIR)$(bindir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(bindir)/$$f"; \
 	done
 
 clean-binPROGRAMS:
@@ -225,16 +296,16 @@
 	$(LINK) $(snort_LDFLAGS) $(snort_OBJECTS) $(snort_LDADD) $(LIBS)
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
@@ -244,7 +315,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -256,7 +333,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -264,7 +341,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -285,17 +368,16 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
 	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -305,14 +387,23 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
@@ -321,8 +412,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -331,19 +438,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -358,15 +467,17 @@
 	    || exit 1; \
 	  fi; \
 	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
 	    (cd $$subdir && \
 	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$(top_distdir)" \
-	        distdir=../$(distdir)/$$subdir \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -376,8 +487,9 @@
 all-am: Makefile $(PROGRAMS)
 installdirs: installdirs-recursive
 installdirs-am:
-	$(mkinstalldirs) $(DESTDIR)$(bindir)
-
+	for dir in "$(DESTDIR)$(bindir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
@@ -389,7 +501,7 @@
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -397,7 +509,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -407,7 +519,7 @@
 clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -415,6 +527,8 @@
 
 dvi-am:
 
+html: html-recursive
+
 info: info-recursive
 
 info-am:
@@ -430,32 +544,38 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
 uninstall-am: uninstall-binPROGRAMS uninstall-info-am
 
 uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
-	clean-binPROGRAMS clean-generic clean-recursive distclean \
-	distclean-compile distclean-generic distclean-recursive \
-	distclean-tags distdir dvi dvi-am dvi-recursive info info-am \
-	info-recursive install install-am install-binPROGRAMS \
-	install-data install-data-am install-data-recursive \
-	install-exec install-exec-am install-exec-recursive \
-	install-info install-info-am install-info-recursive install-man \
-	install-recursive install-strip installcheck installcheck-am \
-	installdirs installdirs-am installdirs-recursive \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-binPROGRAMS clean-generic clean-recursive ctags \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-recursive distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
 	maintainer-clean maintainer-clean-generic \
 	maintainer-clean-recursive mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-recursive tags tags-recursive \
-	uninstall uninstall-am uninstall-binPROGRAMS uninstall-info-am \
-	uninstall-info-recursive uninstall-recursive
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am \
+	uninstall-binPROGRAMS uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/output-plugins/Makefile.in snort-2.3.3.new/src/output-plugins/Makefile.in
--- snort-2.3.3/src/output-plugins/Makefile.in	2005-04-23 16:47:24.000000000 -0300
+++ snort-2.3.3.new/src/output-plugins/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,150 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/output-plugins
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libspo_a_AR = $(AR) $(ARFLAGS)
+libspo_a_LIBADD =
+am_libspo_a_OBJECTS = spo_alert_fast.$(OBJEXT) \
+	spo_alert_full.$(OBJEXT) spo_alert_syslog.$(OBJEXT) \
+	spo_alert_unixsock.$(OBJEXT) spo_csv.$(OBJEXT) \
+	spo_database.$(OBJEXT) spo_log_null.$(OBJEXT) \
+	spo_log_tcpdump.$(OBJEXT) spo_unified.$(OBJEXT) \
+	spo_log_ascii.$(OBJEXT) spo_alert_sf_socket.$(OBJEXT)
+libspo_a_OBJECTS = $(am_libspo_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libspo_a_SOURCES)
+DIST_SOURCES = $(libspo_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libspo.a
-
 libspo_a_SOURCES = spo_alert_fast.c spo_alert_fast.h \
 spo_alert_full.c spo_alert_full.h \
 spo_alert_syslog.c spo_alert_syslog.h spo_alert_unixsock.c     \
@@ -92,48 +165,39 @@
 spo_log_tcpdump.h spo_unified.c spo_unified.h spo_log_ascii.c spo_log_ascii.h \
 spo_alert_sf_socket.h spo_alert_sf_socket.c
 
-subdir = src/output-plugins
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libspo_a_AR = $(AR) cru
-libspo_a_LIBADD =
-am_libspo_a_OBJECTS = spo_alert_fast.$(OBJEXT) spo_alert_full.$(OBJEXT) \
-	spo_alert_syslog.$(OBJEXT) spo_alert_unixsock.$(OBJEXT) \
-	spo_csv.$(OBJEXT) spo_database.$(OBJEXT) spo_log_null.$(OBJEXT) \
-	spo_log_tcpdump.$(OBJEXT) spo_unified.$(OBJEXT) \
-	spo_log_ascii.$(OBJEXT) spo_alert_sf_socket.$(OBJEXT)
-libspo_a_OBJECTS = $(am_libspo_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libspo_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libspo_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/output-plugins/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/output-plugins/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -143,23 +207,18 @@
 	$(RANLIB) libspo.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -168,6 +227,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -179,8 +239,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -189,19 +265,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -219,9 +297,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -233,7 +309,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -241,7 +317,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -251,7 +327,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -259,6 +335,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -274,24 +352,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/output-plugins/spo_alert_fast.c snort-2.3.3.new/src/output-plugins/spo_alert_fast.c
--- snort-2.3.3/src/output-plugins/spo_alert_fast.c	2004-06-03 17:11:06.000000000 -0300
+++ snort-2.3.3.new/src/output-plugins/spo_alert_fast.c	2008-01-03 10:47:44.000000000 -0200
@@ -243,14 +243,14 @@
 
     data = (SpoAlertFastData *)SnortAlloc(sizeof(SpoAlertFastData));
 
-    DEBUG_WRAP(DebugMessage(DEBUG_LOG, "ParseAlertFastArgs: %s\n", args););
-
     if(args == NULL)
     {
         data->file = OpenAlertFile(NULL);
         return data;
     }
 
+    DEBUG_WRAP(DebugMessage(DEBUG_LOG, "ParseAlertFastArgs: %s\n", args););
+
     toks = mSplit(args, " ", 2, &num_toks, 0);
     if(strcasecmp("stdout", toks[0]) == 0)
         data->file = stdout;
diff -Naur snort-2.3.3/src/output-plugins/spo_alert_full.c snort-2.3.3.new/src/output-plugins/spo_alert_full.c
--- snort-2.3.3/src/output-plugins/spo_alert_full.c	2003-10-20 13:03:34.000000000 -0200
+++ snort-2.3.3.new/src/output-plugins/spo_alert_full.c	2008-01-03 10:47:44.000000000 -0200
@@ -236,12 +236,12 @@
     SpoAlertFullData *data;
 
     data = (SpoAlertFullData *)SnortAlloc(sizeof(SpoAlertFullData));
-    DEBUG_WRAP(DebugMessage(DEBUG_LOG,"ParseAlertFullArgs: %s\n", args););
     if(args == NULL)
     {
         data->file = OpenAlertFile(NULL);
         return data;
     }
+    DEBUG_WRAP(DebugMessage(DEBUG_LOG,"ParseAlertFullArgs: %s\n", args););
 
     toks = mSplit(args, " ", 2, &num_toks, 0);
     if(strcasecmp("stdout", toks[0]) == 0)
diff -Naur snort-2.3.3/src/output-plugins/spo_database.c snort-2.3.3.new/src/output-plugins/spo_database.c
--- snort-2.3.3/src/output-plugins/spo_database.c	2004-09-13 14:44:49.000000000 -0300
+++ snort-2.3.3.new/src/output-plugins/spo_database.c	2008-01-03 10:47:44.000000000 -0200
@@ -1896,8 +1896,8 @@
 
    select0 = (char *) SnortAlloc(MAX_QUERY_LENGTH+1);
 
-#if defined(ENABLE_MSSQL) || defined(ENABLE_ODBC)
-   if ( data->shared->dbtype_id == DB_MSSQL ||
+#if defined(ENABLE_MSSQL) || defined(ENABLE_ODBC) 
+   if ( data->shared->dbtype_id == DB_MSSQL || 
         (data->shared->dbtype_id==DB_ODBC && data->u_underlying_dbtype_id==DB_MSSQL) )
    {
       /* "schema" is a keyword in SQL Server, so use square brackets
@@ -1910,9 +1910,23 @@
    else
 #endif
    {
+#if defined(ENABLE_MYSQL)
+      if (data->shared->dbtype_id == DB_MYSQL)
+      {
+         /* "schema" is a keyword in MYSQL, so use `schema`
+          *  to indicate that we are referring to the table
+          */
+         snprintf(select0, MAX_QUERY_LENGTH,
+               "SELECT vseq "
+               "FROM `schema`");
+     }
+     else
+#endif
+      {
       snprintf(select0, MAX_QUERY_LENGTH,
                "SELECT vseq "
                "FROM schema");
+      }
    }
 
    schema_version = Select(select0,data);
diff -Naur snort-2.3.3/src/parser/Makefile.in snort-2.3.3.new/src/parser/Makefile.in
--- snort-2.3.3/src/parser/Makefile.in	2005-04-23 16:47:24.000000000 -0300
+++ snort-2.3.3.new/src/parser/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,116 +13,179 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/parser
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libparser_a_AR = $(AR) $(ARFLAGS)
+libparser_a_LIBADD =
+am_libparser_a_OBJECTS = IpAddrSet.$(OBJEXT)
+libparser_a_OBJECTS = $(am_libparser_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libparser_a_SOURCES)
+DIST_SOURCES = $(libparser_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libparser.a
-
 libparser_a_SOURCES = IpAddrSet.c IpAddrSet.h
-subdir = src/parser
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libparser_a_AR = $(AR) cru
-libparser_a_LIBADD =
-am_libparser_a_OBJECTS = IpAddrSet.$(OBJEXT)
-libparser_a_OBJECTS = $(am_libparser_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libparser_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libparser_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/parser/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/parser/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -132,23 +195,18 @@
 	$(RANLIB) libparser.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -157,6 +215,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -168,8 +227,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -178,19 +253,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -208,9 +285,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -222,7 +297,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -230,7 +305,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -240,7 +315,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -248,6 +323,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -263,24 +340,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/flow/int-snort/Makefile.in snort-2.3.3.new/src/preprocessors/flow/int-snort/Makefile.in
--- snort-2.3.3/src/preprocessors/flow/int-snort/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/flow/int-snort/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,116 +13,179 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/flow/int-snort
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libintsnort_a_AR = $(AR) $(ARFLAGS)
+libintsnort_a_LIBADD =
+am_libintsnort_a_OBJECTS = flow_packet.$(OBJEXT)
+libintsnort_a_OBJECTS = $(am_libintsnort_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libintsnort_a_SOURCES)
+DIST_SOURCES = $(libintsnort_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libintsnort.a
-
 libintsnort_a_SOURCES = flow_packet.h flow_packet.c
-subdir = src/preprocessors/flow/int-snort
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libintsnort_a_AR = $(AR) cru
-libintsnort_a_LIBADD =
-am_libintsnort_a_OBJECTS = flow_packet.$(OBJEXT)
-libintsnort_a_OBJECTS = $(am_libintsnort_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libintsnort_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libintsnort_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/flow/int-snort/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/flow/int-snort/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -132,23 +195,18 @@
 	$(RANLIB) libintsnort.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -157,6 +215,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -168,8 +227,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -178,19 +253,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -208,9 +285,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -222,7 +297,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -230,7 +305,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -240,7 +315,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -248,6 +323,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -263,24 +340,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/flow/Makefile.in snort-2.3.3.new/src/preprocessors/flow/Makefile.in
--- snort-2.3.3/src/preprocessors/flow/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/flow/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,154 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/flow
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libflow_a_AR = $(AR) $(ARFLAGS)
+libflow_a_LIBADD =
+am_libflow_a_OBJECTS = flow.$(OBJEXT) flow_cache.$(OBJEXT) \
+	flow_callback.$(OBJEXT) flow_class.$(OBJEXT) \
+	flow_stat.$(OBJEXT) flow_hash.$(OBJEXT) flow_print.$(OBJEXT)
+libflow_a_OBJECTS = $(am_libflow_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libflow_a_SOURCES)
+DIST_SOURCES = $(libflow_a_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 SUBDIRS = portscan int-snort
-
 noinst_LIBRARIES = libflow.a
-
 libflow_a_SOURCES = common_defs.h \
                     flow.c flow.h \
                     flow_cache.c flow_cache.h \
@@ -95,56 +172,39 @@
                     flow_hash.c flow_hash.h \
                     flow_print.c flow_print.h
 
-subdir = src/preprocessors/flow
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libflow_a_AR = $(AR) cru
-libflow_a_LIBADD =
-am_libflow_a_OBJECTS = flow.$(OBJEXT) flow_cache.$(OBJEXT) \
-	flow_callback.$(OBJEXT) flow_class.$(OBJEXT) \
-	flow_stat.$(OBJEXT) flow_hash.$(OBJEXT) flow_print.$(OBJEXT)
-libflow_a_OBJECTS = $(am_libflow_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/flow.Po ./$(DEPDIR)/flow_cache.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/flow_callback.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/flow_class.Po ./$(DEPDIR)/flow_hash.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/flow_print.Po ./$(DEPDIR)/flow_stat.Po
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libflow_a_SOURCES)
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
-	uninstall-info-recursive all-recursive install-data-recursive \
-	install-exec-recursive installdirs-recursive install-recursive \
-	uninstall-recursive check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
-DIST_SUBDIRS = $(SUBDIRS)
-SOURCES = $(libflow_a_SOURCES)
-
 all: all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/preprocessors/flow/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --gnu  src/preprocessors/flow/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -154,7 +214,7 @@
 	$(RANLIB) libflow.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -167,21 +227,19 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flow_print.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/flow_stat.Po@am__quote@
 
-distclean-depend:
-	-rm -rf ./$(DEPDIR)
-
 .c.o:
-@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
-@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
 
 .c.obj:
-@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
-@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-	$(COMPILE) -c `cygpath -w $<`
-CCDEPMODE = @CCDEPMODE@
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
@@ -191,7 +249,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -203,7 +267,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -211,7 +275,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -232,17 +302,16 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
 	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -252,14 +321,23 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
@@ -268,8 +346,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -278,19 +372,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -305,15 +401,17 @@
 	    || exit 1; \
 	  fi; \
 	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
 	    (cd $$subdir && \
 	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$(top_distdir)" \
-	        distdir=../$(distdir)/$$subdir \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -323,7 +421,6 @@
 all-am: Makefile $(LIBRARIES)
 installdirs: installdirs-recursive
 installdirs-am:
-
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
@@ -335,7 +432,7 @@
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -343,7 +440,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -353,14 +450,17 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-recursive
-
-distclean-am: clean-am distclean-compile distclean-depend \
-	distclean-generic distclean-tags
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
 
 dvi: dvi-recursive
 
 dvi-am:
 
+html: html-recursive
+
 info: info-recursive
 
 info-am:
@@ -376,32 +476,38 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
 uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
-	clean-generic clean-noinstLIBRARIES clean-recursive distclean \
-	distclean-compile distclean-depend distclean-generic \
-	distclean-recursive distclean-tags distdir dvi dvi-am \
-	dvi-recursive info info-am info-recursive install install-am \
-	install-data install-data-am install-data-recursive \
-	install-exec install-exec-am install-exec-recursive \
-	install-info install-info-am install-info-recursive install-man \
-	install-recursive install-strip installcheck installcheck-am \
-	installdirs installdirs-am installdirs-recursive \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-noinstLIBRARIES clean-recursive \
+	ctags ctags-recursive distclean distclean-compile \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
 	maintainer-clean maintainer-clean-generic \
 	maintainer-clean-recursive mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-recursive tags tags-recursive \
-	uninstall uninstall-am uninstall-info-am \
-	uninstall-info-recursive uninstall-recursive
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/flow/portscan/Makefile.in snort-2.3.3.new/src/preprocessors/flow/portscan/Makefile.in
--- snort-2.3.3/src/preprocessors/flow/portscan/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/flow/portscan/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,123 +13,186 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/flow/portscan
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libportscan_a_AR = $(AR) $(ARFLAGS)
+libportscan_a_LIBADD =
+am_libportscan_a_OBJECTS = flowps.$(OBJEXT) scoreboard.$(OBJEXT) \
+	unique_tracker.$(OBJEXT) flowps_snort.$(OBJEXT) \
+	server_stats.$(OBJEXT)
+libportscan_a_OBJECTS = $(am_libportscan_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libportscan_a_SOURCES)
+DIST_SOURCES = $(libportscan_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libportscan.a
-
 libportscan_a_SOURCES = flowps.h flowps.c \
                     scoreboard.h scoreboard.c \
                     unique_tracker.h unique_tracker.c\
                     flowps_snort.h flowps_snort.c \
                     server_stats.c server_stats.h
 
-subdir = src/preprocessors/flow/portscan
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libportscan_a_AR = $(AR) cru
-libportscan_a_LIBADD =
-am_libportscan_a_OBJECTS = flowps.$(OBJEXT) scoreboard.$(OBJEXT) \
-	unique_tracker.$(OBJEXT) flowps_snort.$(OBJEXT) \
-	server_stats.$(OBJEXT)
-libportscan_a_OBJECTS = $(am_libportscan_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libportscan_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libportscan_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/flow/portscan/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/flow/portscan/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -139,23 +202,18 @@
 	$(RANLIB) libportscan.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -164,6 +222,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -175,8 +234,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -185,19 +260,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -215,9 +292,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -229,7 +304,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -237,7 +312,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -247,7 +322,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -255,6 +330,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -270,24 +347,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/anomaly_detection/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/anomaly_detection/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/anomaly_detection/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/anomaly_detection/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/anomaly_detection
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_ad_a_AR = $(AR) $(ARFLAGS)
+libhi_ad_a_LIBADD =
+am_libhi_ad_a_OBJECTS = hi_ad.$(OBJEXT)
+libhi_ad_a_OBJECTS = $(am_libhi_ad_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_ad_a_SOURCES)
+DIST_SOURCES = $(libhi_ad_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_ad.a
-
 libhi_ad_a_SOURCES = \
 hi_ad.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/anomaly_detection
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_ad_a_AR = $(AR) cru
-libhi_ad_a_LIBADD =
-am_libhi_ad_a_OBJECTS = hi_ad.$(OBJEXT)
-libhi_ad_a_OBJECTS = $(am_libhi_ad_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_ad_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_ad_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/anomaly_detection/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/anomaly_detection/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_ad.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/client/hi_client.c snort-2.3.3.new/src/preprocessors/HttpInspect/client/hi_client.c
--- snort-2.3.3/src/preprocessors/HttpInspect/client/hi_client.c	2004-11-02 20:07:18.000000000 -0200
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/client/hi_client.c	2008-01-03 10:47:44.000000000 -0200
@@ -82,6 +82,8 @@
 */
 static LOOKUP_FCN lookup_table[256];
 static int hex_lookup[256];
+static int NextNonWhiteSpace(HI_SESSION *Session, u_char *start,
+        u_char *end, u_char **ptr, URI_PTR *uri_ptr);
 
 /*
 **  NAME
@@ -452,7 +454,7 @@
         return URI_END;
     }
 
-    return NO_URI;
+    return NextNonWhiteSpace(Session, start, end, ptr, uri_ptr);
 }
 
 /*
@@ -663,7 +665,7 @@
             (*ptr)++;
             continue;
         }
-        else if((**ptr == '\t'))
+        else if((**ptr == '\t') || (**ptr == '\r'))
         {
             if(ServerConf->apache_whitespace.on)
             {
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/client/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/client/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/client/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/client/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,146 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/client
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_client_a_AR = $(AR) $(ARFLAGS)
+libhi_client_a_LIBADD =
+am_libhi_client_a_OBJECTS = hi_client.$(OBJEXT) \
+	hi_client_norm.$(OBJEXT)
+libhi_client_a_OBJECTS = $(am_libhi_client_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_client_a_SOURCES)
+DIST_SOURCES = $(libhi_client_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_client.a
-
 libhi_client_a_SOURCES = \
 hi_client.c \
 hi_client_norm.c \
@@ -107,44 +176,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/client
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_client_a_AR = $(AR) cru
-libhi_client_a_LIBADD =
-am_libhi_client_a_OBJECTS = hi_client.$(OBJEXT) hi_client_norm.$(OBJEXT)
-libhi_client_a_OBJECTS = $(am_libhi_client_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_client_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_client_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/client/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/client/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -154,23 +218,18 @@
 	$(RANLIB) libhi_client.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -179,6 +238,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -190,8 +250,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -200,19 +276,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -230,9 +308,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -244,7 +320,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -252,7 +328,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -262,7 +338,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -270,6 +346,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -285,24 +363,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/event_output/hi_eo_log.c snort-2.3.3.new/src/preprocessors/HttpInspect/event_output/hi_eo_log.c
--- snort-2.3.3/src/preprocessors/HttpInspect/event_output/hi_eo_log.c	2004-03-11 19:25:53.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/event_output/hi_eo_log.c	2008-01-03 10:47:43.000000000 -0200
@@ -64,7 +64,9 @@
     {HI_EO_CLIENT_PROXY_USE, HI_EO_LOW_PRIORITY,
         HI_EO_CLIENT_PROXY_USE_STR },
     {HI_EO_CLIENT_WEBROOT_DIR, HI_EO_HIGH_PRIORITY,
-        HI_EO_CLIENT_WEBROOT_DIR_STR }
+        HI_EO_CLIENT_WEBROOT_DIR_STR },
+    { HI_EO_CLIENT_CR_IN_URI, HI_EO_MED_PRIORITY,
+        HI_EO_CLIENT_CR_IN_URI_STR },
 };
 
 static HI_EVENT_INFO anom_server_event_info[HI_EO_ANOM_SERVER_EVENT_NUM] = {
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/event_output/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/event_output/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/event_output/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/event_output/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/event_output
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_eo_a_AR = $(AR) $(ARFLAGS)
+libhi_eo_a_LIBADD =
+am_libhi_eo_a_OBJECTS = hi_eo_log.$(OBJEXT)
+libhi_eo_a_OBJECTS = $(am_libhi_eo_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_eo_a_SOURCES)
+DIST_SOURCES = $(libhi_eo_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_eo.a
-
 libhi_eo_a_SOURCES = \
 hi_eo_log.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/event_output
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_eo_a_AR = $(AR) cru
-libhi_eo_a_LIBADD =
-am_libhi_eo_a_OBJECTS = hi_eo_log.$(OBJEXT)
-libhi_eo_a_OBJECTS = $(am_libhi_eo_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_eo_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_eo_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/event_output/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/event_output/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_eo.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/include/hi_eo_events.h snort-2.3.3.new/src/preprocessors/HttpInspect/include/hi_eo_events.h
--- snort-2.3.3/src/preprocessors/HttpInspect/include/hi_eo_events.h	2004-03-11 19:25:53.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/include/hi_eo_events.h	2008-01-03 10:47:44.000000000 -0200
@@ -24,13 +24,14 @@
 #define HI_EO_CLIENT_LARGE_CHUNK    15  /* done */
 #define HI_EO_CLIENT_PROXY_USE      16  /* done */
 #define HI_EO_CLIENT_WEBROOT_DIR    17  /* done */
+#define HI_EO_CLIENT_CR_IN_URI      18  /* done */
 
 /*
 **  IMPORTANT:
 **  Every time you add a client event, this number must be
 **  incremented.
 */
-#define HI_EO_CLIENT_EVENT_NUM      18
+#define HI_EO_CLIENT_EVENT_NUM      19
 
 /*
 **  These defines are the alert names for each event
@@ -71,6 +72,8 @@
     "(http_inspect) UNAUTHORIZED PROXY USE DETECTED"
 #define HI_EO_CLIENT_WEBROOT_DIR_STR                    \
     "(http_inspect) WEBROOT DIRECTORY TRAVERSAL"
+#define HI_EO_CLIENT_CR_IN_URI_STR                       \
+    "(http_inspect) NON-STD CARRIAGE RETURN IN URI"
 
 /*
 **  Anomalous Server Events
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/include/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/include/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/include/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/include/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,74 +13,129 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/include
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+depcomp =
+am__depfiles_maybe =
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 EXTRA_DIST = \
 hi_ad.h \
 hi_client.h \
@@ -102,38 +157,59 @@
 hi_util_kmap.h \
 hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/include
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-depcomp =
-am__depfiles_maybe =
-DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
 all: all-am
 
 .SUFFIXES:
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/include/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/include/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 uninstall-info-am:
 tags: TAGS
 TAGS:
 
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ctags: CTAGS
+CTAGS:
 
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -151,9 +227,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -165,7 +239,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -173,7 +247,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -183,13 +257,15 @@
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -205,22 +281,31 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
 .PHONY: all all-am check check-am clean clean-generic distclean \
-	distclean-generic distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-exec \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
 	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic uninstall uninstall-am uninstall-info-am
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/Makefile.in	2005-04-23 16:47:24.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,83 +13,164 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhttp_inspect_a_AR = $(AR) $(ARFLAGS)
+libhttp_inspect_a_DEPENDENCIES = user_interface/hi_ui_config.o \
+	user_interface/hi_ui_server_lookup.o \
+	user_interface/hi_ui_iis_unicode_map.o \
+	session_inspection/hi_si.o mode_inspection/hi_mi.o \
+	anomaly_detection/hi_ad.o utils/hi_util_kmap.o \
+	utils/hi_util_xmalloc.o utils/hi_util_hbm.o \
+	event_output/hi_eo_log.o client/hi_client.o \
+	client/hi_client_norm.o server/hi_server.o \
+	normalization/hi_norm.o
+am_libhttp_inspect_a_OBJECTS =
+libhttp_inspect_a_OBJECTS = $(am_libhttp_inspect_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhttp_inspect_a_SOURCES)
+DIST_SOURCES = $(libhttp_inspect_a_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhttp_inspect.a
-
 libhttp_inspect_a_SOURCES = 
-
 SUBDIRS = include utils user_interface session_inspection mode_inspection  \
           anomaly_detection event_output server client normalization 
 
-
 libhttp_inspect_a_LIBADD = \
 user_interface/hi_ui_config.o \
 user_interface/hi_ui_server_lookup.o \
@@ -106,57 +187,38 @@
 server/hi_server.o \
 normalization/hi_norm.o 
 
-subdir = src/preprocessors/HttpInspect
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhttp_inspect_a_AR = $(AR) cru
-libhttp_inspect_a_DEPENDENCIES = user_interface/hi_ui_config.o \
-	user_interface/hi_ui_server_lookup.o \
-	user_interface/hi_ui_iis_unicode_map.o \
-	session_inspection/hi_si.o mode_inspection/hi_mi.o \
-	anomaly_detection/hi_ad.o utils/hi_util_kmap.o \
-	utils/hi_util_xmalloc.o utils/hi_util_hbm.o \
-	event_output/hi_eo_log.o client/hi_client.o \
-	client/hi_client_norm.o server/hi_server.o \
-	normalization/hi_norm.o
-am_libhttp_inspect_a_OBJECTS =
-libhttp_inspect_a_OBJECTS = $(am_libhttp_inspect_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-CFLAGS = @CFLAGS@
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-DIST_SOURCES = $(libhttp_inspect_a_SOURCES)
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
-	uninstall-info-recursive all-recursive install-data-recursive \
-	install-exec-recursive installdirs-recursive install-recursive \
-	uninstall-recursive check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
-DIST_SUBDIRS = $(SUBDIRS)
-SOURCES = $(libhttp_inspect_a_SOURCES)
-
 all: all-recursive
 
 .SUFFIXES:
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -166,7 +228,7 @@
 	$(RANLIB) libhttp_inspect.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -179,7 +241,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -191,7 +259,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -199,7 +267,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -220,17 +294,16 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
 	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -240,14 +313,23 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
@@ -256,8 +338,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -266,19 +364,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -293,15 +393,17 @@
 	    || exit 1; \
 	  fi; \
 	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
 	    (cd $$subdir && \
 	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$(top_distdir)" \
-	        distdir=../$(distdir)/$$subdir \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -311,7 +413,6 @@
 all-am: Makefile $(LIBRARIES)
 installdirs: installdirs-recursive
 installdirs-am:
-
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
@@ -323,7 +424,7 @@
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -331,7 +432,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -341,7 +442,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -349,6 +450,8 @@
 
 dvi-am:
 
+html: html-recursive
+
 info: info-recursive
 
 info-am:
@@ -364,31 +467,37 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
 uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
-	clean-generic clean-noinstLIBRARIES clean-recursive distclean \
-	distclean-compile distclean-generic distclean-recursive \
-	distclean-tags distdir dvi dvi-am dvi-recursive info info-am \
-	info-recursive install install-am install-data install-data-am \
-	install-data-recursive install-exec install-exec-am \
-	install-exec-recursive install-info install-info-am \
-	install-info-recursive install-man install-recursive \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am installdirs-recursive maintainer-clean \
-	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-recursive \
-	tags tags-recursive uninstall uninstall-am uninstall-info-am \
-	uninstall-info-recursive uninstall-recursive
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-noinstLIBRARIES clean-recursive \
+	ctags ctags-recursive distclean distclean-compile \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/mode_inspection/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/mode_inspection/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/mode_inspection/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/mode_inspection/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/mode_inspection
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_mi_a_AR = $(AR) $(ARFLAGS)
+libhi_mi_a_LIBADD =
+am_libhi_mi_a_OBJECTS = hi_mi.$(OBJEXT)
+libhi_mi_a_OBJECTS = $(am_libhi_mi_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_mi_a_SOURCES)
+DIST_SOURCES = $(libhi_mi_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_mi.a
-
 libhi_mi_a_SOURCES = \
 hi_mi.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/mode_inspection
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_mi_a_AR = $(AR) cru
-libhi_mi_a_LIBADD =
-am_libhi_mi_a_OBJECTS = hi_mi.$(OBJEXT)
-libhi_mi_a_OBJECTS = $(am_libhi_mi_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_mi_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_mi_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/mode_inspection/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/mode_inspection/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_mi.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/normalization/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/normalization/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/normalization/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/normalization/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/normalization
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_norm_a_AR = $(AR) $(ARFLAGS)
+libhi_norm_a_LIBADD =
+am_libhi_norm_a_OBJECTS = hi_norm.$(OBJEXT)
+libhi_norm_a_OBJECTS = $(am_libhi_norm_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_norm_a_SOURCES)
+DIST_SOURCES = $(libhi_norm_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_norm.a
-
 libhi_norm_a_SOURCES = \
 hi_norm.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/normalization
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_norm_a_AR = $(AR) cru
-libhi_norm_a_LIBADD =
-am_libhi_norm_a_OBJECTS = hi_norm.$(OBJEXT)
-libhi_norm_a_OBJECTS = $(am_libhi_norm_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_norm_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_norm_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/normalization/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/normalization/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_norm.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/server/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/server/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/server/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/server/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/server
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_server_a_AR = $(AR) $(ARFLAGS)
+libhi_server_a_LIBADD =
+am_libhi_server_a_OBJECTS = hi_server.$(OBJEXT)
+libhi_server_a_OBJECTS = $(am_libhi_server_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_server_a_SOURCES)
+DIST_SOURCES = $(libhi_server_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_server.a
-
 libhi_server_a_SOURCES = \
 hi_server.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/server
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_server_a_AR = $(AR) cru
-libhi_server_a_LIBADD =
-am_libhi_server_a_OBJECTS = hi_server.$(OBJEXT)
-libhi_server_a_OBJECTS = $(am_libhi_server_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_server_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_server_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/server/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/server/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_server.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/session_inspection/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/session_inspection/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/session_inspection/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/session_inspection/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,145 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/session_inspection
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_si_a_AR = $(AR) $(ARFLAGS)
+libhi_si_a_LIBADD =
+am_libhi_si_a_OBJECTS = hi_si.$(OBJEXT)
+libhi_si_a_OBJECTS = $(am_libhi_si_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_si_a_SOURCES)
+DIST_SOURCES = $(libhi_si_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_si.a
-
 libhi_si_a_SOURCES = \
 hi_si.c \
 ../include/hi_ad.h \
@@ -106,44 +174,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/session_inspection
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_si_a_AR = $(AR) cru
-libhi_si_a_LIBADD =
-am_libhi_si_a_OBJECTS = hi_si.$(OBJEXT)
-libhi_si_a_OBJECTS = $(am_libhi_si_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_si_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_si_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/session_inspection/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/session_inspection/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -153,23 +216,18 @@
 	$(RANLIB) libhi_si.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -178,6 +236,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -189,8 +248,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -199,19 +274,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -229,9 +306,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -243,7 +318,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -251,7 +326,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -261,7 +336,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -269,6 +344,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -284,24 +361,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/user_interface/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/user_interface/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/user_interface/Makefile.in	2005-04-23 16:47:25.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/user_interface/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,146 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/user_interface
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_ui_a_AR = $(AR) $(ARFLAGS)
+libhi_ui_a_LIBADD =
+am_libhi_ui_a_OBJECTS = hi_ui_config.$(OBJEXT) \
+	hi_ui_server_lookup.$(OBJEXT) hi_ui_iis_unicode_map.$(OBJEXT)
+libhi_ui_a_OBJECTS = $(am_libhi_ui_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_ui_a_SOURCES)
+DIST_SOURCES = $(libhi_ui_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_ui.a
-
 libhi_ui_a_SOURCES = \
 hi_ui_config.c \
 hi_ui_server_lookup.c \
@@ -108,45 +177,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/user_interface
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_ui_a_AR = $(AR) cru
-libhi_ui_a_LIBADD =
-am_libhi_ui_a_OBJECTS = hi_ui_config.$(OBJEXT) \
-	hi_ui_server_lookup.$(OBJEXT) hi_ui_iis_unicode_map.$(OBJEXT)
-libhi_ui_a_OBJECTS = $(am_libhi_ui_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_ui_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_ui_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/user_interface/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/user_interface/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -156,23 +219,18 @@
 	$(RANLIB) libhi_ui.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -181,6 +239,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -192,8 +251,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -202,19 +277,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -232,9 +309,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -246,7 +321,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -254,7 +329,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -264,7 +339,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -272,6 +347,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -287,24 +364,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/HttpInspect/utils/Makefile.in snort-2.3.3.new/src/preprocessors/HttpInspect/utils/Makefile.in
--- snort-2.3.3/src/preprocessors/HttpInspect/utils/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/HttpInspect/utils/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,146 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../../../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors/HttpInspect/utils
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libhi_utils_a_AR = $(AR) $(ARFLAGS)
+libhi_utils_a_LIBADD =
+am_libhi_utils_a_OBJECTS = hi_util_kmap.$(OBJEXT) \
+	hi_util_xmalloc.$(OBJEXT) hi_util_hbm.$(OBJEXT)
+libhi_utils_a_OBJECTS = $(am_libhi_utils_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libhi_utils_a_SOURCES)
+DIST_SOURCES = $(libhi_utils_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libhi_utils.a
-
 libhi_utils_a_SOURCES = hi_util_kmap.c \
 hi_util_xmalloc.c \
 hi_util_hbm.c \
@@ -107,45 +176,39 @@
 ../include/hi_util_kmap.h \
 ../include/hi_util_xmalloc.h
 
-subdir = src/preprocessors/HttpInspect/utils
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libhi_utils_a_AR = $(AR) cru
-libhi_utils_a_LIBADD =
-am_libhi_utils_a_OBJECTS = hi_util_kmap.$(OBJEXT) \
-	hi_util_xmalloc.$(OBJEXT) hi_util_hbm.$(OBJEXT)
-libhi_utils_a_OBJECTS = $(am_libhi_utils_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libhi_utils_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libhi_utils_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/utils/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/HttpInspect/utils/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -155,23 +218,18 @@
 	$(RANLIB) libhi_utils.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -180,6 +238,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -191,8 +250,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -201,19 +276,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../../../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -231,9 +308,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -245,7 +320,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -253,7 +328,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -263,7 +338,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -271,6 +346,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -286,24 +363,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/Makefile.in snort-2.3.3.new/src/preprocessors/Makefile.in
--- snort-2.3.3/src/preprocessors/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,79 +13,163 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/preprocessors
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libspp_a_AR = $(AR) $(ARFLAGS)
+libspp_a_LIBADD =
+am_libspp_a_OBJECTS = spp_arpspoof.$(OBJEXT) spp_bo.$(OBJEXT) \
+	spp_frag2.$(OBJEXT) spp_portscan.$(OBJEXT) \
+	spp_rpc_decode.$(OBJEXT) spp_stream4.$(OBJEXT) \
+	spp_telnet_negotiation.$(OBJEXT) spp_perfmonitor.$(OBJEXT) \
+	spp_conversation.$(OBJEXT) spp_portscan2.$(OBJEXT) \
+	perf.$(OBJEXT) perf-base.$(OBJEXT) perf-flow.$(OBJEXT) \
+	perf-event.$(OBJEXT) sfprocpidstats.$(OBJEXT) \
+	spp_httpinspect.$(OBJEXT) snort_httpinspect.$(OBJEXT) \
+	spp_flow.$(OBJEXT) portscan.$(OBJEXT) spp_sfportscan.$(OBJEXT) \
+	spp_xlink2state.$(OBJEXT) xlink2state.$(OBJEXT) \
+	str_search.$(OBJEXT)
+libspp_a_OBJECTS = $(am_libspp_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libspp_a_SOURCES)
+DIST_SOURCES = $(libspp_a_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libspp.a
-
 SUBDIRS = flow HttpInspect
-
 libspp_a_SOURCES = spp_arpspoof.c spp_arpspoof.h spp_bo.c spp_bo.h \
 spp_frag2.c spp_frag2.h \
 spp_portscan.c spp_portscan.h spp_rpc_decode.c spp_rpc_decode.h  \
@@ -108,60 +192,39 @@
 str_search.c str_search.h \
 stream.h
 
-subdir = src/preprocessors
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libspp_a_AR = $(AR) cru
-libspp_a_LIBADD =
-am_libspp_a_OBJECTS = spp_arpspoof.$(OBJEXT) spp_bo.$(OBJEXT) \
-	spp_frag2.$(OBJEXT) spp_portscan.$(OBJEXT) \
-	spp_rpc_decode.$(OBJEXT) spp_stream4.$(OBJEXT) \
-	spp_telnet_negotiation.$(OBJEXT) spp_perfmonitor.$(OBJEXT) \
-	spp_conversation.$(OBJEXT) spp_portscan2.$(OBJEXT) \
-	perf.$(OBJEXT) perf-base.$(OBJEXT) perf-flow.$(OBJEXT) \
-	perf-event.$(OBJEXT) sfprocpidstats.$(OBJEXT) \
-	spp_httpinspect.$(OBJEXT) snort_httpinspect.$(OBJEXT) \
-	spp_flow.$(OBJEXT) portscan.$(OBJEXT) spp_sfportscan.$(OBJEXT) \
-	spp_xlink2state.$(OBJEXT) xlink2state.$(OBJEXT) \
-	str_search.$(OBJEXT)
-libspp_a_OBJECTS = $(am_libspp_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libspp_a_SOURCES)
-
-RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
-	uninstall-info-recursive all-recursive install-data-recursive \
-	install-exec-recursive installdirs-recursive install-recursive \
-	uninstall-recursive check-recursive installcheck-recursive
-DIST_COMMON = Makefile.am Makefile.in
-DIST_SUBDIRS = $(SUBDIRS)
-SOURCES = $(libspp_a_SOURCES)
-
 all: all-recursive
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/preprocessors/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/preprocessors/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -171,16 +234,16 @@
 	$(RANLIB) libspp.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
@@ -190,7 +253,13 @@
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
 $(RECURSIVE_TARGETS):
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	target=`echo $@ | sed s/-recursive//`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
@@ -202,7 +271,7 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done; \
 	if test "$$dot_seen" = "no"; then \
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
@@ -210,7 +279,13 @@
 
 mostlyclean-recursive clean-recursive distclean-recursive \
 maintainer-clean-recursive:
-	@set fnord $$MAKEFLAGS; amf=$$2; \
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
 	dot_seen=no; \
 	case "$@" in \
 	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
@@ -231,17 +306,16 @@
 	    local_target="$$target"; \
 	  fi; \
 	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
-	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	  || eval $$failcom; \
 	done && test -z "$$fail"
 tags-recursive:
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
 	done
-
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -251,14 +325,23 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
@@ -267,8 +350,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -277,19 +376,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -304,15 +405,17 @@
 	    || exit 1; \
 	  fi; \
 	done
-	list='$(SUBDIRS)'; for subdir in $$list; do \
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -d $(distdir)/$$subdir \
-	    || mkdir $(distdir)/$$subdir \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
 	    (cd $$subdir && \
 	      $(MAKE) $(AM_MAKEFLAGS) \
-	        top_distdir="$(top_distdir)" \
-	        distdir=../$(distdir)/$$subdir \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -322,7 +425,6 @@
 all-am: Makefile $(LIBRARIES)
 installdirs: installdirs-recursive
 installdirs-am:
-
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
@@ -334,7 +436,7 @@
 installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -342,7 +444,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -352,7 +454,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-recursive
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -360,6 +462,8 @@
 
 dvi-am:
 
+html: html-recursive
+
 info: info-recursive
 
 info-am:
@@ -375,31 +479,37 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
 uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
-	clean-generic clean-noinstLIBRARIES clean-recursive distclean \
-	distclean-compile distclean-generic distclean-recursive \
-	distclean-tags distdir dvi dvi-am dvi-recursive info info-am \
-	info-recursive install install-am install-data install-data-am \
-	install-data-recursive install-exec install-exec-am \
-	install-exec-recursive install-info install-info-am \
-	install-info-recursive install-man install-recursive \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am installdirs-recursive maintainer-clean \
-	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-recursive \
-	tags tags-recursive uninstall uninstall-am uninstall-info-am \
-	uninstall-info-recursive uninstall-recursive
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-noinstLIBRARIES clean-recursive \
+	ctags ctags-recursive distclean distclean-compile \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/preprocessors/spp_stream4.c snort-2.3.3.new/src/preprocessors/spp_stream4.c
--- snort-2.3.3/src/preprocessors/spp_stream4.c	2005-04-22 16:03:56.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/spp_stream4.c	2008-01-03 10:47:44.000000000 -0200
@@ -337,7 +337,7 @@
 void PreprocCleanExitFunction(int);
 static INLINE int isBetween(u_int32_t low, u_int32_t high, u_int32_t cur);
 static INLINE int NotForStream4(Packet *p);
-static INLINE int SetFinSent(Packet *p, Session *ssn, int direction);
+static INLINE int SetFinSent(Session *ssn, int direction, u_int32_t pkt_seq, Packet *p);
 static INLINE int WithinSessionLimits(Packet *p, Stream *stream);
 
  /* helpers for dealing with session byte_counters */
@@ -1445,32 +1445,115 @@
     }
 }
 
+/**
+ * Check a FIN is valid within the window
+ *
+ * @param s stream to set the next_seq on 
+ * @param direction direction of the packet
+ * @param pkt_seq sequence number for the packet
+ * @param p packet to grab the session from
+ * 
+ * @return 0 if everything went ok
+ */
+static INLINE int CheckFin(Stream *s, int direction, u_int32_t pkt_seq, Packet *p)
+{
+    DEBUG_WRAP(DebugMessage(DEBUG_STREAM, "CheckFin() called for %s\n",
+                            direction ? "FROM_CLIENT":"FROM_SERVER"););
+
+    /* If not tracking state ignore it */
+    if( !s4data.stateful_inspection_flag )
+        return 0;
+
+    /*
+     *  We want to make sure the FIN has the next valid sequence that 
+     *  this side should be sending 
+     *  If the pkt_seq < next_seq it's essentially a duplicate 
+     *  sequence, and is probably going to be discarded, it certainly 
+     *  should be. Also, the base sequence includes the SYN sequence count.
+     *  If the packet seq is after the next seq than we should queue the 
+     *  packet for later, in case an out of order packet arrives. We 
+     *  should also honor the FIN-ACK requirements.
+     *
+     *  Ignoring a FIN implies we won't shutdown this session due to it.
+     *  
+     *  This is a standard TCP/IP stack 'in the window' check, but it's 
+     *  not always the way stacks handle FIN's:
+     *  
+     *  if(SEQ_LT(pkt_seq,s->base_seq+s->bytes_tracked) || 
+     *     SEQ_GEQ(pkt_seq,(s->last_ack+s->win_size))) 
+     *  
+     */
+    if(SEQ_LT(pkt_seq,s->base_seq+s->bytes_tracked) || 
+       SEQ_GEQ(pkt_seq,(s->last_ack+s->win_size))) 
+    {
+        DEBUG_WRAP(DebugMessage(DEBUG_STREAM, 
+                    "Bad FIN packet, bad sequence!\n"
+                    "pkt seq: 0x%X   last_ack: 0x%X  win: 0x%X\n",
+                    pkt_seq, s->last_ack, s->win_size););
+
+        /* we should probably alert here */
+        if(s4data.evasion_alerts)
+        {
+            SnortEventqAdd(GENERATOR_SPP_STREAM4, /* GID */
+                    STREAM4_EVASIVE_FIN, /* SID */
+                    1,                      /* Rev */
+                    0,                      /* classification */
+                    3,                      /* priority (low) */
+                    STREAM4_EVASIVE_FIN_STR, /* msg string */
+                    0);
+        }
+        return 1;
+    }
+    return 0;
+}
+
+
 /** 
  * Set that this side of the session has sent a fin.
  *
  * This overloads the next_seq variable to also be used to tell how
  * far forward we can acknowledge data.
  * 
- * @param p packet to grab the session from
  * @param s stream to set the next_seq on 
+ * @param direction direction of the packet
+ * @param pkt_seq sequence number for the packet
+ * @param p packet to grab the session from
  * 
  * @return 0 if everything went ok
  */
-static INLINE int SetFinSent(Packet *p, Session *ssn, int direction)
+static INLINE int SetFinSent(Session *ssn, int direction, u_int32_t pkt_seq, Packet *p)
 {
     Stream *stream;
 
     DEBUG_WRAP(DebugMessage(DEBUG_STREAM, "SetFinSet() called for %s\n",
                             direction ? "FROM_CLIENT":"FROM_SERVER"););
 
+    /* If not tracking state ignore it */
+    if( !s4data.stateful_inspection_flag )
+        return 0;
+
     if(direction == FROM_SERVER)
-    {
+    {        
         stream = &ssn->server;
+        DEBUG_WRAP(DebugMessage(DEBUG_STREAM,"--RST From Server!\n"););
+    }
+    else
+    {        
+        stream = &ssn->client;
+        DEBUG_WRAP(DebugMessage(DEBUG_STREAM,"--RST From Client!\n"););
+    }
+
+    if (CheckFin(stream, direction, pkt_seq, p))
+    {
+        return 0;
+    }
+
+    if(direction == FROM_SERVER)
+    {
         ssn->session_flags |= SSNFLAG_SERVER_FIN;
     }
     else
     {
-        stream = &ssn->client;
         ssn->session_flags |= SSNFLAG_CLIENT_FIN;
     }
     
@@ -2188,14 +2271,6 @@
 
     direction = GetDirection(ssn, p);
 
-    if(p->tcph->th_flags & TH_FIN)
-    {
-        DEBUG_WRAP(DebugMessage(DEBUG_STREAM, 
-                    "Marking that a fin was was sent %s\n",
-                    (direction ? "FROM_CLIENT" : "FROM_SERVER")););
-        SetFinSent(p, ssn, direction);
-    }
-
     if(direction == FROM_SERVER)
     {
         ssn->session_flags |= SSNFLAG_SEEN_SERVER;
@@ -2230,6 +2305,15 @@
                     "   %s state: %s\n", l, state_names[listener->state]););
     }
 
+    if(p->tcph->th_flags & TH_FIN)
+    {
+        DEBUG_WRAP(DebugMessage(DEBUG_STREAM, 
+                    "Marking that a fin was was sent %s\n",
+                    (direction ? "FROM_CLIENT" : "FROM_SERVER")););
+
+        SetFinSent(ssn, direction, pkt_seq, p);
+    }
+
     StreamSegmentAdd(talker, p->dsize); 
 
     if(talker->state == ESTABLISHED)
@@ -2332,10 +2416,13 @@
 
             if((p->tcph->th_flags & TH_FIN) == TH_FIN)
             {
-                talker->state = FIN_WAIT_1;
-                DEBUG_WRAP(DebugMessage(DEBUG_STREAM_STATE,  
-                            "   %s Transition: FIN_WAIT_1\n", t););
-                QueueState(CLOSE_WAIT, listener, TH_ACK, pkt_seq, CHK_SEQ);
+                if (!CheckFin(talker, direction, pkt_seq, p))
+                {
+                    talker->state = FIN_WAIT_1;
+                    DEBUG_WRAP(DebugMessage(DEBUG_STREAM_STATE,  
+                                "   %s Transition: FIN_WAIT_1\n", t););
+                    QueueState(CLOSE_WAIT, listener, TH_ACK, pkt_seq, CHK_SEQ);
+                }
             }
 
             break;
diff -Naur snort-2.3.3/src/preprocessors/xlink2state.c snort-2.3.3.new/src/preprocessors/xlink2state.c
--- snort-2.3.3/src/preprocessors/xlink2state.c	2005-04-23 16:18:29.000000000 -0300
+++ snort-2.3.3.new/src/preprocessors/xlink2state.c	2008-01-03 10:47:44.000000000 -0200
@@ -41,7 +41,7 @@
 
 /* Pointer to current session data */
 XLINK2STATE *_xlink;
-static u_int       _xlink2state_ports[65535];
+static u_int       _xlink2state_ports[65536];
 static u_int       _xlink2state_disabled = 0;
 static u_int       _xlink2state_drop = 0;
 static Packet      *_xlink2state_pkt = NULL;
@@ -70,9 +70,6 @@
     /*  Set up commands we will watch for */
     SearchInit(1);
     
-    /*  Set up commands we will watch for */
-    SearchInit(1);
-    
     SearchAdd(0, "X-LINK2STATE", 0);
     
     SearchPrepPatterns(0);
diff -Naur snort-2.3.3/src/rna_alg.c snort-2.3.3.new/src/rna_alg.c
--- snort-2.3.3/src/rna_alg.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_alg.c	2008-02-18 14:30:29.000000000 -0300
@@ -0,0 +1,840 @@
+#include <math.h>
+#include "rna_alg.h"
+#define Act_Logistic(sum, bias)  ( (sum+bias<10000.0) ? ( 1.0/(1.0 + exp(-sum-bias) ) ) : 0.0 )
+#define Act_Identity(sum, bias)     ( sum )
+#define NULL (void *)0
+  /* Forward Declaration for all unit types */
+  UnitType Units[77];
+  /* Sources definition section */
+  pUnit Sources[] =  {
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, 
+Units + 11, Units + 12, Units + 13, Units + 14, Units + 15, Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, 
+Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, 
+Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, 
+Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+Units + 16, Units + 17, Units + 18, Units + 19, Units + 20, Units + 21, Units + 22, Units + 23, Units + 24, Units + 25, 
+Units + 26, Units + 27, Units + 28, Units + 29, Units + 30, Units + 31, Units + 32, Units + 33, Units + 34, Units + 35, 
+Units + 36, Units + 37, Units + 38, Units + 39, Units + 40, Units + 41, Units + 42, Units + 43, Units + 44, Units + 45, 
+Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, 
+Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, 
+Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, Units + 72, Units + 73, Units + 74, Units + 75, Units + 76, 
+
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+Units + 46, 
+
+  };
+
+  /* Weigths definition section */
+  float Weights[] =  {
+0.723810, 0.661560, -0.657720, 0.335960, 0.085490, -0.144330, 0.050500, -0.258010, 0.752620, -0.265510, 
+0.403410, -0.368120, 0.019000, -0.006560, -0.626930, 0.541860, 0.235100, -0.747080, 0.248810, -0.987540, 
+0.505410, 0.361850, 0.357750, -0.243250, -0.960320, -0.493380, -0.798170, 0.568970, 0.787810, -0.763300, 
+0.969780, 0.630550, -0.846450, 0.141230, 0.772630, -0.623160, 0.620860, 0.030860, 0.840520, 0.063110, 
+0.751960, -0.403610, -0.495280, -0.962170, 0.534100, 
+-0.105650, -0.606010, -0.063910, 0.566970, -0.467370, 0.456830, 0.051940, 0.706710, -0.424190, -0.115530, 
+0.570690, -0.070470, -0.946430, -0.250080, 0.173560, -0.614100, -0.998990, -0.991820, -0.746030, 0.372370, 
+-0.722170, 0.808570, 0.909770, 0.622340, 0.705360, -0.776260, -0.646140, -0.214340, -0.332940, 0.929410, 
+0.155930, 0.743380, 0.477520, 0.173020, 0.024410, 0.138370, -0.071580, 0.620320, 0.352450, -0.851480, 
+-0.459370, -0.835810, -0.331430, 0.933460, -0.894840, 
+-0.243540, -0.407260, -0.161890, -0.960460, -0.650710, 0.707930, -0.818270, 0.503880, 0.536170, 0.942020, 
+0.404150, 0.065620, -0.324560, 0.822770, 0.861020, -0.223950, 0.885250, -0.382420, 0.797520, 0.050240, 
+-0.635010, 0.584520, 0.216860, -0.937740, -0.040290, -0.150370, -0.673940, -0.109660, 0.769640, 0.888580, 
+-0.267870, 0.548830, 0.816570, 0.220920, -0.713570, 0.599940, 0.340160, 0.881710, -0.963820, 0.692110, 
+-0.731920, 0.737930, -0.067890, 0.513680, 0.932190, 
+0.202080, -0.910520, -0.451380, 0.547930, 0.629910, -0.169990, 0.220730, -0.282450, 0.315960, 0.442520, 
+0.646970, 0.475110, -0.341320, 0.284430, 0.623590, 0.363140, 0.985290, -0.682170, -0.768500, -0.584590, 
+-0.647340, 0.784550, -0.617680, 0.170970, -0.193680, 0.637860, -0.860150, 0.170300, 0.176240, -0.086380, 
+-0.316170, 0.095600, -0.760400, -0.882000, 0.547660, 0.765040, -0.010950, 0.050870, -0.557880, -0.925780, 
+-0.522390, -0.957980, -0.400440, -0.238310, -0.723100, 
+0.373400, -0.970570, 0.722290, 0.211860, 0.842570, 0.851870, -0.111230, -0.816790, -0.428970, -0.932300, 
+-0.216110, 0.173400, -0.288600, 0.308320, -0.168780, 0.829640, 0.149130, -0.580880, -0.900210, -0.568400, 
+-0.598370, -0.386390, -0.100500, -0.121740, 0.093730, 0.119130, 0.871300, 0.208190, -0.590120, 0.981510, 
+0.902910, -0.981640, -0.953340, -0.384140, -0.637090, 0.708870, 0.236580, 0.236100, -0.172690, 0.485660, 
+0.285970, -0.095020, -0.443000, -0.638210, 0.260430, 
+0.443980, -0.211770, -0.286400, 0.068560, 0.299320, -0.025690, -0.697750, 0.298760, -0.105370, -0.446670, 
+-0.619490, -0.924080, -0.873840, 0.859240, -0.961080, 0.928640, 0.643140, -0.979900, 0.716790, 0.008430, 
+-0.798250, -0.064830, -0.034100, -0.723290, -0.489510, -0.493370, 0.453510, 0.596780, 0.091790, 0.308040, 
+0.579510, 0.053340, -0.993500, -0.814050, -0.847320, 0.309820, 0.324140, 0.773440, 0.848580, -0.969890, 
+0.731350, -0.217680, -0.973860, -0.880690, -0.740710, 
+-0.583040, -0.926480, 0.735730, -0.189740, 0.723950, 0.524720, 0.946850, -0.966010, -0.293010, 0.896770, 
+-0.175100, -0.487950, -0.868250, 0.198360, -0.754950, 0.185220, -0.742390, 0.876500, 0.513080, -0.771300, 
+-0.690730, -0.838650, -0.963380, -0.471420, -0.941580, 0.942260, 0.427630, 0.500830, 0.825310, 0.215010, 
+0.961050, 0.003390, -0.040530, -0.147920, -0.887760, -0.916370, 0.698520, -0.947640, -0.263180, 0.302690, 
+-0.521880, 0.481830, 0.821560, -0.786840, -0.387720, 
+0.015170, 0.141800, -0.803150, 0.867940, 0.288460, -0.054720, -0.595980, -0.987990, 0.760540, -0.808440, 
+0.737820, 0.590800, -0.830600, 0.042250, -0.804260, 0.803920, 0.880880, -0.966140, 0.920980, -0.476080, 
+-0.089930, -0.477440, 0.449620, 0.795320, 0.005380, 0.955240, 0.180220, -0.115590, 0.648200, -0.717560, 
+-0.395430, 0.461760, 0.786150, -0.639100, 0.396280, -0.726310, -0.802950, -0.165490, -0.395830, 0.522240, 
+-0.071680, -0.063550, 0.152520, 0.128710, 0.969650, 
+-0.771010, 0.145910, 0.059560, -0.789680, -0.892360, -0.183220, -0.922750, 0.841020, -0.563270, 0.705780, 
+0.142510, -0.022080, -0.539540, 0.741560, -0.095160, 0.854430, -0.886990, -0.207810, 0.768920, -0.518410, 
+0.170920, -0.562940, 0.490490, 0.792550, -0.768160, -0.821510, 0.930580, -0.797610, 0.527950, -0.981250, 
+-0.737810, 0.503200, 0.015250, 0.053400, -0.852860, -0.171240, -0.037900, 0.084720, 0.537460, 0.527030, 
+-0.519180, 0.618680, 0.378500, 0.471510, 0.785830, 
+0.641170, -0.167930, -0.790110, -0.731340, -0.751420, -0.453410, -0.132330, -0.399530, 0.342870, -0.417310, 
+-0.936410, -0.996860, 0.420350, -0.751880, 0.657310, 0.102350, 0.723500, 0.151740, -0.881470, 0.636630, 
+0.012360, 0.481040, 0.607160, 0.443170, 0.537270, 0.029030, 0.183200, -0.136670, -0.510680, 0.554760, 
+-0.796850, 0.432920, -0.521280, -0.420080, -0.969310, 0.847080, 0.723540, 0.009860, 0.831200, -0.266990, 
+-0.929850, -0.307830, -0.011540, 0.449500, 0.001800, 
+-0.205800, 0.584300, 0.048560, -0.412100, -0.200350, -0.251030, -0.587890, -0.565520, -0.961640, 0.235140, 
+-0.822370, -0.561110, 0.335020, -0.184100, -0.972520, -0.205100, 0.325110, 0.415820, -0.278530, -0.327670, 
+0.373920, 0.505430, 0.846340, 0.924530, 0.071300, -0.310520, 0.116790, 0.740910, 0.371030, 0.113390, 
+-0.652480, 0.463910, 0.459770, 0.489330, -0.249280, -0.712710, -0.340240, 0.053380, 0.373380, -0.157590, 
+0.523860, -0.294170, -0.557460, -0.972240, -0.703340, 
+-0.657300, -0.478110, -0.338840, 0.889550, -0.520830, -0.054760, -0.703190, -0.868070, -0.366140, -0.447430, 
+0.519510, -0.079490, 0.367840, 0.166350, 0.049220, 0.617550, 0.377400, 0.375700, 0.674980, 0.930370, 
+-0.483420, -0.750450, -0.908710, 0.425740, -0.264580, -0.319180, 0.939510, 0.684170, 0.285670, 0.070580, 
+-0.726020, -0.841690, -0.112560, 0.802310, -0.374210, 0.057290, -0.659830, -0.658400, -0.567020, -0.943780, 
+-0.662590, 0.466720, -0.753920, 0.263970, 0.394560, 
+-0.790700, 0.408250, 0.690020, -0.019080, -0.789510, 0.169610, -0.524740, -0.188580, 0.722880, 0.213170, 
+0.515640, 0.668330, 0.224710, 0.801610, -0.165010, -0.943660, -0.224600, 0.431800, -0.039330, 0.568680, 
+0.512690, -0.123190, -0.189830, 0.613990, -0.928050, -0.498970, 0.260850, -0.308100, 0.585050, 0.251670, 
+0.330160, -0.569600, 0.759120, -0.483490, -0.783000, 0.608990, -0.469960, -0.667650, -0.538010, -0.584520, 
+-0.794590, 0.545540, -0.566480, -0.043050, 0.727630, 
+0.235060, -0.534000, -0.780920, -0.868100, -0.013360, -0.476120, -0.464260, 0.664230, -0.419870, 0.140390, 
+-0.175220, -0.508880, 0.795580, -0.256490, 0.201920, 0.084650, 0.152050, 0.070050, 0.374270, 0.399530, 
+-0.079280, 0.976480, -0.175700, 0.112210, 0.424610, -0.873410, 0.867060, -0.955100, -0.896750, -0.814070, 
+0.993320, 0.314610, -0.414170, -0.678240, -0.041320, -0.858830, 0.158970, 0.215100, -0.563220, -0.371960, 
+-0.328520, -0.449740, 0.464590, -0.146210, -0.933810, 
+-0.728290, 0.701670, 0.885270, -0.794770, -0.110230, 0.860520, 0.607990, 0.247600, -0.804550, 0.293110, 
+0.690940, 0.734550, 0.154550, 0.487700, 0.757470, 0.610000, -0.386000, 0.386570, -0.572380, 0.162840, 
+-0.858840, -0.368990, 0.791880, -0.737760, 0.349620, -0.815470, -0.697670, 0.829130, 0.744340, 0.332000, 
+0.666720, 0.727940, -0.122380, 0.826750, 0.016120, 0.085840, -0.941810, 0.381910, -0.113940, -0.677470, 
+0.616890, -0.190170, -0.743630, 0.606380, -0.482270, 
+0.736520, -0.334850, -0.927080, -0.073730, -0.229690, 0.927360, -0.087000, 0.916700, 0.066610, -0.019390, 
+-0.130010, 0.525090, -0.912380, -0.906130, 0.734620, -0.168710, 0.180950, -0.190380, -0.372040, -0.046920, 
+-0.405990, -0.604120, -0.416550, -0.428790, 0.548110, -0.040530, 0.714490, 0.546890, 0.774390, -0.774930, 
+0.580540, 0.255460, 0.547720, 0.255010, 0.064740, -0.490180, -0.957180, 0.708620, -0.155360, -0.580210, 
+0.506710, -0.302450, 0.963340, 0.105730, 0.366370, 
+-0.573210, -0.179970, 0.879090, 0.855990, -0.779810, -0.387690, 0.332200, 0.740120, -0.883610, -0.125010, 
+-0.142060, -0.596200, 0.309790, -0.252760, -0.611180, -0.563610, 0.528740, 0.217130, -0.452600, 0.753800, 
+-0.266840, 0.655960, -0.982000, -0.318580, -0.398780, 0.000650, 0.420980, -0.084500, -0.145160, 0.697970, 
+-0.503200, 0.997120, -0.420980, -0.618080, -0.379290, 0.836450, -0.877190, -0.626650, 0.709500, -0.661270, 
+0.391260, 0.723820, -0.603000, -0.518700, 0.405530, 
+-0.524220, 0.395810, 0.595940, 0.055320, 0.245660, -0.414180, 0.499430, -0.086060, 0.251710, 0.584390, 
+-0.864680, -0.284300, 0.262830, 0.780360, 0.839350, 0.407260, 0.780030, 0.171770, 0.651910, -0.326910, 
+-0.077240, 0.428580, 0.890610, -0.224030, -0.942950, -0.650620, 0.883980, -0.418430, 0.875200, 0.422110, 
+-0.239660, -0.119950, -0.818720, -0.786400, 0.938060, -0.836030, 0.454450, 0.913570, -0.862100, 0.494610, 
+0.174540, 0.095700, 0.266380, -0.414040, -0.431710, 
+0.513040, 0.197600, 0.998730, -0.648520, -0.240920, 0.165230, -0.722170, -0.502700, 0.330250, 0.334670, 
+0.557670, 0.660250, 0.985710, 0.495550, 0.657960, 0.396320, -0.707380, 0.833150, 0.795110, 0.032020, 
+0.415000, -0.363670, 0.943030, -0.833840, 0.498080, -0.614010, 0.358830, -0.652240, -0.697570, -0.850720, 
+0.923830, -0.285140, -0.529450, 0.459330, -0.049690, -0.901460, 0.091710, -0.044010, -0.978860, -0.196550, 
+-0.123930, 0.971650, 0.801520, 0.113130, 0.156010, 
+0.270770, 0.104070, 0.737050, -0.060230, -0.084760, -0.344360, 0.192420, -0.157130, -0.377880, 0.705660, 
+0.996780, 0.023160, -0.745950, -0.031660, -0.489650, 0.999450, 0.457860, -0.381130, 0.854740, -0.524970, 
+-0.856530, 0.845610, 0.077500, 0.456530, -0.844820, -0.907910, 0.949330, 0.655260, 0.468710, -0.668420, 
+-0.684560, -0.052670, 0.836760, -0.413610, 0.471350, 0.168890, 0.632040, 0.112730, -0.548850, 0.123970, 
+0.113910, 0.736630, -0.820790, -0.800600, 0.233830, 
+-0.805660, -0.682070, -0.963700, 0.449100, -0.886730, 0.692040, -0.921410, 0.787660, -0.397970, -0.481510, 
+-0.298880, 0.149640, 0.810690, -0.128470, -0.961630, -0.573000, -0.136550, 0.222520, -0.863940, 0.279260, 
+0.914030, 0.007620, -0.039750, -0.478200, -0.040830, 0.445750, 0.610960, -0.356190, 0.798760, -0.818710, 
+0.753800, -0.469640, -0.499070, -0.989180, 0.925050, -0.295620, -0.422300, 0.528580, -0.645940, 0.728230, 
+0.451320, -0.819470, -0.082500, -0.577320, -0.061300, 
+0.601300, -0.529230, 0.356560, 0.341040, 0.748320, -0.513360, -0.817000, -0.349110, -0.828330, 0.853640, 
+0.098680, 0.199020, 0.896840, -0.878190, 0.996760, -0.639810, 0.027750, -0.626780, 0.334440, 0.090390, 
+-0.877740, -0.807440, 0.945510, -0.985140, 0.286500, -0.523850, 0.442280, -0.552200, -0.964300, -0.204880, 
+0.662090, -0.806710, 0.332900, 0.834160, 0.546870, -0.191760, 0.123180, 0.041410, 0.686880, 0.582310, 
+0.639240, 0.035520, -0.367400, 0.342120, 0.118220, 
+-0.994440, -0.954770, -0.060440, -0.566700, 0.008680, 0.518140, 0.726340, 0.040890, 0.983130, 0.049290, 
+0.835390, -0.298970, -0.875990, 0.689170, -0.129910, 0.393320, -0.609000, -0.202330, -0.370880, -0.082780, 
+-0.974060, 0.668360, 0.493010, -0.301710, -0.367790, 0.180450, 0.396820, 0.600510, 0.702460, 0.151310, 
+0.530850, -0.593020, -0.844040, -0.570580, 0.141660, -0.432600, -0.086030, -0.956600, 0.657590, 0.144490, 
+0.797090, 0.813910, 0.066750, 0.202870, 0.158750, 
+0.715820, -0.141220, -0.315620, -0.033590, 0.773410, -0.459320, -0.309200, -0.347520, 0.455280, 0.573430, 
+0.502640, 0.502600, 0.066030, -0.736530, -0.576230, -0.520110, 0.036960, 0.597770, -0.292430, -0.211490, 
+0.407690, -0.368910, -0.953830, -0.056830, -0.023580, 0.643830, 0.080390, 0.453580, 0.091660, -0.565860, 
+0.779540, 0.661940, 0.017560, 0.397500, 0.788630, -0.970920, 0.458000, 0.835040, -0.865760, 0.777440, 
+-0.726640, 0.174390, -0.018010, 0.019110, 0.116250, 
+0.243820, 0.340930, -0.618650, 0.759300, -0.854640, -0.152900, 0.029350, -0.102510, 0.195080, 0.809790, 
+0.360280, 0.528240, -0.700780, -0.754740, 0.956950, -0.342960, 0.439210, -0.103060, -0.555870, -0.980780, 
+0.893440, -0.493680, -0.390350, 0.286730, 0.025400, -0.118260, -0.939970, -0.915670, -0.984560, -0.434910, 
+0.534270, 0.739730, 0.099270, -0.082780, 0.358620, -0.533730, 0.864490, 0.857380, 0.125700, 0.881380, 
+0.786050, -0.571340, 0.846230, -0.551760, -0.116340, 
+-0.813180, 0.236240, -0.734370, -0.350110, -0.243080, 0.765810, 0.007630, 0.760670, 0.405590, -0.809480, 
+-0.370040, 0.517630, -0.782580, -0.093880, -0.740160, -0.086170, -0.509510, 0.031270, -0.477090, -0.960730, 
+-0.308000, -0.107360, -0.105710, 0.827110, 0.938930, 0.039540, -0.289700, 0.273700, -0.925430, 0.825900, 
+0.390810, 0.647680, 0.383370, 0.888390, -0.238540, 0.702540, 0.145580, -0.952100, -0.521480, -0.659830, 
+0.776320, 0.690900, -0.247220, -0.986580, 0.261480, 
+0.037960, 0.973210, 0.768300, 0.321370, 0.631230, -0.081000, 0.396860, -0.864730, 0.780250, -0.074360, 
+0.318680, 0.183270, 0.473060, 0.512040, 0.071050, 0.248230, -0.546490, -0.057430, -0.495820, 0.900620, 
+-0.997630, -0.846590, -0.920280, 0.366690, 0.669270, 0.357580, 0.298150, 0.644960, 0.138320, 0.333920, 
+-0.355680, 0.828360, 0.757740, 0.268900, -0.435910, 0.812470, 0.016660, 0.732460, -0.187540, -0.524090, 
+-0.405420, -0.223070, -0.038280, -0.975070, -0.185940, 
+0.746170, -0.608580, 0.163610, -0.467220, -0.234410, 0.350270, -0.038090, -0.703620, 0.297590, 0.600520, 
+-0.222730, -0.035560, -0.326500, 0.101310, 0.381840, 0.343500, -0.635090, -0.278420, -0.390360, -0.826210, 
+0.968490, -0.384110, 0.854580, 0.527750, 0.689930, -0.161460, -0.600230, 0.734970, 0.975770, -0.595510, 
+0.176280, -0.741860, 0.435410, -0.714880, 0.099700, 0.717080, -0.785630, 0.640180, -0.721170, 0.515050, 
+-0.685690, -0.672640, 0.283010, 0.952150, -0.859890, 
+-0.307370, 0.450270, -0.573400, -0.345200, -0.774570, 0.027180, 0.619140, 0.733630, -0.218840, -0.616960, 
+0.984020, 0.720130, -0.778290, -0.221840, 0.478580, -0.957110, 0.241540, -0.109260, 0.400620, -0.643610, 
+-0.622220, -0.537120, -0.903750, -0.405270, 0.377560, 0.986360, -0.938020, -0.768970, -0.857960, 0.734890, 
+-0.343600, 0.817430, -0.030780, -0.936960, -0.247310, -0.867150, -0.576070, 0.279980, -0.709880, -0.828890, 
+0.899200, 0.630620, -0.169700, 0.247530, 0.417230, 
+-0.430680, 0.147160, 0.650890, 0.608810, 0.212110, 0.591540, -0.665640, -0.251760, 0.272370, 0.652000, 
+-0.269900, -0.916330, 0.845020, -0.372800, -0.975960, 0.147240, 0.035930, 0.861080, -0.909850, -0.970550, 
+-0.133790, 0.875920, 0.818560, -0.511620, 0.800940, -0.926340, -0.771310, -0.553690, 0.759410, -0.428530, 
+-0.502720, -0.750110, -0.417430, -0.039930, -0.245910, 0.869080, 0.259690, -0.124410, 0.233480, 0.010790, 
+-0.367640, 0.119460, 0.611360, -0.666130, -0.469080, 
+-0.908460, 0.620030, -0.911110, 0.192440, -0.485250, 0.074700, 0.413980, -0.130550, 0.949010, 0.628970, 
+-0.373260, 0.908410, -0.705990, -0.514130, -0.917980, -0.456610, 0.573710, -0.733810, 0.701150, 0.602720, 
+-0.373330, -0.330720, 0.413420, 0.774490, 0.023910, 0.098660, 0.191450, -0.787350, 0.837590, -0.673570, 
+0.150420, 0.076150, -0.330970, -0.284770, -0.183320, 0.682400, 0.350130, -0.853700, 0.516840, -0.105050, 
+-0.132600, -0.154750, 0.473670, 0.241940, 0.697720, -0.674160, 0.919080, -0.242130, -0.762830, 0.103060, 
+-0.134900, -0.567700, -0.838270, -0.581680, -0.653420, -0.196090, -0.834520, 0.577230, 0.420260, -0.879520, 
+
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+1.000000, 
+
+  };
+
+  /* unit definition section (see also UnitType) */
+  UnitType Units[77] = 
+  {
+    { 0.0, 0.0, 0, NULL , NULL },
+    { /* unit 1 (Entrada) */
+      0.0, -1.000000, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 2 (Entrada) */
+      0.0, -0.998030, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 3 (Entrada) */
+      0.0, -0.916740, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 4 (Entrada) */
+      0.0, -0.646710, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 5 (Entrada) */
+      0.0, -0.270800, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 6 (Entrada) */
+      0.0, -0.817340, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 7 (Entrada) */
+      0.0, -0.815400, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 8 (Entrada) */
+      0.0, -0.025570, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 9 (Entrada) */
+      0.0, 0.053500, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 10 (Entrada) */
+      0.0, -0.091130, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 11 (Entrada) */
+      0.0, -0.533640, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 12 (Entrada) */
+      0.0, 0.662580, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 13 (Entrada) */
+      0.0, 0.863460, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 14 (Entrada) */
+      0.0, 0.136120, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 15 (Entrada) */
+      0.0, 0.112190, 0,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 16 (Oculta) */
+      0.0, -0.898340, 45,
+       &Sources[0] , 
+       &Weights[0] , 
+      },
+    { /* unit 17 (Oculta) */
+      0.0, 0.538440, 45,
+       &Sources[45] , 
+       &Weights[45] , 
+      },
+    { /* unit 18 (Oculta) */
+      0.0, 0.456880, 45,
+       &Sources[90] , 
+       &Weights[90] , 
+      },
+    { /* unit 19 (Oculta) */
+      0.0, -0.162570, 45,
+       &Sources[135] , 
+       &Weights[135] , 
+      },
+    { /* unit 20 (Oculta) */
+      0.0, 0.028180, 45,
+       &Sources[180] , 
+       &Weights[180] , 
+      },
+    { /* unit 21 (Oculta) */
+      0.0, 0.689140, 45,
+       &Sources[225] , 
+       &Weights[225] , 
+      },
+    { /* unit 22 (Oculta) */
+      0.0, 0.449400, 45,
+       &Sources[270] , 
+       &Weights[270] , 
+      },
+    { /* unit 23 (Oculta) */
+      0.0, -0.153330, 45,
+       &Sources[315] , 
+       &Weights[315] , 
+      },
+    { /* unit 24 (Oculta) */
+      0.0, 0.318870, 45,
+       &Sources[360] , 
+       &Weights[360] , 
+      },
+    { /* unit 25 (Oculta) */
+      0.0, -0.914860, 45,
+       &Sources[405] , 
+       &Weights[405] , 
+      },
+    { /* unit 26 (Oculta) */
+      0.0, -0.479760, 45,
+       &Sources[450] , 
+       &Weights[450] , 
+      },
+    { /* unit 27 (Oculta) */
+      0.0, 0.454120, 45,
+       &Sources[495] , 
+       &Weights[495] , 
+      },
+    { /* unit 28 (Oculta) */
+      0.0, 0.747750, 45,
+       &Sources[540] , 
+       &Weights[540] , 
+      },
+    { /* unit 29 (Oculta) */
+      0.0, 0.385990, 45,
+       &Sources[585] , 
+       &Weights[585] , 
+      },
+    { /* unit 30 (Oculta) */
+      0.0, 0.407150, 45,
+       &Sources[630] , 
+       &Weights[630] , 
+      },
+    { /* unit 31 (Oculta) */
+      0.0, 0.683510, 45,
+       &Sources[675] , 
+       &Weights[675] , 
+      },
+    { /* unit 32 (Oculta) */
+      0.0, 0.891370, 45,
+       &Sources[720] , 
+       &Weights[720] , 
+      },
+    { /* unit 33 (Oculta) */
+      0.0, 0.398220, 45,
+       &Sources[765] , 
+       &Weights[765] , 
+      },
+    { /* unit 34 (Oculta) */
+      0.0, -0.593820, 45,
+       &Sources[810] , 
+       &Weights[810] , 
+      },
+    { /* unit 35 (Oculta) */
+      0.0, 0.983790, 45,
+       &Sources[855] , 
+       &Weights[855] , 
+      },
+    { /* unit 36 (Oculta) */
+      0.0, -0.889570, 45,
+       &Sources[900] , 
+       &Weights[900] , 
+      },
+    { /* unit 37 (Oculta) */
+      0.0, -0.272660, 45,
+       &Sources[945] , 
+       &Weights[945] , 
+      },
+    { /* unit 38 (Oculta) */
+      0.0, 0.120790, 45,
+       &Sources[990] , 
+       &Weights[990] , 
+      },
+    { /* unit 39 (Oculta) */
+      0.0, -0.843440, 45,
+       &Sources[1035] , 
+       &Weights[1035] , 
+      },
+    { /* unit 40 (Oculta) */
+      0.0, -0.085500, 45,
+       &Sources[1080] , 
+       &Weights[1080] , 
+      },
+    { /* unit 41 (Oculta) */
+      0.0, -0.810170, 45,
+       &Sources[1125] , 
+       &Weights[1125] , 
+      },
+    { /* unit 42 (Oculta) */
+      0.0, -0.434070, 45,
+       &Sources[1170] , 
+       &Weights[1170] , 
+      },
+    { /* unit 43 (Oculta) */
+      0.0, -0.491010, 45,
+       &Sources[1215] , 
+       &Weights[1215] , 
+      },
+    { /* unit 44 (Oculta) */
+      0.0, -0.986560, 45,
+       &Sources[1260] , 
+       &Weights[1260] , 
+      },
+    { /* unit 45 (Oculta) */
+      0.0, 0.725040, 45,
+       &Sources[1305] , 
+       &Weights[1305] , 
+      },
+    { /* unit 46 (Saida) */
+      0.0, 0.830130, 60,
+       &Sources[1350] , 
+       &Weights[1350] , 
+      },
+    { /* unit 47 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1410] , 
+       &Weights[1410] , 
+      },
+    { /* unit 48 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1411] , 
+       &Weights[1411] , 
+      },
+    { /* unit 49 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1412] , 
+       &Weights[1412] , 
+      },
+    { /* unit 50 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1413] , 
+       &Weights[1413] , 
+      },
+    { /* unit 51 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1414] , 
+       &Weights[1414] , 
+      },
+    { /* unit 52 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1415] , 
+       &Weights[1415] , 
+      },
+    { /* unit 53 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1416] , 
+       &Weights[1416] , 
+      },
+    { /* unit 54 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1417] , 
+       &Weights[1417] , 
+      },
+    { /* unit 55 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1418] , 
+       &Weights[1418] , 
+      },
+    { /* unit 56 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1419] , 
+       &Weights[1419] , 
+      },
+    { /* unit 57 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1420] , 
+       &Weights[1420] , 
+      },
+    { /* unit 58 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1421] , 
+       &Weights[1421] , 
+      },
+    { /* unit 59 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1422] , 
+       &Weights[1422] , 
+      },
+    { /* unit 60 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1423] , 
+       &Weights[1423] , 
+      },
+    { /* unit 61 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1424] , 
+       &Weights[1424] , 
+      },
+    { /* unit 62 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1425] , 
+       &Weights[1425] , 
+      },
+    { /* unit 63 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1426] , 
+       &Weights[1426] , 
+      },
+    { /* unit 64 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1427] , 
+       &Weights[1427] , 
+      },
+    { /* unit 65 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1428] , 
+       &Weights[1428] , 
+      },
+    { /* unit 66 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1429] , 
+       &Weights[1429] , 
+      },
+    { /* unit 67 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1430] , 
+       &Weights[1430] , 
+      },
+    { /* unit 68 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1431] , 
+       &Weights[1431] , 
+      },
+    { /* unit 69 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1432] , 
+       &Weights[1432] , 
+      },
+    { /* unit 70 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1433] , 
+       &Weights[1433] , 
+      },
+    { /* unit 71 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1434] , 
+       &Weights[1434] , 
+      },
+    { /* unit 72 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1435] , 
+       &Weights[1435] , 
+      },
+    { /* unit 73 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1436] , 
+       &Weights[1436] , 
+      },
+    { /* unit 74 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1437] , 
+       &Weights[1437] , 
+      },
+    { /* unit 75 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1438] , 
+       &Weights[1438] , 
+      },
+    { /* unit 76 (Oculta_Esp) */
+      0.0, 0.500000, 1,
+       &Sources[1439] , 
+       &Weights[1439] , 
+      }
+
+  };
+
+
+
+int Rna_alg(float *in, float *out, int init)
+{
+  int member, source;
+  float sum;
+  enum{OK, Error, Not_Valid};
+  pUnit unit;
+
+
+  /* layer definition section (names & member units) */
+
+  pUnit Input[15] = {Units + 1, Units + 2, Units + 3, Units + 4, Units + 5, Units + 6, Units + 7, Units + 8, Units + 9, Units + 10, Units + 11, Units + 12, Units + 13, Units + 14, Units + 15}; /* members */
+
+  pUnit Hidden1[30] = {Units + 16, Units + 17, Units + 18, Units + 19, Units + 20, Units + 21, Units + 22, Units + 23, Units + 24, Units + 25, Units + 26, Units + 27, Units + 28, Units + 29, Units + 30, Units + 31, Units + 32, Units + 33, Units + 34, Units + 35, Units + 36, Units + 37, Units + 38, Units + 39, Units + 40, Units + 41, Units + 42, Units + 43, Units + 44, Units + 45}; /* members */
+
+  pUnit Output1[1] = {Units + 46}; /* members */
+
+  pUnit Special1[30] = {Units + 47, Units + 48, Units + 49, Units + 50, Units + 51, Units + 52, Units + 53, Units + 54, Units + 55, Units + 56, Units + 57, Units + 58, Units + 59, Units + 60, Units + 61, Units + 62, Units + 63, Units + 64, Units + 65, Units + 66, Units + 67, Units + 68, Units + 69, Units + 70, Units + 71, Units + 72, Units + 73, Units + 74, Units + 75, Units + 76}; /* members */
+
+  static int Output[1] = {46};
+
+  for(member = 0; member < 15; member++) {
+    Input[member]->act = in[member];
+  }
+
+  for (member = 0; member < 30; member++) {
+    unit = Hidden1[member];
+    sum = 0.0;
+    for (source = 0; source < unit->NoOfSources; source++) {
+      sum += unit->sources[source]->act
+             * unit->weights[source];
+    }
+    unit->act = Act_Logistic(sum, unit->Bias);
+  };
+
+  for (member = 0; member < 1; member++) {
+    unit = Output1[member];
+    sum = 0.0;
+    for (source = 0; source < unit->NoOfSources; source++) {
+      sum += unit->sources[source]->act
+             * unit->weights[source];
+    }
+    unit->act = Act_Logistic(sum, unit->Bias);
+  };
+
+  for (member = 0; member < 30; member++) {
+    unit = Special1[member];
+    sum = 0.0;
+    for (source = 0; source < unit->NoOfSources; source++) {
+      sum += unit->sources[source]->act
+             * unit->weights[source];
+    }
+    unit->act = Act_Logistic(sum, unit->Bias);
+  };
+
+  for(member = 0; member < 1; member++) {
+    out[member] = Units[Output[member]].act;
+  }
+
+  return(OK);
+}
diff -Naur snort-2.3.3/src/rna_alg.h snort-2.3.3.new/src/rna_alg.h
--- snort-2.3.3/src/rna_alg.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_alg.h	2008-02-17 20:36:14.000000000 -0300
@@ -0,0 +1,25 @@
+/*********************************************************
+  5_100_1.h
+  --------------------------------------------------------
+  generated at Wed Jan  9 21:30:26 2008
+  by snns2c ( Bernward Kett 1995 ) 
+*********************************************************/
+
+extern int Rna_alg(float *in, float *out, int init);
+
+static struct {
+  int NoOfInput;    /* Number of Input Units  */
+  int NoOfOutput;   /* Number of Output Units */
+  int(* propFunc)(float *, float*, int);
+} Rna_algREC = {15,1,Rna_alg};
+
+typedef struct UT {
+          float act;         /* Activation       */
+          float Bias;        /* Bias of the Unit */
+          int   NoOfSources; /* Number of predecessor units */
+   struct UT   **sources; /* predecessor units */
+          float *weights; /* weights from predecessor units */
+        } UnitType, *pUnit;
+
+extern UnitType Units[];
+extern float Weights[];
diff -Naur snort-2.3.3/src/rna.c snort-2.3.3.new/src/rna.c
--- snort-2.3.3/src/rna.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna.c	2008-02-18 14:34:49.000000000 -0300
@@ -0,0 +1,277 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <time.h>
+
+#include "snort.h"
+#include "detect.h"
+#include "plugbase.h"
+#include "debug.h"
+#include "util.h"
+#include "mstring.h"
+#include "tag.h"
+#include "pcrm.h"
+#include "fpcreate.h"
+#include "fpdetect.h"
+#include "sfthreshold.h"
+#include "event_wrapper.h"
+#include "event_queue.h"
+#include "stream.h"
+#include "rna.h"
+#include "rna_alg.h"
+
+#ifdef GIDS
+#include "inline.h"
+#endif /* GIDS */
+
+// extern function definition, it's in define_values
+extern int LoadNetworkValues();
+
+// struct to ip
+typedef struct _my_ip{
+   int seg_1;
+   int seg_2;
+   int seg_3;
+   int seg_4;
+} my_ip;
+
+// transform a ip to a double number
+double ip_to_double(struct in_addr ip)
+{
+   char *point = inet_ntoa(ip);
+   int ret[4]={ 0 , 0 , 0 }, i=0;
+   double retorno=0.0;
+   while( (*point) != '\0')
+   {
+      if ( (*point) == '.')
+      {
+         i++;
+      }else{
+            ret[i]*=10;
+            ret[i]+=(*point)-48;
+      }
+      point++;
+   }
+   retorno = ( ( (ret[0])*1000.0+ret[1] )*1000.0 +ret[2] )*1000.0 +ret[3];
+   return retorno;
+}
+
+// function to complete ip address in struct my_ip
+my_ip *get_ip_part(struct in_addr ip)
+{
+  my_ip *ip_part = (my_ip*) malloc(sizeof(my_ip));
+  unsigned long ip_comp = inet_addr(inet_ntoa(ip));
+  ip_part->seg_1 = (ip_comp)&0xFF;
+  ip_part->seg_2 = (ip_comp>>8)&0xFF;
+  ip_part->seg_3 = (ip_comp>>16)&0xFF;
+  ip_part->seg_4 = (ip_comp>>24)&0xFF;
+
+  //DEBUG   printf("%d.%d.%d.%d\n",ip_part.seg_1,ip_part.seg_2,ip_part.seg_3,ip_part.seg_4);
+  return ip_part;
+}
+
+// function that answer which protocol is being used
+char * which_protocol(int protocolo)
+{
+   switch(protocolo)
+   {
+      case IPPROTO_TCP:
+         return "tcp";
+         break;
+
+      case IPPROTO_UDP:
+         return "udp";
+         break;
+
+      case IPPROTO_ICMP:
+         return "icmp";
+         break;
+
+      case ETHERNET_TYPE_IP:
+         return "ip";
+         break;
+
+      default:
+         return "other";
+         break;
+   }
+}
+
+// write some data at terminal
+void write_dados(Packet *p,my_ip *ip_origem,my_ip *ip_destino)
+{
+   printf("Protocol: %s\n",which_protocol(p->iph->ip_proto));
+   printf("Source: %d.%d.%d.%d\n",ip_origem->seg_1,ip_origem->seg_2,ip_origem->seg_3,ip_origem->seg_4);
+   printf("Dest: %d.%d.%d.%d\n",ip_destino->seg_1,ip_destino->seg_2,ip_destino->seg_3,ip_destino->seg_4);
+   printf("Ports:\n\tSource: %d\n\tDest: %d\n\tSource(datagram): %d\n\tDest(datagram): %d\n",
+           p->sp,p->dp,p->orig_sp,p->orig_dp);
+   printf("CheckSum: %d\n",p->csum_flags);
+   printf("PacketFlags: %d\n",p->packet_flags);
+   printf("version & header length: %d\n", p->iph->ip_verhl);
+   printf("type of service: %d\n",p->iph->ip_tos);
+   printf("datagram length: %d\n",p->iph->ip_len);
+   printf("identification: %d\n",p->iph->ip_id);
+   printf("fragment offset: %d\n",p->iph->ip_off);
+   printf("time to live field: %d\n",p->iph->ip_ttl);
+   printf("datagram protocol: %d\n",p->iph->ip_proto);
+   printf("checksum: %d\n",p->iph->ip_csum);
+   if ( !strcmp( which_protocol(p->iph->ip_proto), "tcp" ) )
+      printf("TCP th_off is %d, passed len is %% lu\n",TCP_OFFSET(p->tcph)/*, (unsigned long)len*/);
+   printf("\n");
+}
+
+// write data at terminal lines to be open at oocalc
+void write_csv(Packet *p,my_ip *ip_origem, my_ip *ip_destino)
+{
+   printf("\"%s\",",which_protocol(p->iph->ip_proto));
+   printf("\"%d.%d.%d.%d\",",ip_origem->seg_1,ip_origem->seg_2,ip_origem->seg_3,ip_origem->seg_4);
+   printf("\"%d.%d.%d.%d\",",ip_destino->seg_1,ip_destino->seg_2,ip_destino->seg_3,ip_destino->seg_4);
+   printf("\"%d\",\"%d\",\"%d\",\"%d\",",p->sp,p->dp,p->orig_sp,p->orig_dp);
+   printf("\"%d\",",p->csum_flags);
+   printf("\"%d\",",p->packet_flags);
+   printf("\"%d\",",p->iph->ip_verhl);
+   printf("\"%d\",",p->iph->ip_tos);
+   printf("\"%d\",",p->iph->ip_len);
+   printf("\"%d\",",p->iph->ip_id);
+   printf("\"%d\",",p->iph->ip_off);
+   printf("\"%d\",",p->iph->ip_ttl);
+   printf("\"%d\",",p->iph->ip_proto);
+   printf("\"%d\"",p->iph->ip_csum);
+}
+
+// write a snns pattern in terminal
+void write_snns_pattern(float *in, int size, FILE *file)
+{
+   int i=1;
+   fprintf(file,"%d",(int)in[0]);
+   while(i<size)
+   {
+      fprintf(file,"\t%d",(int)in[i++]);
+   }
+   fprintf(file,"\t0\n");
+}
+
+// Call the ANN (RNA) and detect attacks
+void Test_with_rna(Packet *p,float *in)
+{
+   int ret_rna;
+   float *out = (float *)malloc(Rna_algREC.NoOfInput * sizeof(float));
+   ret_rna = Rna_alg(in, out, 0);
+   if (pv.verbose_flag) LogMessage("RNA: %f\n",*out);
+
+   if (pv.rna.type == 4)
+   {
+       if (*out > pv.rna.answer)
+       {
+           pv.rna.answer = *out;
+           LogMessage("New bigger answer: %f\n",pv.rna.answer);
+       }
+   }
+   else if (*out >= pv.rna.attack)
+   {
+       // at future, left th user choice the message
+      char message[100];
+      strcpy(message,"Attack");
+      CallAlertPlugins(p, message, NULL, NULL);
+      pc.alert_pkts++;
+
+      LogMessage("\n======== ATTACK ========\n");
+      LogMessage("| [%4s] rna(%1.6f) |\n",which_protocol(p->iph->ip_proto),*out);
+      LogMessage("\\======================/\n");
+   }
+}
+
+// control the flux, called by ProcessPacket in mais program
+void Rna(Packet *p)
+{
+   my_ip *ip_origem, *ip_destino;
+
+   float *in = (float *)malloc(Rna_algREC.NoOfInput * sizeof(float));
+   struct in_addr ip_src,ip_dst; // They are: u_int32_t
+
+   if (p->iph == NULL)
+      return;
+      ip_src = p->iph->ip_src;
+      ip_dst = p->iph->ip_dst;
+
+//     FOR HELP IN FUTURE IMPLEMENTATION
+//     puts(inet_ntoa(ip_src));
+//     ip_to_double(ip_src);
+//     ip_to_double(ip_dst);
+//     inet_netof(ip_src);
+//     printf("Ips: %.0lf -> %.0lf %d\n",in[1],in[2],ntohl(inet_addr(inet_ntoa(ip_src))));
+//     PrintIPPkt(stdout, p->iph->ip_proto, p);
+//     PrintCharData(stdout, (char*) p->data, p->dsize);
+//     Print2ndHeader(stdout,p);
+//     PrintEthHeader(stdout,p);
+//     PrintIPHeader(stdout,p);
+//     PrintTCPHeader(stdout,p);
+//     PrintUDPHeader(stdout,p);
+//     PrintICMPHeader(stdout,p); 
+//     printf("\tSIZE  %d\n", p->dsize);
+
+        in[0]  = p->iph->ip_proto;
+//      printf("\npegando IP src\n");
+        ip_origem=get_ip_part(ip_src);
+        in[1] = ip_origem->seg_1;
+        in[2] = ip_origem->seg_2;
+        in[3] = ip_origem->seg_3;
+        in[4] = ip_origem->seg_4;
+
+//	printf("\npegando IP dst\n");
+        ip_destino=get_ip_part(ip_dst);
+        in[5] = ip_destino->seg_1;
+        in[6] = ip_destino->seg_2;
+        in[7] = ip_destino->seg_3;
+        in[8] = ip_destino->seg_4;
+
+//
+        in[9]  = p->iph->ip_ttl;
+        in[10] = p->iph->ip_len;
+        in[11] = p->iph->ip_id;
+        in[12] = p->iph->ip_csum;
+
+   if(p->sp)
+   {
+      in[13] = p->sp;
+      in[14] = p->dp;
+   }else{
+      in[13] = p->orig_sp;
+      in[14] = p->orig_dp;
+   }
+
+   switch (pv.rna.type)
+   {
+       case 1:
+       case 4:
+            if (!pv.rna.net_loaded) //weights and bias were loaded?
+            {
+                    /* LoadNetworkValues exit 0 means no error, another is the error number */
+                    if (LoadNetworkValues() == 0)
+                    {
+                        LogMessage("Neural network loaded.\n");
+                        pv.rna.net_loaded = 1;
+                    }
+                    else
+                    {
+                        FatalError("Neural Network couldn't be loaded!\n");
+                    }
+            }
+            Test_with_rna(p,in);
+            break;
+       case 2:
+            write_snns_pattern(in,15,pv.rna.train_file);
+            pv.rna.num_patterns++;
+            LogMessage("%d patterns colleted...\n",pv.rna.num_patterns);
+            break;
+   }
+}
diff -Naur snort-2.3.3/src/rna_functions.h snort-2.3.3.new/src/rna_functions.h
--- snort-2.3.3/src/rna_functions.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_functions.h	2008-02-05 15:18:07.000000000 -0200
@@ -0,0 +1,70 @@
+/******************************************************************************
+  FILE           : $Source: /usr/local/bv/SNNS/SNNSv4.1/tools/sources/RCS/functions.h,v $
+  SHORTNAME      : functions.h
+  SNNS VERSION   : 4.1
+
+  PURPOSE        : Function-Table for snns2c.c
+  
+  AUTHOR         : Bernward Kett
+  DATE           : 31.08.94
+
+  CHANGED BY     : Bernward Kett
+  IDENTIFICATION : $State: Exp $ $Locker:  $
+  RCS VERSION    : $Revision: 1.7 $
+  LAST CHANGE    : $Date: 1995/11/16 07:20:16 $
+
+             Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+  
+  used files     : glob_typ.h, kr_ui.h      from kernel/sources
+                   libkernel.a              from kernel/bin/<architecture>
+                   functions.h, templates.h from actual directory
+******************************************************************************/
+  
+/* Number of the first Radial-Basis-Function is needed because */
+/* they need different arguments                               */
+#define ActRbfNumber 14
+
+char *ACT_FUNC_NAMES[]= { "Act_Logistic",
+                          "Act_Elliott", 
+                          "Act_BSB", 
+                          "Act_TanH",
+                          "Act_TanHPlusBias",
+                          "Act_TanH_Xdiv2", 
+                          "Act_Perceptron",
+                          "Act_Signum",
+                          "Act_Signum0",
+                          "Act_StepFunc",
+                          "Act_Identity",
+                          "Act_IdentityPlusBias",
+                          "Act_TD_Logistic",
+	      		  "Act_TD_Elliott",
+                          "Act_RBF_Gaussian",
+                          "Act_RBF_MultiQuadratic",
+                          "Act_RBF_ThinPlateSpline",
+	       		  "",
+                         };
+
+
+char *ACT_FUNCTIONS[] = {
+"#define Act_Logistic(sum, bias)  ( (sum+bias<10000.0) ? ( 1.0/(1.0 + exp(-sum-bias) ) ) : 0.0 )",
+"#define Act_Elliott(sum, bias) ( (sum+bias>0) ? (sum+bias)/(1.0+sum+bias) : (sum+bias)/(1.0-sum-bias) )",
+"#define Act_BSB(sum, bias)          ( sum * bias )",
+"#define Act_TanH(sum, bias)         ( tanh(sum + bias) )",
+"#define Act_TanHPlusBias(sum, bias) ( tanh(sum + bias) )",
+"#define Act_TanH_Xdiv2(sum, bias)   ( tanh( (sum + bias) / 2) )",
+"#define Act_Perceptron(sum, bias)   ( (sum >= bias) ? 1.0 : 0.0)",
+"#define Act_Signum(sum, bias)       ( (sum > 0.0) ? 1.0 : -1.0 )",
+"#define Act_Signum0(sum, bias)      ( (sum == 0.0) ? 0.0 : ActSignum(sum, bias) )",
+"#define Act_StepFunc(sum, bias)     ( (sum > 0.0) ? 1.0 : 0.0)",
+"#define Act_Identity(sum, bias)     ( sum )",
+"#define Act_IdentityPlusBias(sum, bias) (sum + bias)",
+"#define Act_TD_Logistic(sum, bias)     ( 1.0/(1 + exp(-sum-bias) ) )",
+"#define Act_TD_Elliott(sum, bias) ( (sum+bias>0) ? (sum+bias)/(1.0+sum+bias) : (sum+bias)/(1.0-sum-bias) )", 
+"#define Act_RBF_Gaussian(sum2, bias)    (exp(-sum2 * bias) )",
+"#define Act_RBF_MultiQuadratic(sum2, bias) (sqrt(sum2 + bias) )",
+"#define Act_RBF_ThinPlateSpline(sum2, bias) (bias*bias*sum2*(0.5*log(sum2) + log(bias)))",
+};
+
+
+/* not used (yet) */
+typedef float (*tActFunc)(float, float);
diff -Naur snort-2.3.3/src/rna.h snort-2.3.3.new/src/rna.h
--- snort-2.3.3/src/rna.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna.h	2008-02-17 20:35:54.000000000 -0300
@@ -0,0 +1,7 @@
+
+#ifndef __RNA__
+#define __RNA__
+
+void Rna(Packet *p);
+
+#endif /*RNA*/
diff -Naur snort-2.3.3/src/rna_lib.c snort-2.3.3.new/src/rna_lib.c
--- snort-2.3.3/src/rna_lib.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_lib.c	2008-02-05 15:18:07.000000000 -0200
@@ -0,0 +1,365 @@
+/*****************************************************************************
+  FILE           : $Source: /usr/local/bv/SNNS/SNNSv4.1/tools/sources/RCS/snns2clib.c,v $
+  SHORTNAME      : snns2clib.c
+  SNNS VERSION   : 4.1
+
+  PURPOSE        : a Set Type with all needed applications
+
+  AUTHOR         : Berward Kett
+  DATE           : 30.01.95
+
+  CHANGED BY     : Michael Vogt
+  IDENTIFICATION : $State: Exp $ $Locker:  $
+  RCS VERSION    : $Revision: 1.5 $
+  LAST CHANGE    : $Date: 1995/11/16 07:22:02 $
+
+             Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+
+******************************************************************************/
+
+#define NULL (void *)0
+#include <stdlib.h>
+#include <string.h>
+#include "glob_typ.h"
+
+#define LIST_BLOCK_SIZE 10
+
+/* Status (Error) Codes : OK = 0 (NO Error), ERR = 1, ...  */
+typedef enum { OK, ERR, CANT_ADD, CANT_LOAD, MEM_ERR,
+		   WRONG_PARAM, WRONG_ACT_FUNC, CANT_OPEN,
+		   ILLEGAL_CYCLES, NO_CPN} Status;
+
+/* Recordtype for Lists (Sets) */
+typedef struct {
+  int place;			/* No of Elements wich can be hold in the list */
+  int no;			/* No of actual Elements in the list           */
+  int *values;			/* Pointer to the Elements                     */
+} tList, *pList;
+
+#define NoOf(list) list->no
+#define element(list, no) list->values[no]
+
+/******************************************************************************
+  pList newList(void)
+  -----------------------------------------------------------------------------
+  makes a new, empty List
+  <- Pointer to the new list or NULL if an error occurs
+  ******************************************************************************/
+pList newList(void)
+{
+  pList list;
+
+  list = (pList)malloc(sizeof(tList) );
+  if (NULL == list) {
+    return (NULL);
+  }
+  list->values = (int *)malloc(LIST_BLOCK_SIZE * sizeof(int) );
+  if (list->values == NULL) {
+    free(list);
+    return(NULL);
+  }
+  list->place = LIST_BLOCK_SIZE;
+  list->no    = 0;
+  return(list);
+}
+
+
+/*****************************************************************************
+  void killList(pList list)
+  ----------------------------------------------------------------------------
+  kills a list and releases memory
+  
+  -> pointer to the list
+  *****************************************************************************/
+void killList(pList list)
+{
+  free(list->values);
+  free(list);
+}
+
+
+/*****************************************************************************
+  int copyList(pList dest, pList source)
+  ----------------------------------------------------------------------------
+  copies the sources list in the dest list
+  ->  source : original List;
+  <-> dest   : destination List;
+  <- (func) MEM_ERR : error occurs, dest leaves unchanged
+  OK      : no problems
+  *****************************************************************************/
+int copyList(pList dest, pList source)
+{
+  int *newValues;
+ 
+  newValues = (int *)malloc(source->place * sizeof(int) );
+  if (!newValues) return(MEM_ERR);
+  memcpy(newValues, source->values, NoOf(source) * sizeof(int) );
+
+  free(dest->values);
+
+  dest->no     = source->no;
+  dest->place  = source->place;
+  dest->values = newValues;
+  return(OK);
+}
+
+
+/******************************************************************************
+  int searchList(pList list, int member)
+  -----------------------------------------------------------------------------
+  searches an item in a list and returns the closest position. 
+  e.g. if it is in the list it returns the position of the item,
+  otherwise the position where it should be inserted
+  if you only want to check if the item is member of the list use
+  isMember()
+  
+  -> list   : pointer to the list
+  member : item, wich is searched in the list
+  <- (func) position of the item if it exist
+  ******************************************************************************/
+int searchList(pList list, int member)
+{
+  int low, high, pos = 0;
+  low = 0;
+  high = list->no -1;
+
+  if (list->no == 0) {		/* empty list                  */
+    list->values[0] = ++member;	/* must not be equal to member */
+    return(0);
+  }
+
+  while (high > low) {
+    pos = (high + low) / 2;	/* binary search because the values are sorted */
+    if (member > list->values[pos]) {
+      low = pos + 1;		/* in this order, you get the place were    */
+    } /* member should be inserted if not present */
+    else if (member < list->values[pos]) {
+      high = pos;
+    }
+    else {
+      return(pos);
+    }
+  }
+  return(high); 
+}
+
+
+/*****************************************************************************
+  int isMember(pList list, int member)
+  ----------------------------------------------------------------------------
+  checks, if member is part of a list
+  
+  -> list   : pointer to the list
+  member : member wich is to be removed
+  <- TRUE if it is member and FALSE otherwise
+  *****************************************************************************/  
+bool isMember(pList list, int member)
+{
+  int pos;
+  pos = searchList(list, member);
+  return(list->values[pos] == member);
+}
+
+
+/*****************************************************************************
+  int addList(pList list, int member)
+  ----------------------------------------------------------------------------
+  inserts a new member in a list and reserves new memory if needed
+  
+  -> list   : pointer to the list
+  member : new member, wich must be added
+  <- (func)   (OK)       no problems
+  (CANT_ADD) not enough memory for another element
+  *****************************************************************************/ 
+int addList(pList list, int member)
+{
+  int *oldptr, pos, j;
+  pos = searchList(list, member);
+  if (element(list, pos) == member) return(OK); /* no double entries         */
+
+  if (list->no == list->place) { /* e.g. more space is needed */
+    oldptr = list->values;
+    list->place += LIST_BLOCK_SIZE;
+    list->values = (int *)realloc( list->values, list->place * sizeof (int) );
+    if (list->values == NULL) {	/* no more space available   */
+      list->place -= LIST_BLOCK_SIZE; /* restore old state         */
+      list->values = oldptr;
+      return(CANT_ADD);
+    }
+  }
+  
+  if (list->values[list->no - 1] < member) {
+    pos = list->no;		/* so append at the end */
+  }
+  for (j = list->no; j > pos; j--) { /* making place for new entry */
+    list->values[j] = list->values[j-1];    
+  }
+  list->values[pos] = member;
+  (list->no)++;
+
+  return (OK);			/* everything all right       */
+}
+
+
+/*****************************************************************************
+  void remList(pList list, int member)
+  ----------------------------------------------------------------------------
+  removes an item from a list if the item exists in it. Otherwise nothing
+  happens. Releases also unneeded memory.
+  
+  -> list   : pointer to the list
+  member : member wich is to be removed
+  *****************************************************************************/
+void remList(pList list, int member)
+{
+  int i, pos;
+  pos = searchList(list, member); /* search for (possible) position */
+  if (member == list->values[pos]) { /* really a member ?              */
+    for (i = pos; i < list->no - 1; i++) { /* shift all following members    */
+      list->values[i] = list->values[i+1];
+    }
+    (list->no)--;		/* loosed one member */
+  }
+  
+  if (list->no < list->place - LIST_BLOCK_SIZE) { /* release unneeded memory */
+    list->place -= LIST_BLOCK_SIZE;
+    list->values = (int *)realloc(list->values, list->place *sizeof(int) );
+  }
+}
+
+
+/*****************************************************************************
+  void intersectList(pList dest, pList source)
+  ----------------------------------------------------------------------------
+  puts the intersection of dest and sources into dest
+  ->  sources : unchanged list
+  <-> dest    : list wich contains the intersection after intersect list 
+  *****************************************************************************/
+void intersectList(pList dest, pList source)
+{
+  int i = 0, j;
+  while (i < NoOf(dest) ) {
+    if (!isMember(source, element(dest, i) ) ) {
+      ( NoOf(dest) )--;
+      for (j = i; j < NoOf(dest); j++) { /* kill element by overwrite */
+        element(dest, j) = element(dest, j + 1);
+      }	/* so the same place must be checked */
+    }
+    else {
+      i++;			/* element found, so check next one */
+    }
+  }
+}
+
+
+/*****************************************************************************
+  int haveIntersection(pList list1, pList list2)
+  ----------------------------------------------------------------------------
+  checks if list1 and list2 have an identical member
+  -> list1, list2 : Lists wich will be checked
+  <- (func)  TRUE  : they have
+  FALSE : they haven't
+*****************************************************************************/
+bool haveIntersection(pList list1, pList list2)
+{
+  int i;
+  for(i = 0; i < NoOf(list1); i++) {
+    if (isMember(list2, element(list1, i) ) ) return (TRUE);
+  }
+  return (FALSE);
+}
+
+
+/*****************************************************************************
+  int mergeList(pList destList, pList sourcesList)
+  ----------------------------------------------------------------------------
+  puts all members of sourceList in destList
+  -> source     : unchanged List
+  <-> destList  : List wich contains all Elements after 'mergeList'
+  <-  (func)  (OK)       no problems
+  (MEM_ERR)  not enough memory for another element
+  *****************************************************************************/
+int mergeList(pList dest, pList source)
+{
+  int   sc = 0, dc = 0, bc = 0; /* counters for source, dest, big */
+  pList big;                    /* list for all Elements          */
+  int   *old, place;            /* helppointer and needed memory  */
+
+  big = newList();              /* create new List */
+  if (!big) return(MEM_ERR);
+
+  /** allocate (maximum)Memory for the new List **/
+  place = NoOf(source) + NoOf(dest);
+  /* align to LIST_BLOCK_SIZE */
+  place = ( (place / LIST_BLOCK_SIZE) + 1) * LIST_BLOCK_SIZE;
+  old = big->values;
+  big->place  = place;
+  big->values = (int *)realloc(big->values, place * sizeof (int) );
+  if (big->values == NULL) {
+    big->values = old;		/* for killing the whole list */
+    killList(big);
+    return(MEM_ERR);
+  }
+
+  while ( (sc < NoOf(source) ) && (dc < NoOf(dest) ) )
+      {
+	if ( element(source, sc) < element(dest, dc) ) {
+	  element(big, bc++) = element(source, sc++);
+	}
+	else {
+	  element(big, bc++) = element(dest, dc++);
+	  /* if elements of dource and dest were equal */
+	  if (element(source, sc) == element(big, bc -1) ) sc++;
+	}
+
+      }
+
+  /* now only one list may have elements */
+  while (sc < NoOf(source) ) {
+    element(big, bc++) = element(source, sc++);
+  }
+  while (dc < NoOf(dest) ) {
+    element(big, bc++) = element(dest, dc++);
+  }
+
+  big->no = bc;
+
+  while (NoOf(big) + LIST_BLOCK_SIZE < big->place) {
+    big->place -= LIST_BLOCK_SIZE;
+    big->values = (int *)realloc(big->values, big->place * sizeof(int) );
+  }
+ 
+  /* move contens of big in dest */
+  free(dest->values);
+  dest->values = big->values;
+  dest->no     = big->no;
+  dest->place  = big->place;  
+  free(big);
+
+  return(OK);
+}
+
+/****************************************************************************
+  int CompareSources( pList dest, pList source)
+ ----------------------------------------------------------------------------
+  compares two sources sets 1 = equal
+*****************************************************************************/
+
+int CompareSources( pList dest, pList source)
+{
+  int i = 0;
+  while (i < NoOf(dest) ){
+    if (!isMember(source, element(dest, i) ) )
+      return 0;
+    i++;
+  }
+
+  i = 0;
+  while (i < NoOf(source) ){
+    if (!isMember(dest, element(source, i) ) )
+      return 0;
+    i++;
+  }
+  
+  return 1;
+}
diff -Naur snort-2.3.3/src/rna_lib.h snort-2.3.3.new/src/rna_lib.h
--- snort-2.3.3/src/rna_lib.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_lib.h	2008-02-05 15:18:07.000000000 -0200
@@ -0,0 +1,41 @@
+/*****************************************************************************
+  FILE           : $Source: /usr/local/bv/SNNS/SNNSv4.1/tools/sources/RCS/snns2clib.h,v $
+  SHORTNAME      : snns2clib.h
+  SNNS VERSION   : 4.1
+
+  PURPOSE        : Headerfile for including the snns2c-library
+
+  AUTHOR         : Berward Kett
+  DATE           : 30.01.95
+
+  CHANGED BY     : Michael Vogt
+  IDENTIFICATION : $State: Exp $ $Locker:  $
+  RCS VERSION    : $Revision: 1.3 $
+  LAST CHANGE    : $Date: 1995/11/16 07:22:03 $
+
+             Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+
+******************************************************************************/
+
+/* Recordtype for Lists (Sets) */
+
+typedef struct {
+  int place;			/* No of Elements wich can be hold in the list */
+  int no;			/* No of actual Elements in the list           */
+  int *values;			/* Pointer to the Elements                     */
+} tList, *pList;
+
+#define NoOf(list) list->no
+#define element(list, no) list->values[no]
+
+extern pList newList(void);                      /* creates a new set */
+extern void  killList(pList list);               /* deletes a set     */
+extern int   copyList(pList dest, pList source); /* copies a set      */
+extern int   searchList(pList list, int member); /* searches for a member */
+extern int   isMember(pList list, int member);   /* checks if member is element of list */
+extern int   addList(pList list, int member);    /* adds a new element */
+extern void  remList(pList list, int member);    /* removes an element */
+extern void  intersectList(pList dest, pList source); /* calculates the intersection */
+extern int   haveIntersection(pList list1, pList list2); /* does intersection exists */
+extern int   mergeList(pList dest, pList source); /* calculates the union of two sets */
+extern int   CompareSources( pList dest, pList source); /* compares two elements, wether their sources are the same */
diff -Naur snort-2.3.3/src/rna_templates.h snort-2.3.3.new/src/rna_templates.h
--- snort-2.3.3/src/rna_templates.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_templates.h	2008-02-05 15:18:07.000000000 -0200
@@ -0,0 +1,310 @@
+/******************************************************************************
+  FILE           : $Source: /usr/local/bv/SNNS/SNNSv4.1/tools/sources/RCS/templates.h,v $
+  SHORTNAME      : templates.h
+  SNNS VERSION   : 4.1
+
+  PURPOSE        : Templates for snns2c.c
+  
+  AUTHOR         : Bernward Kett
+  DATE           : 31.08.94
+
+  CHANGED BY     : Bernward Kett
+  IDENTIFICATION : $State: Exp $ $Locker:  $
+  RCS VERSION    : $Revision: 1.5 $
+  LAST CHANGE    : $Date: 1995/11/16 07:22:31 $
+
+             Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+  
+  used files     : glob_typ.h, kr_ui.h      from kernel/sources
+                   libkernel.a              from kernel/bin/<architecture>
+                   functions.h, templates.h from actual directory
+******************************************************************************/
+
+#define HeadingTemplate ""\
+"============================================================\n"\
+"   snns2c by Bernward Kett (1995)\n"\
+"============================================================\n"\
+"   converts %s to %s \n"\
+"   Function-Name %s \n"\
+"============================================================\n"
+
+#define HeaderFileTemplate ""\
+"/*********************************************************\n"\
+"  %s\n"\
+"  --------------------------------------------------------\n"\
+"  generated at %s  by snns2c ( Bernward Kett 1995 ) \n"\
+"*********************************************************/\n\n"\
+"extern int %s(float *in, float *out, int init);\n\n"\
+"static struct {\n"\
+"  int NoOfInput;    /* Number of Input Units  */\n"\
+"  int NoOfOutput;   /* Number of Output Units */\n"\
+"  int(* propFunc)(float *, float*, int);\n"\
+"} %sREC = {%d,%d,%s};\n"
+
+#define ProgHeader ""\
+"/*********************************************************\n"\
+"  %s\n"\
+"  --------------------------------------------------------\n"\
+"  generated at %s  by snns2c ( Bernward Kett 1995 ) \n"\
+"*********************************************************/\n\n"\
+"#include <math.h>\n\n"
+ 
+
+#define ProcHeader ""\
+"\n\nint %s(float *in, float *out, int init)\n"\
+"{\n  int member, source;\n"\
+"  float sum;\n"\
+"  enum{OK, Error, Not_Valid};\n"\
+
+#define TypeTemplate "\n"\
+"typedef struct UT {\n"\
+"          float act;         /* Activation       */\n"\
+"          float Bias;        /* Bias of the Unit */\n"\
+"          int   NoOfSources; /* Number of predecessor units */\n"\
+"   struct UT   **sources; /* predecessor units */\n"\
+"          float *weights; /* weights from predecessor units */\n"\
+"        } UnitType, *pUnit;\n\n"
+
+#define InputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    Input[member]->act = in[member];\n  }\n\n"
+
+#define OutputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    out[member] = Units[Output[member]].act;\n  }\n\n"
+
+#define NormalTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    unit = %s[member];\n"\
+"    sum = 0.0;\n"\
+"    for (source = 0; source < unit->NoOfSources; source++) {\n"\
+"      sum += unit->sources[source]->act\n"\
+"             * unit->weights[source];\n"\
+"    }\n"\
+"    unit->act = %s(sum, unit->Bias);\n"\
+"  };\n\n"
+
+#define RbfTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    unit = %s[member];\n"\
+"    sum = 0.0;\n"\
+"    for (source = 0; source < unit->NoOfSources; source++) {\n"\
+"      static float diff;\n"\
+"      diff = unit->sources[source]->act\n"\
+"             - unit->weights[source];\n"\
+"      sum += diff * diff;\n"\
+"    }\n"\
+"    unit->act = %s(sum, unit->Bias);\n"\
+"  };\n\n"
+
+#define DlvqTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    unit = %s[member];\n"\
+"    sum = 0.0;\n"\
+"    for (source = 0; source < unit->NoOfSources; source++) {\n"\
+"      sum += unit->sources[source]->act\n"\
+"             * unit->weights[source];\n"\
+"    }\n"\
+"    if (sum > maxSum) {\n"\
+"      maxSum = sum;\n"\
+"      out[0] = unit->Bias;\n"\
+"    }\n"\
+"  };\n\n"
+
+/* not needed, because the output is already calculated */
+#define DlvqOutputTemplate " "
+
+
+/* --------------------------------------------------------------- */
+/* ------ Backpropagation through time (BPTT) - Section  --------- */
+/* --------------------------------------------------------------- */
+
+#define BpttInputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    Input[member]->act[old] = in[member];\n  }\n\n"
+
+#define BpttTypeTemplate "\n"\
+"typedef struct UT {\n"\
+"          float act[2];      /* Activation       */\n"\
+"          float Bias;        /* Bias of the Unit */\n"\
+"          int   NoOfSources; /* Number of predecessor units */\n"\
+"   struct UT   *sources[%d]; /* predecessor units */\n"\
+"          float weights[%d]; /* weights from predecessor units */\n"\
+"        } UnitType, *pUnit;\n\n"
+
+#define BpttTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    unit = %s[member];\n"\
+"    sum = 0.0;\n"\
+"    for (source = 0; source < unit->NoOfSources; source++) {\n"\
+"      sum += unit->sources[source]->act[old]\n"\
+"             * unit->weights[source];\n"\
+"    }\n"\
+"    unit->act[new] = %s(sum, unit->Bias);\n"\
+"  };\n\n"
+
+#define BpttOutputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    out[member] = Units[Output[member]].act[new];\n  }\n\n"
+
+#define BpttExitTemplate ""\
+"  old  = new; new = !new; \n"
+
+#define BpttFirstTemplate ""\
+"  static int new = 1, old = 0; /* variables for the current activations */\n"\
+"  if (init) {\n"\
+"    for(unit = 0; unit < Units + %d; unit++) unit->act[old] = 0.0;\n"\
+"  }\n\n"
+
+
+/* --------------------------------------------------------------- */
+/* ------------------ CounterPropagation (CPN) - Section --------- */
+/* --------------------------------------------------------------- */
+
+#define CpnTypeTemplate "\n"\
+"typedef struct UT {\n"\
+"          float act;         /* Activation       */\n"\
+"          float Bias;        /* Bias of the Unit */\n"\
+"          int   NoOfSources; /* Number of predecessor units */\n"\
+"   struct UT   *sources[%d]; /* predecessor units */\n"\
+"          float weights[%d]; /* weights from predecessor units */\n"\
+"          float dest[%d];    /* weights to output units */\n"\
+"        } UnitType, *pUnit;\n\n"
+
+#define CpnTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    unit = %s[member];\n"\
+"    sum = 0.0;\n"\
+"    for (source = 0; source < unit->NoOfSources; source++) {\n"\
+"      sum += unit->sources[source]->act\n"\
+"             * unit->weights[source];\n"\
+"    }\n"\
+"    if (sum > maxSum) {\n"\
+"      maxSum = sum;\n"\
+"      winner = unit;\n"\
+"    }\n"\
+"  };\n"\
+
+#define CpnOutputTemplate ""\
+"  for (member = 0; member < %d; member++) {\n"\
+"    out[member] = winner->dest[member];\n"\
+"  }\n\n"
+
+#define CpnDummyUnit ""\
+"    {0.0, 0.0, 0, {NULL}, {0.0}, {0.0} /* dummy unit */}"
+
+/* --------------------------------------------------------------- */
+/* ------------------- TDNN section ------------------------------ */
+/* --------------------------------------------------------------- */
+
+#define TdnnHeaderFileTemplate ""\
+"/*********************************************************\n"\
+"  %s\n"\
+"  --------------------------------------------------------\n"\
+"  generated at %s  by snns2c ( Bernward Kett 1995 ) \n"\
+"*********************************************************/\n\n"\
+"extern int %s(float *in, float *out, int init);\n\n"\
+"static struct {\n"\
+"  int NoOfInput;    /* Number of Input Units  */\n"\
+"  int NoOfOutput;   /* Number of Output Units */\n"\
+"  int MinDelay;     /* Timestep needed for first valid output */\n"\
+"  int(* propFunc)(float *, float*, int);\n"\
+"} %sREC = {%d,%d,%d,%s};\n"
+
+
+#define TdnnFirstTemplate ""\
+"  if (init) Pattern_counter = 0;\n"
+
+#define TdnnExitTemplate ""\
+"  if (++Pattern_counter < %d) return(Not_Valid);\n"\
+"  else return(OK);\n" 
+
+#define TdnnTypeTemplate "\n"\
+"typedef struct UT {\n"\
+"          float act[%d];         /* Activations of the Delays   */\n"\
+"          float Bias;            /* Bias of the Unit            */\n"\
+"          int   NoOfSources;     /* Number of predecessor units */\n"\
+"   struct UT   *sources[%d];     /* predecessor units           */\n"\
+"          float weights[%d][%d]; /* weights from pred. units and their delays */\n"\
+"        } UnitType, *pUnit;\n\n"
+
+#define TdnnInputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    Input[member]->act[InputWriteCounter] = in[member];\n  }\n\n"
+
+#define TdnnOutputTemplate ""\
+"  for(member = 0; member < %d; member++) {\n"\
+"    out[member] = Units[Output[member]].act[Output1ReadCounter];\n  }\n\n"
+
+/*************************************************************************
+  The Template TdnnTemplate
+  ------------------------------------------------------------------------
+  At first a pseudo-Code which explains the function of the Template:
+  It is only necessary to compute the newest Activation of the Feature
+  Units (e.g. Delay 0)
+
+  For all Units U in a layer L:   
+    For all Source Feature Units SFU of the Unit U:
+      For all delays in DelayLength:
+         sum = sum + (delayed Activation of the Feature Unit)
+                      * ( weight to the delayed Activation)
+      end
+    end
+    Activation (Unit U, delay 0 ) = ActivationFunc(sum, bias of Unit U) 
+  end
+
+  After updating all units the activation of the  units become older, 
+  e.g. the delay of each Activation is increased. To avoid this work
+  there is a pointer for each Layer which shows which activation
+  is the newest one.
+  ------------------------------------------------------------------------
+  Explanation of the needed Parameters:
+
+  Shortcuts : DP  : DelayPointer of a Layer
+              DL  : DelayLength of a Receptive Field
+              TDL : Total Delay Length of a Feature Unit
+
+  DP      is a variable Name
+  Actfunc is the Name of a Actifationfunction
+  TD, TDL are integer Values
+
+  Parameters in order of Occurence
+
+  - Number of Layer Members
+  - Layer Name
+  - DP(source), DL(target), TDL(source)
+  - DP(source), DP(source), DL(target)
+  - DP(source)
+  - DP(source), TDL(source)
+  - DP(source)
+  - DP(source), DL(target), TDL(source)
+  - DP(source), TDL(source)
+  - DP(target), ActFunc(target)
+
+  => 19 params
+***************************************************************************/
+#define TdnnTemplate ""\
+"  for (member = 0; member < %d; member++) { \n"\
+"    unit = %s[member]; \n"\
+"      sum = 0.0; \n"\
+"      for(source = 0; source < unit->NoOfSources; source++) { \n"\
+"        static int delay; \n"\
+"        if (%s + %d < %d) { \n"\
+"          for(delay = %s; delay < %s + %d; delay++) { \n"\
+"            sum += unit->sources[source]->act[delay] \n"\
+"                   * unit->weights[source][delay-%s]; \n"\
+"          } \n"\
+"        } \n"\
+"        else { \n"\
+"          for(delay = %s; delay < %d; delay++) { \n"\
+"            sum += unit->sources[source]->act[delay] \n"\
+"                   * unit->weights[source][delay-%s]; \n"\
+"          } \n"\
+"          for(delay = 0; delay < %s + %d - %d; delay++) { \n"\
+"            sum += unit->sources[source]->act[delay] \n"\
+"                   * unit->weights[source][delay- %s + %d]; \n"\
+"          } \n"\
+"        } /* if */  \n"\
+"     }  /* for source */ \n"\
+"     unit->act[%s] = %s(sum, unit->Bias); \n"\
+"  };  /* for member */ \n\n"  
diff -Naur snort-2.3.3/src/rna_train.c snort-2.3.3.new/src/rna_train.c
--- snort-2.3.3/src/rna_train.c	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_train.c	2008-02-17 20:24:55.000000000 -0300
@@ -0,0 +1,167 @@
+#include "snort.h"
+#include "rna_train.h"
+
+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+FROM: SNNSv4.1/tools/sources/RCS/netlearn.c
+      SNNS VERSION  => 4.1
+      AUTHOR         : Niels Mache 
+      DATE           : 19.10.90
+      CHANGED BY     : Jacson RC Silva <jacsonrcsilva@gmail.com>
+      LAST CHANGE    : 2008/02/01 04:06:14
+
+             Copyright (c) 1990-1995  SNNS Group, IPVR, Univ. Stuttgart, FRG
+
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+void errChk( int err_code )
+{
+  if (err_code != KRERR_NO_ERROR)  {
+    printf( "%s\n", krui_error( err_code ));
+    exit( 1 );
+  }
+}
+
+int Rna_train()
+{
+  int   ret_code, N, i, j, no_of_sites, no_of_links, no_of_units,
+	no_of_patterns, dummy, NoOfReturnVals, no_of_input_params,
+        no_of_output_params, step, set_no;
+  char	*netname;
+  bool	shuffle;
+  float learn_parameters[5], updateParameterArray[5],
+	parameterInArray[5], sum_error;
+  float *return_values;
+  int spIsize[5], spOsize[5], spIstep[5], spOstep[5];
+
+
+  printf( "\n%s\n", krui_getVersion() );
+  printf( "----  Network Learning -----\n" );
+  printf( "Loading the network %s ...\n",pv.rna.net_filename );
+  ret_code = krui_loadNet( pv.rna.net_filename, &netname );
+  errChk( ret_code );
+  krui_getNetInfo( &no_of_sites, &no_of_links, &dummy, &dummy );
+  no_of_units = krui_getNoOfUnits();
+  printf( "Network name: %s\n", netname );
+  printf( "No. of units       : %d\n", no_of_units );
+  printf( "No. of input units : %d\n", krui_getNoOfTTypeUnits( INPUT ) );
+  printf( "No. of output units: %d\n", krui_getNoOfTTypeUnits( OUTPUT ) );
+  printf( "No. of sites: %d\n", no_of_sites );
+  printf( "No. of links: %d\n\n", no_of_links );
+  printf( "Learning function: %s\n", krui_getLearnFunc() );
+  printf( "Update function  : %s\n", krui_getUpdateFunc() );
+
+//   printf( "\nFilename of the pattern file: %s\n",pv.rna.train_filename );
+//   scanf( "%s", file_name );
+  printf( "Loading the patterns %s ...\n",pv.rna.train_filename );
+  ret_code = krui_loadNewPatterns( pv.rna.train_filename, &set_no );
+  errChk( ret_code );
+  no_of_patterns = krui_getNoOfPatterns();
+  printf( "No. of patterns: %d\n", no_of_patterns );
+
+  /*  determine the no. of parameters of the current learning function
+  */
+  (void) krui_getFuncParamInfo( krui_getLearnFunc(), LEARN_FUNC,
+				&no_of_input_params, &no_of_output_params );
+  
+  LogMessage( "\nThe learning function '%s' needs %d input parameters:\n",
+	  krui_getLearnFunc(), no_of_input_params );
+
+  for (i = 0; i < no_of_input_params; i++)
+  {
+      learn_parameters[i] = pv.rna.parameters[i];
+      LogMessage( "\tParameter [%d]: %f\n", i + 1 ,learn_parameters[i]);
+  }
+
+//   printf( "\nChoose no. of cycles: " );
+//   scanf("%d", &N);
+  N = (pv.rna.train_cycles);
+  LogMessage("Cycles: %d\n",N);
+
+  if (N <= 0)  FatalError( "\nInvalid no. of cycles !\n" );
+
+//   printf( "\nShuffle patterns? (Y/N) " );
+//   scanf( "%s", file_name );
+//   shuffle = toupper( file_name[0] ) == 'Y';
+  shuffle=0;
+//   if (shuffle)
+//     printf( "\nShuffleing of patterns enabled\n" );
+//   else
+//     printf( "\nShuffleing of patterns disabled\n" );
+
+    printf( "\nBegin learning ...\n" );
+
+    step = ((N - 1) / 20) + 1;
+  
+    for(j=0; j<5; j++) {
+        spIsize[j] = 0; spIstep[j] = 0;
+        spOsize[j] = 0; spOstep[j] = 0;
+    }
+    
+   errChk (
+         //krui_DefTrainSubPat(int *insize, int *outsize,int *instep, int *outstep, int *max_n_pos)
+      //krui_DefTrainSubPat(no_of_input_params, no_of_output_params, spIstep, spOstep, &dummy)
+         krui_DefTrainSubPat(spIsize, spOsize, spIstep, spOstep, &dummy) 
+      );
+  for (i = 0; i < N; i++)  {
+//     if (shuffle)
+//       {  /*  shuffle patterns every cycle  */
+//       ret_code = krui_shufflePatterns( TRUE );
+//       errChk( ret_code );
+//     }
+
+/*  REMEMBER:  return_values[ 0 ] returns the current net error
+               learn_parameters[ 0 ] contains the learning parameter
+               learn_parameters[ 1 ] contains the max. devitation to learn
+*/
+
+//float *parameterInArray, int NoOfInParams, float **parameterOutArray, int *NoOfOutParams
+    ret_code = krui_learnAllPatterns( learn_parameters, no_of_input_params , &return_values, &NoOfReturnVals );
+    //ret_code = krui_learnAllPatterns( learn_parameters, 1, &return_values, &NoOfReturnVals );
+    errChk( ret_code );
+
+    /*	print the return values of the learning function  */
+//     if ((i % step == 0) || i == (N - 1))  {
+//       printf( "\nCycle: %d\nLearning function value(s): ", i + 1);
+//       for (j = 0; j < NoOfReturnVals; j++ )
+//         printf( "[%d]: %f  ", j + 1, return_values[ j ] );
+//       printf( "\n" );
+//     }
+  }
+
+//   printf( "\nEnd learning ...\n" );
+//   printf( "\nCalculating the last error of the network ...\n" );
+
+  sum_error = 0.0;
+  parameterInArray[0] = 0.0;  /*  set the max. devitation to 0.0  */
+
+/*   ====================== Attention: ==================================
+   Formerly the network propagated the patterns here. With the new pattern 
+   handling of version 3.2 this can not longer be done without major rewriting 
+   of the function krui_testNet. Since this function is not used within SNNS,
+   we decided, that it is not worth the effort and dropped the function.
+   ==> Anybody who needs it here has to rewrite it himself. Sorry.
+*/
+/*
+  for (i = 1; i <= no_of_patterns; i++)  {
+    ret_code = krui_testNet( i,
+                             updateParameterArray, 0,
+			     parameterInArray, 1,
+			     &return_values, &NoOfReturnVals );
+    errChk( ret_code );
+    sum_error += return_values[0];
+  }
+  printf( "The error is: %g\n", sum_error );
+*/
+
+  /*  save the network	*/
+//   printf( "\n\nFilename of the network to save: " );
+//   scanf( "%s", file_name );
+  printf( "Saving the network on %s...\n",pv.rna.net_filename );
+  ret_code = krui_saveNet( pv.rna.net_filename, netname );
+  errChk( ret_code );
+
+  /*  before exiting: delete network  */
+  krui_deleteNet();
+  printf("Done!\n");
+  return( 0 );
+}
diff -Naur snort-2.3.3/src/rna_train.h snort-2.3.3.new/src/rna_train.h
--- snort-2.3.3/src/rna_train.h	1969-12-31 21:00:00.000000000 -0300
+++ snort-2.3.3.new/src/rna_train.h	2008-02-05 15:18:07.000000000 -0200
@@ -0,0 +1,12 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+/*  SNNS-Kernel constants and data type definitions  */
+#include "glob_typ.h"
+/*  SNNS-Kernel User-Interface Function Prototypes   */
+#include "kr_ui.h"
+
+extern void errChk( err_code );
+extern int Rna_train();
diff -Naur snort-2.3.3/src/sfutil/Makefile.in snort-2.3.3.new/src/sfutil/Makefile.in
--- snort-2.3.3/src/sfutil/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/sfutil/Makefile.in	2008-01-03 10:47:44.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,77 +13,151 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/sfutil
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libsfutil_a_AR = $(AR) $(ARFLAGS)
+libsfutil_a_LIBADD =
+am_libsfutil_a_OBJECTS = sfghash.$(OBJEXT) sfhashfcn.$(OBJEXT) \
+	sflsq.$(OBJEXT) sfmemcap.$(OBJEXT) sfthd.$(OBJEXT) \
+	sfxhash.$(OBJEXT) ipobj.$(OBJEXT) mwm.$(OBJEXT) \
+	sfksearch.$(OBJEXT) acsmx.$(OBJEXT) acsmx2.$(OBJEXT) \
+	mpse.$(OBJEXT) util_math.$(OBJEXT) util_net.$(OBJEXT) \
+	util_str.$(OBJEXT) asn1.$(OBJEXT) sfeventq.$(OBJEXT) \
+	sfsnprintfappend.$(OBJEXT)
+libsfutil_a_OBJECTS = $(am_libsfutil_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libsfutil_a_SOURCES)
+DIST_SOURCES = $(libsfutil_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
-
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign no-dependencies
-
 noinst_LIBRARIES = libsfutil.a
-
 libsfutil_a_SOURCES = sfghash.c sfghash.h \
                       sfhashfcn.c sfhashfcn.h \
                       sflsq.c sflsq.h \
@@ -104,50 +178,39 @@
                       sfeventq.c sfeventq.h \
                       sfsnprintfappend.c sfsnprintfappend.h
 
-subdir = src/sfutil
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-LIBRARIES = $(noinst_LIBRARIES)
-
-libsfutil_a_AR = $(AR) cru
-libsfutil_a_LIBADD =
-am_libsfutil_a_OBJECTS = sfghash.$(OBJEXT) sfhashfcn.$(OBJEXT) \
-	sflsq.$(OBJEXT) sfmemcap.$(OBJEXT) sfthd.$(OBJEXT) \
-	sfxhash.$(OBJEXT) ipobj.$(OBJEXT) mwm.$(OBJEXT) \
-	sfksearch.$(OBJEXT) acsmx.$(OBJEXT) acsmx2.$(OBJEXT) \
-	mpse.$(OBJEXT) util_math.$(OBJEXT) util_net.$(OBJEXT) \
-	util_str.$(OBJEXT) asn1.$(OBJEXT) sfeventq.$(OBJEXT) \
-	sfsnprintfappend.$(OBJEXT)
-libsfutil_a_OBJECTS = $(am_libsfutil_a_OBJECTS)
-
-DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
-CPPFLAGS = @CPPFLAGS@
-LDFLAGS = @LDFLAGS@
-LIBS = @LIBS@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-CFLAGS = @CFLAGS@
-DIST_SOURCES = $(libsfutil_a_SOURCES)
-DIST_COMMON = Makefile.am Makefile.in
-SOURCES = $(libsfutil_a_SOURCES)
-
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .o .obj
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/sfutil/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/sfutil/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
-
-AR = ar
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 
 clean-noinstLIBRARIES:
 	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
@@ -157,23 +220,18 @@
 	$(RANLIB) libsfutil.a
 
 mostlyclean-compile:
-	-rm -f *.$(OBJEXT) core *.core
+	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 .c.o:
-	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+	$(COMPILE) -c $<
 
 .c.obj:
-	$(COMPILE) -c `cygpath -w $<`
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 uninstall-info-am:
 
-ETAGS = etags
-ETAGSFLAGS =
-
-tags: TAGS
-
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
@@ -182,6 +240,7 @@
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
+tags: TAGS
 
 TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
@@ -193,8 +252,24 @@
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$tags$$unique" \
-	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
 
 GTAGS:
@@ -203,19 +278,21 @@
 	  && gtags -i $(GTAGS_ARGS) $$here
 
 distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@list='$(DISTFILES)'; for file in $$list; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -233,9 +310,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile $(LIBRARIES)
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -247,7 +322,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -255,7 +330,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -265,7 +340,7 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-tags
 
@@ -273,6 +348,8 @@
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -288,24 +365,33 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-compile mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
-.PHONY: GTAGS all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic tags \
-	uninstall uninstall-am uninstall-info-am
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur snort-2.3.3/src/snort.c snort-2.3.3.new/src/snort.c
--- snort-2.3.3/src/snort.c	2005-01-13 18:36:20.000000000 -0200
+++ snort-2.3.3.new/src/snort.c	2008-02-17 21:51:28.000000000 -0300
@@ -76,6 +76,8 @@
 #include "event_queue.h"
 #include "asn1.h"
 #include "inline.h"
+#include "rna.h"
+#include "rna_alg.h"
 
 /*  G L O B A L S  ************************************************************/
 extern OutputFuncNode *AlertList;
@@ -140,6 +142,11 @@
 static void SigHupHandler(int signal);
 static void SigUsr1Handler(int signal);
 
+/* RNA locale functions *******************************************************/
+static void rna_write_pat_header();
+static void rna_finalize_pat_file();
+static void rna_load_config();
+
 /*
  *
  * Function: main(int, char *)
@@ -175,7 +182,6 @@
         return SnortServiceMain(argc, argv);
     }
 #endif /* WIN32 && ENABLE_WIN32_SERVICE */
-
     return SnortMain(argc,argv);
 }
 
@@ -243,6 +249,21 @@
     /* TODO: only do this when we know we are going into IDS mode */
     fpInitDetectionEngine();
 
+    /*for rna*/
+    pv.rna.type = 0;
+    pv.rna.train_cycles=1000;
+    pv.rna.net_loaded = 0;
+    pv.rna.attack=-9999.0;
+    pv.rna.answer=-999.0;
+    pv.rna.parameters[0]=0.2;
+    pv.rna.parameters[1]=0.1;
+    pv.rna.parameters[2]=0.5;
+    pv.rna.parameters[3]=0.0;
+    pv.rna.parameters[4]=0.0;
+    pv.rna.net_filename = NULL;
+    pv.rna.train_filename = NULL;
+    pv.rna.train_file = NULL;
+
     /* initialize the packet counter to loop forever */
     pv.pkt_cnt = -1;
 
@@ -284,7 +305,12 @@
         signal(SIGHUP, SigCantHupHandler);
     
     /* determine what run mode we are going to be in */
-    if(pv.config_file)
+    if (pv.rna.type)
+    {
+        runMode = MODE_IDS;
+        LogMessage("Running in IDS mode with Artificial Neural Network\n");
+    }
+    else if(pv.config_file)
     {
         runMode = MODE_IDS;
         if(!pv.quiet_flag)
@@ -443,7 +469,6 @@
             LogMessage("Rule application order changed to Pass->Alert->Log\n");
         }
     }
-
     /*
      * if daemon mode requested, fork daemon first, otherwise on linux
      * interface will be reset.
@@ -461,6 +486,7 @@
     if((runMode == MODE_IDS) || pv.log_mode || pv.daemon_flag 
             || *pv.pidfile_suffix)
     {
+
         /* ... then create a PID file if not reading from a file */
         if (!pv.readmode_flag && (pv.daemon_flag || *pv.pidfile_suffix))
         {
@@ -503,7 +529,6 @@
         DumpPlugIns();
         DumpOutputPlugins();
 #endif
-
         /* setup the default rule action anchor points */
         CreateDefaultRules();
 
@@ -519,7 +544,7 @@
         if(!(pv.quiet_flag && !pv.daemon_flag))
             LogMessage("Parsing Rules file %s\n", pv.config_file);
 
-        ParseRulesFile(pv.config_file, 0);
+        if (!pv.rna.type) ParseRulesFile(pv.config_file, 0);
     
         CheckLogDir();
 
@@ -689,6 +714,7 @@
         }
     }
 
+    //jeiks
     switch(runMode)
     {
         case MODE_PACKET_LOG:
@@ -705,17 +731,17 @@
             } 
             
             /* start calling the detection processes */
-            Preprocess(&p);
+            //jeiks - RNA will enter around here.. hehe
+            if (pv.rna.type) Rna(&p);
+            else          Preprocess(&p);
             break;
         default:
             break;
     }
-
     ClearDumpBuf();
 
 }
 
-
 /*
  * Function: ShowUsage(char *)
  *
@@ -806,6 +832,11 @@
     FPUTS_BOTH ("        -X         Dump the raw packet data starting at the link layer\n");
     FPUTS_BOTH ("        -y         Include year in timestamp in the alert and log files\n");
     FPUTS_BOTH ("        -z         Set assurance mode, match on established sesions (for TCP)\n");
+    FPUTS_BOTH ("        -Z <opt>   Use Artificial Neural Network, <opt> can be:\n\t\t\t"
+                                       "'run' to execute detection with ANN,\n\t\t\t"
+                                       "'train' to train ANN\n\t\t\t"
+                                       "'trainoff' to train again with the last pattern\n\t\t\t"
+                                       "'printresult' to print the ANN bigger answer\n");
     FPUTS_BOTH ("        -?         Show this information\n");
     FPUTS_BOTH ("<Filter Options> are standard BPF options, as seen in TCPDump\n");
 
@@ -867,18 +898,18 @@
 #ifndef WIN32
 #ifdef GIDS
 #ifndef IPFW
-    valid_options = "?A:bB:c:CdDefF:g:h:i:Ik:l:L:m:n:NoOpP:qQr:R:sS:t:Tu:UvVwXyz";
+    valid_options = "?A:bB:c:CdDefF:g:h:i:Ik:l:L:m:n:NoOpP:qQr:R:sS:t:Tu:UvVwXyz:Z:";
 #else
-    valid_options = "?A:bB:c:CdDefF:g:h:i:IJ:k:l:L:m:n:NoOpP:qr:R:sS:t:Tu:UvVwXyz";
+    valid_options = "?A:bB:c:CdDefF:g:h:i:IJ:k:l:L:m:n:NoOpP:qr:R:sS:t:Tu:UvVwXyz:Z:";
 #endif /* IPFW */
 #else
     /* Unix does not support an argument to -s <wink marty!> OR -E, -W */
-    valid_options = "?A:bB:c:CdDefF:g:h:i:Ik:l:L:m:n:NoOpP:qr:R:sS:t:Tu:UvVwXyz";
+    valid_options = "?A:bB:c:CdDefF:g:h:i:Ik:l:L:m:n:NoOpP:qr:R:sS:t:Tu:UvVwXyz:Z:";
 #endif /* GIDS */
 #else
     /* Win32 does not support:  -D, -g, -m, -t, -u */
     /* Win32 no longer supports an argument to -s, either! */
-    valid_options = "?A:bB:c:CdeEfF:h:i:Ik:l:L:n:NoOpP:qr:R:sS:TUvVwWXyz";
+    valid_options = "?A:bB:c:CdeEfF:h:i:Ik:l:L:n:NoOpP:qr:R:sS:TUvVwWXyz:Z:";
 #endif
 
     /* loop through each command line var and process it */
@@ -1388,6 +1419,52 @@
                 pv.assurance_mode = ASSURE_EST;
                 break;
 
+            //jeiks
+            case 'Z':
+#ifndef WIN32
+                pv.rna.config_filename=strdup("/etc/snort/rna.conf");
+#else
+                pv.rna.config_filename=strdup("./rna.conf");
+#endif
+
+                if (!strcasecmp(optarg, "run")){
+                   pv.rna.type=1;
+#ifndef WIN32
+                   pv.rna.net_filename=strdup("/etc/snort/rna.net");
+#else
+                   pv.rna.net_filename=strdup("./rna.net");
+#endif
+                }
+                else if (!strcasecmp(optarg, "train")){
+                   pv.rna.type=2;
+#ifndef WIN32
+                   pv.rna.net_filename=strdup("/etc/snort/rna.net");
+                   pv.rna.train_filename=strdup("/etc/snort/rna.pat");
+#else
+                   pv.rna.net_filename=strdup("./rna.net");
+                   pv.rna.train_filename=strdup("./rna.pat");
+#endif
+                }else if (!strcasecmp(optarg, "trainoff")){
+                   pv.rna.type=3;
+#ifndef WIN32
+                   pv.rna.net_filename=strdup("/etc/snort/rna.net");
+                   pv.rna.train_filename=strdup("/etc/snort/rna.pat");
+#else
+                   pv.rna.net_filename=strdup("./rna.net");
+                   pv.rna.train_filename=strdup("./rna.pat");
+#endif
+                }else if (!strcasecmp(optarg, "printresult")){
+                   pv.rna.type=4;
+#ifndef WIN32
+                   pv.rna.net_filename=strdup("/etc/snort/rna.net");
+#else
+                   pv.rna.net_filename=strdup("./rna.net");
+#endif
+                }else{
+                   FatalError("Unknown Command, try [run] or [train]\n");
+                }
+                break;
+
             case '?':  /* show help and exit with 1 */
                 DisplayBanner();
                 ShowUsage(progname);
@@ -1741,6 +1818,20 @@
 
     bzero((char *) &tz, sizeof(tz));
     gettimeofday(&starttime, &tz);
+    
+    if (pv.rna.type) rna_load_config( fopen(pv.rna.config_filename,"r") );
+    /* open the rna pattern file */
+    switch(pv.rna.type)
+    {
+        case 2:
+            if ( (pv.rna.train_file = fopen(pv.rna.train_filename,"w"))==NULL )
+                   ErrorMessage("Couldn't open the pattern file for write!\n");
+            else   rna_write_pat_header();
+            break;
+        case 3:
+            CleanExit(0);
+            break;
+    }
 
     /* Read all packets on the device.  Continue until cnt packets read */
     if(pcap_loop(pd, pv.pkt_cnt, (pcap_handler) ProcessPacket, NULL) < 0)
@@ -1752,7 +1843,7 @@
 
         CleanExit(1);
     }
-
+    
     gettimeofday(&endtime, &tz);
 
     TIMERSUB(&endtime, &starttime, &difftime);
@@ -2162,7 +2253,6 @@
         return;
     }
     already_exiting = 1;
-
     /* Print Statistics */
     if(!pv.test_mode_flag)
     {
@@ -2201,12 +2291,23 @@
     if (pd && !InlineMode())
         pcap_close(pd);
 
-    LogMessage("Snort exiting\n");
 
     /* remove pid file */
     if(pv.pid_filename)
         unlink(pv.pid_filename);
 
+    /*if the train file is open...*/
+    if(pv.rna.type==2 || pv.rna.type==3)
+    {
+        if (pv.rna.type==2) rna_finalize_pat_file();
+        if (pv.rna.num_patterns) Rna_train();
+        else FatalError("No Patterns to train ANN\n");
+    }else if(pv.rna.type == 4)
+    {
+        LogMessage("The bigger ANN answer: %f\n\n",pv.rna.answer);
+    }
+
+    LogMessage("Snort exiting\n");
     /* exit */
     exit(exit_val);
 }
@@ -2244,6 +2345,17 @@
 
     if(pv.pid_filename)
         unlink(pv.pid_filename);
+
+    /*if the train file is open...*/
+    if(pv.rna.type==2 || pv.rna.type==3)
+    {
+        if (pv.rna.type==2) rna_finalize_pat_file();
+        Rna_train();
+    }else if(pv.rna.type == 4)
+    {
+        LogMessage("The bigger ANN answer: %f\n\n",pv.rna.answer);
+    }
+
     LogMessage("Restarting Snort\n");
 
     /* re-exec Snort */
@@ -2258,9 +2370,97 @@
     exit(1);
 }
 
+static void rna_write_pat_header()
+{
+    time_t t;
+    time(&t);
+    fprintf(pv.rna.train_file,"SNNS pattern definition file V1.4\n");
+    fprintf(pv.rna.train_file,"generated at %s\n\n", ctime( &t));
+    fprintf(pv.rna.train_file,"No. of patterns     : ");
+    fgetpos(pv.rna.train_file,&(pv.rna.num_pat));
+    fprintf(pv.rna.train_file,"                              \n");
+    fprintf(pv.rna.train_file,"No. of input units  : %d\n", Rna_algREC.NoOfInput);
+    fprintf(pv.rna.train_file,"No. of output units : %d\n", Rna_algREC.NoOfOutput);
+    fprintf(pv.rna.train_file,"\n");
+}
 
+static void rna_finalize_pat_file()
+{
+    fsetpos(pv.rna.train_file,&(pv.rna.num_pat));
+    fprintf(pv.rna.train_file,"%d",pv.rna.num_patterns);
+    fclose(pv.rna.train_file);
+}
 
+void read_float_rna(FILE *arq, float *where, char opt[50])
+{
+    fscanf(arq,"%f",where);
+    opt[0]='\0';
+}
 
+void read_int_rna(FILE *arq, int *where, char opt[50])
+{
+    fscanf(arq,"%d",where);
+    opt[0]='\0';
+}
 
+static void rna_load_config(FILE *arq)
+{
+    char car;
+    char opt[50];
+    if (arq==NULL) ErrorMessage("Couldn't open the pattern file for write!\n");
+    opt[0]='\0';
+    do
+    {
+        car = fgetc(arq);
+        if (car == '=')
+        {
+            if (strncasecmp(opt,"attack",6)==0){
+                read_float_rna(arq,&(pv.rna.attack),opt);
+
+            }else if (strncasecmp(opt,"parameter_0",11)==0){
+                read_float_rna(arq,&(pv.rna.parameters[0]),opt);
+
+            }else if (strncasecmp(opt,"parameter_1",11)==0){
+                read_float_rna(arq,&(pv.rna.parameters[1]),opt);
+
+            }else if (strncasecmp(opt,"parameter_2",11)==0){
+                read_float_rna(arq,&(pv.rna.parameters[2]),opt);
+
+            }else if (strncasecmp(opt,"parameter_3",11)==0){
+                read_float_rna(arq,&(pv.rna.parameters[3]),opt);
+
+            }else if (strncasecmp(opt,"parameter_4",11)==0){
+                read_float_rna(arq,&(pv.rna.parameters[4]),opt);
+
+            }else if (strncasecmp(opt,"cycles",11)==0){
+                read_int_rna(arq,&(pv.rna.train_cycles),opt);
+
+            }
+
+        }else if (car == '\n')
+        {
+            opt[0]='\0';
+        }
+        else{
+            opt[strlen(opt)+1]='\0';
+            opt[strlen(opt)]=car;
+        }
+    }while(!feof(arq));
+    fclose(arq);
+
+    if (pv.verbose_flag){
+        if (pv.rna.type==1 || pv.rna.type==4)
+        {
+            LogMessage("RNA Attack: %f\n\n",pv.rna.attack);
+        }else if (pv.rna.type==2 || pv.rna.type==3)
+        {
+            LogMessage("Learning Parameter[0]=%f\n",pv.rna.parameters[0]);
+            LogMessage("Learning Parameter[1]=%f\n",pv.rna.parameters[1]);
+            LogMessage("Learning Parameter[2]=%f\n",pv.rna.parameters[2]);
+            LogMessage("Learning Parameter[3]=%f\n",pv.rna.parameters[3]);
+            LogMessage("Learning Parameter[4]=%f\n\n",pv.rna.parameters[4]);
+        }
+    }
+}
 /* vim: smartindent:expandtab:sw=4:ts=4:tw=0
  */
diff -Naur snort-2.3.3/src/snort.h snort-2.3.3.new/src/snort.h
--- snort-2.3.3/src/snort.h	2005-04-23 16:27:57.000000000 -0300
+++ snort-2.3.3.new/src/snort.h	2008-02-18 01:02:56.000000000 -0300
@@ -134,6 +134,24 @@
     Capabilities capabilities;
 } runtime_config;
 
+typedef struct _rna_opts
+{
+    int type;              /* tipo de execução: run, train, trainoff... */
+    int net_loaded;        /* verificação se a rede pôde ser carregada*/
+    int train_cycles;      /* quantidade de ciclos que devem ser feitos no treinamento*/
+    int num_patterns;      /* número de entradas existentes no arquivo .pat */
+    char *config_filename; /* nome do arquivo de cofiguração */
+    char *net_filename;    /* nome do arquivo da rede neural */
+    char *train_filename;  /* nome do arquivo de treinamento */
+    fpos_t num_pat,        /* número de conjunto entradas */
+           num_input,      /* número de neurônios da camada de entrada */
+	   num_output;     /* número de neurônios da camada de saída */
+    float attack;          /* número mínimo para a detcção de ataques */
+    float answer;          /* armazenamento do maior número que a rede neural respondeu */
+    FILE *train_file;      /* stream do arquivo de treinamento */
+    float parameters[5];   /* parâmetros para o treinamento */
+} RNA_OPTS;
+
 #define LOG_ASCII   1
 #define LOG_PCAP    2
 #define LOG_NONE    3
@@ -151,6 +169,7 @@
 /* struct to contain the program variables and command line args */
 typedef struct _progvars
 {
+    RNA_OPTS rna; //rna options
     int stateful;
     int line_buffer_flag;
     int checksums_mode;
@@ -340,5 +359,4 @@
 int ShowUsage(char *);
 void SigCantHupHandler(int signal);
 
-
 #endif  /* __SNORT_H__ */
diff -Naur snort-2.3.3/src/win32/Makefile.in snort-2.3.3.new/src/win32/Makefile.in
--- snort-2.3.3/src/win32/Makefile.in	2005-04-23 16:47:26.000000000 -0300
+++ snort-2.3.3.new/src/win32/Makefile.in	2008-01-03 10:47:43.000000000 -0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.6.3 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
-# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,72 +13,128 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-SHELL = @SHELL@
-
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-
-bindir = @bindir@
-sbindir = @sbindir@
-libexecdir = @libexecdir@
-datadir = @datadir@
-sysconfdir = @sysconfdir@
-sharedstatedir = @sharedstatedir@
-localstatedir = @localstatedir@
-libdir = @libdir@
-infodir = @infodir@
-mandir = @mandir@
-includedir = @includedir@
-oldincludedir = /usr/include
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ../..
-
-ACLOCAL = @ACLOCAL@
-AUTOCONF = @AUTOCONF@
-AUTOMAKE = @AUTOMAKE@
-AUTOHEADER = @AUTOHEADER@
-
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
 INSTALL = @INSTALL@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_DATA = @INSTALL_DATA@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_HEADER = $(INSTALL_DATA)
-transform = @program_transform_name@
+transform = $(program_transform_name)
 NORMAL_INSTALL = :
 PRE_INSTALL = :
 POST_INSTALL = :
 NORMAL_UNINSTALL = :
 PRE_UNINSTALL = :
 POST_UNINSTALL = :
-host_alias = @host_alias@
+build_triplet = @build@
 host_triplet = @host@
-
-EXEEXT = @EXEEXT@
-OBJEXT = @OBJEXT@
-PATH_SEPARATOR = @PATH_SEPARATOR@
+subdir = src/win32
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+depcomp =
+am__depfiles_maybe =
+SOURCES =
+DIST_SOURCES =
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
 CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
 DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
 INCLUDES = @INCLUDES@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
+MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
 STRIP = @STRIP@
 VERSION = @VERSION@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
+am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
 extra_incl = @extra_incl@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
 install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
 
 # $Id: Makefile.am,v 1.10 2004/06/23 15:01:01 jhewlett Exp $
 AUTOMAKE_OPTIONS = foreign no-dependencies
@@ -176,39 +232,60 @@
 ./WIN32-Prj/snort.dsw \
 ./WIN32-Prj/snort.mak
 
-subdir = src/win32
-mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-depcomp =
-am__depfiles_maybe =
-DIST_SOURCES =
-DIST_COMMON = Makefile.am Makefile.in
 all: all-am
 
 .SUFFIXES:
-$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  src/win32/Makefile'; \
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  src/win32/Makefile
-Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 uninstall-info-am:
 tags: TAGS
 TAGS:
 
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ctags: CTAGS
+CTAGS:
 
-top_distdir = ../..
-distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
 
 distdir: $(DISTFILES)
-	$(mkinstalldirs) $(distdir)/./WIN32-Code $(distdir)/./WIN32-Includes $(distdir)/./WIN32-Includes/NET $(distdir)/./WIN32-Includes/NETINET $(distdir)/./WIN32-Includes/libnet $(distdir)/./WIN32-Includes/mysql $(distdir)/./WIN32-Includes/rpc $(distdir)/./WIN32-Libraries $(distdir)/./WIN32-Libraries/libnet $(distdir)/./WIN32-Libraries/mysql $(distdir)/./WIN32-Prj
-	@list='$(DISTFILES)'; for file in $$list; do \
+	$(mkdir_p) $(distdir)/./WIN32-Code $(distdir)/./WIN32-Includes $(distdir)/./WIN32-Includes/NET $(distdir)/./WIN32-Includes/NETINET $(distdir)/./WIN32-Includes/libnet $(distdir)/./WIN32-Includes/mysql $(distdir)/./WIN32-Includes/rpc $(distdir)/./WIN32-Libraries $(distdir)/./WIN32-Libraries/libnet $(distdir)/./WIN32-Libraries/mysql $(distdir)/./WIN32-Prj
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    dir="/$$dir"; \
-	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
 	  else \
 	    dir=''; \
 	  fi; \
@@ -226,9 +303,7 @@
 check-am: all-am
 check: check-am
 all-am: Makefile
-
 installdirs:
-
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -240,7 +315,7 @@
 installcheck: installcheck-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  INSTALL_STRIP_FLAG=-s \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
@@ -248,7 +323,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -258,13 +333,15 @@
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-
+	-rm -f Makefile
 distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
 
 dvi-am:
 
+html: html-am
+
 info: info-am
 
 info-am:
@@ -280,22 +357,31 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-
+	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-am
 
 mostlyclean-am: mostlyclean-generic
 
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
 uninstall-am: uninstall-info-am
 
 .PHONY: all all-am check check-am clean clean-generic distclean \
-	distclean-generic distdir dvi dvi-am info info-am install \
-	install-am install-data install-data-am install-exec \
+	distclean-generic distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
 	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic uninstall uninstall-am uninstall-info-am
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
